0001   0000             ;****************************************************************************************************
0002   0000             ;*
0003   0000             ;* GENERAL NOTES
0004   0000             ;* -------------
0005   0000             ;*
0006   0000             ;* CPU
0007   0000             ;* ----
0008   0000             ;* The microcomputer chip used in the 1G DSM ECU seems to be a custom application 
0009   0000             ;* built around the 6801 architecture, Check the 6801, 6803, 6301, 68HC11 at places 
0010   0000             ;* such as alldatasheet.com, etc. CPU clock frequency is assumed to be 2MHz, i.e. 
0011   0000             ;* the inctructions cycle time is 0.5us.
0012   0000             ;*
0013   0000             ;* Assembly binary verifications: 
0014   0000             ;* ------------------------------
0015   0000             ;*
0016   0000             ;*    The 2 binaries produced without any customization ("enableCustom" definition is
0017   0000             ;*    commented-out) have been verified to be identical to the E931 and E932 eprom 
0018   0000             ;*    images at hand.
0019   0000             ;*
0020   0000             ;*    To check the validity of symbolic substitution, the entire code section and tables 
0021   0000             ;*    was offset by $0200 using "codeOffset" and the corresponding binary was tested on
0022   0000             ;*    my car (E932) without any problems for weeks. Additional tests were conducted by
0023   0000             ;*    writing inline code in several part of the code and no adverse effect was ever noted.
0024   0000             ;*
0025   0000             ;*    To check the validity of symbolic substitution for ram addresses, every ram location
0026   0000             ;*    starting at $0057 was offset by 1 (i.e. temp1 was at memory address $58 instead of 
0027   0000             ;*    $57, etc) and the corresponding binary was tested on my car (E932) without any problems
0028   0000             ;*    during car startup and engine revving. No additional test performed.
0029   0000             ;*
0030   0000             ;*    This means that the code can be modified inline and in most cases, ram memories can 
0031   0000             ;*    be moved around by changing the label addresses. Note however that some groups of
0032   0000             ;*    ram memories have to be moved in blocks because the code assumes they are contiguous.
0033   0000             ;*    e.g. the temp1 to temp9 variables, the inj1_offT, inj3_offT, inj4_offT and inj2_offT
0034   0000             ;*    variables, etc.
0035   0000             ;*
0036   0000             ;* Ram memory: 
0037   0000             ;* -----------
0038   0000             ;*    Memory from $0040 to $01bf is backed-up by battery, meaning it is preserved when the
0039   0000             ;*    ECU is powered-off as long as battery power is supplied. However, memory from $0057 to
0040   0000             ;*    $0190 is cleared to 0 by the code every time the ECU is powered-on. That can be however
0041   0000             ;*    changed by modifying the code... Battery backup was checked by disabling memory reset using
0042   0000             ;*    the "noRamReset"  and then check ram memory at $018f to see if it gets preserved after power 
0043   0000             ;*    off/on cycle, and it did. During the test, $018f was used as a distance counter using 
0044   0000             ;*    the reed switch.
0045   0000             ;*
0046   0000             ;* Comments: 
0047   0000             ;* --------
0048   0000             ;*   Some comments use variable names quite loosly. For instance, multi-byte variables
0049   0000             ;*   such as [airCnt0:airCnt1:airCnt2] might be refered to as only airCnt0. airCnt0
0050   0000             ;*   might therefore refer to the single byte airCnt0, to the 16 bit value 
0051   0000             ;*   [airCnt0:airCnt1] or to the 24 bit complete variable, depending on the context.
0052   0000             ;*
0053   0000             ;*   Comments were added incrementally as my knowledge of code and variables
0054   0000             ;*   increased. As new knowledge was learned, old comments were updated or corrected
0055   0000             ;*   as much as possible but not necessarily all of them, so beware... In the end, the
0056   0000             ;*   code is the only truth... Some small areas of the code were also never completly
0057   0000             ;*   understood as a general understanding was reached and I did not care to go further
0058   0000             ;*   e.g. airflow sensor active filter reset
0059   0000             ;*
0060   0000             ;* Opcodes: 
0061   0000             ;* --------
0062   0000             ;*    -cmpd: cmpd1 is used for some addressing modes instead of cmpd since 
0063   0000             ;*           TASM does not support unusual mitsubishi ECU cmpd opcodes..   
0064   0000             ;*
0065   0000             ;*    -brclr: branch if ALL the given bits are clear
0066   0000             ;*
0067   0000             ;*    -brset: branch if ANY of the given bits are set (as opposed to usual 
0068   0000             ;*            implementation of ALL bits set...)
0069   0000             ;*
0070   0000             ;*    -The addressing mode using Y indexing also implicitly
0071   0000             ;*     modifies the y register. It seems that y is increased
0072   0000             ;*     by 1 or 2 depending whether the instruction is a 8 bit
0073   0000             ;*     or 16 bits operation... The following cases are confirmed
0074   0000             ;*
0075   0000             ;*         cmpa $00,y  -> y = y + 1 
0076   0000             ;*         cmpb $00,y  -> y = y + 1 
0077   0000             ;*         ldaa $00,y  -> y = y + 1
0078   0000             ;*         suba $00,y  -> y = y + 1
0079   0000             ;*         ldx  $00,y  -> y = y + 2
0080   0000             ;*         std  $00,y  -> y = y + 2
0081   0000             ;*
0082   0000             ;*                
0083   0000             ;* Telemark assembler:
0084   0000             ;* --------------------
0085   0000             ;*    This assembler does not provide warning messages when code assembles to
0086   0000             ;*    the same memory space, e.g. you insert code in the middle of the file 
0087   0000             ;*    which result in the rest of the code to be offset by N bytes. This
0088   0000             ;*    results in the interrupt vector table to be overwritten. No warning 
0089   0000             ;*    is given. The only way to know about it is to manually check the listing 
0090   0000             ;*    file produced by the assembler. Check that the buffer space between 
0091   0000             ;*    sections is all "$ff". Check that there is no code spilage over .org 
0092   0000             ;*    statements. Check that the address space does not exceed $ffff. Use the 
0093   0000             ;*    "codeOffset" at the beginnng of the file to correct the problem.
0094   0000             ;*              
0095   0000             ;*              
0096   0000             ;* Fuel injector and coil power transistor control
0097   0000             ;* ------------------------------------------------
0098   0000             ;*    Although the 4 fuel injectors and the 2 coil power transistors are mapped to
0099   0000             ;*    regular ports (port1, port2 and port5) which can be read to know the current
0100   0000             ;*    state of these outputs, they are also mapped in hardware to output compare
0101   0000             ;*    registers in order to activate or deactivate them at specific time instants.
0102   0000             ;*    Writing to the ports might therefore not work unless the output compare 
0103   0000             ;*    configuration registers are changed to disable harware control of these 
0104   0000             ;*    outputs. This might not be possible unless an "output enable" bit exists,
0105   0000             ;*    which I haven't found at this point...
0106   0000             ;*    Another way to activate or deactivate them would be to use the output
0107   0000             ;*    compare registers (as currently done by the ECU code) and provoke an 
0108   0000             ;*    immediat output change.
0109   0000             ;*
0110   0000             ;*    Here is my current understanding of how injector scheduling works, not 
0111   0000             ;*    everything is clear to me so don't take this as gospel...:
0112   0000             ;*    The output compare registers for the fuel injectors seem to be at least double
0113   0000             ;*    buffered and maybe triple buffered (see schedInjSim routine). That means that 
0114   0000             ;*    up to 3 different output compare values can be written to t1_outCmpWr and t2_outCmpWr
0115   0000             ;*    to activate or deactivate the injectors at those time instants. Each time a value
0116   0000             ;*    is written to t1_outCmpWr or t2_outCmpWr, the corresponding injector state
0117   0000             ;*    is also internally stored. That means that to activate injector #1 at time X,
0118   0000             ;*    you would first reset bit 0 of t1_csr, corresponding to injector #1 and then
0119   0000             ;*    write X to t1_outCmpWr. You could then immediately schedule the deactivation
0120   0000             ;*    of injector #1 by setting bit 0 of t1_csr to 1 and then write the deactivation 
0121   0000             ;*    time to t1_outCmpWr. When one of the output compare register stored value matches 
0122   0000             ;*    the clock at t1t2_clk, the injector is activated/deactivated and the corresponding
0123   0000             ;*    interrupt routine is called (if the interrupt mask is clear...) at outCompInt1 or 
0124   0000             ;*    outCompInt2.
0125   0000             ;*
0126   0000             ;*    Here is my current understanding of how the coil power transistor scheduling 
0127   0000             ;*    works, not everything is clear to me so don't take this as gospel...: t3_outCmpWr
0128   0000             ;*    is the output compare register used to activate or deactivate the coil power 
0129   0000             ;*    transistors (energize the coil and provoke ignition at the specified time instants)
0130   0000             ;*    To energize the coil for cylinder 1 and 4 at time X you would write X to t3_outCmpWr 
0131   0000             ;*    and reset(0) bit 2 of t3_csr0. At time X, t3_csr0.2 would be loaded into port5.1 
0132   0000             ;*    which would energize the coil. t3_csr0.2 should not be changed until that happens.
0133   0000             ;*    In the code, most of the time 2 successive values (the same one) are written to t3_outCmpWr 
0134   0000             ;*    but there are some instances where only 1 value is written. My impression is that
0135   0000             ;*    the first value serves to activate/deactivate the coil power transistor at the 
0136   0000             ;*    specified instant while the second one only serves to generate an interrupt
0137   0000             ;*    in order to call the outCompInt3 routine. Hence when only the coil need
0138   0000             ;*    to be activated/deactivated without calling outCompInt3, you would only write 
0139   0000             ;*    one value. If in addition you want to have outCompInt3 called when the coil 
0140   0000             ;*    is energized/ignited, you would write two successive values (corresponding to the 
0141   0000             ;*    same time...). This is all speculation of course... As for the 2 clocks at t3_clock1
0142   0000             ;*    and t3_clock1, I assume they are connected to the same internal clock at 250KHz
0143   0000             ;*    but might be input capture registers latched when one of the two output compare 
0144   0000             ;*    at t3_outCmpWr is triggered??????? Again speculation, this is the part of the code
0145   0000             ;*    I understand the least...
0146   0000             ;*
0147   0000             ;*
0148   0000             ;* Timing diagram 
0149   0000             ;* --------------          
0150   0000             ;*
0151   0000             ;* -4 cylinders = 2 rotations = 2 * 360degrees = 720 degrees
0152   0000             ;*
0153   0000             ;* -For sequential injection, fuel injection starts on the cas falling edge 
0154   0000             ;*  i.e. cylinder #1 injection starts at -5 BTDC of #3 TDC
0155   0000             ;*
0156   0000             ;* -Simultaneous injection of all 4 injectors is performed when starting to 
0157   0000             ;*  crank or starting a cold engine or during acceleration, check the tech manual
0158   0000             ;*  and code for more details. Simultaneous injection starts on the 5deg BTDC
0159   0000             ;*  cas signal except in the case of acceleration where it starts when an
0160   0000             ;*  injector is deactivated and no other injector is active (i.e. at the 
0161   0000             ;*  beginning of the time period where no injector is active)
0162   0000             ;*
0163   0000             ;* -Coil energization is usually scheduled (the energization time is loaded into
0164   0000             ;*  the output compare register, energization will occur at the specified time)
0165   0000             ;*  from the cas rising edge. Coil ignition can be scheduled when energization
0166   0000             ;*  occurs (output compare interrupt) or on the cas falling edge depending on 
0167   0000             ;*  the desired timing. Note however that coil energization can also be scheduled
0168   0000             ;*  when ignition occurs on the preceeding cylinder. This would correspond to 
0169   0000             ;*  scheduling ignition before the cas rising edge (at high rpm I assume). Coil
0170   0000             ;*  energization can also be scheduled on the cas falling edge when the desired
0171   0000             ;*  timing is high (e.g. 10deg ATDC). As this shows, there are several combinations 
0172   0000             ;*  and the complexity of the code to handle the coil reflects that fact.
0173   0000             ;*  
0174   0000             ;*           
0175   0000             ;*                         No 1 TDC         No 3 TDC          No 4 TDC          No 2 TDC
0176   0000             ;*                            :                 :                 :                 :
0177   0000             ;*                   ___________                         _____ 
0178   0000             ;* TDC sensor       |           |                       |     |
0179   0000             ;* signal           |         : |               :       |     |   :                 :
0180   0000             ;*              ____|___________|_______________________|_____|________________________
0181   0000             ;*  degrees        85           55                      85   15
0182   0000             ;* (BTDC/ATDC)                :                 :                 :                 :
0183   0000             ;*                    ______            ______            ______            ______ 
0184   0000             ;* CAS sensor        |      |          |      |          |      |          |      |
0185   0000             ;* signal            |      | :        |      | :        |      | :        |      | :
0186   0000             ;*              _____|______|__________|______|__________|______|__________|______|____
0187   0000             ;*  degrees          75     5 :       75      5 :       75      5 :        75     5 :
0188   0000             ;*  (BTDC)                    :                 :                 :                 :
0189   0000             ;*           
0190   0000             ;*                            :                 :                 :                 : 
0191   0000             ;*  No 1 cyl.     compression :   combustion    :    exhaust      :     intake      : compression
0192   0000             ;*  No 3 cyl.       intake    :   compression   :   combustion    :     exhaust     :  intake     
0193   0000             ;*  No 4 cyl.       exhaust   :     intake      :   compression   :    combustion   :  exhaust    
0194   0000             ;*  No 2 cyl.     combustion  :     exhaust     :    intake       :    compression  : combustion  
0195   0000             ;*           
0196   0000             ;*           
0197   0000             ;*           
0198   0000             ;* Airflow calculations dependencies, more details in code
0199   0000             ;* --------------------------------------------------------
0200   0000             ;*           
0201   0000             ;* masProc: airflow sensor interrupt, increases [airCntNew0:airCntNew1] 
0202   0000             ;*    |     by airQuantum for every airflow sensor pulse received
0203   0000             ;*    |
0204   0000             ;*    | 
0205   0000             ;*    |
0206   0000             ;*    |--> [airCntNew0:airCntNew1]: Increased by airQuantum for every airflow sensor pulse
0207   0000             ;*             |                    Reset and used as input to [airCnt0:airCnt1:airCnt2]
0208   0000             ;*             |                    on every cas falling edge, i.e. air is counted twice
0209   0000             ;*             |                    per rotation, once for every cylinder cycle... It can 
0210   0000             ;*             |                    therefore be seen as the air count per cylinder.
0211   0000             ;*             |
0212   0000             ;*             |--> [airCnt0:airCnt1:airCnt2]: Filtered version of 256*[airCntNew0:airCntNew1]
0213   0000             ;*                        |                    exponential averaging is used.
0214   0000             ;*                        |
0215   0000             ;*                        |
0216   0000             ;*                        |
0217   0000             ;*                        |--> mafraw16: 16 bit airflow sensor pulse frequency (mafraw16/10.24)Hz
0218   0000             ;*                        |       |      mafraw16 = 8205*[airCnt0:airCnt1]/Tcas
0219   0000             ;*                        |       |
0220   0000             ;*                        |       |
0221   0000             ;*                        |       |--> mafraw: 8 bit airflow sensor pulse frequency (6.25*mafraw)Hz
0222   0000             ;*                        |                    mafraw: = mafraw16/64
0223   0000             ;*                        |
0224   0000             ;*                        |
0225   0000             ;*                        |
0226   0000             ;*                        |--> airVol16: Equals [airCnt0:airCnt1] * masScalar/65536
0227   0000             ;*                        |       |
0228   0000             ;*                        |       |
0229   0000             ;*                        |       |
0230   0000             ;*                        |       |--> airVol   : Equals airVol16/2
0231   0000             ;*                        |       |--> airVolT  : Equals airVol16/2 * iatCompFact/128
0232   0000             ;*                        |       |--> airVolTB : Equals airVol16/2 * iatCompFact/128 * baroFact/128
0233   0000             ;*                        |       |--> airVolB  : Equals airVol16/2 * baroFact/128
0234   0000             ;*                        |
0235   0000             ;*                        |
0236   0000             ;*                        |--> injPw: Injector pulse width in "normal" operation, 
0237   0000             ;*                                    injPw = [airCnt0:airCnt1] * injFactor/256  + other corrections
0238   0000             ;*
0239   0000             ;*
0240   0000             ;*
0241   0000             ;* Discussion on MAS compensation factors
0242   0000             ;* ---------------------------------------
0243   0000             ;*
0244   0000             ;*     Total airflow sensor compensation is made-up of:
0245   0000             ;*     
0246   0000             ;*          totMasComp(freq,iat,baro) = masComp + t_masComp(freq) + t_masLin(freq,iat,baro)
0247   0000             ;*     
0248   0000             ;*     where maxComp is a fixed offset ($64 for 1G and $40 for 2G) and t_masComp and t_masLin
0249   0000             ;*     are table values interpolated from frequency, intake air temperature and barometric 
0250   0000             ;*     pressure. t_masComp(freq) is basically compensation for the airflow sensor charcteristic
0251   0000             ;*     curve as a function of frequency (to linearize the number of pulse per sec vs. the volume
0252   0000             ;*     of air passing through the sensor) while t_masLin(freq,iat,baro) is a smaller factor
0253   0000             ;*     probably compensating for temperature drift (electronic) and airflow characteristic 
0254   0000             ;*     change as a function of air density???
0255   0000             ;*     
0256   0000             ;*     Assuming the following:
0257   0000             ;*     
0258   0000             ;*         -injComp     = 100% (for 260cc injectors at 36psi)
0259   0000             ;*         -workFtrim   = 100%
0260   0000             ;*         -o2FuelAdj   = 100%
0261   0000             ;*         -iatCompFact = 100% (at 25.6degC)
0262   0000             ;*         -baroFact    = 100% (~1 bar)
0263   0000             ;*         -openLoopEnr = 100%
0264   0000             ;*         -coldTempEnr = 100%
0265   0000             ;*         -enrWarmup   = 0%
0266   0000             ;*     
0267   0000             ;*     
0268   0000             ;*     Then the injector pulswidth is calculated by the ECU as (excluding deadtime)
0269   0000             ;*     
0270   0000             ;*         injPw(usec/cylinder) = numPulsePerCasInterrupts *$9c * totMasComp * 16/256
0271   0000             ;*                              = numPulsePerCasInterrupts * totMasComp * 9.75
0272   0000             ;*     
0273   0000             ;*     If we also assume a 14.7 air to fuel ratio, Dair=1.18 air density (g/litre) at 25degC, 
0274   0000             ;*     Dgas=0.775 fuel density (g/cc) then we would need 23900 usec of injection per 
0275   0000             ;*     litre of air using the same 260cc at 36psi, working that factor into the equation, we 
0276   0000             ;*     get
0277   0000             ;*     
0278   0000             ;*         injPw(usec/cylinder) = numPulsePerCasInterrupts * totMasComp * 9.75
0279   0000             ;*                              = numPulsePerCasInterrupts * totMasComp/2452 * 2452 * 9.75 
0280   0000             ;*                              = numPulsePerCasInterrupts * totMasComp/2452 * 23900usecOfInjection/litreOfAir
0281   0000             ;*     
0282   0000             ;*     This means that under the above assumptions, totMasComp/2452 has units of 
0283   0000             ;*     litreOfAirPerAirflowSensorPulse. 
0284   0000             ;*     
0285   0000             ;*     The factor 2452 is similar to the one provided by J. Oberholtzer, I think. 
0286   0000             ;*     The exact value must be somewhere in that range...
0287   0000             ;*     
0288   0000             ;*     masScalar is also used for maf compensation ($5e86,24198 for 1G, $7A03,31235 for 2g) 
0289   0000             ;*     for controls other than fuel injection. It probably correspond to some metric of
0290   0000             ;*     the totMasComp curve (average or max under given conditions). From 1G and 2G numbers,
0291   0000             ;*     It could correspond to the max of the masComp + t_masComp(freq) curve multiplied 
0292   0000             ;*     by 0.808*128? It could also correspond to the masComp + t_masComp(freq) curve
0293   0000             ;*     sampled at around 69Hz and multiplied by 128.
0294   0000             ;*     
0295   0000             ;*          masScalar = maxTotMasComp*0.808*128 = totMasComp(69Hz)*128
0296   0000             ;*     
0297   0000             ;*     We then have in the case of masScalar = maxTotMasComp*0.808*128:
0298   0000             ;*     
0299   0000             ;*         airVol16 = numPulsePerCasInterrupts * $9c * masScalar / 65536
0300   0000             ;*                  = numPulsePerCasInterrupts * $9c * maxTotMasComp*0.808*128 / 65536
0301   0000             ;*                  = numPulsePerCasInterrupts * maxTotMasComp * 0.2462
0302   0000             ;*                  = numPulsePerCasInterrupts * maxTotMasComp/2452 * 2452*0.2462
0303   0000             ;*                  = numPulsePerCasInterrupts * maxTotMasComp/2452 * 603.68
0304   0000             ;*     
0305   0000             ;*     since totMasComp/2452 is litreOfAirPerAirflowSensorPulse, we have
0306   0000             ;*     
0307   0000             ;*         airVol16 = numPulsePerCasInterrupts * litreOfAirPerAirflowSensorPulse * 603.68
0308   0000             ;*     
0309   0000             ;*     Using again 1.18g/litre air density we get
0310   0000             ;*     
0311   0000             ;*         airVol16 = numPulsePerCasInterrupts * litreOfAirPerAirflowSensorPulse *1.18 * 603.68/1.18
0312   0000             ;*                  = numPulsePerCasInterrupts * gramsOfAirPerAirflowSensorPulse * 512
0313   0000             ;*                  = gramsOfAirPerCasInterrupts * 512
0314   0000             ;*     
0315   0000             ;*     In that case, airVol16/512 can be seen has having units of gramsOfAirPerCasInterrupts 
0316   0000             ;*     (grams of air entering one cylinder). Note that the factor of 512 is not random, the
0317   0000             ;*     factor 0.808 is used to get it in that case...
0318   0000             ;*     
0319   0000             ;*     The load index values used to interpolate the fuel map is then
0320   0000             ;*     
0321   0000             ;*         airVol16/2 <= 96
0322   0000             ;*     
0323   0000             ;*             loadIndex = (airVol16/2-32)/16 
0324   0000             ;*                       = (gramsOfAirPerCasInterrupts*512/2 -32)/16
0325   0000             ;*                       = gramsOfAirPerCasInterrupts*16-2
0326   0000             ;*     
0327   0000             ;*         airVol16/2 >= 96
0328   0000             ;*     
0329   0000             ;*             loadIndex = gramsOfAirPerCasInterrupts * 512/2 * 0.668/16
0330   0000             ;*                       = gramsOfAirPerCasInterrupts*10.69
0331   0000             ;*     
0332   0000             ;*     Which correspond to (gramsOfAirPerCasInterrupts for each index value)
0333   0000             ;*     
0334   0000             ;*            0      1      2       3       4       5       6      7       8       9       10     11
0335   0000             ;*          0.125  0.1875  0.25  0.3125  0.3750  0.4678  0.5614 0.6549  0.7485  0.8421  0.9356  1.0292
0336   0000             ;*     
0337   0000             ;*     gramsOfAirPerRevolution would be twice those values. Notice that the max value of 1.0292
0338   0000             ;*     correspond to about 250HP when BSFC=0.55 which is in the range of the stock 1G 195HP...
0339   0000             ;*     
0340   0000             ;*     Also notice that the 8 bit airflow airVol = airVol16/2 will saturate to $ff when 
0341   0000             ;*     airVol16/2 = 255 which correspond to gramsOfAirPerCasInterrupts = 1 gram. airVolT
0342   0000             ;*     airVolTB and airVolB will also saturate in the same range...
0343   0000             ;*     
0344   0000             ;*     We can now compare these results with the stock boost gauge. It has a max range 
0345   0000             ;*     of 1Kg per sq cm which equals 14.2 psi. The boost gauge duty cycle is given by 
0346   0000             ;*     
0347   0000             ;*         bGaugeODuty = t_bGauge(airVolT/32)/24
0348   0000             ;*     
0349   0000             ;*     When maximum airVolT = 255 = iatCompFact*airVol16/2, bGaugeODuty = 20/24 = 0.83.
0350   0000             ;*     At 25.6 degC, iatCompFact = 1.0 and therefore airVol16=510 which translates to
0351   0000             ;*     1g of air. boost gauge duty of 0.83 correspond to approx. 10.9psi (by eye...). 
0352   0000             ;*     Assuming a displacement of 0.5litre per cylinder and charge air density of  1.18 
0353   0000             ;*     (25degC, probably too low for that psi range, unless you have a perfect intercooler..) 
0354   0000             ;*     we would get 1.18*0.5*(10.9+14.5)/14.5 = 1.03g of air per cylinder (cas 
0355   0000             ;*     interrupt). This is quite close to the 1.0g we had earlier.
0356   0000             ;*     
0357   0000             ;*     The 0psi point on the gauge correspond to a duty cycle of about 40.5% which 
0358   0000             ;*     correspond to bGaugeODuty=9.75/24 which from t_bGauge correspond to 
0359   0000             ;*     airVolT/32=2.875 which means airVolT = 92. with iatCompFact = 1.0 @25degC, 
0360   0000             ;*     we get airVol16 = 2*airVolT/iatCompFact = 184 which correspond to 0.36grams of air 
0361   0000             ;*     Assuming a displacement of 0.5litre per cylinder and charge air density of 1.18@25degC
0362   0000             ;*     we would get 1.18*0.5 = 0.59g of air per cylinder (cas interrupt) at 0psi. Compared to 
0363   0000             ;*     0.36g we had earlier this is a large error but then there are several factor not taken onto 
0364   0000             ;*     account in the calculations, I suppose???.
0365   0000             ;*     
0366   0000             ;*     
0367   0000             ;* Engine coolant and intake air temperature 
0368   0000             ;* ------------------------------------------
0369   0000             ;*
0370   0000             ;*     Approximate sensor curves (temperature 
0371   0000             ;*     against ADC value, taken from MMCD). The
0372   0000             ;*     control points in the service manual are
0373   0000             ;*     quite close (0 to 2 degC off).
0374   0000             ;*
0375   0000             ;*
0376   0000             ;*       ADC   ECT   IAT          ADC  ECT   IAT         ADC  ECT   IAT        ADC   ECT    IAT 
0377   0000             ;*               degC                    degC                    degC                   degC
0378   0000             ;*                                   
0379   0000             ;*       $00  158.0  184.0        $40  52.0  56.0        $80  21.0  23.0       $c0   -7.0   -7.0  
0380   0000             ;*       $01  154.4  178.1        $41  51.3  55.3        $81  20.6  22.5       $c1   -7.5   -7.6  
0381   0000             ;*       $02  150.9  172.5        $42  50.7  54.6        $82  20.2  22.1       $c2   -8.1   -8.2  
0382   0000             ;*       $03  147.5  167.2        $43  50.1  53.9        $83  19.8  21.7       $c3   -8.6   -8.8  
0383   0000             ;*       $04  144.2  162.0        $44  49.5  53.3        $84  19.4  21.2       $c4   -9.2   -9.4  
0384   0000             ;*       $05  140.9  157.1        $45  48.9  52.6        $85  19.0  20.8       $c5   -9.8  -10.1  
0385   0000             ;*       $06  137.7  152.4        $46  48.3  52.0        $86  18.7  20.4       $c6  -10.4  -10.7  
0386   0000             ;*       $07  134.6  148.0        $47  47.7  51.3        $87  18.3  19.9       $c7  -10.9  -11.3  
0387   0000             ;*       $08  131.6  143.7        $48  47.2  50.7        $88  17.9  19.5       $c8  -11.5  -12.0  
0388   0000             ;*       $09  128.6  139.6        $49  46.6  50.1        $89  17.6  19.0       $c9  -12.1  -12.6  
0389   0000             ;*       $0a  125.7  135.7        $4a  46.1  49.4        $8a  17.2  18.6       $ca  -12.7  -13.2  
0390   0000             ;*       $0b  122.9  132.0        $4b  45.6  48.8        $8b  16.9  18.2       $cb  -13.2  -13.9  
0391   0000             ;*       $0c  120.2  128.5        $4c  45.0  48.2        $8c  16.5  17.7       $cc  -13.8  -14.5  
0392   0000             ;*       $0d  117.5  125.1        $4d  44.5  47.7        $8d  16.1  17.3       $cd  -14.3  -15.1  
0393   0000             ;*       $0e  114.9  121.9        $4e  44.0  47.1        $8e  15.7  16.8       $ce  -14.9  -15.7  
0394   0000             ;*       $0f  112.4  118.8        $4f  43.5  46.5        $8f  15.3  16.4       $cf  -15.4  -16.3  
0395   0000             ;*       $10  110.0  116.0        $50  43.0  46.0        $90  15.0  16.0       $d0  -16.0  -17.0  
0396   0000             ;*       $11  107.6  113.2        $51  42.4  45.4        $91  14.5  15.5       $d1  -16.5  -17.6  
0397   0000             ;*       $12  105.3  110.6        $52  41.9  44.9        $92  14.1  15.1       $d2  -17.0  -18.2  
0398   0000             ;*       $13  103.0  108.1        $53  41.4  44.3        $93  13.7  14.6       $d3  -17.5  -18.8  
0399   0000             ;*       $14  100.8  105.8        $54  40.9  43.8        $94  13.3  14.2       $d4  -18.0  -19.4  
0400   0000             ;*       $15   98.7  103.5        $55  40.4  43.3        $95  12.9  13.7       $d5  -18.6  -20.1  
0401   0000             ;*       $16   96.7  101.4        $56  39.9  42.8        $96  12.4  13.3       $d6  -19.2  -20.8  
0402   0000             ;*       $17   94.7   99.4        $57  39.3  42.3        $97  12.0  12.8       $d7  -19.8  -21.5  
0403   0000             ;*       $18   92.8   97.5        $58  38.8  41.8        $98  11.5  12.4       $d8  -20.5  -22.3  
0404   0000             ;*       $19   91.0   95.7        $59  38.3  41.4        $99  11.1  12.0       $d9  -21.3  -23.1  
0405   0000             ;*       $1a   89.2   93.9        $5a  37.8  40.9        $9a  10.6  11.5       $da  -22.1  -24.0  
0406   0000             ;*       $1b   87.5   92.3        $5b  37.3  40.4        $9b  10.2  11.1       $db  -23.0  -24.9  
0407   0000             ;*       $1c   85.9   90.7        $5c  36.9  39.9        $9c   9.7  10.7       $dc  -24.0  -26.0  
0408   0000             ;*       $1d   84.3   89.2        $5d  36.4  39.4        $9d   9.3  10.2       $dd  -25.0  -27.1  
0409   0000             ;*       $1e   82.8   87.7        $5e  35.9  38.9        $9e   8.8   9.8       $de  -26.2  -28.3  
0410   0000             ;*       $1f   81.3   86.3        $5f  35.4  38.4        $9f   8.4   9.4       $df  -27.5  -29.6  
0411   0000             ;*       $20   80.0   85.0        $60  35.0  38.0        $a0   8.0   9.0       $e0  -29.0  -31.0  
0412   0000             ;*       $21   78.6   83.6        $61  34.5  37.5        $a1   7.5   8.5       $e1  -30.5  -32.5  
0413   0000             ;*       $22   77.4   82.4        $62  34.0  37.0        $a2   7.1   8.1       $e2  -32.2  -34.1  
0414   0000             ;*       $23   76.2   81.1        $63  33.6  36.4        $a3   6.6   7.7       $e3  -33.9  -35.7  
0415   0000             ;*       $24   75.0   79.9        $64  33.1  35.9        $a4   6.2   7.3       $e4  -35.8  -37.5  
0416   0000             ;*       $25   73.9   78.8        $65  32.7  35.4        $a5   5.8   6.9       $e5  -37.7  -39.3  
0417   0000             ;*       $26   72.9   77.7        $66  32.3  34.9        $a6   5.3   6.4       $e6  -39.7  -41.2  
0418   0000             ;*       $27   71.9   76.6        $67  31.8  34.4        $a7   4.9   6.0       $e7  -41.7  -43.0  
0419   0000             ;*       $28   70.9   75.5        $68  31.4  33.9        $a8   4.5   5.6       $e8  -43.7  -44.9  
0420   0000             ;*       $29   69.9   74.5        $69  31.0  33.4        $a9   4.0   5.2       $e9  -45.8  -46.8  
0421   0000             ;*       $2a   69.0   73.5        $6a  30.5  32.9        $aa   3.6   4.7       $ea  -47.8  -48.7  
0422   0000             ;*       $2b   68.1   72.5        $6b  30.1  32.4        $ab   3.2   4.3       $eb  -49.8  -50.6  
0423   0000             ;*       $2c   67.3   71.5        $6c  29.7  31.9        $ac   2.7   3.8       $ec  -51.8  -52.4  
0424   0000             ;*       $2d   66.4   70.6        $6d  29.3  31.4        $ad   2.3   3.4       $ed  -53.7  -54.1  
0425   0000             ;*       $2e   65.6   69.7        $6e  28.8  30.9        $ae   1.8   2.9       $ee  -55.5  -55.8  
0426   0000             ;*       $2f   64.8   68.8        $6f  28.4  30.4        $af   1.4   2.4       $ef  -57.3  -57.4  
0427   0000             ;*       $30   64.0   68.0        $70  28.0  30.0        $b0   1.0   2.0       $f0  -59.0  -59.0  
0428   0000             ;*       $31   63.1   67.1        $71  27.5  29.5        $b1   0.5   1.5       $f1  -59.0  -59.0  
0429   0000             ;*       $32   62.3   66.3        $72  27.1  29.0        $b2   0.0   0.9       $f2  -59.0  -59.0  
0430   0000             ;*       $33   61.5   65.5        $73  26.6  28.6        $b3  -0.3   0.4       $f3  -59.0  -59.0  
0431   0000             ;*       $34   60.7   64.7        $74  26.2  28.1        $b4  -0.8  -0.0       $f4  -59.0  -59.0  
0432   0000             ;*       $35   59.9   63.9        $75  25.7  27.7        $b5  -1.3  -0.5       $f5  -59.0  -59.0  
0433   0000             ;*       $36   59.2   63.1        $76  25.3  27.2        $b6  -1.8  -1.1       $f6  -59.0  -59.0  
0434   0000             ;*       $37   58.4   62.3        $77  24.8  26.8        $b7  -2.3  -1.6       $f7  -59.0  -59.0  
0435   0000             ;*       $38   57.6   61.6        $78  24.4  26.4        $b8  -2.8  -2.2       $f8  -59.0  -59.0  
0436   0000             ;*       $39   56.9   60.9        $79  23.9  25.9        $b9  -3.3  -2.8       $f9  -59.0  -59.0  
0437   0000             ;*       $3a   56.1   60.1        $7a  23.5  25.5        $ba  -3.8  -3.3       $fa  -59.0  -59.0  
0438   0000             ;*       $3b   55.4   59.4        $7b  23.0  25.1        $bb  -4.3  -3.9       $fb  -59.0  -59.0  
0439   0000             ;*       $3c   54.7   58.7        $7c  22.6  24.7        $bc  -4.8  -4.5       $fc  -59.0  -59.0  
0440   0000             ;*       $3d   54.0   58.0        $7d  22.2  24.2        $bd  -5.3  -5.1       $fd  -59.0  -59.0  
0441   0000             ;*       $3e   53.3   57.3        $7e  21.8  23.8        $be  -5.9  -5.7       $fe  -59.0  -59.0  
0442   0000             ;*       $3f   52.6   56.6        $7f  21.4  23.4        $bf  -6.4  -6.3       $ff  -59.0  -59.0  
0443   0000             ;*
0444   0000             ;*
0445   0000             ;*
0446   0000             ;*     
0447   0000             ;****************************************************************************************************
0448   0000             
0449   0000             ;***************************************************************
0450   0000             ;*
0451   0000             ;*
0452   0000             ;* Assembler general settings
0453   0000             ;*
0454   0000             ;*
0455   0000             ;*
0456   0000             ;***************************************************************
0457   0000                         .msfirst                        ; Assembler endian setting, do not change
0458   0000                         .define   E931                  ; E931 or E932 depending on desired output
0459   0000                         ;.define   enableCustom          ; Define to enable custom features below, comment-out to get the original E931 or E932 binaries
0460   0000             
0461   0000~            #ifdef enableCustom
0462   0000~                        ;-----------------
0463   0000~                        ; Custom settings 
0464   0000~                        ;-----------------
0465   0000~            codeOffset  .equ      $0100                 ; Allows to move all the code up in the eprom to make space for new code, Original offset is 0.
0466   0000~                        .define   ftrimMax     $b3      ; Maximum fuel trim adjustement (xx/$80)%, $b3=140%
0467   0000~                        .define   fuelMapClip  $d0      ; Fuel map max value (will be clippped to this in code)
0468   0000~                        .define   injComp      $31      ; Injector size compensation referenced to $80=100% for 260cc at 36psi: 390cc(4E,43psi);450(4A);510(41);550(3D);600(38);650(33);660(32);680(31);700(30);750(2C);800(2A);850(27);
0469   0000~                        .define   idleVal      $64      ; Idle speed /8, Normal $60
0470   0000~                        .define   idleDrVal    $57      ; Idle speed /8, Normal $53
0471   0000~                        .define   fuelCutVal   $ff      ; Fuel cut value, Original $a0
0472   0000~                        .define   masComp      $40      ; Mas multiplier (1G:$64, 2G:$40)
0473   0000~                        .define   masScalar    $7a03    ; Mas scalar (1G:$5e86, 2G:$7a03)
0474   0000~                        .define   baudRate     $02      ; BaudRate divider->00(125000baud),01(15625baud),02(1953baud),03(488baud)
0475   0000~            
0476   0000~                        .define   custDeadTime          ; Use custom injector deadtime table
0477   0000~                        .define   custMas               ; Use custom MAS table
0478   0000~                        .define   custFuelMap           ; Use custom fuel map
0479   0000~                        .define   custTimingMap         ; Use custom timing map
0480   0000~                        .define   custOctaneMap         ; Use custom octane map
0481   0000~                        .define   octaneReset           ; Reset octane on every start
0482   0000~                        .define   extLoadRange          ; Extended load range for timing, fuel and octane maps...
0483   0000~                        .define   extLoadRange2         ; Use temperature compensation for load calc when extLoadRange is enabled
0484   0000~                        .define   batteryGauge          ; Battery gauge instead of boost gauge
0485   0000~                        .define   masLog2X              ; Double the MAS logging range
0486   0000~                        ;.define  noFuelCut             ; Remove fuel cut altogether
0487   0000~                        ;.define  noRamReset            ; 
0488   0000~                        .define  noClosedLoop          ; Remove closed loop mode, for testing...
0489   0000~            
0490   0000             #else
0491   0000             #ifdef E931
0492   0000                         ;--------------------------------------
0493   0000                         ; Default values for original 931 ECU
0494   0000                         ;--------------------------------------
0495   0000             codeOffset  .equ      $0000                ; 
0496   0000                         .define   ftrimMax     $b3     ;
0497   0000                         .define   fuelMapClip  $ca     ;
0498   0000                         .define   injComp      $4a     ; 450cc injectors used at 36psi...
0499   0000                         .define   idleVal      $60     ;
0500   0000                         .define   fuelCutVal   $a0     ; 
0501   0000                         .define   masComp      $64     ; 
0502   0000                         .define   masScalar    $5e86   ;                                              
0503   0000                         .define   baudRate     $02     ; 
0504   0000~            #else
0505   0000~                        ;--------------------------------------
0506   0000~                        ; Default values for original 932 ECU
0507   0000~                        ;--------------------------------------
0508   0000~            codeOffset  .equ      $0000                ;
0509   0000~                        .define   ftrimMax     $b0     ;
0510   0000~                        .define   fuelMapClip  $c0     ;
0511   0000~                        .define   injComp      $4e     ; 390cc injectors used at 43psi, the value reflects that pressure difference compared to E931
0512   0000~                        .define   idleVal      $60     ;
0513   0000~                        .define   idleDrVal    $53     ; 
0514   0000~                        .define   fuelCutVal   $a0     ; 
0515   0000~                        .define   masComp      $64     ; 
0516   0000~                        .define   masScalar    $5e86   ;                                              
0517   0000~                        .define   baudRate     $02     ; 
0518   0000             #endif
0519   0000             #endif
0520   0000             
0521   0000             
0522   0000             
0523   0000             ;***************************************************************
0524   0000             ;*
0525   0000             ;*
0526   0000             ;* Microcontroller registers
0527   0000             ;*
0528   0000             ;*
0529   0000             ;***************************************************************
0530   0000             p1_ddr           .EQU     $0000                  ; Port 1 data direction register. Initialized with $7E=01111110  (0=intput, 1=output)
0531   0000             p2_ddr           .EQU     $0001                  ; Port 2 data direction register. Initialized with $16=00010110
0532   0000             port1            .EQU     $0002                  ; Port 1 Data register                                             
0533   0000                                                              ;    bit 0 (0x01):  in  - Unused but varies(seems to have correlation with CAS), by extrapolation, set to out for injector #5 or #6 on other ECUs?                                                 
0534   0000                                                              ;    bit 1 (0x02):  out - Set to 0 to activate injector #3?                                             
0535   0000                                                              ;    bit 2 (0x04):  out - Set to 0 to activate injector #2?                                            
0536   0000                                                              ;    bit 3 (0x08):  out - Set to 0 to activate injector #4?                                              
0537   0000                                                              ;    bit 4 (0x10):  out - Fuel pump relay
0538   0000                                                              ;    bit 5 (0x20):  out - Air cond. clutch
0539   0000                                                              ;    bit 6 (0x40):  out - ???, reset to 0 on init and first sub    
0540   0000                                                              ;    bit 7 (0x80):  in  - Reed switch, 4 square pulse (square wave) per odometer rotation, each of the 4 complete square wave correspond to ~40cm (20cm for each rising or falling edge)
0541   0000             port2            .EQU     $0003                  ; Port 2 Data register
0542   0000                                                              ;    bit 0 (0x01):  in  - Unused but varies (seems to have correlation with CAS), by extrapolation, set to out for injector #5 or #6 on other ECUs?                                                                                                           
0543   0000                                                              ;    bit 1 (0x02):  out - Set to 0 to activate injector #1?                                                                                                             
0544   0000                                                              ;    bit 2 (0x04):  out - Airflow sensor active filter reset. Set/reset depending on tps,rpm,airVol,idleSwitch??????   (in serial clock)-  Connected to serial port clock???
0545   0000                                                              ;    bit 3 (0x08):  in  - Connected to serial port input (if serial RE is enabled) and test connector serial interface                                                                              
0546   0000                                                              ;    bit 4 (0x10):  out - Connected to serial port output (if serial TE is enabled) and test connector serial interface, controlled directly to output heart beat code to test connector
0547   0000                                                              ;    bit 5 (0x20):  in  - 0, ECU Operating mode PC0 (latched on ECU reset)                                                               
0548   0000                                                              ;    bit 6 (0x40):  in  - 1, ECU Operating mode PC1                                                                                      
0549   0000                                                              ;    bit 7 (0x80):  in  - 0, ECU Operating mode PC2                                                                                      
0550   0000             p3_ddr           .EQU     $0004                  ; Port 3 data direction register, Initialized to 0 (all input) 
0551   0000             p4_ddr           .EQU     $0005                  ; Port 4 data direction register, Initialized to 0 (all input) 
0552   0000             port3            .EQU     $0006                  ; Port 3 Data register                                         
0553   0000                                                              ;    bit 0 (0x01):  in  - IG2 related, 0 when IG2 at +12V??? (ABS unit?????)  see around Md4d4 and M23db?                                    
0554   0000                                                              ;    bit 1 (0x02):  in  - IG1. 0 when IG1 at +12V. Set to 1 when power has been turned off and control relay is about to turn off. i.e. ECU is going to loose power in a short while.
0555   0000                                                              ;    bit 2 (0x04):  in  - Top dead center sensor signal (TDC). Set to 0 when TDC signal is active
0556   0000                                                              ;    bit 3 (0x08):  in  - Set to 1 if power steering pump is activated
0557   0000                                                              ;    bit 4 (0x10):  in  - Air cond. switch (1=off). 0 indicate that AC should be activated, if possible... Connected to the output of the A/C control unit through the the ECT switch (switch cuts signal therefore asking ECU to cut clutch...)
0558   0000                                                              ;    bit 5 (0x20):  in  - Inhibitor switch (A/T only) Set to 1 when transmission is in park or neutral
0559   0000                                                              ;    bit 6 (0x40):  in  - 0 if key is in start position
0560   0000                                                              ;    bit 7 (0x80):  in  - Set to 1 when the idle switch is on
0561   0000             port4            .EQU     $0007                  ; Port 4 data register 
0562   0000                                                              ;    bit 0 (0x01):  in  - c0, set when config resistor R129 is installed. used in conjucntion with c1 in #t_strap1 lookup, FEDERAL (0) or CALIFORNIA (1)                                                
0563   0000                                                              ;    bit 1 (0x02):  in  - c1, set when config resistor R130 is installed. used in conjucntion with c0 in #t_strap1 lookup, FWD (0) or AWD (1)                                                
0564   0000                                                              ;    bit 2 (0x04):  in  - Signal from the ignition sensing circuit. Toggled on every ignition signal sent to the coil (toggled on every cylinder ignition if the power transistor output changed...), stays at the given level from one ignition to the other
0565   0000                                                              ;    bit 3 (0x08):  in  - Set to 1 when ECU test mode terminal is grounded                
0566   0000                                                              ;    bit 4 (0x10):  in  - Set to 1 when the timing terminal is grounded                                                 
0567   0000                                                              ;    bit 5 (0x20):  in  - Knock sensor feedback? (set to 1 indicates it works...)???                                                
0568   0000                                                              ;    bit 6 (0x40):  in  - Fuel pump driven feedback? 0 when FP is driven?                                               
0569   0000                                                              ;    bit 7 (0x80):  in  - Injector driven feedback. Set to 0 when injector circuit is working properly??? Bit is tested when an injector to test was just deactivated and no other injector is active??? Bit might be loaded on the falling edge of the injector driving current???
0570   0000                                                              ;                         Service manual says injector is bad if injector is not continuously driven for 4 sec during idle or cranking. 4 sec is implemented by fault code regular code... So this bit would be "injector driven" bit
0571   0000             t1_csr           .EQU     $0008                  ; Dual of $18, Timer1 control and status register, dual of t2_csr                                                             
0572   0000                                                              ;    bit 0 (0x01): Injector 1 activation/deactivation bit. Bit is transfered to port2.1 when a t1 or t2 output compare interrupt is generated???
0573   0000                                                              ;    bit 1 (0x02): cas edge detection polarity, set to 0 to trigger an interrupt on the CAS rising edge, set to 1 to trigger an interrupt on the CAS falling edge
0574   0000                                                              ;    bit 2 (0x04): By extrapolation, set to 0 when injector 5/6 is on????
0575   0000                                                              ;    bit 3 (0x08): Set to 1 to enable outCompInt1 interrupts (injector 1 only or 1 and 4)?
0576   0000                                                              ;    bit 4 (0x10): Set to 1 to enable inCaptInt1 interrupts (cas)?
0577   0000                                                              ;    bit 5 (0x20): By extrapolation, set to 0 when injector 5/6 is on????
0578   0000                                                              ;    bit 6 (0x40): 1 indicate that outCompInt1 interrupt is pending/has been activated (injector #1 or #4 activation/deactivation)                                                                                               
0579   0000                                                              ;    bit 7 (0x80): 1 indicate that inCaptInt1 interrupt is pending/has been activated (cas)
0580   0000             t1t2_clk         .EQU     $0009   ;:$000a        ; Free running counter at 1MHz for t1 and t2 timer functions
0581   0000             t1_outCmpWr      .EQU     $000b   ;:$000c        ; Dual of $001B, Output compare register, value is compared to t1t2_clk and when a match occurs, injector ports are loaded with the values indicated in t1_csr. Seems 2 or 3 successive value can be written (injector activation and deactivation times...)
0582   0000             t1_inCapt        .EQU     $000d   ;:$000e        ; Cas sensor input capture register. Contains the value of t1t2_clk when the cas sensor "edge" was detected
0583   0000             L000f            .EQU     $000f                  ; Init to 0??????????????
0584   0000             sci_baud         .EQU     $0010                  ; Serial communication rate and mode control register (clock source = 2MHz)                     
0585   0000                                                              ;    bit 0 (0x01): SS0, [SS1:SS0] is baud rate divider, 00(16) 01(128) 10(1024) 11(4096), assuming basic clock of 2MHZ, we get 125000baud, 15625baud, 1953baud, 488baud                           
0586   0000                                                              ;    bit 1 (0x02): SS1                            
0587   0000                                                              ;    bit 2 (0x04): CC0, [CC1:CC0] is the mode control register                          
0588   0000                                                              ;    bit 3 (0x08): CC1                            
0589   0000                                                              ;    bit 4 (0x10): NU?                                                                
0590   0000                                                              ;    bit 5 (0x20): NU?                                                                
0591   0000                                                              ;    bit 6 (0x40): NU?                                                                
0592   0000                                                              ;    bit 7 (0x80): NU?                                                                
0593   0000             sci_scr          .EQU     $0011                  ; Serial communication status and control register?                             
0594   0000                                                              ;    bit 0 (0x01): WU   - Wake-up on idle line                                     
0595   0000                                                              ;    bit 1 (0x02): TE   - transmit enable, set to 1                                
0596   0000                                                              ;    bit 2 (0x04): TIE  - Tx interrupt enable, reset to 0                          
0597   0000                                                              ;    bit 3 (0x08): RE   - Rx enable, checked for set before tx                     
0598   0000                                                              ;    bit 4 (0x10): RIE  - Rx interrupt enable,  Reset/set to 0/1 in real time int        
0599   0000                                                              ;    bit 5 (0x20): TDRE - transmit data register empty                             
0600   0000                                                              ;    bit 6 (0x40)  ORFE - Overrun and framing error                                
0601   0000                                                              ;    bit 7 (0x80): RDRF - Read data register full                                  
0602   0000             sci_rx           .EQU     $0012                  ; SCI data read register   
0603   0000             sci_tx           .EQU     $0013                  ; SCI data write register  
0604   0000             ramControl       .EQU     $0014                  ; RAM control register/battery saving status register
0605   0000                                                              ;    bit 0 (0x01): Init to 0? 
0606   0000                                                              ;    bit 1 (0x02): Init to 0?
0607   0000                                                              ;    bit 2 (0x04): Init to 0?
0608   0000                                                              ;    bit 3 (0x08): Init to 0?
0609   0000                                                              ;    bit 4 (0x10): Init to 0?
0610   0000                                                              ;    bit 5 (0x20): Init to 0?
0611   0000                                                              ;    bit 6 (0x40): Ram enable bit??? Set to 1 after the fresh reset initialization is done, reset to 0 in failureInt?
0612   0000                                                              ;    bit 7 (0x80): Power standby bit, Set to 1 after the fresh reset initialization is done, reset to 0 if we loose standby power (i.e. 0 when ram content was not preserved after a power-off) 
0613   0000             p5_ddr           .EQU     $0015                  ; Port 5 data direction register, Initialized to $#fe (1111 1110)
0614   0000             port5            .EQU     $0016                  ; Port 5      
0615   0000                                                              ;    bit 0 (0x01): in  - CAS, crank angle sensor signal. Set to 0 when the CAS signal is activated                                                                                  
0616   0000                                                              ;    bit 1 (0x02): out - Power transistor output for cyl 1 and 4. Set to 0 to energize the coil. 
0617   0000                                                              ;    bit 2 (0x04): out - Power transistor output for cyl 2 and 3. Set to 0 to energize the coil. 
0618   0000                                                              ;    bit 3 (0x08): out - EGR control solenoid output
0619   0000                                                              ;    bit 4 (0x10): out - Fuel pressure solenoid output (0=activated)                                                                                
0620   0000                                                              ;    bit 5 (0x20): out - Boost control solenoid output
0621   0000                                                              ;    bit 6 (0x40): out - ISC step control, see table t_iscPattern                                                                 
0622   0000                                                              ;    bit 7 (0x80): out - ISC step control, see table t_iscPattern                                                                 
0623   0000             L0017            .EQU     $0017                  ; Init to 0?????
0624   0000             t2_csr           .EQU     $0018                  ; Timer2 control and status register, uses the same clock as timer 1 (t1t2_clk)
0625   0000                                                              ;    bit 0 (0x01): Injector 3 activation/deactivation bit. Bit is transfered to port1.1 when a t1 or t2 output compare interrupt is generated
0626   0000                                                              ;    bit 1 (0x02): Airflow sensor edge detection polarity (0=rising edge, 1=falling edge, or the opposite?). See masProc subroutine header
0627   0000                                                              ;    bit 2 (0x04): Injector 2 activation/deactivation bit. Bit is transfered to port1.2 when a t1 or t2 output compare interrupt is generated
0628   0000                                                              ;    bit 3 (0x08): Set to 1 to enable outCompInt2 interrupts (injectors 2, 3 and maybe 4)?
0629   0000                                                              ;    bit 4 (0x10): Set to 1 to enable inCaptInt2 interrupts (airflow sensor)?
0630   0000                                                              ;    bit 5 (0x20): Injector 4 activation/deactivation bit. Bit is transfered to port1.3 when a t1 or t2 output compare interrupt is generated
0631   0000                                                              ;    bit 6 (0x40): 1 indicate that outCompInt2 interrupt is pending/has been activated (injectors #2 or #3 activation/deactivation)                                                                                               
0632   0000                                                              ;    bit 7 (0x80): 1 indicate that inCaptInt2 interruot is pending/has been activated (airflow sensor pulse)  
0633   0000             t3_csr0          .EQU     $0019                  ; Normally the dual of $0009 but since the ECU didn't need the equivalent of t1t2_clk for timer 2 (timer 1 and timer 2 both use t1t2_clk), it is used for something else...
0634   0000                                                              ; timer 3 (coil) control ans status register 0 ???
0635   0000                                                              ;    bit 0 (0x01): 0 all the time except, set to 1 when no cas interrupt received for 1.275sec???
0636   0000                                                              ;    bit 1 (0x02): 1 on every loop
0637   0000                                                              ;    bit 2 (0x04): 1 Set to 0 when the output compare interrupt need to energize coil for cylinder 1 or 4, i.e. bit will be loaded in port5.1 when interrupt occur
0638   0000                                                              ;    bit 3 (0x08): 1 Set to 0 when the output compare interrupt need to energize coil for cylinder 2 or 3, i.e. bit will be loaded in port5.2 when interrupt occur
0639   0000                                                              ;    bit 4 (0x10): 1 on init but not on every loop, Used to decide which of t3_clock1 or t3_clock2 should be used upon a CAS interrupt???
0640   0000                                                              ;    bit 5 (0x20): 0 on every loop
0641   0000                                                              ;    bit 6 (0x40): 1 on every loop
0642   0000                                                              ;    bit 7 (0x80): 0 on every loop
0643   0000             t3_csr1          .EQU     $001a                  ; Normally the dual of $000a but since the ECU didn't need the equivalent of t1t2_clk for timer 2 (timer 1 and timer 2 both use t1t2_clk), it is used for something else...
0644   0000                                                              ; timer 3 (coil) control ans status register 1???
0645   0000                                                              ;    bit 0 (0x01): 0 Cylinder 1/4 or 2/3 ?? output compare detection polarity?
0646   0000                                                              ;    bit 1 (0x02): 1 Cylinder 1/4 or 2/3 ?? output compare detection polarity?
0647   0000                                                              ;    bit 2 (0x04): 0 Cylinder 1/4 or 2/3 ?? output compare detection polarity?
0648   0000                                                              ;    bit 3 (0x08): 1 Cylinder 1/4 or 2/3 ?? output compare detection polarity?
0649   0000                                                              ;    bit 4 (0x10): 0
0650   0000                                                              ;    bit 5 (0x20): 0
0651   0000                                                              ;    bit 6 (0x40): 0 1 indicate that the outCompInt3 interrupt is pending/has been activated???                                                                                               
0652   0000                                                              ;    bit 7 (0x80): 0
0653   0000             t2_outCmpWr      .EQU     $001b   ;:$001c        ; Dual of $0b:$0c, Output compare register, value is compared to t1t2_clk and when a match occurs, injector ports are loaded with the values indicated in t2_csr. seems 2 or 3 successive value can be written (injector activation and deactivation times...)
0654   0000             t2_inCapt        .EQU     $001d   ;:$001e        ; Dual of $0d:$0e, Airflow sensor input capture register. Contains the value of t1t2_clk when an airflow sensor pulse edge detected
0655   0000             adc_ctl          .EQU     $001f                  ; ADC control; [bit 3 = start bit?, bit 2:0 = channel select ]???
0656   0000                                                              ;    bit 0 (0x01): c0 [c2:c1:c0] is the port number to use aas input to the A/D converter                                                                      
0657   0000                                                              ;    bit 1 (0x02): c1                                                                       
0658   0000                                                              ;    bit 2 (0x04): c2                                                                       
0659   0000                                                              ;    bit 3 (0x08): Start bit, set to 1 to start A/D conversion                                                                         
0660   0000                                                              ;    bit 4 (0x10): ?                                                                       
0661   0000                                                              ;    bit 5 (0x20): ?                                                                       
0662   0000                                                              ;    bit 6 (0x40): ?
0663   0000                                                              ;    bit 7 (0x80): ?                                                                       
0664   0000             adc_data         .EQU     $0020                  ; 8 bit A to D converter result data
0665   0000             L0021            .EQU     $0021                  ; Unused?
0666   0000             L0022            .EQU     $0022                  ; Unused?
0667   0000             L0023            .EQU     $0023                  ; Unused?
0668   0000             L0024            .EQU     $0024                  ; Init to 0?
0669   0000             L0025            .EQU     $0025                  ; Unused?
0670   0000             rti_ctl          .EQU     $0026                  ; Timer control and status register for real time interrupt? init to $4D = 0100 1101
0671   0000                                                              ;    bit 0 (0x01): ?                                                                       
0672   0000                                                              ;    bit 1 (0x02): ?                                                                       
0673   0000                                                              ;    bit 2 (0x04): ?                                                                       
0674   0000                                                              ;    bit 3 (0x08): ?                                                                       
0675   0000                                                              ;    bit 4 (0x10): ?                                                                       
0676   0000                                                              ;    bit 5 (0x20): ?                                                                       
0677   0000                                                              ;    bit 6 (0x40): Set to 1 to enable rti interrupts?
0678   0000                                                              ;    bit 7 (0x80): ?                                                                       
0679   0000             rti_freq         .EQU     $0027                  ; Real time interrupt frequency setting: Freq = 125000/(256-x) where x is the content of rti_freq
0680   0000             L0028            .EQU     $0028                  ; Unused?
0681   0000             t3_clock1        .EQU     $0029   ;:$002a        ; Readable counter. Frequency seems to be 250KHz (2MHz/8).
0682   0000             t3_outCmpWr      .EQU     $002b   ;:$002c        ; Writable output compare register for counters at $0029:$002A and $002D:$002E
0683   0000                                                              ; Seems to be double buffered...
0684   0000             t3_clock2        .EQU     $002d   ;:$002e        ; Dual of $0029. I think it always has the same value as t3_clock1 but ipon a cas interrupt, the code decides between t3_clock1 and t3_clock2???
0685   0000             port6            .EQU     $002f                  ; Port 6 (all output, no data direction register?)                                             
0686   0000                                                              ;    bit 0 (0x01): out - Write 1 to reset instant knock count???
0687   0000                                                              ;    bit 1 (0x02): out - ??? Set to 0 when rpm>4688rpm, set to 1 when rpm<4600, could be some kind of ECU board filter setting for the knock sensor???
0688   0000                                                              ;    bit 2 (0x04): out - Boost gauge output
0689   0000                                                              ;    bit 3 (0x08): out - Check engine (CE) light
0690   0000                                                              ;    bit 4 (0x10): out - Reset to 0 to activate purge solenoid?
0691   0000                                                              ;    bit 5 (0x20): out - Toggled at F924 if main loop frequency >20Hz, could be tied to ECU reset in case of trouble (COP clock)
0692   0000                                                              ;    bit 6 (0x40): out - Not used?                                                         
0693   0000                                                              ;    bit 7 (0x80): out - Not used?                                                         
0694   0000                              
0695   0000                              ;------------------------------
0696   0000                              ; Block of 16 probably unused 
0697   0000                              ; microcontroller registers??? 
0698   0000                              ;------------------------------
0699   0000             L0030            .EQU     $0030                  ; Unused
0700   0000             L0031            .EQU     $0031                  ; Unused
0701   0000             L0032            .EQU     $0032                  ; Unused
0702   0000             L0033            .EQU     $0033                  ; Unused
0703   0000             L0034            .EQU     $0034                  ; Unused
0704   0000             L0035            .EQU     $0035                  ; Unused
0705   0000             L0036            .EQU     $0036                  ; Unused
0706   0000             L0037            .EQU     $0037                  ; Unused
0707   0000             L0038            .EQU     $0038                  ; Unused
0708   0000             L0039            .EQU     $0039                  ; Unused
0709   0000             L003a            .EQU     $003a                  ; Unused
0710   0000             L003b            .EQU     $003b                  ; Unused
0711   0000             L003c            .EQU     $003c                  ; Unused
0712   0000             L003d            .EQU     $003d                  ; Unused
0713   0000             L003e            .EQU     $003e                  ; Unused
0714   0000             L003f            .EQU     $003f                  ; Unused 
0715   0000                         
0716   0000             
0717   0000             
0718   0000             ;***************************************************************
0719   0000             ;*
0720   0000             ;*
0721   0000             ;* Block of RAM used to preserve settings when the ECU is off 
0722   0000             ;* (This block is not cleared to 0 when the ECU is powered-on)
0723   0000             ;*
0724   0000             ;*
0725   0000             ;***************************************************************
0726   0000             ftrim_low        .EQU     $0040                  ; Fuel trim low  (.78x)%                     
0727   0000             ftrim_mid        .EQU     $0041                  ; Fuel trim mid  (.78x)%                     
0728   0000             ftrim_hi         .EQU     $0042                  ; Fuel trim high (.78x)%                     
0729   0000             ftrimCntr        .EQU     $0043                  ; Fuel trim counter. This counter is increased/decreased by 5 (+/-5 at 40Hz) whenever a fuel trim is below/above o2Fbk threshold. The fuel trim is increased/decreased by 1 whenever this counter rools over, giving an effective update rate of 40Hz/(256/5)=0.78125Hz for the fuel trims update                                           
0730   0000             isc0             .EQU     $0044   ;:$0045        ; iscm (isc0 or isc1) are 16 bit long term correction factors/feedback for the isc step adjustment. It is centered at $8000 (100%, no correction). Init to $8c00, A value higher than $8000 indicate that we need to increase the isc step since the current rpm is lower than the desired one
0731   0000                                                              ; The isc step used is increased/decreased by iscm/256 - $80. iscm is updated from the short term iscYn variable.The isc step used is increased/decreased by iscm/256 - $80
0732   0000                                                              ; isc0 is the long term learning variable when A/C is off, 16 bits, see iscPointers function
0733   0000             isc1             .EQU     $0046   ;:$0047        ; isc1 is the long term learning variable when A/C is on, 16 bits, see iscPointers function
0734   0000             iscStepCom       .EQU     $0048                  ; isc step complement, shlould be equal to  ~iscStepCurr & $7f. Not sure of its utility???
0735   0000             iscStepCurr      .EQU     $0049                  ; Current isc step (x) range of 0 to 120 (or 13x???)                             
0736   0000             iscPatrnIdx      .EQU     $004a                  ; Current ISC pattern index, two lower bits are used as index into t_iscPattern to update port5.6.7 in order to move the ISC spindle...                                          
0737   0000             iscFlags0        .EQU     $004b                  ; Flag register for ISC updating
0738   0000                                                              ;    bit 0 (0x01): Set to 1 once the isc calibration is started. This means we initialized iscStepCurr to 135 and set the iscStepTarg to 0. The spindle will therefore be moved to the minimum position irrespective of the starting position, which will allow us to know its real position... Reset to 0 once calibration is finished and ISC is back to iscStepCurr=6
0739   0000                                                              ;    bit 1 (0x02): Set to 1 once the isc calibration is finished. i.e. once iscStepCurr reached 0. See bit 0.  Reset to 0 once calibration is finished and ISC is back to iscStepCurr=6
0740   0000                                                              ;    bit 2 (0x04): Set when basic idle speed adjustment mode is active 
0741   0000                                                              ;    bit 3 (0x08): Set to 1 when a fixed isc step is used because the engine is running but we are not receiving airflow sensor interrupts. 
0742   0000                                                              ;    bit 4 (0x10): Set to 1 when a fixed isc step is used because the ECU is about to loose power 
0743   0000                                                              ;    bit 5 (0x20): Set to 1 when ISC min calibration need to be performed, i.e. move the spindle 135 steps toward 0, that ensures the spindle is positionned at the minimum position, wherever we started from... Reset to 0 once calibration is finished and ISC is back to iscStepCurr=6
0744   0000                                                              ;    bit 6 (0x40): Set to 1 when the ISC max calibration has been performed, see bit 7
0745   0000                                                              ;    bit 7 (0x80): Set to 1 when ISC max calibration need to be performed. Max calibration is achieved by setting iscStepTarg to 135, wait for iscStepCurr to reach 135 (higher than max usable valu of 120) and then set iscStepCurr to 120 since this is the max usable value 
0746   0000             stFaultHi        .EQU     $004c                  ; Stored faults, High byte. Notice we say its high byte because it is the ECU convention to store high byte before low byte and it is also used that way in the code                   
0747   0000             stFaultLo        .EQU     $004d                  ; Stored faults, Low byte. 
0748   0000             faultHi          .EQU     $004e                  ; Faults, high byte. Notice we say its high byte because it is the ECU convention to store high byte before low byte and it is also used that way in the code                   
0749   0000             faultLo          .EQU     $004f                  ; Faults, low byte                         
0750   0000             o2BadCnt         .EQU     $0050                  ; Used to test the o2 sensor, 0 when 02 sensor not in fault or not tested, 1 or greater when o2 sensor is bad. Can only increase by 1 each time the ECU is turned on and sensor is tested
0751   0000             egrtBadCnt       .EQU     $0051                  ; Used to test the egrt sensor, 0 when egrt sensor not in fault or not tested, 1 or greater when egrt sensor is bad. Can only increase by 1 each time the ECU is turned on and sensor is tested
0752   0000             octane           .EQU     $0052                  ; Octane value used in timing advance calculation with min 0(bad fuel...), max 255 (no knock). Updated at 2.5Hz from knockSum under specific circumstances (decremented by 1 if knocksum>5, incremented by 1 if knocksum<3)
0753   0000             knockFlags       .EQU     $0053                  ; Flags related to knock sensor
0754   0000                                                              ;    bit 0 (0x01): 
0755   0000                                                              ;    bit 1 (0x02): 
0756   0000                                                              ;    bit 2 (0x04): 
0757   0000                                                              ;    bit 3 (0x08): 
0758   0000                                                              ;    bit 4 (0x10): 
0759   0000                                                              ;    bit 5 (0x20): 
0760   0000                                                              ;    bit 6 (0x40): Set to 1 when engine has been runnning for more than 1 sec
0761   0000                                                              ;    bit 7 (0x80): Set to 1 when airVol>$49, used to know whether engine is under high or loaw load for knockSum and knockSum decay calculations
0762   0000             L0054            .EQU     $0054                  ; UNUSED?
0763   0000             config1          .EQU     $0055                  ; Configuration flags depending on config resistors, Loaded with t_strap1[port4& (#$03 << 1)]
0764   0000                                                              ;    bit 0 (0x01): 
0765   0000                                                              ;    bit 1 (0x02): 
0766   0000                                                              ;    bit 2 (0x04): 
0767   0000                                                              ;    bit 3 (0x08): 
0768   0000                                                              ;    bit 4 (0x10): 
0769   0000                                                              ;    bit 5 (0x20): 
0770   0000                                                              ;    bit 6 (0x40): 
0771   0000                                                              ;    bit 7 (0x80): 
0772   0000             config2          .EQU     $0056                  ; Configuration flags depending on config resistors, Loaded with t_strap1[port4& (#$03 << 1)+1]  
0773   0000                                                              ;    bit 0 (0x01): 
0774   0000                                                              ;    bit 1 (0x02): 
0775   0000                                                              ;    bit 2 (0x04): 
0776   0000                                                              ;    bit 3 (0x08): 
0777   0000                                                              ;    bit 4 (0x10): 
0778   0000                                                              ;    bit 5 (0x20): 
0779   0000                                                              ;    bit 6 (0x40): 
0780   0000                                                              ;    bit 7 (0x80): 
0781   0000                                                                       
0782   0000                                                                                                         
0783   0000                                                                                                        
0784   0000             ;***************************************************************
0785   0000             ;*
0786   0000             ;*
0787   0000             ;* RAM, cleared to 0 when the ECU is powered-on
0788   0000             ;*
0789   0000             ;*
0790   0000             ;***************************************************************
0791   0000             ramClearStart    .EQU     $0057
0792   0000             temp1            .EQU     $0057                  ;
0793   0000             temp2            .EQU     $0058                  ;
0794   0000             temp3            .EQU     $0059                  ;
0795   0000             temp4            .EQU     $005a                  ;
0796   0000             temp5            .EQU     $005b                  ;
0797   0000             temp6            .EQU     $005c                  ;
0798   0000             temp7            .EQU     $005d                  ;
0799   0000             temp8            .EQU     $005e                  ;
0800   0000             temp9            .EQU     $005f                  ;
0801   0000             realT2X          .EQU     $0060                  ; Unused
0802   0000             casFlags0        .EQU     $0061                  ; Flag register
0803   0000                                                              ;    bit 0 (0x01): Bit is set to 1 when rpm(Tcas) >= 505, reset when rpm(Tcas) < 401 (hysteresis)
0804   0000                                                              ;    bit 1 (0x02): Old value of bit 0 
0805   0000                                                              ;    bit 2 (0x04): 1 if rpm(Tcas) >  1775rpm
0806   0000                                                              ;    bit 3 (0x08): Old value of bit 2 
0807   0000                                                              ;    bit 4 (0x10): 1 if rpm(Tcas) >  1540rpm 
0808   0000                                                              ;    bit 5 (0x20): 1 if rpm(Tcas) >  4801rpm
0809   0000                                                              ;    bit 6 (0x40): Set to 1 if timing adjustment mode is active
0810   0000                                                              ;    bit 7 (0x80): Unused?
0811   0000             ignFallFlags     .EQU     $0062                  ; Coil ignition scheduling on the cas falling edge
0812   0000                                                              ;    bit 0 (0x01): Set to 1 when coil ignition was not scheduled on the CAS 
0813   0000                                                              ;                  rising edge and therefore need to be scheduled on the CAS falling edge?
0814   0000                                                              ;    bit 1 (0x02): not used
0815   0000                                                              ;    bit 2 (0x04): not used 
0816   0000                                                              ;    bit 3 (0x08): not used
0817   0000                                                              ;    bit 4 (0x10): not used
0818   0000                                                              ;    bit 5 (0x20): not used
0819   0000                                                              ;    bit 6 (0x40): not used
0820   0000                                                              ;    bit 7 (0x80): not used
0821   0000             enerFlags        .EQU     $0063                  ; Coil energization state, bit 0 and 1 are mutually exclusive, they are never set at the same time...
0822   0000                                                              ; Note that when rpm is low, these flags might not be set as indicated (during cranking?)
0823   0000                                                              ;    bit 0 (0x01): Set to 1 when coil is currently energized?
0824   0000                                                              ;    bit 1 (0x02): Set to 1 when coil energization has been scheduled?
0825   0000                                                              ;    bit 2 (0x04): not used
0826   0000                                                              ;    bit 3 (0x08): not used
0827   0000                                                              ;    bit 4 (0x10): not used
0828   0000                                                              ;    bit 5 (0x20): not used
0829   0000                                                              ;    bit 6 (0x40): not used
0830   0000                                                              ;    bit 7 (0x80): not used
0831   0000             TcasLast0        .EQU     $0064                  ; TcasLast0:TcasLast1 (250KHz clock) is identical to TcasNew0:TcasNew1 but it has been validated for range. Basically it is the last Tcas value that was valid
0832   0000             TcasLast1        .EQU     $0065                  ; See TcasLast0 
0833   0000             TcasNew0         .EQU     $0066                  ; TcasNew0:TcasNew1 (250KHz clock) is the new value of Tcas calculated during the CAS interrupt 
0834   0000             TcasNew1         .EQU     $0067                  ; See TcasNew0
0835   0000             casRiseTime0     .EQU     $0068                  ; casRiseTime0:casRiseTime1 (250KHz clock) is the clock value when the last CAS rising edge interrupt occured  
0836   0000             casRiseTime1     .EQU     $0069                  ; See casRiseTime0
0837   0000             casFallTime0     .EQU     $006a                  ; casFallTime0:casFallTime1 (250KHz clock) is the clock value when the last CAS falling edge interrupt occured  
0838   0000             casFallTime1     .EQU     $006b                  ; See casFallTime0
0839   0000             timCas0          .EQU     $006c                  ; The current ignition timing (xx/256*90)degrees referenced to the CAS pulse rising edge (75deg BTDC), [timCas0:timCas1] =  256 * (75.77 - degAdv)/90, calculated from tim61 + $002a
0840   0000             timCas1          .EQU     $006d                  ; See timCas0
0841   0000             ignRelTime0      .EQU     $006e                  ; [ignRelTime0:ignRelTime1] is the current ignition time minus 72us measured in 1/250000 sec (timer clock) and referenced to the CAS rising edge (75deg BTDC). Calculated from timCas0: [ignRelTime0:ignRelTime1] = [TcasNew0:TcasNew1]/2 * [timCas0:timCas1]/256 - $0012
0842   0000             ignRelTime1      .EQU     $006f                  ; See ignRelTime0
0843   0000             ignFallRelTime0  .EQU     $0070                  ;
0844   0000             ignFallRelTime1  .EQU     $0071                  ;
0845   0000             enerLenX0        .EQU     $0072                  ;
0846   0000             enerLenX1        .EQU     $0073                  ;
0847   0000             enerAbsTime0     .EQU     $0074                  ;
0848   0000             enerAbsTime1     .EQU     $0075                  ;
0849   0000             ignTime0         .EQU     $0076                  ;
0850   0000             ignTime1         .EQU     $0077                  ;
0851   0000             enerAbsTimeNext0 .EQU     $0078                  ;
0852   0000             enerAbsTimeNext1 .EQU     $0079                  ;
0853   0000             TcasLast128      .EQU     $007a                  ; Set to TcasLast0/128
0854   0000             tdcMask0         .EQU     $007b                  ; tdcMask0:tdcMask1 contains $0204 when TDC signal is active (cylinder 1 or 4) on the CAS rising edge, $0402 otherwise. Toggled on every CAS rising edge
0855   0000             tdcMask1         .EQU     $007c                  ; See tdcMask0
0856   0000             tim61            .EQU     $007d                  ; Current timing (xx/256*90)degrees referenced to 61deg BTDC, tim61 = 256 * (61 - degAdv) / 90, where degAdv is the timing advance in degrees. Calculated from tim61Tot0
0857   0000             temp20           .EQU     $007e                  ; 
0858   0000             temp21           .EQU     $007f                  ;
0859   0000             temp22           .EQU     $0080                  ;
0860   0000             temp23           .EQU     $0081                  ;
0861   0000             temp24           .EQU     $0082                  ;
0862   0000             tdcCasCount      .EQU     $0083                  ; CAS rising edge counter when key is not in start, incremented on every CAS rising edge up to a maximum value of 6, used in TDC synch. operation
0863   0000             T40s_casInt      .EQU     $0084                  ; Initialized to 1.275sec on every CAS rising edge interrupt and decremented in first subroutine at ~40Hz. Will reach 0 (expire) only when no CAS interrupt was received for over 1.275sec, i.e. engine is really not rotating or something is wrong?
0864   0000             coilChkFlags     .EQU     $0085                  ; Flag register used to validate the ignition signal using the ignition coil sensing circuit
0865   0000                                                              ;    bit 0 (0x01): Injector 1, set to 1 to indicate that the injector can be used, 0 indicate injector is disabled because ignition is not happening on the corresponding cylinder
0866   0000                                                              ;    bit 1 (0x02): Injector 3, set to 1 to indicate that the injector can be used, 0 indicate injector is disabled because ignition is not happening on the corresponding cylinder
0867   0000                                                              ;    bit 2 (0x04): Injector 4, set to 1 to indicate that the injector can be used, 0 indicate injector is disabled because ignition is not happening on the corresponding cylinder
0868   0000                                                              ;    bit 3 (0x08): Injector 2, set to 1 to indicate that the injector can be used, 0 indicate injector is disabled because ignition is not happening on the corresponding cylinder
0869   0000                                                              ;    bit 4 (0x10): 
0870   0000                                                              ;    bit 5 (0x20): Set to 1 when engine is running and rpm<5000 and 8V<=battRaw<=18V, meaning we can proceed with checking the ignition
0871   0000                                                              ;    bit 6 (0x40): 
0872   0000                                                              ;    bit 7 (0x80): Set to 1 when we detected that several ignition signals were missing, ignition is not working properly.
0873   0000             p4Latched        .EQU     $0086                  ; Loaded with port4 and checked for bit #$04 in CAS interrupt
0874   0000             timAdjFlags      .EQU     $0087                  ; Timing adjustment mode flags
0875   0000                                                              ;    bit 0 (0x01): Set when rpm31>2000rpm, reset when rpm31 goes lower than 1813rpm (hysteresis) 
0876   0000                                                              ;    bit 1 (0x02): 
0877   0000                                                              ;    bit 2 (0x04): 
0878   0000                                                              ;    bit 3 (0x08): 
0879   0000                                                              ;    bit 4 (0x10): 
0880   0000                                                              ;    bit 5 (0x20): 
0881   0000                                                              ;    bit 6 (0x40):
0882   0000                                                              ;    bit 7 (0x80): Set to 1 when timing adjustment mode is active (timing terminal is grounded but the ECU test mode terminal is not grounded
0883   0000             tim61Tot0        .EQU     $0088                  ; New target timing (xx/256*90)degrees referenced to 61deg BTDC. knockSum is added to this value in order to retard timing further and then a maximum rate of change of 22.5deg/iteration is applied. The result becomes the new timing to apply (tim61 and timCas0:timCas1). Calculated from advTotal
0884   0000             enerLen          .EQU     $0089                  ; Coil energization time as loaded from the t_enerLen(battRaw) table. Actual energization time used might be different, longer...
0885   0000             timingAdv        .EQU     $008a                  ; Current timing advance, (x-10)degrees, timingAdv = degAdv+10, Calculated from tim61
0886   0000             knockSum         .EQU     $008b                  ; Current knock sum value
0887   0000             T200s_knock      .EQU     $008c                  ; Knock attenuation timer decremented at 200Hz and looping at 1.67Hz or 100Hz depending on airVol, knockSum is decremented by 1 every time this timer expires 
0888   0000             airCnt0          .EQU     $008d                  ; [airCnt0:airCnt1:airCnt2] is the exponentially averaged 24 bit air count (input is 16 bit [airCntNew0:airCntNew1]*256)
0889   0000             airCnt1          .EQU     $008e                  ; See airCnt0
0890   0000             airCnt2          .EQU     $008f                  ; See airCnt0
0891   0000             airCntNew0       .EQU     $0090                  ; airCntNew0:airCntNew1 is the 16 bits air count used as input to [airCnt0:airCnt1:airCnt2]. It is equal (N+r) * $9c where N is the number of airflow sensor pulse counted by the mas interrupt between each cas interrupt (1 cas interrupt for every cylinder cycle, 4 per every 2 engine rotations) r<=1 is a "remainder" proportional to the time elapsed since the last interrupt... 
0892   0000             airCntNew1       .EQU     $0091                  ; See airCntNew0
0893   0000             oldAirCnt0       .EQU     $0092   ;:$0093        ; This is the old value of airCnt0:airCnt1 used to compute some kind of air count derivative
0894   0000             airDiffPos       .EQU     $0094                  ; Contains airCnt0-oldAirCnt0 when the difference is positive, This is kind of the derivative of air count which is positive when air count is increasing (acceleration)
0895   0000             airDiffNeg       .EQU     $0095                  ; Contains abs(airCnt0-oldAirCnt0) when the difference is negative (contains oldAirCnt0-airCnt0...). This is kind of the derivative of air count which is negative when air count is decreasing (decceleration)
0896   0000             t1_lastCas       .EQU     $0096   ;:$0097        ; Latest value of t1_inCapt when CAS interrupt was called
0897   0000             t2_lastMas       .EQU     $0098   ;:$0099        ; Latest value of t2_inCapt when MAS interrupt was called                                                                             
0898   0000             t2_diff8         .EQU     $009a   ;:$009b        ; Time between 2 edges (2 edges per pulse...) of the airflow sensor with timer based rounding (see code), calculated on each mas interrupts from t2_inCapt/8
0899   0000             airQuantum       .EQU     $009c                  ; This value ($9c) is the the "amount of air" corresponding to 1 airflow sensor pulse. Using a non unitary value allows the ECU to interpolate the airflow in between pulses, i.e. if at the time we calculate airflow we are at 2/3 in between two pulses then we add 2/3 of airQuantum...  
0900   0000                                                              ; It is added to [airCntNew0:airCntNew1] on each mas interrupt call (accumulates N times $9C...).  A ratio is also applied to this value when it is added to [airCntNew0:airCntNew1] for the last time (partial count in between pulses) before airCnt0 is calculated.
0901   0000             L009d            .EQU     $009d                  ; Not used?
0902   0000             masCasFlags      .EQU     $009e                  ; Flag register
0903   0000                                                              ;    bit 0 (0x01): Bit is set when the CAS rising edge interrupt code is executed to flag event to main loop. Flag is read from main loop to update rpmX4Filt and then reset
0904   0000                                                              ;    bit 1 (0x02): 
0905   0000                                                              ;    bit 2 (0x04): 
0906   0000                                                              ;    bit 3 (0x08): 
0907   0000                                                              ;    bit 4 (0x10): 
0908   0000                                                              ;    bit 5 (0x20): 
0909   0000                                                              ;    bit 6 (0x40):
0910   0000                                                              ;    bit 7 (0x80): Scaling for the airflow sensor pulse counting. Set to 0 when we count both the rising and falling edge of the airflow sensor pulse. Set to 0 in case we count only the rising edges (or only the falling ones)
0911   0000             airFiltFact      .EQU     $009f                  ; airCnt0 exponential averaging factor with alpha = airFiltFact/256, 0<=alpha<=1, basically used to filter the air count: new airCnt0 = alpha * old airCnt0 + (1-alpha)*newAirCntValue, possible values in the code are $b3(70%), $d1(82%) or $e4(89%) 
0912   0000             airCntMax        .EQU     $00a0                  ; Air count based on rpm, ect and iat, 8*airCntMax is used as a maximum on airCnt0 or when engine not rotating/starting to rotate 
0913   0000             accEnr           .EQU     $00a1                  ; Acceleration enrichment (100x/255)%. This value is actually  updated with min(airCnt0-oldAirCnt0,$48) under acceleration, see code. Max value is $48 from code
0914   0000             state3           .EQU     $00a2                  ; Flag register   
0915   0000                                                              ;    bit 0 (0x01): Copied from same bit in state1 (1=startingToCrank)
0916   0000                                                              ;    bit 1 (0x02): Copied from same bit in state1 (1=no pulse accumulator interrupts)
0917   0000                                                              ;    bit 2 (0x04): Set when RPM exceeds threshold (rev limiter)
0918   0000                                                              ;    bit 3 (0x08): Copied from same bit in state1 (1=rotatingStopInj)
0919   0000                                                              ;    bit 4 (0x10): Copied from same bit in state1 (1=notRotating)
0920   0000                                                              ;    bit 5 (0x20): Set if rotatingStopInj and not runningFast 
0921   0000                                                              ;    bit 6 (0x40):
0922   0000                                                              ;    bit 7 (0x80): Set to injFlags0.7 (1 when startingToCrankColdEngine)
0923   0000             injFactor        .EQU     $00a3   ;:$00a4        ; Global injector factor used to calculate injPw from [airCnt0:airCnt1],  
0924   0000                                                              ; injFactor = 16*totMasComp * injComp/128 * [workFtrim + o2FuelAdj + 2*$80]/512 * iatCompFact/128 * baroFact/128 * openLoopEnr/128 * coldTempEnr/128  * (2*enrWarmup + $80)/128
0925   0000             oldReedVal       .EQU     $00a5                  ;
0926   0000             deadTime         .EQU     $00a6                  ; Injector deadtime in increment of 24uS as a function of batteryVoltage
0927   0000             injPw            .EQU     $00a7   ;:$00a8        ; 16 bit injector pulse width in microseconds. Logger reports high and low bytes: (.256 highByte)mS
0928   0000             inj1_offT        .EQU     $00a9   ;:$00aa        ; Injector #1? deactivation time (relative to timer count at t1t2_clk/t1_outCmpWr/t2_outCmpWr)  
0929   0000             inj3_offT        .EQU     $00ab   ;:$00ac        ; Injector #3? deactivation time (relative to timer count at t1t2_clk/t1_outCmpWr/t2_outCmpWr)  
0930   0000             inj4_offT        .EQU     $00ad   ;:$00ae        ; Injector #4? deactivation time (relative to timer count at t1t2_clk/t1_outCmpWr/t2_outCmpWr)  
0931   0000             inj2_offT        .EQU     $00af   ;:$00b0        ; Injector #2? deactivation time (relative to timer count at t1t2_clk/t1_outCmpWr/t2_outCmpWr)  
0932   0000             last_t1t2_clk    .EQU     $00b1                  ; Initialized to  t1t2_clk/256 on CAS falling edge, every one of them??? 
0933   0000             injToAct         .EQU     $00b2                  ; Indicate which injectors are currently active or should be activated, Set to 1 for an active injector 
0934   0000                                                              ;    bit 0 (0x01): Inj 1?  
0935   0000                                                              ;    bit 1 (0x02): Inj 3? 
0936   0000                                                              ;    bit 2 (0x04): Inj 4? 
0937   0000                                                              ;    bit 3 (0x08): Inj 2? 
0938   0000                                                              ;    bit 4 (0x10): 
0939   0000                                                              ;    bit 5 (0x20): 
0940   0000                                                              ;    bit 6 (0x40): 
0941   0000                                                              ;    bit 7 (0x80): 
0942   0000             tdcCasFlags      .EQU     $00b3                  ; Init to 5
0943   0000                                                              ;    bit 0 (0x01): c0, c2:c1:c0 used as a down counter (on every CAS pulse falling edge) initialized with 5. Reset to 0 when the CAS pulse falling edge correpond to the cylinder #1 TDC pulse (see bit 7)
0944   0000                                                              ;    bit 1 (0x02): c1
0945   0000                                                              ;    bit 2 (0x04): c2
0946   0000                                                              ;    bit 3 (0x08): Set to the last value of TDC bit on port3. 2
0947   0000                                                              ;    bit 4 (0x10):
0948   0000                                                              ;    bit 5 (0x20):
0949   0000                                                              ;    bit 6 (0x40):
0950   0000                                                              ;    bit 7 (0x80): Set to 1 when cylinder #1 TDC is detected on the CAS falling edge. Set to 1 when we detect that TDC bit on port3.2 has changed from 1 to 0 (falling edge) from one CAS falling edge to the other. That basically indicate cylinder #1 TDC  
0951   0000             casCylIndex      .EQU     $00b4                  ; Cas current cylinder index (0,1,2,3 -> cyl #2,#1,#3,#4). Counter looping from 0 to 3 and increased on every CAS falling edge. re-init to 0 when TDC of cylinder #1 is detected (tdcCasFlags.7 set). 
0952   0000                                                              ;    bit 0 (0x01): Inj 1?  
0953   0000                                                              ;    bit 1 (0x02): Inj 3? 
0954   0000                                                              ;    bit 2 (0x04): Inj 4? 
0955   0000                                                              ;    bit 3 (0x08): Inj 2? 
0956   0000                                                              ;    bit 4 (0x10): 
0957   0000                                                              ;    bit 5 (0x20): 
0958   0000                                                              ;    bit 6 (0x40): 
0959   0000                                                              ;    bit 7 (0x80): 
0960   0000             newInjToAct      .EQU     $00b5                  ; Indicate which injector should be activated (also, bit 7 is set when doing simultaneous injection). Mostly updated on the CAS falling edge
0961   0000                                                              ;    bit 0 (0x01): Inj 1?  
0962   0000                                                              ;    bit 1 (0x02): Inj 3? 
0963   0000                                                              ;    bit 2 (0x04): Inj 4? 
0964   0000                                                              ;    bit 3 (0x08): Inj 2? 
0965   0000                                                              ;    bit 4 (0x10): Inj 5/6?
0966   0000                                                              ;    bit 5 (0x20): Inj 5/6?
0967   0000                                                              ;    bit 6 (0x40): 
0968   0000                                                              ;    bit 7 (0x80): Set to 1 when when we should be doing simultaneous injection on all 4 cylinders, 0 indicate sequential injection
0969   0000             tdcCheck         .EQU     $00b6                  ; Init to 8 on the cas falling edge of the cylinder #1 TDC, decremented by 1 on every cas falling edge. Used to check that TDC sensor is working correctly, it should never reach 0...
0970   0000             oldInjToAct      .EQU     $00b7                  ; Old value of injToAct (before it was updated)
0971   0000             injToTest        .EQU     $00b8                  ; The current injector to test for proper operation (set to 1 to test), 1 bit per injector. Testing proceed from bit 0 to bit 3. We stay on the same injector if it is found to be bad, see around L1884
0972   0000                                                              ;    bit 0 (0x01): Inj 1?  
0973   0000                                                              ;    bit 1 (0x02): Inj 3? 
0974   0000                                                              ;    bit 2 (0x04): Inj 4? 
0975   0000                                                              ;    bit 3 (0x08): Inj 2? 
0976   0000                                                              ;    bit 4 (0x10): 
0977   0000                                                              ;    bit 5 (0x20): 
0978   0000                                                              ;    bit 6 (0x40): 
0979   0000                                                              ;    bit 7 (0x80): 
0980   0000             injBad           .EQU     $00b9                  ; Injector testing flags
0981   0000                                                              ;    bit 0 (0x01): Set to 1 when one of the injector is not working correctly based on injector feedback bit, see injToTest
0982   0000                                                              ;    bit 1 (0x02): Not used
0983   0000                                                              ;    bit 2 (0x04): Not used
0984   0000                                                              ;    bit 3 (0x08): Not used
0985   0000                                                              ;    bit 4 (0x10): Not used
0986   0000                                                              ;    bit 5 (0x20): Not used
0987   0000                                                              ;    bit 6 (0x40): Not used
0988   0000                                                              ;    bit 7 (0x80): Not used
0989   0000             obdInjCmd        .EQU     $00ba                  ; processing of OBD code bit 0 to 5 correspond to injectors being turned on/off                                                                                                    
0990   0000                                                              ;    bit 0 (0x01): Inj. 1, Set to 0 if injector is currently turned off by obd command, 1 in normal operation 
0991   0000                                                              ;    bit 1 (0x02): Inj. 3, See bit 0
0992   0000                                                              ;    bit 2 (0x04): Inj. 4, See bit 0
0993   0000                                                              ;    bit 3 (0x08): Inj. 2, See bit 0
0994   0000                                                              ;    bit 4 (0x10): Inj 5/6 See bit 0
0995   0000                                                              ;    bit 5 (0x20): Inj 5/6 See bit 0
0996   0000                                                              ;    bit 6 (0x40): Not used 
0997   0000                                                              ;    bit 7 (0x80): Not used
0998   0000             rtiCnt           .EQU     $00bb                  ; free counter increased on every real time interrupt (~800Hz), used to execute some functions only 1 out of N times (check count value)                                                         
0999   0000             rtiCnt48         .EQU     $00bc                  ; counter increased on every real time interrupt, maximum value is 2F (47), period 48.                                                                                                  
1000   0000             rtiReedFlags     .EQU     $00bd                  ; Flag register                                                                                                                                                                                 
1001   0000                                                              ;    bit 0 (0x01): Bit is set in real time int. at 40Hz when T200_40Hz reach 0 (T200_40Hz loop from 5 to 0 at 200Hz)
1002   0000                                                              ;    bit 1 (0x02): not used?
1003   0000                                                              ;    bit 2 (0x04): not used?
1004   0000                                                              ;    bit 3 (0x08): not used?
1005   0000                                                              ;    bit 4 (0x10): not used?
1006   0000                                                              ;    bit 5 (0x20): not used?
1007   0000                                                              ;    bit 6 (0x40): not used?
1008   0000                                                              ;    bit 7 (0x80): Latest reed switch value
1009   0000                              
1010   0000                              ;-------------------------------------------------
1011   0000                              ; $be-$c2, series of timers (counting down to 0)
1012   0000                              ; (see L1929) decremented in real time interrupt 
1013   0000                              ; at ~200Hz
1014   0000                              ;-------------------------------------------------
1015   0000             T200_40Hz        .EQU     $00be                  ; Loops from from 5 to 0 producing 40Hz for main loop (set rtiReedFlags.0)
1016   0000             T200_casRise     .EQU     $00bf                  ; Used by CAS interrupt as a timeout to validate the time in between CAS interrupts when RPM is very low and 16 bit timers roll over. Timer initialized on every cas rising edge
1017   0000             T200_casFall     .EQU     $00c0                  ; Used by CAS interrupt as a timeout to validate the time in between CAS interrupts when RPM is very low and 16 bit timers roll over. Timer initialized on every cas falling edge
1018   0000             T200_mas         .EQU     $00c1                  ; Used by the mas subroutine to know when the pulses are getting too close together (and we need to apply scaling). Re-initialized to 130ms on every airflow sensor interrupt (every pulse received)
1019   0000             T200_cop         .EQU     $00c2                  ; Used to toggle port6.5 if main loop executes at more than 20Hz, could be some sort of COP to reset ECU in case main loop goes slower than 20Hz.
1020   0000                              
1021   0000             oldTps1          .EQU     $00c3                  ; Set to "old" TPS value for comparison with new during cranking?                                                                                                                   
1022   0000             vssCnt1          .EQU     $00c4                  ; Counter Initialized to $#C8 every time the reed switch change value, decreased at real time int. frequency down to 0; Will be 0 only when when speed is lower than X (very slow speed?)
1023   0000             vssCnt2          .EQU     $00c5                  ; Counter used for speed sensor calculation, initialized to $E2, decreased on every call, speed = $E2-current value of this register                                                
1024   0000             vss              .EQU     $00c6                  ; "Vehicle speed sensor", actually computed from the reed switch transitions. Value is the period in 1/400sec of one complete reed switch square wave, approx 40cm. Speed in km/h is approximately given by 3.6*400*0.4/xx
1025   0000             oldTps2          .EQU     $00c7                  ;
1026   0000             tpsDiffMax1      .EQU     $00c8                  ; Maximum positive rate of change of tpsRaw seen during 1 main loop execution. (high value means driver is stepping on the gas, value of 0 means throttle is at constant position or decreasing). Set to the maximum value of tpsRaw-oldTps2 (updated at 100Hz) 
1027   0000             tempFlagTps      .EQU     $00c9                  ; Used as a temp flag during port2.2 activation/deactivation (aiflow sensor active filter reset???). Set to $ff when tpsRaw has increased by more than 1.5% and is between 26%-50%, $00 otherwise
1028   0000             L00ca            .EQU     $00ca                  ; Init to 6 but never used. Notice it is located in front of the 8 memories used to store ADC values? It also correspond to obd code $ca which erases all fault codes...
1029   0000             ectRaw           .EQU     $00cb                  ; Engine coolant temperature, see curve at beginning of file 
1030   0000             iatRaw           .EQU     $00cc                  ; Raw intake air temperature, see curve at beginning of file 
1031   0000             baroRaw          .EQU     $00cd                  ; Atmostpheric pressure: (.00486x)bar            
1032   0000             o2Raw            .EQU     $00ce                  ; Oxygen sensor (.0195x)v.                    
1033   0000             egrtRaw          .EQU     $00cf                  ; Exhaust gas recirculation temperature, unknown temperature curve, used this formula for now (-2.7x + 597.7)deg F              
1034   0000             battRaw          .EQU     $00d0                  ; Battery voltage (.0733x)v.                          
1035   0000             knockSensor      .EQU     $00d1                  ; Knock sensor                                
1036   0000             tpsRaw           .EQU     $00d2                  ; Throttle position sensor (100x/255)%               
1037   0000             ectFiltered      .EQU     $00d3                  ; This is the engine coolant tempterature that has been validated and then filtered to limit its rate of change to a few degrees per sec...
1038   0000             iatChecked       .EQU     $00d4                  ; Validated intake air temperature
1039   0000             baroChecked      .EQU     $00d5                  ; Verified barometer voltage, $cd=1bar
1040   0000             state2           .EQU     $00d6                  ;    bit 0 (0x01): Set if ectRaw >236 OR <5, FAULT VALUE = 30                                                                               
1041   0000                                                              ;    bit 1 (0x02): Set if iatRaw >234 OR <14, FAULT VALUE = 123                                                                             
1042   0000                                                              ;    bit 2 (0x04): Set if baroRaw >228 OR <100, FAULT VALUE = 205                                                                           
1043   0000                                                              ;    bit 3 (0x08): Set when timer T40_mas expires, which means no pulse accumulator interrupt was received for over 0.3s-> no air is getting in or something wrong...
1044   0000                                                              ;    bit 4 (0x10): Engine collant temp related?                                                                                                 
1045   0000                                                              ;    bit 5 (0x20): Set to 1 if knock senor is not working???. Set to ^(port4Snap.5)
1046   0000                                                              ;    bit 6 (0x40):                                                                                                                              
1047   0000                                                              ;    bit 7 (0x80):                                                                                                                              
1048   0000             port3Snap0       .EQU     $00d7                  ; Loaded with port3 with some values reset by code depending on ???,                
1049   0000                                                              ; used in idle speed calc? -> load that need to be considered in calc of idle speed 
1050   0000                                                              ;    bit 0 (0x01): IG2 related, 0 when IG2 at +12V, ABS unit?  only used used for fuel trim on E931 only, see around Md4d4?                                                                     
1051   0000                                                              ;    bit 1 (0x02): IG1 related? 0 when IG1 at +12V.                                                                                                                                            
1052   0000                                                              ;    bit 2 (0x04): always reset to 0????
1053   0000                                                              ;    bit 3 (0x08): Set to 1 if power steering pump is on
1054   0000                                                              ;    bit 4 (0x10): AC switch (1=off) -> always set if ??? (config resistor???)                 
1055   0000                                                              ;    bit 5 (0x20): Park/neutral -> always set by code???                                  
1056   0000                                                              ;    bit 6 (0x40): 0 if key in start?
1057   0000                                                              ;    bit 7 (0x80): idle position switch (1=on)?                                        
1058   0000             port4Snap        .EQU     $00d8                  ; Snapshot of port4 & 01111000
1059   0000                                                              ;    bit 0 (0x01):                                                                     
1060   0000                                                              ;    bit 1 (0x02):                                                                     
1061   0000                                                              ;    bit 2 (0x04): 
1062   0000                                                              ;    bit 3 (0x08): 1 when ECU test mode terminal grounded               
1063   0000                                                              ;    bit 4 (0x10): 1 when timing terminal grounded                     
1064   0000                                                              ;    bit 5 (0x20): knock sensor related (set indicates it works...)
1065   0000                                                              ;    bit 6 (0x40): Fuel pump driven feedback?                      
1066   0000                                                              ;    bit 7 (0x80): 
1067   0000             Tclocks          .EQU     $00d9                  ; State Flags for software counters, Updated from scratch (zero) on every main loop execution 
1068   0000                                                              ;    bit 0 (0x01): Set at ~40Hz, set when 40Hz flag from real time interrupt was processed during loop (40Hz counters where decremented if required)
1069   0000                                                              ;    bit 1 (0x02): Set at ~10Hz
1070   0000                                                              ;    bit 2 (0x04): Set at ~2Hz, Used by heart beat mode
1071   0000                                                              ;    bit 3 (0x08): Set at ~0.5Hz
1072   0000                                                              ;    bit 4 (0x10): Not used?                                                       
1073   0000                                                              ;    bit 5 (0x20): Not used?                                                       
1074   0000                                                              ;    bit 6 (0x40): Not used?                                                       
1075   0000                                                              ;    bit 7 (0x80): Not used?                                                       
1076   0000             rpm4             .EQU     $00da   ;:$00db        ; RPM/3.90625                                                       
1077   0000             rpm8             .EQU     $00dc                  ; RPM/7.8125                                                        
1078   0000             rpm31            .EQU     $00dd                  ; RPM/31.25 (engine rpm = RPM31p25 * 31.25)                         
1079   0000             airVol16         .EQU     $00de   ;:$00df        ; Air volume, 16 bit, airVol16 = [airCnt0:airCnt1] * masScalar/65536
1080   0000             airVol           .EQU     $00e0                  ; Air volume,  8 bit,   airVol = airVol16/2
1081   0000             airVolT          .EQU     $00e1                  ; Air volume,  8 bit,  airVolT = airVol16/2 * iatCompFact/128
1082   0000             airVolTB         .EQU     $00e2                  ; Air volume,  8 bit, airVolTB = airVol16/2 * iatCompFact/128 * baroFact/128
1083   0000             airVolB          .EQU     $00e3                  ; Air volume,  8 bit,  airVolB = airVol16/2 *    baroFact/128
1084   0000             mafRaw           .EQU     $00e4                  ; 8 bit airflow sensor pulse frequency  (6.25x)Hz, calculated from mafRaw16 (mafRaw = mafRaw16/64)
1085   0000             ftrimFlags       .EQU     $00e5                  ; Flag register for fuel trim???
1086   0000                                                              ;    bit 0 (0x01): c0: c1c0 form the current trim range (00=low, 01=mid, 10=high) updated according to mafRaw16
1087   0000                                                              ;    bit 1 (0x02): c1
1088   0000                                                              ;    bit 2 (0x04): Set (E931 only) when speed exceed threshold (24km/h) with hysteresis, 
1089   0000                                                              ;    bit 3 (0x08): Set (E931 only) if port3Snap0.0 & port3.0 are both set on E931 when speed exceed 24km/h?
1090   0000                                                              ;    bit 4 (0x10): Set when rpm > L1983(xx) ~1000rpm with hysteresis  
1091   0000                                                              ;    bit 5 (0x20): 
1092   0000                                                              ;    bit 6 (0x40): 
1093   0000                                                              ;    bit 7 (0x80):  Set when airVolT >24, reset when airVolT<=15. Theshold is 19.5 with +/-4.5 hysteresis
1094   0000             state1           .EQU     $00e6                  ; State flags mainly used to track engine start-up stages and running condition (not rotating, startingToCrank, etc.). Bits 0 to 4 will be clear when engine is running normally
1095   0000                                                              ;    bit 0 (0x01): stage1 (startingToCrank?): 1 indicate engine is just rotating but no TDC signal seen yet????, reset to 0 once CAS/TDC??? or engine rpm>~400rpm
1096   0000                                                              ;    bit 1 (0x02): no pulse accumulator interrupts ?: 1 indicate we did not receive a valid pulse accumulator interrupts for a long time, see state2
1097   0000                                                              ;    bit 2 (0x04): stage3 (runningFast): 1 indicate the ECU has detected that the engine rpm was too high for current conditions?
1098   0000                                                              ;    bit 3 (0x08): stage2 (rotatingStopInj): 1 indicate engine should be running or be started but something is preventing us from doing fuel injection (fuel cut, CAS not working, etc.). Injection could still proceed if runningFast is set
1099   0000                                                              ;    bit 4 (0x10): stage0 (notRotating): 1 indicate state1 was calculated but nothing to report, set to 1 on init subr. reset to 0 when engine is rotating
1100   0000                                                              ;    bit 5 (0x20): state1Calculated: 1 indicate state 1 was calculated, never reset?
1101   0000                                                              ;    bit 6 (0x40): Not used?                                                                          
1102   0000                                                              ;    bit 7 (0x80): closedLoop: 1 indicate closed loop mode, 0 indicate open loop                                  
1103   0000             injFlags0        .EQU     $00e7                  ; Flags related to injectors
1104   0000                                                              ;    bit 0 (0x01): Flag is 0 on reset (meaning injectors interrupts not yet initiated?) and set to 1 once sInjPw is initialized. If required, first interrupt for injectors is also scheduled when initializing this flag to 1
1105   0000                                                              ;    bit 1 (0x02): ??? 
1106   0000                                                              ;    bit 2 (0x04): Set when rpm>=437.5
1107   0000                                                              ;    bit 3 (0x08): ???
1108   0000                                                              ;    bit 4 (0x10): 
1109   0000                                                              ;    bit 5 (0x20): Set when temperature(ectFiltered) < -8degC, updated only when engine is notRotating
1110   0000                                                              ;    bit 6 (0x40): 
1111   0000                                                              ;    bit 7 (0x80): Set to 1 if startingToCrankColdEngine. Fuel should be injected simultaneously in all cylinders twice per rotation (every cas)
1112   0000             closedLpFlags    .EQU     $00e8                  ; Flags relaed to closed loop mode, 02 sensor, fuel trims
1113   0000                                                              ;    bit 0 (0x01): Set to 1 when the air volume (airVolTB) is too high to use closed loop mode (first threshold) 
1114   0000                                                              ;    bit 1 (0x02): Set to 1 when we should be using closed loop mode??? (might not use it anyway...)
1115   0000                                                              ;    bit 2 (0x04): 
1116   0000                                                              ;    bit 3 (0x08): 
1117   0000                                                              ;    bit 4 (0x10): 
1118   0000                                                              ;    bit 5 (0x20): 
1119   0000                                                              ;    bit 6 (0x40): o2 sensor bad flag. Set to 1 when the o2 sensor voltage did not switch from lean to rich or rich to lean for a certain amount of time in closed loop. Also set to 1 if notRotating
1120   0000                                                              ;    bit 7 (0x80): rich/lean flag, set to 1 o2Raw >= 0.6v (rich), Set to 0 if o2Raw < 0.6v (lean), updated once o2 sensor has warmed-up
1121   0000             o2Fbk            .EQU     $00e9   ;:$00ea        ; Oxygen feedback trim (16 bits actually used, most of the time only highest byte is used...) (.78x)% -> 100% = $80
1122   0000             o2Fbk_dec        .EQU     $00eb                  ; o2Fbk is decreased using this value when in closed loop and running rich
1123   0000             o2Fbk_inc        .EQU     $00ec                  ; o2Fbk is increased using this value when in closed loop and running lean
1124   0000             iscY0            .EQU     $00ed                  ; iscYn variables are short term correction factors/feedback for the isc step adjustment. It is centered at $80 (100%, no correction). A value higher than $80 indicate that we need to increase the isc step since the current rpm is lower than the desired one
1125   0000                                                              ; The isc step used is increased/decreased by iscYn-$80
1126   0000                                                              ; iscY0 is the ISC learning variable when A/C is off and PS is off, see iscPointers function. Value of $80=100% 
1127   0000             iscY1            .EQU     $00ee                  ; iscY1 is the ISC learning variable when A/C is on and PS is off, see iscPointers function. Value of $80=100%
1128   0000             iscY2            .EQU     $00ef                  ; iscY2 is the ISC learning variable when PS is on, see iscPointers function. Value of $80=100%
1129   0000             iscStepMax       .EQU     $00f0                  ; Maximum value applied to iscStepCurr in code
1130   0000             port3Snap1       .EQU     $00f1                  ; Loaded with port3Snap0 with some values set by code depending on ???,                
1131   0000                                                              ;    bit 0 (0x01): IG2 related, 0 when IG2 at +12V, ABS unit?  only used used for fuel trim on E931 only, see around Md4d4?
1132   0000                                                              ;    bit 1 (0x02): IG1 related? 0 when IG1 at +12V.                                                                        
1133   0000                                                              ;    bit 2 (0x04): Set to 1 if vssCnt1 != 0 (car speed > 2.9km/h???)
1134   0000                                                              ;    bit 3 (0x08): Set to 1 if power steering pump is on
1135   0000                                                              ;    bit 4 (0x10): AC switch (1=off) 
1136   0000                                                              ;    bit 5 (0x20): Park/neutral -> always set by code                                   
1137   0000                                                              ;    bit 6 (0x40): 0 if key in start?                                                   
1138   0000                                                              ;    bit 7 (0x80): idle position switch (1=on)?                                        
1139   0000             oldP3Snap1       .EQU     $00f2                  ; Old value of port3Snap1
1140   0000             iscLrnFlags      .EQU     $00f3                  ; Isc leanrning flags, all flags are reset to 0 in basic idle speed adjustment mode.  All flags except bit 0 are reset to 0 when notRotating or startingToCrank
1141   0000                                                              ;    bit 0 (0x01): Set to 1 when engine is notRotating or startingToCrank, reset to 0 when engine is running
1142   0000                                                              ;    bit 1 (0x02): 
1143   0000                                                              ;    bit 2 (0x04): Set to 1 when the engine is running too slow? i.e. temperature(ectFiltered) > 55degC, rpm8 < 500rpm, engine is running, T40_acOnTrans is expired 
1144   0000                                                              ;    bit 3 (0x08): 
1145   0000                                                              ;    bit 4 (0x10): Set to 1 when conditions are good to update the isc leanrning variables.
1146   0000                                                              ;    bit 5 (0x20): Set to 1 when iscStStall has been updated, i.e. when idle switch is off and iscFlags1.7 = 0 and rpm8>=500. Reset to 0 when iscStStall is reset to 0???
1147   0000                                                              ;    bit 6 (0x40): 
1148   0000                                                              ;    bit 7 (0x80): 
1149   0000             iscFlags1        .EQU     $00f4                  ; Flag register
1150   0000                                                              ;    bit 0 (0x01): Set to 1 when engine not rotating or is running (basic idle speed adjustment mode is not active). Reset to 0 when key in start and iscStTargSpec = iscStepCurr
1151   0000                                                              ;    bit 1 (0x02): 
1152   0000                                                              ;    bit 2 (0x04): 
1153   0000                                                              ;    bit 3 (0x08): 
1154   0000                                                              ;    bit 4 (0x10): 
1155   0000                                                              ;    bit 5 (0x20): Set to 1 when  engine StartingToCrank and temperature(iat) < 75degC. Only changed during startingToCrank. Used is setting isc step during cold engine startup
1156   0000                                                              ;    bit 6 (0x40): 
1157   0000                                                              ;    bit 7 (0x80): Set to 1 when tps has been high and airVol low for more than 0.5sec (tpsRaw >= 86% and airVol < $3a)
1158   0000             T_maxAdv         .EQU     $00f5                  ; E931 only, used to ramp down the effect of maxAdv 
1159   0000             maxAdv           .EQU     $00f6                  ; E931 only, maximum value of timing advance timingOct for E931 when engine is runningFast (timingOct is clipped to that value), T_maxAdv is used to ramp-down its effect with time
1160   0000             L00f7            .EQU     $00f7                  ; Unused?
1161   0000             varFlags0        .EQU     $00f8                  ; Various flags...
1162   0000                                                              ;    bit 0 (0x01): Used in A/C cutoff for AT, 1 indicates TPS exceeded 82% the last time we checked it...
1163   0000                                                              ;    bit 1 (0x02): Hot start flag, set to 1 when startingToCrank and open loop and temperature(iatChecked) >= 60degC and  temperature(ectFiltered) >= 93degC (hot start), used to increase fuel enrichement (reduce vapor lock maybe???)                              
1164   0000                                                              ;    bit 2 (0x04): 
1165   0000                                                              ;    bit 3 (0x08): 
1166   0000                                                              ;    bit 4 (0x10): 
1167   0000                                                              ;    bit 5 (0x20): Second priority, Set to 1 when purge solenoid is to be deactivated since min conditions for normal purge activation are not met
1168   0000                                                              ;    bit 6 (0x40): First priority, Set to 1 when purge solenoid is to be activated by OBD command or normal activation criteria
1169   0000                                                              ;    bit 7 (0x80): Third priority, Set to 1 when purge solenoid should be deactivated. This flag is toggled between 0 and 1 to implement pulsewidth modulation (very long period) of purge solenoid when the other two higher priority flags are not set  
1170   0000             fpsBcsFlags      .EQU     $00f9                  ; Flags related to fuel pressure solenoid and boost control solenoid
1171   0000                                                              ;    bit 0 (0x01): 
1172   0000                                                              ;    bit 1 (0x02): 
1173   0000                                                              ;    bit 2 (0x04): Set to 1 when the fuel pressure solenoid was just deactivated (set to 1 only when bit 7 goes from 1 to 0). Reset to 0 at any other time
1174   0000                                                              ;    bit 3 (0x08): Set to 1 when ECU decides that fuel pressure solenoid should be activated to reduce vapor lock 
1175   0000                                                              ;    bit 4 (0x10): bcs, Set to 1 when mafRaw16 is above $4e ($4a for E932) with hysteresis, low threshold is $38
1176   0000                                                              ;    bit 5 (0x20): bcs, Set to 1 when octane is above $c0 with hysteresis, low threshold is $9a
1177   0000                                                              ;    bit 6 (0x40): bcs
1178   0000                                                              ;    bit 7 (0x80): 
1179   0000             obdFlags         .EQU     $00fa                  ; Current state of diagnostic port command/query processing
1180   0000                                                              ;    bit 0 (0x01): 1 toggle bit on every second "subroutine 1" loop                                                                                                                                                  
1181   0000                                                              ;    bit 1 (0x02): 1 if serial output on port 2 is initialized.                                                                                                                                                      
1182   0000                                                              ;    bit 2 (0x04): ?a                                                                                                                                                                                                
1183   0000                                                              ;    bit 3 (0x08): ?a                                                                                                                                                                                                
1184   0000                                                              ;    bit 4 (0x10): ?a                                                                                                                                                                                                
1185   0000                                                              ;    bit 5 (0x20): ?a                                                                                                                                                                                                
1186   0000                                                              ;    bit 6 (0x40): Set to 1 when a new OBD code was stored in obdCode? reset when obdCode has been processed.
1187   0000                                                              ;    bit 7 (0x80): Set to 1 to indicate that a response to the query/command is being sent on the diagnostic port (new requests will be ignored)
1188   0000             obdActCmd        .EQU     $00fb                  ; processing of OBD code, contains which actuator is being currently processed. Set to 0 when actuator is off
1189   0000                                                              ;    bit 0 (0x01): Purge solenoid
1190   0000                                                              ;    bit 1 (0x02): Fuel pump
1191   0000                                                              ;    bit 2 (0x04): Fuel pressure solenoid
1192   0000                                                              ;    bit 3 (0x08): Egr solemoid
1193   0000                                                              ;    bit 4 (0x10): Unused
1194   0000                                                              ;    bit 5 (0x20): Boost control solenoid
1195   0000                                                              ;    bit 6 (0x40): Unused
1196   0000                                                              ;    bit 7 (0x80): Unused
1197   0000             validFlags       .EQU     $00fc                  ; Flag related to the validation of sensors...
1198   0000                                                              ;    bit 0 (0x01): Set to 1 when T40_engRot is expired (no CAS interrupt received for a long time)  
1199   0000                                                              ;    bit 1 (0x02): Set to 1 when the condition of the o2 sensor was determined (good or not). Only reset when car key is put in off I think
1200   0000                                                              ;    bit 2 (0x04): Set to 1 when the condition of the egrt sensor was determined (good or not). Only reset when car key is put if off I think
1201   0000                                                              ;    bit 3 (0x08): 
1202   0000                                                              ;    bit 4 (0x10): 
1203   0000                                                              ;    bit 5 (0x20): 
1204   0000                                                              ;    bit 6 (0x40): 
1205   0000                                                              ;    bit 7 (0x80): Set to 1 if o2Raw > 0.6V (rich), 0 otherwise 
1206   0000             iscStepTarg      .EQU     $00fd                  ; Target ISC step, that's the target value for iscStepCurr
1207   0000             idleSpdTarg      .EQU     $00fe                  ; Current target idle speed (xx*7.8125)rpm based on ect, A/C switch, etc.
1208   0000             airCntDef        .EQU     $00ff                  ; airCntDef*8*256 is the default value of [airCnt0:airCnt1:airCnt2] when mas interrupts are not being received, calculated from rpm, tps, ect, tables
1209   0000             injPwStart       .EQU     $0100   ;:$0101        ; The value of injPw used when engine is "rotating" (start-up). Calculated from fixed values (no air count)
1210   0000             oldFtrimFlg      .EQU     $0102                  ; Old value of ftrimFlags
1211   0000             accEnrDecay      .EQU     $0103                  ; Acceleration enrichment decay factor. accEnr is multiplied by (1-accEnrDecay/256) on each iteration. Initialized from a table as a function of ect.
1212   0000             accEnrTimer      .EQU     $0104                  ; Timer used to continue applying acceleration enrichement for 4 iterations after airflow is below minimum threshold (accEnrMinAf). 
1213   0000             accEnrMinAf      .EQU     $0105   ;:$0106        ; Minimum value of airCnt0 above/below which acceleration/deceleration enrichment should be applied (for acceleration, when airflow goes below, we stop applying acc enrichment after 4 iterations, see accEnrTimer. For decelaration, we stop reducing injPw as soon as we are above threshold)
1214   0000             decEnr           .EQU     $0107                  ; Deceleration enrichment (100x/255)%. This value is actually  updated with min(airCnt0-oldAirCnt0,$ff) under deceleration, see code. Max value is $ff from code
1215   0000             accEnrFact       .EQU     $0108   ;:$0109        ; Factor used in increasing injPw during acceleration enrichment
1216   0000             decEnrFact       .EQU     $010a   ;:$010b        ; Factor used in decreasing injPw during deceleration enrichment
1217   0000             accEnrDiffT      .EQU     $010c                  ; Minimum value of (airCnt0-oldAirCnt0) required to update decEnr or accEnr
1218   0000             accEnrTmr2       .EQU     $010d                  ; Timer used to hold accEnr for 4 or 5 iterations when it is getting small, before decreasing it to 0. 
1219   0000             oldTps3          .EQU     $010e                  ; Old value of tpsRaw calculated at 100Hz, used to compute tpsDiff100
1220   0000             tpsDiff100       .EQU     $010f                  ; Used to interpolate t_sInjEnr. Correspond to max(tpsRaw-oldTps3,0) calculated at 100Hz, used in the calculation of sInjEnr.
1221   0000             T200s_sInj       .EQU     $0110                  ; sInjEnr is reset to 0 when this timer expires (0.2sec after conditions don't warrant having sInjEnr anymore) 
1222   0000             sInjEnr          .EQU     $0111                  ; Kind of acceleration fuel enrichement when still using simultaneous injection?
1223   0000             sInjEnrMax       .EQU     $0112                  ; Maximum value applied to sInjEnr 
1224   0000             sInjTpsMax       .EQU     $0113                  ; sInjEnr is only increased if oldTps3 <= sInjTpsMax 
1225   0000             sInjPw           .EQU     $0114   ;:$0115        ; Injector pulsewidth used when simulataneous injection is used
1226   0000             sInjEnrInc       .EQU     $0116                  ; sInjEnr is increased by sInjEnrInc/128 * t_sInjEnr(tpsDiff100) = sInjEnrMax/32 * t_sInjEnr(tpsDiff100) at 100Hz under specific scenario
1227   0000                              
1228   0000                              ;----------------------------------------------------
1229   0000                              ; $117-$132, series of software timers (counting down to 0)
1230   0000                              ; decremented in subroutine 4 at ~40Hz
1231   0000                              ;----------------------------------------------------
1232   0000             T40_2hz          .EQU     $0117                  ; set to $14 on init and loop at $14 (produces 2Hz)
1233   0000             T40_0p5hz        .EQU     $0118                  ; set to $50 on init and loop at $50 (produces 0.5Hz)
1234   0000             T40_start        .EQU     $0119                  ; Set to $ff when key in start, start counting when key no more in start?
1235   0000             T40_crank        .EQU     $011a                  ; Set to $ff when startingToCrank, starts counting when engine is no more startingToCrank (engine running or other state...)
1236   0000             T40_baro         .EQU     $011b                  ; Used to ignore barometric sensor input if battery<8V and 0.35s after battery>8V (baro sensor sensitive to voltage...). Sensor is ignore when timer is not 0
1237   0000             T40_stInj0       .EQU     $011c                  ; Starts counting from 1 sec when rotatingStopInj flag is activated. Used to activate T40_stInj1
1238   0000             T40_stInj1       .EQU     $011d                  ; Initialized to 2 sec when T40_stInj0 expires (ongoing rotatingStopInj for more than 1sec) starts counting when rotatingStopInj is deactivated. This timer is therefore non-zero 1 sec after rotatingStopInj starts and 2 sec after is stops
1239   0000             T40_o2Fbk        .EQU     $011e                  ; Timer will only be 0 when the low trim range will have been selected for more than 4 sec. Used to eventually calculate o2Fbk_dec,o2Fbk_inc, how fast o2 feedback is adjusting...
1240   0000             T40_ftrim2       .EQU     $011f                  ; Used on E931 as an additional condition to update fuel trims
1241   0000             T40_engRot       .EQU     $0120                  ; Kind of an "engine rotating" flag, This timer is re-initialized to 0.6s or 1.2s on every CAS interrupt, will reach 0 only if no CAS int. is received (engine not rotating or very slowy) for more than that time (rpm<0.83/K???)
1242   0000             T40_mas          .EQU     $0121                  ; This timer is periodically initialized to 12 (0.3s) and will reach 0 only if no mas interrupt is received for that long (no air is getting in or something is wrong...)
1243   0000             T40_fuelCut      .EQU     $0122                  ; Fuel cut timer, fuel cut is applied only when this timer reach 0: After air flow threshold is exceeded for more than 1s
1244   0000             T40_ftrim        .EQU     $0123                  ; Fuel trim update timer. Fuel trim are not updated unless this timer is expired (=0). It is set to 5 sec when condition are stable, i.e. fuel trim are update only after conditions are stable for more than 5 sec
1245   0000             T40_noPower      .EQU     $0124                  ; Timer is init at 0.125sec on every loop when ECU receives power? Will reach 0 when the ECU is about to turn-off (ECU relay turns-off after a few seconds...)
1246   0000             T40_revving      .EQU     $0125                  ; Timer used in updating iscStStall. Re-init to 0.5sec if  tpsRaw < 86% or airVol >= $3a. Timer will start counting when tpsRaw>86% and airVol < $3a and will expire 0.5sec later. Keeps track of rapid throttle plate opening in stalling calculations???
1247   0000             T40_iscLrn       .EQU     $0126                  ; Timer looping at 40 (produces 1 Hz) used to update isc0/isc1 and iscY1/iscY2/iscY3 at 1Hz (isc learning...)
1248   0000             T40_stall        .EQU     $0127                  ; Used to update iscStStall at ~2Hz
1249   0000             T40_acOnTrans    .EQU     $0128                  ; Used to filter out (0.1sec) the impact of A/C being turned-on (transcient load) when evaluating whether the engine is running too slow (<500rpm) 
1250   0000             T40_iscStart     .EQU     $0129                  ; Used to decrement iscStStartMaster as a function of time upon engine startup
1251   0000             T40_checkTargRpm .EQU     $012a                  ; Timer used to schedule every 1sec the comparison between current rpm to target rpm and adjust isc if necessary
1252   0000             T40_iSpAdj       .EQU     $012b                  ; Timer is 0 when Idle speed adjustment mode is active. Set to 0.2sec after both timing adjustment and ECU test mode terminals are grounded. i.e. idle speed adjustement mode is applied 0.2sec after terminals are grounded...
1253   0000             T40_21           .EQU     $012c                  ; For E932, used to decrement iscStBaseAcAdj at 2.22Hz
1254   0000             T40_obdCmd       .EQU     $012d                  ; Implement the processing of OBD command code, set to $f0 (6 seconds at 40Hz) if an injector is off or an actuator on
1255   0000             T40_acOn         .EQU     $012e                  ; Implement min time before engaging A/C clutch after A/C button is pressed
1256   0000             T40_acOnRpm      .EQU     $012f                  ; Implement min time before engaging A/C clutch after RPM > 438 (after car is started-up)
1257   0000             T40_acCut        .EQU     $0130                  ; Implement the 5s A/C cutoff when TPS goes above (and stays above) 82% in AT (5 sec countdown)
1258   0000             T40_26           .EQU     $0131                  ; Unused (but decremented...)
1259   0000             T40_27           .EQU     $0132                  ; Unused (but decremented...)
1260   0000                              
1261   0000                              
1262   0000                              ;-----------------------------------------
1263   0000                              ; Software timer at ~40Hz decremented individually
1264   0000                              ;-----------------------------------------
1265   0000             T40s_Idle        .EQU     $0133                  ; Only decremented under some specific conditions, init with $1e(0.75s) when idle switch is off, will reach 0 when idle switch has been on for more than 0.75s, used to condition idle flag with A/C switch. 
1266   0000                              
1267   0000                              ;----------------------------------------------------
1268   0000                              ; $134-$13f, series of software timers (counting down to 0)
1269   0000                              ; decremented in subroutine 4 at ~2Hz
1270   0000                              ;----------------------------------------------------
1271   0000             T2_crank         .EQU     $0134                  ; Set to $ff when startingToCrank, starts counting when engine is no more startingToCrank (engine running or other state...)
1272   0000             T2_EcuPower      .EQU     $0135                  ; Starts counting from $ff when the ECU receives power, used to blink the "check engine" light when the ECU is turned on. 
1273   0000             T2_closedLp      .EQU     $0136                  ; Used to prolong closed loop mode when we go over an airVolTB threshold for a short period of time, Init to 12sec or 20sec
1274   0000             T2_o2Sensor      .EQU     $0137                  ; Used to validate the o2 sensor voltage. If timer expires with the o2 sensor voltage never switching (rich/lean) then o2 sensor is not working correctly...
1275   0000             T2_hotEnrich     .EQU     $0138                  ; Used for fuel enrichement during 120sec after starting engine under very hot intake air temperature (reduce vapor lock???)
1276   0000             T2_airVolT       .EQU     $0139                  ; Set to 5 sec whenever airVolT>24. Will expire once airVolT<=15 for more than 5sec
1277   0000             T2_6             .EQU     $013a                  ; Unused? (but decremented...)
1278   0000             T2_snsrChk       .EQU     $013b                  ; Sensor is flagged as bad only when it has been consistently been tested as bad for 4sec. T2_snsrChk implement that 4sec. Initialized to 4 sec everytime sensrChkIdx is reset to 0
1279   0000             T2_o2Chk         .EQU     $013c                  ; Used in o2 sensor testing/validation. re-initialized to 30sec as long as all the testing pre-conditions are not met or as long as we are running rich. Starts counting when we are running lean and pre-conditions are met...
1280   0000             T2_egrtChk       .EQU     $013d                  ; Used in egrt sensor testing/validation.
1281   0000             T2_stCrank       .EQU     $013e                  ; Init to $ff when startingToCrank or when engine just started rotating, starts counting after state change 
1282   0000             T2_11            .EQU     $013f                  ; Unused? (but decremented...)
1283   0000                              
1284   0000                              ;---------------------------------------------------
1285   0000                              ; 140-144, series of software timers (counting down to 0)
1286   0000                              ; decremented in subroutine 4 at ~0.5Hz
1287   0000                              ;---------------------------------------------------
1288   0000             T0p5_crank1      .EQU     $0140                  ; Set to $ff when startingToCrank, starts counting when engine is no more startingToCrank (engine running or other state...)
1289   0000             T0p5_crCold      .EQU     $0141                  ; Basically not null for 120sec after a cold engine is being cranked/started. Initialized to 120sec when startingToCrank and temperature(ectFiltered) <= 88degC or to 0 if startingToCrank and temperature(ectFiltered) >88degC. Never updated otherwise. Starts counting when we are not startingToCrank. Reset to 0 when notRotating. 
1290   0000             T0p5_purge       .EQU     $0142                  ; Used to implement pulsewidth modulation of the purge solenoid (if some conditions are met), period is very long, 236sec
1291   0000             T0p5_crank2      .EQU     $0143                  ; Similar to T0p5_crank1
1292   0000             T0p5_ect         .EQU     $0144                  ; Reloaded with 5 min on every loop. Starts counting from 5 min only when ect equals exactly 41degC, used in ECT sensor fault routine. Since ect should not stay at that temp for long, counter should never reach 0???
1293   0000                              
1294   0000             Tcas             .EQU     $0145   ;:$0146        ; Tcas (125KHz clock, half the real clock...) is the time(s) per cas interrupt * 125000, rpm = 60/(2*Tcas/125000), Tcas = 60/(2*rpm/125000)    (there are 4 cas interrupt for every 2 engine rotations). Tcas is calculated from [TcasLast0:TcasLast1]/2
1295   0000             TcasOld          .EQU     $0147   ;:$0148        ; previous value of Tcas
1296   0000             airDiffPos1      .EQU     $0149                  ; airDiffPos is transfered to it in subroutine 1
1297   0000             airDiffNeg1      .EQU     $014a                  ; airDiffNeg is transfered to it in subroutine 1
1298   0000             mafRaw16         .EQU     $014b   ;:$014c        ; 16 bit mafRaw, Airflow sensor pulse frequency (x/10.24)Hz, calculated from filtered air count (airCnt0:airCnt1) and rpm
1299   0000             tpsDiffMax2      .EQU     $014d                  ; Value tpsDiffMax1 is transfered here on every main loop execution    
1300   0000             ectCond          .EQU     $014e                  ; Conditionned ect for table interpolation, calculated from ectFiltered, see around L1035 
1301   0000             iatCond          .EQU     $014f                  ; Condtionned intake air temperature -> validated and offset/clipped  = max(min(iatChecked,$e0)-$20,0)     
1302   0000             airVolCond       .EQU     $0150                  ; Conditionned airVol used in table interpolation
1303   0000             rpmIndex1        .EQU     $0151                  ; Set to min(max(RPM31p25-500rpm,0),4500rpm), used in 2D interpolation of t_egrDutyFact (column) 
1304   0000             baroCond         .EQU     $0152                  ; Conditionned barometric pressure, non-linear range of $00 to $80 (0.45bar to 0.92bar): 1:1 from $00 to $40 and 2:1 from $40 to $80 
1305   0000             injMasComp       .EQU     $0153   ;:$0154        ; totMasComp*16 * injComp/128
1306   0000             totMasComp       .EQU     $0155   ;:$0156        ; Total mas compensation factor, (masComp+t_masComp(xx))* masLinComp/128
1307   0000             masLinComp       .EQU     $0157                  ; Interpolated t_masLin, compensate for airflow sensor non-linearity as a function of iat, baro and airflow sensor frequency
1308   0000             L0158            .EQU     $0158                  ; Not used????
1309   0000             openLoopEnr      .EQU     $0159                  ; Open loop enrichement factor, based on timing/knock fuel enrichment conditionned on tps and timer based enrichement
1310   0000             o2FuelAdj        .EQU     $015a                  ; Factor to increase/reduce fuel depending on o2 sensor voltage/feedback, value from 0 to 255, $80=100%->no fuel adjustment. o2FuelAdj = o2Fbk +/-  t_closedLpV1(xx) or t_closedLpV2(xx)
1311   0000             workFtrim        .EQU     $015b                  ; Working fuel trim, the fuel trim selected according to current fuel trim range
1312   0000             coldTempEnr      .EQU     $015c                  ; Fuel enrichement factor for cold engine under low airflow conditions, Value of $80=100% means no enrichement
1313   0000             enrWarmup        .EQU     $015d                  ; Current fuel enrichment during warmup/startup, enrichement factor = (2*enrWarmup+$80)/$80
1314   0000             T_enrWarm        .EQU     $015e                  ; Counter used to lower enrWarmup as a function of time down to 0 
1315   0000             iatCompFact      .EQU     $015f                  ; Air density factor as a function of temperature ($80=1.0)
1316   0000             baroFact         .EQU     $0160                  ; Barometric pressure factor, pressure=(baroFact/128)bar
1317   0000             timFuelEnr       .EQU     $0161                  ; Fuel enrich based on knock/timing??? (Temporarily the timing map value)
1318   0000             T40s_iscStable   .EQU     $0162                  ; Timer is re-initialized to various values (highest of new and current is kept) every time a ISC impacting load is detected (i.e power steering pump is turned on). Timer is decremented only when iscStepTarg=iscStepCurr, i.e. idle speed target is reached. 
1319   0000                                                              ; It will therefore reach 0 only when the ISC step has reached its target and stayed there for a while, ISC is stable...
1320   0000             iscStStall       .EQU     $0163                  ; This is the minimum isc step to use when the idle switch transition from off to on. It is decreased by 3 at ~20Hz???. I suppose this is to smooth the rapid change of airflow when the throttle plate closes and reduce the possibility of stalling the engine
1321   0000             iscStStartUsed   .EQU     $0164                  ; This is the current value of the offset to add to base isc step when the engine was just started. It is slowly decreased (following iscStStartMaster) until the isc step stabilizes. It then stays constant. Whatever value remains after stabilization is used to update iscYn learning variables
1322   0000             iscLowBatt       .EQU     $0165                  ; Keep track of battery condition for ISC spindle updating. Bit 7 is set when battRaw >= 10V (with hysteresis). 2 lower bits used as counter (3 max) as to how many consecutive times battRaw >= 10V, ISC spindle is not moved until this counter is $03
1323   0000             iscStTargSpec    .EQU     $0166                  ; The value that will be stored in iscStepTarg when the engine is runnning but iscLrnFlags.1 is set
1324   0000             iscStBase        .EQU     $0167                  ; Basic ISC step as a function of ECT
1325   0000             iscStBaseAc      .EQU     $0168                  ; iscStBase corrected for A/C and transmission load
1326   0000             iscStBaseCSt     .EQU     $0169                  ; iscStBase corrected for cold start period, i.e. high ISC step at start and then decreasing towards iscStBase over 120sec. Set to 0 after 120sec
1327   0000             iscStBarOff      .EQU     $016a                  ; Offset to add to the basic ISC step to compensate for barometric pressure
1328   0000             iscStBaseAcAdj   .EQU     $016b                  ; For E932, used to adjust iscStBaseAc when transmission is engaged, i.e. drive, decremented down to 0 at 2.22Hz...  
1329   0000             idleSpdInit      .EQU     $016c                  ; Preliminary idle speed target (xx*7.8125)rpm, t_idleSpd(ect) or t_idleSpdDr(ect), used in the computation of idleSpdTarg
1330   0000             idleSpdMin       .EQU     $016d                  ; Minimum idle speed target (xx*7.8125)rpm, used in the computation of idleSpdTarg
1331   0000             L016e            .EQU     $016e                  ; Unused?
1332   0000             advTotal         .EQU     $016f                  ; Sum of the timing (xx-10)degrees BTDC from the timing maps (timingOct) and of three other timing corrections (advEct-$80, advIat-$80, advRpm-$80)
1333   0000             timingOct        .EQU     $0170                  ; Base timing (xx-10)degrees corrrected for octane: timingOct = alpha * t_timingHiOct(rpm, load) + (1-alpha) * t_timingLoOct(rpm, load)    where alpha = octane/255
1334   0000             advEct           .EQU     $0171                  ; Ect based timing correction (xx-$80)degrees
1335   0000             advIat           .EQU     $0172                  ; Iat based timing correction (xx-$80)degrees
1336   0000             advRpm           .EQU     $0173                  ; Rpm based timing correction (xx-$80)degrees
1337   0000             coilChkCnt       .EQU     $0174                  ; Used to set an error flag if the ignition coil sensing circuit shows that the ignition is not working properly 
1338   0000             coilHist         .EQU     $0175                  ; coilHist basically contains the ignition coil sensing circuit history (0 or 1 from port4.2) for the last 8 CAS interrupts, bit 7 being the oldest and bit 0 the newest
1339   0000             T40s_octane      .EQU     $0176                  ; octane timer decremented at 40Hz and looping at $10. octane is updated when timer reaches 0 (at 2.5Hz total)
1340   0000             knockTimer       .EQU     $0177                  ; Used in the validation of the raw knock sensor voltage received from the ADC
1341   0000             egrtTimerThr     .EQU     $0178                  ; Timer threshold (compared to T0p5_crank2) used to decide whether enough time has elapsed to test the egrt sensor (180sec or 360sec), threshold is ect based
1342   0000             sensrChkIdx      .EQU     $0179                  ; The current index in table t_snsrChk indicating which sensor is to be checked/tested next.
1343   0000             obdCode          .EQU     $017a                  ; Contain the latest code received from OBD connector
1344   0000             errCodeIdx       .EQU     $017b                  ; Processing of diagnoctic port error code output (heart beat mode), 
1345   0000                                                              ; c4:c3:c2:c1:c0 is the index of the current error being output
1346   0000                                                              ; d2:d1:d0 are used as a small 2Hz timer to produce the "heart beat"...
1347   0000                                                              ;     bit 0 (0x01): c0 
1348   0000                                                              ;     bit 1 (0x02): c1
1349   0000                                                              ;     bit 2 (0x04): c2
1350   0000                                                              ;     bit 3 (0x08): c3
1351   0000                                                              ;     bit 4 (0x10): c4
1352   0000                                                              ;     bit 5 (0x20): d0
1353   0000                                                              ;     bit 6 (0x40): d1
1354   0000                                                              ;     bit 7 (0x80): d2
1355   0000             errCodeProc      .EQU     $017c                  ; Loaded with the error code (t_snsrChkCode) being output to the test connector (heart beat mode) and then updated as the code is being output.
1356   0000                                                              ;     bit 0 (0x01): a0  a3:a2:a1:a0 is the number of short pulse left to output to connector
1357   0000                                                              ;     bit 1 (0x02): a1
1358   0000                                                              ;     bit 2 (0x04): a2
1359   0000                                                              ;     bit 3 (0x08): a3
1360   0000                                                              ;     bit 4 (0x10): b0 b2:b1:b0 is the number of long pulse left to output to connector
1361   0000                                                              ;     bit 5 (0x20): b1
1362   0000                                                              ;     bit 6 (0x40): b2
1363   0000                                                              ;     bit 7 (0x80): c0 Set to 1 when a new code is loaded, reset to 0 at midpoint between long and short pulses
1364   0000             egrDuty128       .EQU     $017d                  ; EGR solenoid Duty cycle value from 0 to $80 produces 0 to 100% (not sure of correspondance)
1365   0000             egrDuty          .EQU     $017e                  ; EGR solenoid Duty cycle (48-value)/48, value of table at FF88 interpolated by ECT
1366   0000             bGaugeODuty      .EQU     $017f                  ; Boost gauge "off-duty" cycle, value between $00 and $18, $00 corresponding to the maximum of the boost gauge scale
1367   0000             T40s_bcs         .EQU     $0180                  ; bcs timer, decremented at 40Hz, loops at $14 (20), bcs duty cycle is updated when this timer reaches 0 (at 2Hz)
1368   0000             bcsDuty          .EQU     $0181                  ; bcs duty cycle, duty cycle = (48-value)/48
1369   0000             T40s_tps         .EQU     $0182                  ;
1370   0000             ectStCrank       .EQU     $0183                  ; Loaded with ectFiltered when engine is startingToCrank, used in ect sensor check
1371   0000             rpmX4Filt        .EQU     $0184   ;:$0185        ; Filtered version of 16*rpm4 (xx*16/3.90625)rpm. Filtering is achieved using exponential averaging with alpha = 0.90625
1372   0000             injCount         .EQU     $0186                  ; Used in the calculation of injPwStart. Incremented by 1 (255 max) every time injPw !=0 in interrupt rountine (fuel is injected)
1373   0000             airCntMin0       .EQU     $0187                  ; [airCntMin0:airCntMin1] is the minimum value of [airCntNew0:airCntNew1] before it is used for airCnt0 calcuations
1374   0000             airCntMin1       .EQU     $0188                  ; See airCntMin0
1375   0000             
1376   0000             
1377   0000                               ;------------------------------------------------------------
1378   0000                               ; Unused memory block, except for iscStStartMaster
1379   0000                               ;
1380   0000                               ; Also provides a buffer space in case of stack overflow...
1381   0000                               ; Memories should always be 0 else it means the stack 
1382   0000                               ; overflowed in this region... 
1383   0000                               ;------------------------------------------------------------
1384   0000             L0189            .EQU     $0189                  ;
1385   0000             L018a            .EQU     $018a                  ;
1386   0000             L018b            .EQU     $018b                  ;
1387   0000             L018c            .EQU     $018c                  ;
1388   0000             iscStStartMaster .EQU     $018d                  ; This is the master isc step offset used upon engine startup. It is initialized with a value from table and then decreased as a function of time down to 0. See iscStStartUsed for more details...
1389   0000             L018e            .EQU     $018e                  ;
1390   0000             L018f            .EQU     $018f                  ;
1391   0000             L0190            .EQU     $0190                  ; Memory cleared up to (and including) here
1392   0000             ramClearEnd      .EQU     $0190                  ;
1393   0000                              
1394   0000                               ;--------------------------------------------
1395   0000                               ; Memory below is reserved for the stack
1396   0000                               ;--------------------------------------------
1397   0000             L0191            .EQU     $0191                  ;                             
1398   0000             L0192            .EQU     $0192                  ; 
1399   0000             L0193            .EQU     $0193                  ; 
1400   0000             L0194            .EQU     $0194                  ; 
1401   0000             L0195            .EQU     $0195                  ; 
1402   0000             L0196            .EQU     $0196                  ; 
1403   0000             L0197            .EQU     $0197                  ; 
1404   0000             L0198            .EQU     $0198                  ; 
1405   0000             L0199            .EQU     $0199                  ; 
1406   0000             L019a            .EQU     $019a                  ; 
1407   0000             L019b            .EQU     $019b                  ; 
1408   0000             L019c            .EQU     $019c                  ; 
1409   0000             L019d            .EQU     $019d                  ; 
1410   0000             L019e            .EQU     $019e                  ; 
1411   0000             L019f            .EQU     $019f                  ; 
1412   0000             L01a0            .EQU     $01a0                  ; 
1413   0000             L01a1            .EQU     $01a1                  ; 
1414   0000             L01a2            .EQU     $01a2                  ; 
1415   0000             L01a3            .EQU     $01a3                  ; 
1416   0000             L01a4            .EQU     $01a4                  ; 
1417   0000             L01a5            .EQU     $01a5                  ; 
1418   0000             L01a6            .EQU     $01a6                  ; 
1419   0000             L01a7            .EQU     $01a7                  ; 
1420   0000             L01a8            .EQU     $01a8                  ; 
1421   0000             L01a9            .EQU     $01a9                  ; 
1422   0000             L01aa            .EQU     $01aa                  ; 
1423   0000             L01ab            .EQU     $01ab                  ; 
1424   0000             L01ac            .EQU     $01ac                  ; 
1425   0000             L01ad            .EQU     $01ad                  ; 
1426   0000             L01ae            .EQU     $01ae                  ; 
1427   0000             L01af            .EQU     $01af                  ; 
1428   0000             L01b0            .EQU     $01b0                  ; 
1429   0000             L01b1            .EQU     $01b1                  ; 
1430   0000             L01b2            .EQU     $01b2                  ; 
1431   0000             L01b3            .EQU     $01b3                  ; 
1432   0000             L01b4            .EQU     $01b4                  ; 
1433   0000             L01b5            .EQU     $01b5                  ; 
1434   0000             L01b6            .EQU     $01b6                  ; 
1435   0000             L01b7            .EQU     $01b7                  ; 
1436   0000             L01b8            .EQU     $01b8                  ; 
1437   0000             L01b9            .EQU     $01b9                  ; 
1438   0000             L01ba            .EQU     $01ba                  ; 
1439   0000             L01bb            .EQU     $01bb                  ; 
1440   0000             L01bc            .EQU     $01bc                  ; 
1441   0000             L01bd            .EQU     $01bd                  ; 
1442   0000             L01be            .EQU     $01be                  ; 
1443   0000             stack            .EQU     $01bf                  ; Top of stack location(grows backward (push-> SP=SP-1)
1444   0000                         
1445   0000               
1446   0000                                         
1447   0000             ;***************************************************************
1448   0000             ;*
1449   0000             ;*
1450   0000             ;* Unused/Unavailable memory?
1451   0000             ;*
1452   0000             ;*
1453   0000             ;***************************************************************
1454   0000             empty1      .EQU    $01C0   ;:$01FF
1455   0000             
1456   0000             
1457   0000             
1458   0000             ;******************************************************************
1459   0000             ;
1460   0000             ;
1461   0000             ; 32KB chip address range start
1462   0000             ;
1463   0000             ;
1464   0000             ;******************************************************************
1465   8000             epromStart   .org    $8000
1466   8000             
1467   8000             
1468   8000             
1469   8000             ;******************************************************************
1470   8000             ;
1471   8000             ;
1472   8000             ; Battery gauge code
1473   8000             ;
1474   8000             ; 0psi boost ~12.14V ~ 40% duty
1475   8000             ;
1476   8000             ;
1477   8000             ;
1478   8000             ;******************************************************************
1479   8000 FF FF FF FF             .fill   newCode-$, $ff
1479   8004 FF FF FF FF 
1479   8008 FF FF FF FF 
1479   800C FF FF FF FF 
1479   8010 FF FF FF FF 
1479   8014 FF FF FF FF 
1479   8018 FF FF FF FF 
1479   801C FF FF FF FF 
1479   8020 FF FF FF FF 
1479   8024 FF FF FF FF 
1479   8028 FF FF FF FF 
1479   802C FF FF FF FF 
1479   8030 FF FF FF FF 
1479   8034 FF FF FF FF 
1479   8038 FF FF FF FF 
1479   803C FF FF FF FF 
1479   8040 FF FF FF FF 
1479   8044 FF FF FF FF 
1479   8048 FF FF FF FF 
1479   804C FF FF FF FF 
1479   8050 FF FF FF FF 
1479   8054 FF FF FF FF 
1479   8058 FF FF FF FF 
1479   805C FF FF FF FF 
1479   8060 FF FF FF FF 
1479   8064 FF FF FF FF 
1479   8068 FF FF FF FF 
1479   806C FF FF FF FF 
1479   8070 FF FF FF FF 
1479   8074 FF FF FF FF 
1479   8078 FF FF FF FF 
1479   807C FF FF FF FF 
1479   8080 FF FF FF FF 
1479   8084 FF FF FF FF 
1479   8088 FF FF FF FF 
1479   808C FF FF FF FF 
1479   8090 FF FF FF FF 
1479   8094 FF FF FF FF 
1479   8098 FF FF FF FF 
1479   809C FF FF FF FF 
1479   80A0 FF FF FF FF 
1479   80A4 FF FF FF FF 
1479   80A8 FF FF FF FF 
1479   80AC FF FF FF FF 
1479   80B0 FF FF FF FF 
1479   80B4 FF FF FF FF 
1479   80B8 FF FF FF FF 
1479   80BC FF FF FF FF 
1479   80C0 FF FF FF FF 
1479   80C4 FF FF FF FF 
1479   80C8 FF FF FF FF 
1479   80CC FF FF FF FF 
1479   80D0 FF FF FF FF 
1479   80D4 FF FF FF FF 
1479   80D8 FF FF FF FF 
1479   80DC FF FF FF FF 
1479   80E0 FF FF FF FF 
1479   80E4 FF FF FF FF 
1479   80E8 FF FF FF FF 
1479   80EC FF FF FF FF 
1479   80F0 FF FF FF FF 
1479   80F4 FF FF FF FF 
1479   80F8 FF FF FF FF 
1479   80FC FF FF FF FF 
1479   8100 FF FF FF FF 
1479   8104 FF FF FF FF 
1479   8108 FF FF FF FF 
1479   810C FF FF FF FF 
1479   8110 FF FF FF FF 
1479   8114 FF FF FF FF 
1479   8118 FF FF FF FF 
1479   811C FF FF FF FF 
1479   8120 FF FF FF FF 
1479   8124 FF FF FF FF 
1479   8128 FF FF FF FF 
1479   812C FF FF FF FF 
1479   8130 FF FF FF FF 
1479   8134 FF FF FF FF 
1479   8138 FF FF FF FF 
1479   813C FF FF FF FF 
1479   8140 FF FF FF FF 
1479   8144 FF FF FF FF 
1479   8148 FF FF FF FF 
1479   814C FF FF FF FF 
1479   8150 FF FF FF FF 
1479   8154 FF FF FF FF 
1479   8158 FF FF FF FF 
1479   815C FF FF FF FF 
1479   8160 FF FF FF FF 
1479   8164 FF FF FF FF 
1479   8168 FF FF FF FF 
1479   816C FF FF FF FF 
1479   8170 FF FF FF FF 
1479   8174 FF FF FF FF 
1479   8178 FF FF FF FF 
1479   817C FF FF FF FF 
1479   8180 FF FF FF FF 
1479   8184 FF FF FF FF 
1479   8188 FF FF FF FF 
1479   818C FF FF FF FF 
1479   8190 FF FF FF FF 
1479   8194 FF FF FF FF 
1479   8198 FF FF FF FF 
1479   819C FF FF FF FF 
1479   81A0 FF FF FF FF 
1479   81A4 FF FF FF FF 
1479   81A8 FF FF FF FF 
1479   81AC FF FF FF FF 
1479   81B0 FF FF FF FF 
1479   81B4 FF FF FF FF 
1479   81B8 FF FF FF FF 
1479   81BC FF FF FF FF 
1479   81C0 FF FF FF FF 
1479   81C4 FF FF FF FF 
1479   81C8 FF FF FF FF 
1479   81CC FF FF FF FF 
1479   81D0 FF FF FF FF 
1479   81D4 FF FF FF FF 
1479   81D8 FF FF FF FF 
1479   81DC FF FF FF FF 
1479   81E0 FF FF FF FF 
1479   81E4 FF FF FF FF 
1479   81E8 FF FF FF FF 
1479   81EC FF FF FF FF 
1479   81F0 FF FF FF FF 
1479   81F4 FF FF FF FF 
1479   81F8 FF FF FF FF 
1479   81FC FF FF FF FF 
1479   8200 FF FF FF FF 
1479   8204 FF FF FF FF 
1479   8208 FF FF FF FF 
1479   820C FF FF FF FF 
1479   8210 FF FF FF FF 
1479   8214 FF FF FF FF 
1479   8218 FF FF FF FF 
1479   821C FF FF FF FF 
1479   8220 FF FF FF FF 
1479   8224 FF FF FF FF 
1479   8228 FF FF FF FF 
1479   822C FF FF FF FF 
1479   8230 FF FF FF FF 
1479   8234 FF FF FF FF 
1479   8238 FF FF FF FF 
1479   823C FF FF FF FF 
1479   8240 FF FF FF FF 
1479   8244 FF FF FF FF 
1479   8248 FF FF FF FF 
1479   824C FF FF FF FF 
1479   8250 FF FF FF FF 
1479   8254 FF FF FF FF 
1479   8258 FF FF FF FF 
1479   825C FF FF FF FF 
1479   8260 FF FF FF FF 
1479   8264 FF FF FF FF 
1479   8268 FF FF FF FF 
1479   826C FF FF FF FF 
1479   8270 FF FF FF FF 
1479   8274 FF FF FF FF 
1479   8278 FF FF FF FF 
1479   827C FF FF FF FF 
1479   8280 FF FF FF FF 
1479   8284 FF FF FF FF 
1479   8288 FF FF FF FF 
1479   828C FF FF FF FF 
1479   8290 FF FF FF FF 
1479   8294 FF FF FF FF 
1479   8298 FF FF FF FF 
1479   829C FF FF FF FF 
1479   82A0 FF FF FF FF 
1479   82A4 FF FF FF FF 
1479   82A8 FF FF FF FF 
1479   82AC FF FF FF FF 
1479   82B0 FF FF FF FF 
1479   82B4 FF FF FF FF 
1479   82B8 FF FF FF FF 
1479   82BC FF FF FF FF 
1479   82C0 FF FF FF FF 
1479   82C4 FF FF FF FF 
1479   82C8 FF FF FF FF 
1479   82CC FF FF FF FF 
1479   82D0 FF FF FF FF 
1479   82D4 FF FF FF FF 
1479   82D8 FF FF FF FF 
1479   82DC FF FF FF FF 
1479   82E0 FF FF FF FF 
1479   82E4 FF FF FF FF 
1479   82E8 FF FF FF FF 
1479   82EC FF FF FF FF 
1479   82F0 FF FF FF FF 
1479   82F4 FF FF FF FF 
1479   82F8 FF FF FF FF 
1479   82FC FF FF FF FF 
1479   8300 FF FF FF FF 
1479   8304 FF FF FF FF 
1479   8308 FF FF FF FF 
1479   830C FF FF FF FF 
1479   8310 FF FF FF FF 
1479   8314 FF FF FF FF 
1479   8318 FF FF FF FF 
1479   831C FF FF FF FF 
1479   8320 FF FF FF FF 
1479   8324 FF FF FF FF 
1479   8328 FF FF FF FF 
1479   832C FF FF FF FF 
1479   8330 FF FF FF FF 
1479   8334 FF FF FF FF 
1479   8338 FF FF FF FF 
1479   833C FF FF FF FF 
1479   8340 FF FF FF FF 
1479   8344 FF FF FF FF 
1479   8348 FF FF FF FF 
1479   834C FF FF FF FF 
1479   8350 FF FF FF FF 
1479   8354 FF FF FF FF 
1479   8358 FF FF FF FF 
1479   835C FF FF FF FF 
1479   8360 FF FF FF FF 
1479   8364 FF FF FF FF 
1479   8368 FF FF FF FF 
1479   836C FF FF FF FF 
1479   8370 FF FF FF FF 
1479   8374 FF FF FF FF 
1479   8378 FF FF FF FF 
1479   837C FF FF FF FF 
1479   8380 FF FF FF FF 
1479   8384 FF FF FF FF 
1479   8388 FF FF FF FF 
1479   838C FF FF FF FF 
1479   8390 FF FF FF FF 
1479   8394 FF FF FF FF 
1479   8398 FF FF FF FF 
1479   839C FF FF FF FF 
1479   83A0 FF FF FF FF 
1479   83A4 FF FF FF FF 
1479   83A8 FF FF FF FF 
1479   83AC FF FF FF FF 
1479   83B0 FF FF FF FF 
1479   83B4 FF FF FF FF 
1479   83B8 FF FF FF FF 
1479   83BC FF FF FF FF 
1479   83C0 FF FF FF FF 
1479   83C4 FF FF FF FF 
1479   83C8 FF FF FF FF 
1479   83CC FF FF FF FF 
1479   83D0 FF FF FF FF 
1479   83D4 FF FF FF FF 
1479   83D8 FF FF FF FF 
1479   83DC FF FF FF FF 
1479   83E0 FF FF FF FF 
1479   83E4 FF FF FF FF 
1479   83E8 FF FF FF FF 
1479   83EC FF FF FF FF 
1479   83F0 FF FF FF FF 
1479   83F4 FF FF FF FF 
1479   83F8 FF FF FF FF 
1479   83FC FF FF FF FF 
1479   8400 FF FF FF FF 
1479   8404 FF FF FF FF 
1479   8408 FF FF FF FF 
1479   840C FF FF FF FF 
1479   8410 FF FF FF FF 
1479   8414 FF FF FF FF 
1479   8418 FF FF FF FF 
1479   841C FF FF FF FF 
1479   8420 FF FF FF FF 
1479   8424 FF FF FF FF 
1479   8428 FF FF FF FF 
1479   842C FF FF FF FF 
1479   8430 FF FF FF FF 
1479   8434 FF FF FF FF 
1479   8438 FF FF FF FF 
1479   843C FF FF FF FF 
1479   8440 FF FF FF FF 
1479   8444 FF FF FF FF 
1479   8448 FF FF FF FF 
1479   844C FF FF FF FF 
1479   8450 FF FF FF FF 
1479   8454 FF FF FF FF 
1479   8458 FF FF FF FF 
1479   845C FF FF FF FF 
1479   8460 FF FF FF FF 
1479   8464 FF FF FF FF 
1479   8468 FF FF FF FF 
1479   846C FF FF FF FF 
1479   8470 FF FF FF FF 
1479   8474 FF FF FF FF 
1479   8478 FF FF FF FF 
1479   847C FF FF FF FF 
1479   8480 FF FF FF FF 
1479   8484 FF FF FF FF 
1479   8488 FF FF FF FF 
1479   848C FF FF FF FF 
1479   8490 FF FF FF FF 
1479   8494 FF FF FF FF 
1479   8498 FF FF FF FF 
1479   849C FF FF FF FF 
1479   84A0 FF FF FF FF 
1479   84A4 FF FF FF FF 
1479   84A8 FF FF FF FF 
1479   84AC FF FF FF FF 
1479   84B0 FF FF FF FF 
1479   84B4 FF FF FF FF 
1479   84B8 FF FF FF FF 
1479   84BC FF FF FF FF 
1479   84C0 FF FF FF FF 
1479   84C4 FF FF FF FF 
1479   84C8 FF FF FF FF 
1479   84CC FF FF FF FF 
1479   84D0 FF FF FF FF 
1479   84D4 FF FF FF FF 
1479   84D8 FF FF FF FF 
1479   84DC FF FF FF FF 
1479   84E0 FF FF FF FF 
1479   84E4 FF FF FF FF 
1479   84E8 FF FF FF FF 
1479   84EC FF FF FF FF 
1479   84F0 FF FF FF FF 
1479   84F4 FF FF FF FF 
1479   84F8 FF FF FF FF 
1479   84FC FF FF FF FF 
1479   8500 FF FF FF FF 
1479   8504 FF FF FF FF 
1479   8508 FF FF FF FF 
1479   850C FF FF FF FF 
1479   8510 FF FF FF FF 
1479   8514 FF FF FF FF 
1479   8518 FF FF FF FF 
1479   851C FF FF FF FF 
1479   8520 FF FF FF FF 
1479   8524 FF FF FF FF 
1479   8528 FF FF FF FF 
1479   852C FF FF FF FF 
1479   8530 FF FF FF FF 
1479   8534 FF FF FF FF 
1479   8538 FF FF FF FF 
1479   853C FF FF FF FF 
1479   8540 FF FF FF FF 
1479   8544 FF FF FF FF 
1479   8548 FF FF FF FF 
1479   854C FF FF FF FF 
1479   8550 FF FF FF FF 
1479   8554 FF FF FF FF 
1479   8558 FF FF FF FF 
1479   855C FF FF FF FF 
1479   8560 FF FF FF FF 
1479   8564 FF FF FF FF 
1479   8568 FF FF FF FF 
1479   856C FF FF FF FF 
1479   8570 FF FF FF FF 
1479   8574 FF FF FF FF 
1479   8578 FF FF FF FF 
1479   857C FF FF FF FF 
1479   8580 FF FF FF FF 
1479   8584 FF FF FF FF 
1479   8588 FF FF FF FF 
1479   858C FF FF FF FF 
1479   8590 FF FF FF FF 
1479   8594 FF FF FF FF 
1479   8598 FF FF FF FF 
1479   859C FF FF FF FF 
1479   85A0 FF FF FF FF 
1479   85A4 FF FF FF FF 
1479   85A8 FF FF FF FF 
1479   85AC FF FF FF FF 
1479   85B0 FF FF FF FF 
1479   85B4 FF FF FF FF 
1479   85B8 FF FF FF FF 
1479   85BC FF FF FF FF 
1479   85C0 FF FF FF FF 
1479   85C4 FF FF FF FF 
1479   85C8 FF FF FF FF 
1479   85CC FF FF FF FF 
1479   85D0 FF FF FF FF 
1479   85D4 FF FF FF FF 
1479   85D8 FF FF FF FF 
1479   85DC FF FF FF FF 
1479   85E0 FF FF FF FF 
1479   85E4 FF FF FF FF 
1479   85E8 FF FF FF FF 
1479   85EC FF FF FF FF 
1479   85F0 FF FF FF FF 
1479   85F4 FF FF FF FF 
1479   85F8 FF FF FF FF 
1479   85FC FF FF FF FF 
1479   8600 FF FF FF FF 
1479   8604 FF FF FF FF 
1479   8608 FF FF FF FF 
1479   860C FF FF FF FF 
1479   8610 FF FF FF FF 
1479   8614 FF FF FF FF 
1479   8618 FF FF FF FF 
1479   861C FF FF FF FF 
1479   8620 FF FF FF FF 
1479   8624 FF FF FF FF 
1479   8628 FF FF FF FF 
1479   862C FF FF FF FF 
1479   8630 FF FF FF FF 
1479   8634 FF FF FF FF 
1479   8638 FF FF FF FF 
1479   863C FF FF FF FF 
1479   8640 FF FF FF FF 
1479   8644 FF FF FF FF 
1479   8648 FF FF FF FF 
1479   864C FF FF FF FF 
1479   8650 FF FF FF FF 
1479   8654 FF FF FF FF 
1479   8658 FF FF FF FF 
1479   865C FF FF FF FF 
1479   8660 FF FF FF FF 
1479   8664 FF FF FF FF 
1479   8668 FF FF FF FF 
1479   866C FF FF FF FF 
1479   8670 FF FF FF FF 
1479   8674 FF FF FF FF 
1479   8678 FF FF FF FF 
1479   867C FF FF FF FF 
1479   8680 FF FF FF FF 
1479   8684 FF FF FF FF 
1479   8688 FF FF FF FF 
1479   868C FF FF FF FF 
1479   8690 FF FF FF FF 
1479   8694 FF FF FF FF 
1479   8698 FF FF FF FF 
1479   869C FF FF FF FF 
1479   86A0 FF FF FF FF 
1479   86A4 FF FF FF FF 
1479   86A8 FF FF FF FF 
1479   86AC FF FF FF FF 
1479   86B0 FF FF FF FF 
1479   86B4 FF FF FF FF 
1479   86B8 FF FF FF FF 
1479   86BC FF FF FF FF 
1479   86C0 FF FF FF FF 
1479   86C4 FF FF FF FF 
1479   86C8 FF FF FF FF 
1479   86CC FF FF FF FF 
1479   86D0 FF FF FF FF 
1479   86D4 FF FF FF FF 
1479   86D8 FF FF FF FF 
1479   86DC FF FF FF FF 
1479   86E0 FF FF FF FF 
1479   86E4 FF FF FF FF 
1479   86E8 FF FF FF FF 
1479   86EC FF FF FF FF 
1479   86F0 FF FF FF FF 
1479   86F4 FF FF FF FF 
1479   86F8 FF FF FF FF 
1479   86FC FF FF FF FF 
1479   8700 FF FF FF FF 
1479   8704 FF FF FF FF 
1479   8708 FF FF FF FF 
1479   870C FF FF FF FF 
1479   8710 FF FF FF FF 
1479   8714 FF FF FF FF 
1479   8718 FF FF FF FF 
1479   871C FF FF FF FF 
1479   8720 FF FF FF FF 
1479   8724 FF FF FF FF 
1479   8728 FF FF FF FF 
1479   872C FF FF FF FF 
1479   8730 FF FF FF FF 
1479   8734 FF FF FF FF 
1479   8738 FF FF FF FF 
1479   873C FF FF FF FF 
1479   8740 FF FF FF FF 
1479   8744 FF FF FF FF 
1479   8748 FF FF FF FF 
1479   874C FF FF FF FF 
1479   8750 FF FF FF FF 
1479   8754 FF FF FF FF 
1479   8758 FF FF FF FF 
1479   875C FF FF FF FF 
1479   8760 FF FF FF FF 
1479   8764 FF FF FF FF 
1479   8768 FF FF FF FF 
1479   876C FF FF FF FF 
1479   8770 FF FF FF FF 
1479   8774 FF FF FF FF 
1479   8778 FF FF FF FF 
1479   877C FF FF FF FF 
1479   8780 FF FF FF FF 
1479   8784 FF FF FF FF 
1479   8788 FF FF FF FF 
1479   878C FF FF FF FF 
1479   8790 FF FF FF FF 
1479   8794 FF FF FF FF 
1479   8798 FF FF FF FF 
1479   879C FF FF FF FF 
1479   87A0 FF FF FF FF 
1479   87A4 FF FF FF FF 
1479   87A8 FF FF FF FF 
1479   87AC FF FF FF FF 
1479   87B0 FF FF FF FF 
1479   87B4 FF FF FF FF 
1479   87B8 FF FF FF FF 
1479   87BC FF FF FF FF 
1479   87C0 FF FF FF FF 
1479   87C4 FF FF FF FF 
1479   87C8 FF FF FF FF 
1479   87CC FF FF FF FF 
1479   87D0 FF FF FF FF 
1479   87D4 FF FF FF FF 
1479   87D8 FF FF FF FF 
1479   87DC FF FF FF FF 
1479   87E0 FF FF FF FF 
1479   87E4 FF FF FF FF 
1479   87E8 FF FF FF FF 
1479   87EC FF FF FF FF 
1479   87F0 FF FF FF FF 
1479   87F4 FF FF FF FF 
1479   87F8 FF FF FF FF 
1479   87FC FF FF FF FF 
1479   8800 FF FF FF FF 
1479   8804 FF FF FF FF 
1479   8808 FF FF FF FF 
1479   880C FF FF FF FF 
1479   8810 FF FF FF FF 
1479   8814 FF FF FF FF 
1479   8818 FF FF FF FF 
1479   881C FF FF FF FF 
1479   8820 FF FF FF FF 
1479   8824 FF FF FF FF 
1479   8828 FF FF FF FF 
1479   882C FF FF FF FF 
1479   8830 FF FF FF FF 
1479   8834 FF FF FF FF 
1479   8838 FF FF FF FF 
1479   883C FF FF FF FF 
1479   8840 FF FF FF FF 
1479   8844 FF FF FF FF 
1479   8848 FF FF FF FF 
1479   884C FF FF FF FF 
1479   8850 FF FF FF FF 
1479   8854 FF FF FF FF 
1479   8858 FF FF FF FF 
1479   885C FF FF FF FF 
1479   8860 FF FF FF FF 
1479   8864 FF FF FF FF 
1479   8868 FF FF FF FF 
1479   886C FF FF FF FF 
1479   8870 FF FF FF FF 
1479   8874 FF FF FF FF 
1479   8878 FF FF FF FF 
1479   887C FF FF FF FF 
1479   8880 FF FF FF FF 
1479   8884 FF FF FF FF 
1479   8888 FF FF FF FF 
1479   888C FF FF FF FF 
1479   8890 FF FF FF FF 
1479   8894 FF FF FF FF 
1479   8898 FF FF FF FF 
1479   889C FF FF FF FF 
1479   88A0 FF FF FF FF 
1479   88A4 FF FF FF FF 
1479   88A8 FF FF FF FF 
1479   88AC FF FF FF FF 
1479   88B0 FF FF FF FF 
1479   88B4 FF FF FF FF 
1479   88B8 FF FF FF FF 
1479   88BC FF FF FF FF 
1479   88C0 FF FF FF FF 
1479   88C4 FF FF FF FF 
1479   88C8 FF FF FF FF 
1479   88CC FF FF FF FF 
1479   88D0 FF FF FF FF 
1479   88D4 FF FF FF FF 
1479   88D8 FF FF FF FF 
1479   88DC FF FF FF FF 
1479   88E0 FF FF FF FF 
1479   88E4 FF FF FF FF 
1479   88E8 FF FF FF FF 
1479   88EC FF FF FF FF 
1479   88F0 FF FF FF FF 
1479   88F4 FF FF FF FF 
1479   88F8 FF FF FF FF 
1479   88FC FF FF FF FF 
1479   8900 FF FF FF FF 
1479   8904 FF FF FF FF 
1479   8908 FF FF FF FF 
1479   890C FF FF FF FF 
1479   8910 FF FF FF FF 
1479   8914 FF FF FF FF 
1479   8918 FF FF FF FF 
1479   891C FF FF FF FF 
1479   8920 FF FF FF FF 
1479   8924 FF FF FF FF 
1479   8928 FF FF FF FF 
1479   892C FF FF FF FF 
1479   8930 FF FF FF FF 
1479   8934 FF FF FF FF 
1479   8938 FF FF FF FF 
1479   893C FF FF FF FF 
1479   8940 FF FF FF FF 
1479   8944 FF FF FF FF 
1479   8948 FF FF FF FF 
1479   894C FF FF FF FF 
1479   8950 FF FF FF FF 
1479   8954 FF FF FF FF 
1479   8958 FF FF FF FF 
1479   895C FF FF FF FF 
1479   8960 FF FF FF FF 
1479   8964 FF FF FF FF 
1479   8968 FF FF FF FF 
1479   896C FF FF FF FF 
1479   8970 FF FF FF FF 
1479   8974 FF FF FF FF 
1479   8978 FF FF FF FF 
1479   897C FF FF FF FF 
1479   8980 FF FF FF FF 
1479   8984 FF FF FF FF 
1479   8988 FF FF FF FF 
1479   898C FF FF FF FF 
1479   8990 FF FF FF FF 
1479   8994 FF FF FF FF 
1479   8998 FF FF FF FF 
1479   899C FF FF FF FF 
1479   89A0 FF FF FF FF 
1479   89A4 FF FF FF FF 
1479   89A8 FF FF FF FF 
1479   89AC FF FF FF FF 
1479   89B0 FF FF FF FF 
1479   89B4 FF FF FF FF 
1479   89B8 FF FF FF FF 
1479   89BC FF FF FF FF 
1479   89C0 FF FF FF FF 
1479   89C4 FF FF FF FF 
1479   89C8 FF FF FF FF 
1479   89CC FF FF FF FF 
1479   89D0 FF FF FF FF 
1479   89D4 FF FF FF FF 
1479   89D8 FF FF FF FF 
1479   89DC FF FF FF FF 
1479   89E0 FF FF FF FF 
1479   89E4 FF FF FF FF 
1479   89E8 FF FF FF FF 
1479   89EC FF FF FF FF 
1479   89F0 FF FF FF FF 
1479   89F4 FF FF FF FF 
1479   89F8 FF FF FF FF 
1479   89FC FF FF FF FF 
1479   8A00 FF FF FF FF 
1479   8A04 FF FF FF FF 
1479   8A08 FF FF FF FF 
1479   8A0C FF FF FF FF 
1479   8A10 FF FF FF FF 
1479   8A14 FF FF FF FF 
1479   8A18 FF FF FF FF 
1479   8A1C FF FF FF FF 
1479   8A20 FF FF FF FF 
1479   8A24 FF FF FF FF 
1479   8A28 FF FF FF FF 
1479   8A2C FF FF FF FF 
1479   8A30 FF FF FF FF 
1479   8A34 FF FF FF FF 
1479   8A38 FF FF FF FF 
1479   8A3C FF FF FF FF 
1479   8A40 FF FF FF FF 
1479   8A44 FF FF FF FF 
1479   8A48 FF FF FF FF 
1479   8A4C FF FF FF FF 
1479   8A50 FF FF FF FF 
1479   8A54 FF FF FF FF 
1479   8A58 FF FF FF FF 
1479   8A5C FF FF FF FF 
1479   8A60 FF FF FF FF 
1479   8A64 FF FF FF FF 
1479   8A68 FF FF FF FF 
1479   8A6C FF FF FF FF 
1479   8A70 FF FF FF FF 
1479   8A74 FF FF FF FF 
1479   8A78 FF FF FF FF 
1479   8A7C FF FF FF FF 
1479   8A80 FF FF FF FF 
1479   8A84 FF FF FF FF 
1479   8A88 FF FF FF FF 
1479   8A8C FF FF FF FF 
1479   8A90 FF FF FF FF 
1479   8A94 FF FF FF FF 
1479   8A98 FF FF FF FF 
1479   8A9C FF FF FF FF 
1479   8AA0 FF FF FF FF 
1479   8AA4 FF FF FF FF 
1479   8AA8 FF FF FF FF 
1479   8AAC FF FF FF FF 
1479   8AB0 FF FF FF FF 
1479   8AB4 FF FF FF FF 
1479   8AB8 FF FF FF FF 
1479   8ABC FF FF FF FF 
1479   8AC0 FF FF FF FF 
1479   8AC4 FF FF FF FF 
1479   8AC8 FF FF FF FF 
1479   8ACC FF FF FF FF 
1479   8AD0 FF FF FF FF 
1479   8AD4 FF FF FF FF 
1479   8AD8 FF FF FF FF 
1479   8ADC FF FF FF FF 
1479   8AE0 FF FF FF FF 
1479   8AE4 FF FF FF FF 
1479   8AE8 FF FF FF FF 
1479   8AEC FF FF FF FF 
1479   8AF0 FF FF FF FF 
1479   8AF4 FF FF FF FF 
1479   8AF8 FF FF FF FF 
1479   8AFC FF FF FF FF 
1479   8B00 FF FF FF FF 
1479   8B04 FF FF FF FF 
1479   8B08 FF FF FF FF 
1479   8B0C FF FF FF FF 
1479   8B10 FF FF FF FF 
1479   8B14 FF FF FF FF 
1479   8B18 FF FF FF FF 
1479   8B1C FF FF FF FF 
1479   8B20 FF FF FF FF 
1479   8B24 FF FF FF FF 
1479   8B28 FF FF FF FF 
1479   8B2C FF FF FF FF 
1479   8B30 FF FF FF FF 
1479   8B34 FF FF FF FF 
1479   8B38 FF FF FF FF 
1479   8B3C FF FF FF FF 
1479   8B40 FF FF FF FF 
1479   8B44 FF FF FF FF 
1479   8B48 FF FF FF FF 
1479   8B4C FF FF FF FF 
1479   8B50 FF FF FF FF 
1479   8B54 FF FF FF FF 
1479   8B58 FF FF FF FF 
1479   8B5C FF FF FF FF 
1479   8B60 FF FF FF FF 
1479   8B64 FF FF FF FF 
1479   8B68 FF FF FF FF 
1479   8B6C FF FF FF FF 
1479   8B70 FF FF FF FF 
1479   8B74 FF FF FF FF 
1479   8B78 FF FF FF FF 
1479   8B7C FF FF FF FF 
1479   8B80 FF FF FF FF 
1479   8B84 FF FF FF FF 
1479   8B88 FF FF FF FF 
1479   8B8C FF FF FF FF 
1479   8B90 FF FF FF FF 
1479   8B94 FF FF FF FF 
1479   8B98 FF FF FF FF 
1479   8B9C FF FF FF FF 
1479   8BA0 FF FF FF FF 
1479   8BA4 FF FF FF FF 
1479   8BA8 FF FF FF FF 
1479   8BAC FF FF FF FF 
1479   8BB0 FF FF FF FF 
1479   8BB4 FF FF FF FF 
1479   8BB8 FF FF FF FF 
1479   8BBC FF FF FF FF 
1479   8BC0 FF FF FF FF 
1479   8BC4 FF FF FF FF 
1479   8BC8 FF FF FF FF 
1479   8BCC FF FF FF FF 
1479   8BD0 FF FF FF FF 
1479   8BD4 FF FF FF FF 
1479   8BD8 FF FF FF FF 
1479   8BDC FF FF FF FF 
1479   8BE0 FF FF FF FF 
1479   8BE4 FF FF FF FF 
1479   8BE8 FF FF FF FF 
1479   8BEC FF FF FF FF 
1479   8BF0 FF FF FF FF 
1479   8BF4 FF FF FF FF 
1479   8BF8 FF FF FF FF 
1479   8BFC FF FF FF FF 
1479   8C00 FF FF FF FF 
1479   8C04 FF FF FF FF 
1479   8C08 FF FF FF FF 
1479   8C0C FF FF FF FF 
1479   8C10 FF FF FF FF 
1479   8C14 FF FF FF FF 
1479   8C18 FF FF FF FF 
1479   8C1C FF FF FF FF 
1479   8C20 FF FF FF FF 
1479   8C24 FF FF FF FF 
1479   8C28 FF FF FF FF 
1479   8C2C FF FF FF FF 
1479   8C30 FF FF FF FF 
1479   8C34 FF FF FF FF 
1479   8C38 FF FF FF FF 
1479   8C3C FF FF FF FF 
1479   8C40 FF FF FF FF 
1479   8C44 FF FF FF FF 
1479   8C48 FF FF FF FF 
1479   8C4C FF FF FF FF 
1479   8C50 FF FF FF FF 
1479   8C54 FF FF FF FF 
1479   8C58 FF FF FF FF 
1479   8C5C FF FF FF FF 
1479   8C60 FF FF FF FF 
1479   8C64 FF FF FF FF 
1479   8C68 FF FF FF FF 
1479   8C6C FF FF FF FF 
1479   8C70 FF FF FF FF 
1479   8C74 FF FF FF FF 
1479   8C78 FF FF FF FF 
1479   8C7C FF FF FF FF 
1479   8C80 FF FF FF FF 
1479   8C84 FF FF FF FF 
1479   8C88 FF FF FF FF 
1479   8C8C FF FF FF FF 
1479   8C90 FF FF FF FF 
1479   8C94 FF FF FF FF 
1479   8C98 FF FF FF FF 
1479   8C9C FF FF FF FF 
1479   8CA0 FF FF FF FF 
1479   8CA4 FF FF FF FF 
1479   8CA8 FF FF FF FF 
1479   8CAC FF FF FF FF 
1479   8CB0 FF FF FF FF 
1479   8CB4 FF FF FF FF 
1479   8CB8 FF FF FF FF 
1479   8CBC FF FF FF FF 
1479   8CC0 FF FF FF FF 
1479   8CC4 FF FF FF FF 
1479   8CC8 FF FF FF FF 
1479   8CCC FF FF FF FF 
1479   8CD0 FF FF FF FF 
1479   8CD4 FF FF FF FF 
1479   8CD8 FF FF FF FF 
1479   8CDC FF FF FF FF 
1479   8CE0 FF FF FF FF 
1479   8CE4 FF FF FF FF 
1479   8CE8 FF FF FF FF 
1479   8CEC FF FF FF FF 
1479   8CF0 FF FF FF FF 
1479   8CF4 FF FF FF FF 
1479   8CF8 FF FF FF FF 
1479   8CFC FF FF FF FF 
1479   8D00 FF FF FF FF 
1479   8D04 FF FF FF FF 
1479   8D08 FF FF FF FF 
1479   8D0C FF FF FF FF 
1479   8D10 FF FF FF FF 
1479   8D14 FF FF FF FF 
1479   8D18 FF FF FF FF 
1479   8D1C FF FF FF FF 
1479   8D20 FF FF FF FF 
1479   8D24 FF FF FF FF 
1479   8D28 FF FF FF FF 
1479   8D2C FF FF FF FF 
1479   8D30 FF FF FF FF 
1479   8D34 FF FF FF FF 
1479   8D38 FF FF FF FF 
1479   8D3C FF FF FF FF 
1479   8D40 FF FF FF FF 
1479   8D44 FF FF FF FF 
1479   8D48 FF FF FF FF 
1479   8D4C FF FF FF FF 
1479   8D50 FF FF FF FF 
1479   8D54 FF FF FF FF 
1479   8D58 FF FF FF FF 
1479   8D5C FF FF FF FF 
1479   8D60 FF FF FF FF 
1479   8D64 FF FF FF FF 
1479   8D68 FF FF FF FF 
1479   8D6C FF FF FF FF 
1479   8D70 FF FF FF FF 
1479   8D74 FF FF FF FF 
1479   8D78 FF FF FF FF 
1479   8D7C FF FF FF FF 
1479   8D80 FF FF FF FF 
1479   8D84 FF FF FF FF 
1479   8D88 FF FF FF FF 
1479   8D8C FF FF FF FF 
1479   8D90 FF FF FF FF 
1479   8D94 FF FF FF FF 
1479   8D98 FF FF FF FF 
1479   8D9C FF FF FF FF 
1479   8DA0 FF FF FF FF 
1479   8DA4 FF FF FF FF 
1479   8DA8 FF FF FF FF 
1479   8DAC FF FF FF FF 
1479   8DB0 FF FF FF FF 
1479   8DB4 FF FF FF FF 
1479   8DB8 FF FF FF FF 
1479   8DBC FF FF FF FF 
1479   8DC0 FF FF FF FF 
1479   8DC4 FF FF FF FF 
1479   8DC8 FF FF FF FF 
1479   8DCC FF FF FF FF 
1479   8DD0 FF FF FF FF 
1479   8DD4 FF FF FF FF 
1479   8DD8 FF FF FF FF 
1479   8DDC FF FF FF FF 
1479   8DE0 FF FF FF FF 
1479   8DE4 FF FF FF FF 
1479   8DE8 FF FF FF FF 
1479   8DEC FF FF FF FF 
1479   8DF0 FF FF FF FF 
1479   8DF4 FF FF FF FF 
1479   8DF8 FF FF FF FF 
1479   8DFC FF FF FF FF 
1479   8E00 FF FF FF FF 
1479   8E04 FF FF FF FF 
1479   8E08 FF FF FF FF 
1479   8E0C FF FF FF FF 
1479   8E10 FF FF FF FF 
1479   8E14 FF FF FF FF 
1479   8E18 FF FF FF FF 
1479   8E1C FF FF FF FF 
1479   8E20 FF FF FF FF 
1479   8E24 FF FF FF FF 
1479   8E28 FF FF FF FF 
1479   8E2C FF FF FF FF 
1479   8E30 FF FF FF FF 
1479   8E34 FF FF FF FF 
1479   8E38 FF FF FF FF 
1479   8E3C FF FF FF FF 
1479   8E40 FF FF FF FF 
1479   8E44 FF FF FF FF 
1479   8E48 FF FF FF FF 
1479   8E4C FF FF FF FF 
1479   8E50 FF FF FF FF 
1479   8E54 FF FF FF FF 
1479   8E58 FF FF FF FF 
1479   8E5C FF FF FF FF 
1479   8E60 FF FF FF FF 
1479   8E64 FF FF FF FF 
1479   8E68 FF FF FF FF 
1479   8E6C FF FF FF FF 
1479   8E70 FF FF FF FF 
1479   8E74 FF FF FF FF 
1479   8E78 FF FF FF FF 
1479   8E7C FF FF FF FF 
1479   8E80 FF FF FF FF 
1479   8E84 FF FF FF FF 
1479   8E88 FF FF FF FF 
1479   8E8C FF FF FF FF 
1479   8E90 FF FF FF FF 
1479   8E94 FF FF FF FF 
1479   8E98 FF FF FF FF 
1479   8E9C FF FF FF FF 
1479   8EA0 FF FF FF FF 
1479   8EA4 FF FF FF FF 
1479   8EA8 FF FF FF FF 
1479   8EAC FF FF FF FF 
1479   8EB0 FF FF FF FF 
1479   8EB4 FF FF FF FF 
1479   8EB8 FF FF FF FF 
1479   8EBC FF FF FF FF 
1479   8EC0 FF FF FF FF 
1479   8EC4 FF FF FF FF 
1479   8EC8 FF FF FF FF 
1479   8ECC FF FF FF FF 
1479   8ED0 FF FF FF FF 
1479   8ED4 FF FF FF FF 
1479   8ED8 FF FF FF FF 
1479   8EDC FF FF FF FF 
1479   8EE0 FF FF FF FF 
1479   8EE4 FF FF FF FF 
1479   8EE8 FF FF FF FF 
1479   8EEC FF FF FF FF 
1479   8EF0 FF FF FF FF 
1479   8EF4 FF FF FF FF 
1479   8EF8 FF FF FF FF 
1479   8EFC FF FF FF FF 
1479   8F00 FF FF FF FF 
1479   8F04 FF FF FF FF 
1479   8F08 FF FF FF FF 
1479   8F0C FF FF FF FF 
1479   8F10 FF FF FF FF 
1479   8F14 FF FF FF FF 
1479   8F18 FF FF FF FF 
1479   8F1C FF FF FF FF 
1479   8F20 FF FF FF FF 
1479   8F24 FF FF FF FF 
1479   8F28 FF FF FF FF 
1479   8F2C FF FF FF FF 
1479   8F30 FF FF FF FF 
1479   8F34 FF FF FF FF 
1479   8F38 FF FF FF FF 
1479   8F3C FF FF FF FF 
1479   8F40 FF FF FF FF 
1479   8F44 FF FF FF FF 
1479   8F48 FF FF FF FF 
1479   8F4C FF FF FF FF 
1479   8F50 FF FF FF FF 
1479   8F54 FF FF FF FF 
1479   8F58 FF FF FF FF 
1479   8F5C FF FF FF FF 
1479   8F60 FF FF FF FF 
1479   8F64 FF FF FF FF 
1479   8F68 FF FF FF FF 
1479   8F6C FF FF FF FF 
1479   8F70 FF FF FF FF 
1479   8F74 FF FF FF FF 
1479   8F78 FF FF FF FF 
1479   8F7C FF FF FF FF 
1479   8F80 FF FF FF FF 
1479   8F84 FF FF FF FF 
1479   8F88 FF FF FF FF 
1479   8F8C FF FF FF FF 
1479   8F90 FF FF FF FF 
1479   8F94 FF FF FF FF 
1479   8F98 FF FF FF FF 
1479   8F9C FF FF FF FF 
1479   8FA0 FF FF FF FF 
1479   8FA4 FF FF FF FF 
1479   8FA8 FF FF FF FF 
1479   8FAC FF FF FF FF 
1479   8FB0 FF FF FF FF 
1479   8FB4 FF FF FF FF 
1479   8FB8 FF FF FF FF 
1479   8FBC FF FF FF FF 
1479   8FC0 FF FF FF FF 
1479   8FC4 FF FF FF FF 
1479   8FC8 FF FF FF FF 
1479   8FCC FF FF FF FF 
1479   8FD0 FF FF FF FF 
1479   8FD4 FF FF FF FF 
1479   8FD8 FF FF FF FF 
1479   8FDC FF FF FF FF 
1479   8FE0 FF FF FF FF 
1479   8FE4 FF FF FF FF 
1479   8FE8 FF FF FF FF 
1479   8FEC FF FF FF FF 
1479   8FF0 FF FF FF FF 
1479   8FF4 FF FF FF FF 
1479   8FF8 FF FF FF FF 
1479   8FFC FF FF FF FF 
1479   9000 FF FF FF FF 
1479   9004 FF FF FF FF 
1479   9008 FF FF FF FF 
1479   900C FF FF FF FF 
1479   9010 FF FF FF FF 
1479   9014 FF FF FF FF 
1479   9018 FF FF FF FF 
1479   901C FF FF FF FF 
1479   9020 FF FF FF FF 
1479   9024 FF FF FF FF 
1479   9028 FF FF FF FF 
1479   902C FF FF FF FF 
1479   9030 FF FF FF FF 
1479   9034 FF FF FF FF 
1479   9038 FF FF FF FF 
1479   903C FF FF FF FF 
1479   9040 FF FF FF FF 
1479   9044 FF FF FF FF 
1479   9048 FF FF FF FF 
1479   904C FF FF FF FF 
1479   9050 FF FF FF FF 
1479   9054 FF FF FF FF 
1479   9058 FF FF FF FF 
1479   905C FF FF FF FF 
1479   9060 FF FF FF FF 
1479   9064 FF FF FF FF 
1479   9068 FF FF FF FF 
1479   906C FF FF FF FF 
1479   9070 FF FF FF FF 
1479   9074 FF FF FF FF 
1479   9078 FF FF FF FF 
1479   907C FF FF FF FF 
1479   9080 FF FF FF FF 
1479   9084 FF FF FF FF 
1479   9088 FF FF FF FF 
1479   908C FF FF FF FF 
1479   9090 FF FF FF FF 
1479   9094 FF FF FF FF 
1479   9098 FF FF FF FF 
1479   909C FF FF FF FF 
1479   90A0 FF FF FF FF 
1479   90A4 FF FF FF FF 
1479   90A8 FF FF FF FF 
1479   90AC FF FF FF FF 
1479   90B0 FF FF FF FF 
1479   90B4 FF FF FF FF 
1479   90B8 FF FF FF FF 
1479   90BC FF FF FF FF 
1479   90C0 FF FF FF FF 
1479   90C4 FF FF FF FF 
1479   90C8 FF FF FF FF 
1479   90CC FF FF FF FF 
1479   90D0 FF FF FF FF 
1479   90D4 FF FF FF FF 
1479   90D8 FF FF FF FF 
1479   90DC FF FF FF FF 
1479   90E0 FF FF FF FF 
1479   90E4 FF FF FF FF 
1479   90E8 FF FF FF FF 
1479   90EC FF FF FF FF 
1479   90F0 FF FF FF FF 
1479   90F4 FF FF FF FF 
1479   90F8 FF FF FF FF 
1479   90FC FF FF FF FF 
1479   9100 FF FF FF FF 
1479   9104 FF FF FF FF 
1479   9108 FF FF FF FF 
1479   910C FF FF FF FF 
1479   9110 FF FF FF FF 
1479   9114 FF FF FF FF 
1479   9118 FF FF FF FF 
1479   911C FF FF FF FF 
1479   9120 FF FF FF FF 
1479   9124 FF FF FF FF 
1479   9128 FF FF FF FF 
1479   912C FF FF FF FF 
1479   9130 FF FF FF FF 
1479   9134 FF FF FF FF 
1479   9138 FF FF FF FF 
1479   913C FF FF FF FF 
1479   9140 FF FF FF FF 
1479   9144 FF FF FF FF 
1479   9148 FF FF FF FF 
1479   914C FF FF FF FF 
1479   9150 FF FF FF FF 
1479   9154 FF FF FF FF 
1479   9158 FF FF FF FF 
1479   915C FF FF FF FF 
1479   9160 FF FF FF FF 
1479   9164 FF FF FF FF 
1479   9168 FF FF FF FF 
1479   916C FF FF FF FF 
1479   9170 FF FF FF FF 
1479   9174 FF FF FF FF 
1479   9178 FF FF FF FF 
1479   917C FF FF FF FF 
1479   9180 FF FF FF FF 
1479   9184 FF FF FF FF 
1479   9188 FF FF FF FF 
1479   918C FF FF FF FF 
1479   9190 FF FF FF FF 
1479   9194 FF FF FF FF 
1479   9198 FF FF FF FF 
1479   919C FF FF FF FF 
1479   91A0 FF FF FF FF 
1479   91A4 FF FF FF FF 
1479   91A8 FF FF FF FF 
1479   91AC FF FF FF FF 
1479   91B0 FF FF FF FF 
1479   91B4 FF FF FF FF 
1479   91B8 FF FF FF FF 
1479   91BC FF FF FF FF 
1479   91C0 FF FF FF FF 
1479   91C4 FF FF FF FF 
1479   91C8 FF FF FF FF 
1479   91CC FF FF FF FF 
1479   91D0 FF FF FF FF 
1479   91D4 FF FF FF FF 
1479   91D8 FF FF FF FF 
1479   91DC FF FF FF FF 
1479   91E0 FF FF FF FF 
1479   91E4 FF FF FF FF 
1479   91E8 FF FF FF FF 
1479   91EC FF FF FF FF 
1479   91F0 FF FF FF FF 
1479   91F4 FF FF FF FF 
1479   91F8 FF FF FF FF 
1479   91FC FF FF FF FF 
1479   9200 FF FF FF FF 
1479   9204 FF FF FF FF 
1479   9208 FF FF FF FF 
1479   920C FF FF FF FF 
1479   9210 FF FF FF FF 
1479   9214 FF FF FF FF 
1479   9218 FF FF FF FF 
1479   921C FF FF FF FF 
1479   9220 FF FF FF FF 
1479   9224 FF FF FF FF 
1479   9228 FF FF FF FF 
1479   922C FF FF FF FF 
1479   9230 FF FF FF FF 
1479   9234 FF FF FF FF 
1479   9238 FF FF FF FF 
1479   923C FF FF FF FF 
1479   9240 FF FF FF FF 
1479   9244 FF FF FF FF 
1479   9248 FF FF FF FF 
1479   924C FF FF FF FF 
1479   9250 FF FF FF FF 
1479   9254 FF FF FF FF 
1479   9258 FF FF FF FF 
1479   925C FF FF FF FF 
1479   9260 FF FF FF FF 
1479   9264 FF FF FF FF 
1479   9268 FF FF FF FF 
1479   926C FF FF FF FF 
1479   9270 FF FF FF FF 
1479   9274 FF FF FF FF 
1479   9278 FF FF FF FF 
1479   927C FF FF FF FF 
1479   9280 FF FF FF FF 
1479   9284 FF FF FF FF 
1479   9288 FF FF FF FF 
1479   928C FF FF FF FF 
1479   9290 FF FF FF FF 
1479   9294 FF FF FF FF 
1479   9298 FF FF FF FF 
1479   929C FF FF FF FF 
1479   92A0 FF FF FF FF 
1479   92A4 FF FF FF FF 
1479   92A8 FF FF FF FF 
1479   92AC FF FF FF FF 
1479   92B0 FF FF FF FF 
1479   92B4 FF FF FF FF 
1479   92B8 FF FF FF FF 
1479   92BC FF FF FF FF 
1479   92C0 FF FF FF FF 
1479   92C4 FF FF FF FF 
1479   92C8 FF FF FF FF 
1479   92CC FF FF FF FF 
1479   92D0 FF FF FF FF 
1479   92D4 FF FF FF FF 
1479   92D8 FF FF FF FF 
1479   92DC FF FF FF FF 
1479   92E0 FF FF FF FF 
1479   92E4 FF FF FF FF 
1479   92E8 FF FF FF FF 
1479   92EC FF FF FF FF 
1479   92F0 FF FF FF FF 
1479   92F4 FF FF FF FF 
1479   92F8 FF FF FF FF 
1479   92FC FF FF FF FF 
1479   9300 FF FF FF FF 
1479   9304 FF FF FF FF 
1479   9308 FF FF FF FF 
1479   930C FF FF FF FF 
1479   9310 FF FF FF FF 
1479   9314 FF FF FF FF 
1479   9318 FF FF FF FF 
1479   931C FF FF FF FF 
1479   9320 FF FF FF FF 
1479   9324 FF FF FF FF 
1479   9328 FF FF FF FF 
1479   932C FF FF FF FF 
1479   9330 FF FF FF FF 
1479   9334 FF FF FF FF 
1479   9338 FF FF FF FF 
1479   933C FF FF FF FF 
1479   9340 FF FF FF FF 
1479   9344 FF FF FF FF 
1479   9348 FF FF FF FF 
1479   934C FF FF FF FF 
1479   9350 FF FF FF FF 
1479   9354 FF FF FF FF 
1479   9358 FF FF FF FF 
1479   935C FF FF FF FF 
1479   9360 FF FF FF FF 
1479   9364 FF FF FF FF 
1479   9368 FF FF FF FF 
1479   936C FF FF FF FF 
1479   9370 FF FF FF FF 
1479   9374 FF FF FF FF 
1479   9378 FF FF FF FF 
1479   937C FF FF FF FF 
1479   9380 FF FF FF FF 
1479   9384 FF FF FF FF 
1479   9388 FF FF FF FF 
1479   938C FF FF FF FF 
1479   9390 FF FF FF FF 
1479   9394 FF FF FF FF 
1479   9398 FF FF FF FF 
1479   939C FF FF FF FF 
1479   93A0 FF FF FF FF 
1479   93A4 FF FF FF FF 
1479   93A8 FF FF FF FF 
1479   93AC FF FF FF FF 
1479   93B0 FF FF FF FF 
1479   93B4 FF FF FF FF 
1479   93B8 FF FF FF FF 
1479   93BC FF FF FF FF 
1479   93C0 FF FF FF FF 
1479   93C4 FF FF FF FF 
1479   93C8 FF FF FF FF 
1479   93CC FF FF FF FF 
1479   93D0 FF FF FF FF 
1479   93D4 FF FF FF FF 
1479   93D8 FF FF FF FF 
1479   93DC FF FF FF FF 
1479   93E0 FF FF FF FF 
1479   93E4 FF FF FF FF 
1479   93E8 FF FF FF FF 
1479   93EC FF FF FF FF 
1479   93F0 FF FF FF FF 
1479   93F4 FF FF FF FF 
1479   93F8 FF FF FF FF 
1479   93FC FF FF FF FF 
1479   9400 FF FF FF FF 
1479   9404 FF FF FF FF 
1479   9408 FF FF FF FF 
1479   940C FF FF FF FF 
1479   9410 FF FF FF FF 
1479   9414 FF FF FF FF 
1479   9418 FF FF FF FF 
1479   941C FF FF FF FF 
1479   9420 FF FF FF FF 
1479   9424 FF FF FF FF 
1479   9428 FF FF FF FF 
1479   942C FF FF FF FF 
1479   9430 FF FF FF FF 
1479   9434 FF FF FF FF 
1479   9438 FF FF FF FF 
1479   943C FF FF FF FF 
1479   9440 FF FF FF FF 
1479   9444 FF FF FF FF 
1479   9448 FF FF FF FF 
1479   944C FF FF FF FF 
1479   9450 FF FF FF FF 
1479   9454 FF FF FF FF 
1479   9458 FF FF FF FF 
1479   945C FF FF FF FF 
1479   9460 FF FF FF FF 
1479   9464 FF FF FF FF 
1479   9468 FF FF FF FF 
1479   946C FF FF FF FF 
1479   9470 FF FF FF FF 
1479   9474 FF FF FF FF 
1479   9478 FF FF FF FF 
1479   947C FF FF FF FF 
1479   9480 FF FF FF FF 
1479   9484 FF FF FF FF 
1479   9488 FF FF FF FF 
1479   948C FF FF FF FF 
1479   9490 FF FF FF FF 
1479   9494 FF FF FF FF 
1479   9498 FF FF FF FF 
1479   949C FF FF FF FF 
1479   94A0 FF FF FF FF 
1479   94A4 FF FF FF FF 
1479   94A8 FF FF FF FF 
1479   94AC FF FF FF FF 
1479   94B0 FF FF FF FF 
1479   94B4 FF FF FF FF 
1479   94B8 FF FF FF FF 
1479   94BC FF FF FF FF 
1479   94C0 FF FF FF FF 
1479   94C4 FF FF FF FF 
1479   94C8 FF FF FF FF 
1479   94CC FF FF FF FF 
1479   94D0 FF FF FF FF 
1479   94D4 FF FF FF FF 
1479   94D8 FF FF FF FF 
1479   94DC FF FF FF FF 
1479   94E0 FF FF FF FF 
1479   94E4 FF FF FF FF 
1479   94E8 FF FF FF FF 
1479   94EC FF FF FF FF 
1479   94F0 FF FF FF FF 
1479   94F4 FF FF FF FF 
1479   94F8 FF FF FF FF 
1479   94FC FF FF FF FF 
1479   9500 FF FF FF FF 
1479   9504 FF FF FF FF 
1479   9508 FF FF FF FF 
1479   950C FF FF FF FF 
1479   9510 FF FF FF FF 
1479   9514 FF FF FF FF 
1479   9518 FF FF FF FF 
1479   951C FF FF FF FF 
1479   9520 FF FF FF FF 
1479   9524 FF FF FF FF 
1479   9528 FF FF FF FF 
1479   952C FF FF FF FF 
1479   9530 FF FF FF FF 
1479   9534 FF FF FF FF 
1479   9538 FF FF FF FF 
1479   953C FF FF FF FF 
1479   9540 FF FF FF FF 
1479   9544 FF FF FF FF 
1479   9548 FF FF FF FF 
1479   954C FF FF FF FF 
1479   9550 FF FF FF FF 
1479   9554 FF FF FF FF 
1479   9558 FF FF FF FF 
1479   955C FF FF FF FF 
1479   9560 FF FF FF FF 
1479   9564 FF FF FF FF 
1479   9568 FF FF FF FF 
1479   956C FF FF FF FF 
1479   9570 FF FF FF FF 
1479   9574 FF FF FF FF 
1479   9578 FF FF FF FF 
1479   957C FF FF FF FF 
1479   9580 FF FF FF FF 
1479   9584 FF FF FF FF 
1479   9588 FF FF FF FF 
1479   958C FF FF FF FF 
1479   9590 FF FF FF FF 
1479   9594 FF FF FF FF 
1479   9598 FF FF FF FF 
1479   959C FF FF FF FF 
1479   95A0 FF FF FF FF 
1479   95A4 FF FF FF FF 
1479   95A8 FF FF FF FF 
1479   95AC FF FF FF FF 
1479   95B0 FF FF FF FF 
1479   95B4 FF FF FF FF 
1479   95B8 FF FF FF FF 
1479   95BC FF FF FF FF 
1479   95C0 FF FF FF FF 
1479   95C4 FF FF FF FF 
1479   95C8 FF FF FF FF 
1479   95CC FF FF FF FF 
1479   95D0 FF FF FF FF 
1479   95D4 FF FF FF FF 
1479   95D8 FF FF FF FF 
1479   95DC FF FF FF FF 
1479   95E0 FF FF FF FF 
1479   95E4 FF FF FF FF 
1479   95E8 FF FF FF FF 
1479   95EC FF FF FF FF 
1479   95F0 FF FF FF FF 
1479   95F4 FF FF FF FF 
1479   95F8 FF FF FF FF 
1479   95FC FF FF FF FF 
1479   9600 FF FF FF FF 
1479   9604 FF FF FF FF 
1479   9608 FF FF FF FF 
1479   960C FF FF FF FF 
1479   9610 FF FF FF FF 
1479   9614 FF FF FF FF 
1479   9618 FF FF FF FF 
1479   961C FF FF FF FF 
1479   9620 FF FF FF FF 
1479   9624 FF FF FF FF 
1479   9628 FF FF FF FF 
1479   962C FF FF FF FF 
1479   9630 FF FF FF FF 
1479   9634 FF FF FF FF 
1479   9638 FF FF FF FF 
1479   963C FF FF FF FF 
1479   9640 FF FF FF FF 
1479   9644 FF FF FF FF 
1479   9648 FF FF FF FF 
1479   964C FF FF FF FF 
1479   9650 FF FF FF FF 
1479   9654 FF FF FF FF 
1479   9658 FF FF FF FF 
1479   965C FF FF FF FF 
1479   9660 FF FF FF FF 
1479   9664 FF FF FF FF 
1479   9668 FF FF FF FF 
1479   966C FF FF FF FF 
1479   9670 FF FF FF FF 
1479   9674 FF FF FF FF 
1479   9678 FF FF FF FF 
1479   967C FF FF FF FF 
1479   9680 FF FF FF FF 
1479   9684 FF FF FF FF 
1479   9688 FF FF FF FF 
1479   968C FF FF FF FF 
1479   9690 FF FF FF FF 
1479   9694 FF FF FF FF 
1479   9698 FF FF FF FF 
1479   969C FF FF FF FF 
1479   96A0 FF FF FF FF 
1479   96A4 FF FF FF FF 
1479   96A8 FF FF FF FF 
1479   96AC FF FF FF FF 
1479   96B0 FF FF FF FF 
1479   96B4 FF FF FF FF 
1479   96B8 FF FF FF FF 
1479   96BC FF FF FF FF 
1479   96C0 FF FF FF FF 
1479   96C4 FF FF FF FF 
1479   96C8 FF FF FF FF 
1479   96CC FF FF FF FF 
1479   96D0 FF FF FF FF 
1479   96D4 FF FF FF FF 
1479   96D8 FF FF FF FF 
1479   96DC FF FF FF FF 
1479   96E0 FF FF FF FF 
1479   96E4 FF FF FF FF 
1479   96E8 FF FF FF FF 
1479   96EC FF FF FF FF 
1479   96F0 FF FF FF FF 
1479   96F4 FF FF FF FF 
1479   96F8 FF FF FF FF 
1479   96FC FF FF FF FF 
1479   9700 FF FF FF FF 
1479   9704 FF FF FF FF 
1479   9708 FF FF FF FF 
1479   970C FF FF FF FF 
1479   9710 FF FF FF FF 
1479   9714 FF FF FF FF 
1479   9718 FF FF FF FF 
1479   971C FF FF FF FF 
1479   9720 FF FF FF FF 
1479   9724 FF FF FF FF 
1479   9728 FF FF FF FF 
1479   972C FF FF FF FF 
1479   9730 FF FF FF FF 
1479   9734 FF FF FF FF 
1479   9738 FF FF FF FF 
1479   973C FF FF FF FF 
1479   9740 FF FF FF FF 
1479   9744 FF FF FF FF 
1479   9748 FF FF FF FF 
1479   974C FF FF FF FF 
1479   9750 FF FF FF FF 
1479   9754 FF FF FF FF 
1479   9758 FF FF FF FF 
1479   975C FF FF FF FF 
1479   9760 FF FF FF FF 
1479   9764 FF FF FF FF 
1479   9768 FF FF FF FF 
1479   976C FF FF FF FF 
1479   9770 FF FF FF FF 
1479   9774 FF FF FF FF 
1479   9778 FF FF FF FF 
1479   977C FF FF FF FF 
1479   9780 FF FF FF FF 
1479   9784 FF FF FF FF 
1479   9788 FF FF FF FF 
1479   978C FF FF FF FF 
1479   9790 FF FF FF FF 
1479   9794 FF FF FF FF 
1479   9798 FF FF FF FF 
1479   979C FF FF FF FF 
1479   97A0 FF FF FF FF 
1479   97A4 FF FF FF FF 
1479   97A8 FF FF FF FF 
1479   97AC FF FF FF FF 
1479   97B0 FF FF FF FF 
1479   97B4 FF FF FF FF 
1479   97B8 FF FF FF FF 
1479   97BC FF FF FF FF 
1479   97C0 FF FF FF FF 
1479   97C4 FF FF FF FF 
1479   97C8 FF FF FF FF 
1479   97CC FF FF FF FF 
1479   97D0 FF FF FF FF 
1479   97D4 FF FF FF FF 
1479   97D8 FF FF FF FF 
1479   97DC FF FF FF FF 
1479   97E0 FF FF FF FF 
1479   97E4 FF FF FF FF 
1479   97E8 FF FF FF FF 
1479   97EC FF FF FF FF 
1479   97F0 FF FF FF FF 
1479   97F4 FF FF FF FF 
1479   97F8 FF FF FF FF 
1479   97FC FF FF FF FF 
1479   9800 FF FF FF FF 
1479   9804 FF FF FF FF 
1479   9808 FF FF FF FF 
1479   980C FF FF FF FF 
1479   9810 FF FF FF FF 
1479   9814 FF FF FF FF 
1479   9818 FF FF FF FF 
1479   981C FF FF FF FF 
1479   9820 FF FF FF FF 
1479   9824 FF FF FF FF 
1479   9828 FF FF FF FF 
1479   982C FF FF FF FF 
1479   9830 FF FF FF FF 
1479   9834 FF FF FF FF 
1479   9838 FF FF FF FF 
1479   983C FF FF FF FF 
1479   9840 FF FF FF FF 
1479   9844 FF FF FF FF 
1479   9848 FF FF FF FF 
1479   984C FF FF FF FF 
1479   9850 FF FF FF FF 
1479   9854 FF FF FF FF 
1479   9858 FF FF FF FF 
1479   985C FF FF FF FF 
1479   9860 FF FF FF FF 
1479   9864 FF FF FF FF 
1479   9868 FF FF FF FF 
1479   986C FF FF FF FF 
1479   9870 FF FF FF FF 
1479   9874 FF FF FF FF 
1479   9878 FF FF FF FF 
1479   987C FF FF FF FF 
1479   9880 FF FF FF FF 
1479   9884 FF FF FF FF 
1479   9888 FF FF FF FF 
1479   988C FF FF FF FF 
1479   9890 FF FF FF FF 
1479   9894 FF FF FF FF 
1479   9898 FF FF FF FF 
1479   989C FF FF FF FF 
1479   98A0 FF FF FF FF 
1479   98A4 FF FF FF FF 
1479   98A8 FF FF FF FF 
1479   98AC FF FF FF FF 
1479   98B0 FF FF FF FF 
1479   98B4 FF FF FF FF 
1479   98B8 FF FF FF FF 
1479   98BC FF FF FF FF 
1479   98C0 FF FF FF FF 
1479   98C4 FF FF FF FF 
1479   98C8 FF FF FF FF 
1479   98CC FF FF FF FF 
1479   98D0 FF FF FF FF 
1479   98D4 FF FF FF FF 
1479   98D8 FF FF FF FF 
1479   98DC FF FF FF FF 
1479   98E0 FF FF FF FF 
1479   98E4 FF FF FF FF 
1479   98E8 FF FF FF FF 
1479   98EC FF FF FF FF 
1479   98F0 FF FF FF FF 
1479   98F4 FF FF FF FF 
1479   98F8 FF FF FF FF 
1479   98FC FF FF FF FF 
1479   9900 FF FF FF FF 
1479   9904 FF FF FF FF 
1479   9908 FF FF FF FF 
1479   990C FF FF FF FF 
1479   9910 FF FF FF FF 
1479   9914 FF FF FF FF 
1479   9918 FF FF FF FF 
1479   991C FF FF FF FF 
1479   9920 FF FF FF FF 
1479   9924 FF FF FF FF 
1479   9928 FF FF FF FF 
1479   992C FF FF FF FF 
1479   9930 FF FF FF FF 
1479   9934 FF FF FF FF 
1479   9938 FF FF FF FF 
1479   993C FF FF FF FF 
1479   9940 FF FF FF FF 
1479   9944 FF FF FF FF 
1479   9948 FF FF FF FF 
1479   994C FF FF FF FF 
1479   9950 FF FF FF FF 
1479   9954 FF FF FF FF 
1479   9958 FF FF FF FF 
1479   995C FF FF FF FF 
1479   9960 FF FF FF FF 
1479   9964 FF FF FF FF 
1479   9968 FF FF FF FF 
1479   996C FF FF FF FF 
1479   9970 FF FF FF FF 
1479   9974 FF FF FF FF 
1479   9978 FF FF FF FF 
1479   997C FF FF FF FF 
1479   9980 FF FF FF FF 
1479   9984 FF FF FF FF 
1479   9988 FF FF FF FF 
1479   998C FF FF FF FF 
1479   9990 FF FF FF FF 
1479   9994 FF FF FF FF 
1479   9998 FF FF FF FF 
1479   999C FF FF FF FF 
1479   99A0 FF FF FF FF 
1479   99A4 FF FF FF FF 
1479   99A8 FF FF FF FF 
1479   99AC FF FF FF FF 
1479   99B0 FF FF FF FF 
1479   99B4 FF FF FF FF 
1479   99B8 FF FF FF FF 
1479   99BC FF FF FF FF 
1479   99C0 FF FF FF FF 
1479   99C4 FF FF FF FF 
1479   99C8 FF FF FF FF 
1479   99CC FF FF FF FF 
1479   99D0 FF FF FF FF 
1479   99D4 FF FF FF FF 
1479   99D8 FF FF FF FF 
1479   99DC FF FF FF FF 
1479   99E0 FF FF FF FF 
1479   99E4 FF FF FF FF 
1479   99E8 FF FF FF FF 
1479   99EC FF FF FF FF 
1479   99F0 FF FF FF FF 
1479   99F4 FF FF FF FF 
1479   99F8 FF FF FF FF 
1479   99FC FF FF FF FF 
1479   9A00 FF FF FF FF 
1479   9A04 FF FF FF FF 
1479   9A08 FF FF FF FF 
1479   9A0C FF FF FF FF 
1479   9A10 FF FF FF FF 
1479   9A14 FF FF FF FF 
1479   9A18 FF FF FF FF 
1479   9A1C FF FF FF FF 
1479   9A20 FF FF FF FF 
1479   9A24 FF FF FF FF 
1479   9A28 FF FF FF FF 
1479   9A2C FF FF FF FF 
1479   9A30 FF FF FF FF 
1479   9A34 FF FF FF FF 
1479   9A38 FF FF FF FF 
1479   9A3C FF FF FF FF 
1479   9A40 FF FF FF FF 
1479   9A44 FF FF FF FF 
1479   9A48 FF FF FF FF 
1479   9A4C FF FF FF FF 
1479   9A50 FF FF FF FF 
1479   9A54 FF FF FF FF 
1479   9A58 FF FF FF FF 
1479   9A5C FF FF FF FF 
1479   9A60 FF FF FF FF 
1479   9A64 FF FF FF FF 
1479   9A68 FF FF FF FF 
1479   9A6C FF FF FF FF 
1479   9A70 FF FF FF FF 
1479   9A74 FF FF FF FF 
1479   9A78 FF FF FF FF 
1479   9A7C FF FF FF FF 
1479   9A80 FF FF FF FF 
1479   9A84 FF FF FF FF 
1479   9A88 FF FF FF FF 
1479   9A8C FF FF FF FF 
1479   9A90 FF FF FF FF 
1479   9A94 FF FF FF FF 
1479   9A98 FF FF FF FF 
1479   9A9C FF FF FF FF 
1479   9AA0 FF FF FF FF 
1479   9AA4 FF FF FF FF 
1479   9AA8 FF FF FF FF 
1479   9AAC FF FF FF FF 
1479   9AB0 FF FF FF FF 
1479   9AB4 FF FF FF FF 
1479   9AB8 FF FF FF FF 
1479   9ABC FF FF FF FF 
1479   9AC0 FF FF FF FF 
1479   9AC4 FF FF FF FF 
1479   9AC8 FF FF FF FF 
1479   9ACC FF FF FF FF 
1479   9AD0 FF FF FF FF 
1479   9AD4 FF FF FF FF 
1479   9AD8 FF FF FF FF 
1479   9ADC FF FF FF FF 
1479   9AE0 FF FF FF FF 
1479   9AE4 FF FF FF FF 
1479   9AE8 FF FF FF FF 
1479   9AEC FF FF FF FF 
1479   9AF0 FF FF FF FF 
1479   9AF4 FF FF FF FF 
1479   9AF8 FF FF FF FF 
1479   9AFC FF FF FF FF 
1479   9B00 FF FF FF FF 
1479   9B04 FF FF FF FF 
1479   9B08 FF FF FF FF 
1479   9B0C FF FF FF FF 
1479   9B10 FF FF FF FF 
1479   9B14 FF FF FF FF 
1479   9B18 FF FF FF FF 
1479   9B1C FF FF FF FF 
1479   9B20 FF FF FF FF 
1479   9B24 FF FF FF FF 
1479   9B28 FF FF FF FF 
1479   9B2C FF FF FF FF 
1479   9B30 FF FF FF FF 
1479   9B34 FF FF FF FF 
1479   9B38 FF FF FF FF 
1479   9B3C FF FF FF FF 
1479   9B40 FF FF FF FF 
1479   9B44 FF FF FF FF 
1479   9B48 FF FF FF FF 
1479   9B4C FF FF FF FF 
1479   9B50 FF FF FF FF 
1479   9B54 FF FF FF FF 
1479   9B58 FF FF FF FF 
1479   9B5C FF FF FF FF 
1479   9B60 FF FF FF FF 
1479   9B64 FF FF FF FF 
1479   9B68 FF FF FF FF 
1479   9B6C FF FF FF FF 
1479   9B70 FF FF FF FF 
1479   9B74 FF FF FF FF 
1479   9B78 FF FF FF FF 
1479   9B7C FF FF FF FF 
1479   9B80 FF FF FF FF 
1479   9B84 FF FF FF FF 
1479   9B88 FF FF FF FF 
1479   9B8C FF FF FF FF 
1479   9B90 FF FF FF FF 
1479   9B94 FF FF FF FF 
1479   9B98 FF FF FF FF 
1479   9B9C FF FF FF FF 
1479   9BA0 FF FF FF FF 
1479   9BA4 FF FF FF FF 
1479   9BA8 FF FF FF FF 
1479   9BAC FF FF FF FF 
1479   9BB0 FF FF FF FF 
1479   9BB4 FF FF FF FF 
1479   9BB8 FF FF FF FF 
1479   9BBC FF FF FF FF 
1479   9BC0 FF FF FF FF 
1479   9BC4 FF FF FF FF 
1479   9BC8 FF FF FF FF 
1479   9BCC FF FF FF FF 
1479   9BD0 FF FF FF FF 
1479   9BD4 FF FF FF FF 
1479   9BD8 FF FF FF FF 
1479   9BDC FF FF FF FF 
1479   9BE0 FF FF FF FF 
1479   9BE4 FF FF FF FF 
1479   9BE8 FF FF FF FF 
1479   9BEC FF FF FF FF 
1479   9BF0 FF FF FF FF 
1479   9BF4 FF FF FF FF 
1479   9BF8 FF FF FF FF 
1479   9BFC FF FF FF FF 
1479   9C00 FF FF FF FF 
1479   9C04 FF FF FF FF 
1479   9C08 FF FF FF FF 
1479   9C0C FF FF FF FF 
1479   9C10 FF FF FF FF 
1479   9C14 FF FF FF FF 
1479   9C18 FF FF FF FF 
1479   9C1C FF FF FF FF 
1479   9C20 FF FF FF FF 
1479   9C24 FF FF FF FF 
1479   9C28 FF FF FF FF 
1479   9C2C FF FF FF FF 
1479   9C30 FF FF FF FF 
1479   9C34 FF FF FF FF 
1479   9C38 FF FF FF FF 
1479   9C3C FF FF FF FF 
1479   9C40 FF FF FF FF 
1479   9C44 FF FF FF FF 
1479   9C48 FF FF FF FF 
1479   9C4C FF FF FF FF 
1479   9C50 FF FF FF FF 
1479   9C54 FF FF FF FF 
1479   9C58 FF FF FF FF 
1479   9C5C FF FF FF FF 
1479   9C60 FF FF FF FF 
1479   9C64 FF FF FF FF 
1479   9C68 FF FF FF FF 
1479   9C6C FF FF FF FF 
1479   9C70 FF FF FF FF 
1479   9C74 FF FF FF FF 
1479   9C78 FF FF FF FF 
1479   9C7C FF FF FF FF 
1479   9C80 FF FF FF FF 
1479   9C84 FF FF FF FF 
1479   9C88 FF FF FF FF 
1479   9C8C FF FF FF FF 
1479   9C90 FF FF FF FF 
1479   9C94 FF FF FF FF 
1479   9C98 FF FF FF FF 
1479   9C9C FF FF FF FF 
1479   9CA0 FF FF FF FF 
1479   9CA4 FF FF FF FF 
1479   9CA8 FF FF FF FF 
1479   9CAC FF FF FF FF 
1479   9CB0 FF FF FF FF 
1479   9CB4 FF FF FF FF 
1479   9CB8 FF FF FF FF 
1479   9CBC FF FF FF FF 
1479   9CC0 FF FF FF FF 
1479   9CC4 FF FF FF FF 
1479   9CC8 FF FF FF FF 
1479   9CCC FF FF FF FF 
1479   9CD0 FF FF FF FF 
1479   9CD4 FF FF FF FF 
1479   9CD8 FF FF FF FF 
1479   9CDC FF FF FF FF 
1479   9CE0 FF FF FF FF 
1479   9CE4 FF FF FF FF 
1479   9CE8 FF FF FF FF 
1479   9CEC FF FF FF FF 
1479   9CF0 FF FF FF FF 
1479   9CF4 FF FF FF FF 
1479   9CF8 FF FF FF FF 
1479   9CFC FF FF FF FF 
1479   9D00 FF FF FF FF 
1479   9D04 FF FF FF FF 
1479   9D08 FF FF FF FF 
1479   9D0C FF FF FF FF 
1479   9D10 FF FF FF FF 
1479   9D14 FF FF FF FF 
1479   9D18 FF FF FF FF 
1479   9D1C FF FF FF FF 
1479   9D20 FF FF FF FF 
1479   9D24 FF FF FF FF 
1479   9D28 FF FF FF FF 
1479   9D2C FF FF FF FF 
1479   9D30 FF FF FF FF 
1479   9D34 FF FF FF FF 
1479   9D38 FF FF FF FF 
1479   9D3C FF FF FF FF 
1479   9D40 FF FF FF FF 
1479   9D44 FF FF FF FF 
1479   9D48 FF FF FF FF 
1479   9D4C FF FF FF FF 
1479   9D50 FF FF FF FF 
1479   9D54 FF FF FF FF 
1479   9D58 FF FF FF FF 
1479   9D5C FF FF FF FF 
1479   9D60 FF FF FF FF 
1479   9D64 FF FF FF FF 
1479   9D68 FF FF FF FF 
1479   9D6C FF FF FF FF 
1479   9D70 FF FF FF FF 
1479   9D74 FF FF FF FF 
1479   9D78 FF FF FF FF 
1479   9D7C FF FF FF FF 
1479   9D80 FF FF FF FF 
1479   9D84 FF FF FF FF 
1479   9D88 FF FF FF FF 
1479   9D8C FF FF FF FF 
1479   9D90 FF FF FF FF 
1479   9D94 FF FF FF FF 
1479   9D98 FF FF FF FF 
1479   9D9C FF FF FF FF 
1479   9DA0 FF FF FF FF 
1479   9DA4 FF FF FF FF 
1479   9DA8 FF FF FF FF 
1479   9DAC FF FF FF FF 
1479   9DB0 FF FF FF FF 
1479   9DB4 FF FF FF FF 
1479   9DB8 FF FF FF FF 
1479   9DBC FF FF FF FF 
1479   9DC0 FF FF FF FF 
1479   9DC4 FF FF FF FF 
1479   9DC8 FF FF FF FF 
1479   9DCC FF FF FF FF 
1479   9DD0 FF FF FF FF 
1479   9DD4 FF FF FF FF 
1479   9DD8 FF FF FF FF 
1479   9DDC FF FF FF FF 
1479   9DE0 FF FF FF FF 
1479   9DE4 FF FF FF FF 
1479   9DE8 FF FF FF FF 
1479   9DEC FF FF FF FF 
1479   9DF0 FF FF FF FF 
1479   9DF4 FF FF FF FF 
1479   9DF8 FF FF FF FF 
1479   9DFC FF FF FF FF 
1479   9E00 FF FF FF FF 
1479   9E04 FF FF FF FF 
1479   9E08 FF FF FF FF 
1479   9E0C FF FF FF FF 
1479   9E10 FF FF FF FF 
1479   9E14 FF FF FF FF 
1479   9E18 FF FF FF FF 
1479   9E1C FF FF FF FF 
1479   9E20 FF FF FF FF 
1479   9E24 FF FF FF FF 
1479   9E28 FF FF FF FF 
1479   9E2C FF FF FF FF 
1479   9E30 FF FF FF FF 
1479   9E34 FF FF FF FF 
1479   9E38 FF FF FF FF 
1479   9E3C FF FF FF FF 
1479   9E40 FF FF FF FF 
1479   9E44 FF FF FF FF 
1479   9E48 FF FF FF FF 
1479   9E4C FF FF FF FF 
1479   9E50 FF FF FF FF 
1479   9E54 FF FF FF FF 
1479   9E58 FF FF FF FF 
1479   9E5C FF FF FF FF 
1479   9E60 FF FF FF FF 
1479   9E64 FF FF FF FF 
1479   9E68 FF FF FF FF 
1479   9E6C FF FF FF FF 
1479   9E70 FF FF FF FF 
1479   9E74 FF FF FF FF 
1479   9E78 FF FF FF FF 
1479   9E7C FF FF FF FF 
1479   9E80 FF FF FF FF 
1479   9E84 FF FF FF FF 
1479   9E88 FF FF FF FF 
1479   9E8C FF FF FF FF 
1479   9E90 FF FF FF FF 
1479   9E94 FF FF FF FF 
1479   9E98 FF FF FF FF 
1479   9E9C FF FF FF FF 
1479   9EA0 FF FF FF FF 
1479   9EA4 FF FF FF FF 
1479   9EA8 FF FF FF FF 
1479   9EAC FF FF FF FF 
1479   9EB0 FF FF FF FF 
1479   9EB4 FF FF FF FF 
1479   9EB8 FF FF FF FF 
1479   9EBC FF FF FF FF 
1479   9EC0 FF FF FF FF 
1479   9EC4 FF FF FF FF 
1479   9EC8 FF FF FF FF 
1479   9ECC FF FF FF FF 
1479   9ED0 FF FF FF FF 
1479   9ED4 FF FF FF FF 
1479   9ED8 FF FF FF FF 
1479   9EDC FF FF FF FF 
1479   9EE0 FF FF FF FF 
1479   9EE4 FF FF FF FF 
1479   9EE8 FF FF FF FF 
1479   9EEC FF FF FF FF 
1479   9EF0 FF FF FF FF 
1479   9EF4 FF FF FF FF 
1479   9EF8 FF FF FF FF 
1479   9EFC FF FF FF FF 
1479   9F00 FF FF FF FF 
1479   9F04 FF FF FF FF 
1479   9F08 FF FF FF FF 
1479   9F0C FF FF FF FF 
1479   9F10 FF FF FF FF 
1479   9F14 FF FF FF FF 
1479   9F18 FF FF FF FF 
1479   9F1C FF FF FF FF 
1479   9F20 FF FF FF FF 
1479   9F24 FF FF FF FF 
1479   9F28 FF FF FF FF 
1479   9F2C FF FF FF FF 
1479   9F30 FF FF FF FF 
1479   9F34 FF FF FF FF 
1479   9F38 FF FF FF FF 
1479   9F3C FF FF FF FF 
1479   9F40 FF FF FF FF 
1479   9F44 FF FF FF FF 
1479   9F48 FF FF FF FF 
1479   9F4C FF FF FF FF 
1479   9F50 FF FF FF FF 
1479   9F54 FF FF FF FF 
1479   9F58 FF FF FF FF 
1479   9F5C FF FF FF FF 
1479   9F60 FF FF FF FF 
1479   9F64 FF FF FF FF 
1479   9F68 FF FF FF FF 
1479   9F6C FF FF FF FF 
1479   9F70 FF FF FF FF 
1479   9F74 FF FF FF FF 
1479   9F78 FF FF FF FF 
1479   9F7C FF FF FF FF 
1479   9F80 FF FF FF FF 
1479   9F84 FF FF FF FF 
1479   9F88 FF FF FF FF 
1479   9F8C FF FF FF FF 
1479   9F90 FF FF FF FF 
1479   9F94 FF FF FF FF 
1479   9F98 FF FF FF FF 
1479   9F9C FF FF FF FF 
1479   9FA0 FF FF FF FF 
1479   9FA4 FF FF FF FF 
1479   9FA8 FF FF FF FF 
1479   9FAC FF FF FF FF 
1479   9FB0 FF FF FF FF 
1479   9FB4 FF FF FF FF 
1479   9FB8 FF FF FF FF 
1479   9FBC FF FF FF FF 
1479   9FC0 FF FF FF FF 
1479   9FC4 FF FF FF FF 
1479   9FC8 FF FF FF FF 
1479   9FCC FF FF FF FF 
1479   9FD0 FF FF FF FF 
1479   9FD4 FF FF FF FF 
1479   9FD8 FF FF FF FF 
1479   9FDC FF FF FF FF 
1479   9FE0 FF FF FF FF 
1479   9FE4 FF FF FF FF 
1479   9FE8 FF FF FF FF 
1479   9FEC FF FF FF FF 
1479   9FF0 FF FF FF FF 
1479   9FF4 FF FF FF FF 
1479   9FF8 FF FF FF FF 
1479   9FFC FF FF FF FF 
1479   A000 FF FF FF FF 
1479   A004 FF FF FF FF 
1479   A008 FF FF FF FF 
1479   A00C FF FF FF FF 
1479   A010 FF FF FF FF 
1479   A014 FF FF FF FF 
1479   A018 FF FF FF FF 
1479   A01C FF FF FF FF 
1479   A020 FF FF FF FF 
1479   A024 FF FF FF FF 
1479   A028 FF FF FF FF 
1479   A02C FF FF FF FF 
1479   A030 FF FF FF FF 
1479   A034 FF FF FF FF 
1479   A038 FF FF FF FF 
1479   A03C FF FF FF FF 
1479   A040 FF FF FF FF 
1479   A044 FF FF FF FF 
1479   A048 FF FF FF FF 
1479   A04C FF FF FF FF 
1479   A050 FF FF FF FF 
1479   A054 FF FF FF FF 
1479   A058 FF FF FF FF 
1479   A05C FF FF FF FF 
1479   A060 FF FF FF FF 
1479   A064 FF FF FF FF 
1479   A068 FF FF FF FF 
1479   A06C FF FF FF FF 
1479   A070 FF FF FF FF 
1479   A074 FF FF FF FF 
1479   A078 FF FF FF FF 
1479   A07C FF FF FF FF 
1479   A080 FF FF FF FF 
1479   A084 FF FF FF FF 
1479   A088 FF FF FF FF 
1479   A08C FF FF FF FF 
1479   A090 FF FF FF FF 
1479   A094 FF FF FF FF 
1479   A098 FF FF FF FF 
1479   A09C FF FF FF FF 
1479   A0A0 FF FF FF FF 
1479   A0A4 FF FF FF FF 
1479   A0A8 FF FF FF FF 
1479   A0AC FF FF FF FF 
1479   A0B0 FF FF FF FF 
1479   A0B4 FF FF FF FF 
1479   A0B8 FF FF FF FF 
1479   A0BC FF FF FF FF 
1479   A0C0 FF FF FF FF 
1479   A0C4 FF FF FF FF 
1479   A0C8 FF FF FF FF 
1479   A0CC FF FF FF FF 
1479   A0D0 FF FF FF FF 
1479   A0D4 FF FF FF FF 
1479   A0D8 FF FF FF FF 
1479   A0DC FF FF FF FF 
1479   A0E0 FF FF FF FF 
1479   A0E4 FF FF FF FF 
1479   A0E8 FF FF FF FF 
1479   A0EC FF FF FF FF 
1479   A0F0 FF FF FF FF 
1479   A0F4 FF FF FF FF 
1479   A0F8 FF FF FF FF 
1479   A0FC FF FF FF FF 
1479   A100 FF FF FF FF 
1479   A104 FF FF FF FF 
1479   A108 FF FF FF FF 
1479   A10C FF FF FF FF 
1479   A110 FF FF FF FF 
1479   A114 FF FF FF FF 
1479   A118 FF FF FF FF 
1479   A11C FF FF FF FF 
1479   A120 FF FF FF FF 
1479   A124 FF FF FF FF 
1479   A128 FF FF FF FF 
1479   A12C FF FF FF FF 
1479   A130 FF FF FF FF 
1479   A134 FF FF FF FF 
1479   A138 FF FF FF FF 
1479   A13C FF FF FF FF 
1479   A140 FF FF FF FF 
1479   A144 FF FF FF FF 
1479   A148 FF FF FF FF 
1479   A14C FF FF FF FF 
1479   A150 FF FF FF FF 
1479   A154 FF FF FF FF 
1479   A158 FF FF FF FF 
1479   A15C FF FF FF FF 
1479   A160 FF FF FF FF 
1479   A164 FF FF FF FF 
1479   A168 FF FF FF FF 
1479   A16C FF FF FF FF 
1479   A170 FF FF FF FF 
1479   A174 FF FF FF FF 
1479   A178 FF FF FF FF 
1479   A17C FF FF FF FF 
1479   A180 FF FF FF FF 
1479   A184 FF FF FF FF 
1479   A188 FF FF FF FF 
1479   A18C FF FF FF FF 
1479   A190 FF FF FF FF 
1479   A194 FF FF FF FF 
1479   A198 FF FF FF FF 
1479   A19C FF FF FF FF 
1479   A1A0 FF FF FF FF 
1479   A1A4 FF FF FF FF 
1479   A1A8 FF FF FF FF 
1479   A1AC FF FF FF FF 
1479   A1B0 FF FF FF FF 
1479   A1B4 FF FF FF FF 
1479   A1B8 FF FF FF FF 
1479   A1BC FF FF FF FF 
1479   A1C0 FF FF FF FF 
1479   A1C4 FF FF FF FF 
1479   A1C8 FF FF FF FF 
1479   A1CC FF FF FF FF 
1479   A1D0 FF FF FF FF 
1479   A1D4 FF FF FF FF 
1479   A1D8 FF FF FF FF 
1479   A1DC FF FF FF FF 
1479   A1E0 FF FF FF FF 
1479   A1E4 FF FF FF FF 
1479   A1E8 FF FF FF FF 
1479   A1EC FF FF FF FF 
1479   A1F0 FF FF FF FF 
1479   A1F4 FF FF FF FF 
1479   A1F8 FF FF FF FF 
1479   A1FC FF FF FF FF 
1479   A200 FF FF FF FF 
1479   A204 FF FF FF FF 
1479   A208 FF FF FF FF 
1479   A20C FF FF FF FF 
1479   A210 FF FF FF FF 
1479   A214 FF FF FF FF 
1479   A218 FF FF FF FF 
1479   A21C FF FF FF FF 
1479   A220 FF FF FF FF 
1479   A224 FF FF FF FF 
1479   A228 FF FF FF FF 
1479   A22C FF FF FF FF 
1479   A230 FF FF FF FF 
1479   A234 FF FF FF FF 
1479   A238 FF FF FF FF 
1479   A23C FF FF FF FF 
1479   A240 FF FF FF FF 
1479   A244 FF FF FF FF 
1479   A248 FF FF FF FF 
1479   A24C FF FF FF FF 
1479   A250 FF FF FF FF 
1479   A254 FF FF FF FF 
1479   A258 FF FF FF FF 
1479   A25C FF FF FF FF 
1479   A260 FF FF FF FF 
1479   A264 FF FF FF FF 
1479   A268 FF FF FF FF 
1479   A26C FF FF FF FF 
1479   A270 FF FF FF FF 
1479   A274 FF FF FF FF 
1479   A278 FF FF FF FF 
1479   A27C FF FF FF FF 
1479   A280 FF FF FF FF 
1479   A284 FF FF FF FF 
1479   A288 FF FF FF FF 
1479   A28C FF FF FF FF 
1479   A290 FF FF FF FF 
1479   A294 FF FF FF FF 
1479   A298 FF FF FF FF 
1479   A29C FF FF FF FF 
1479   A2A0 FF FF FF FF 
1479   A2A4 FF FF FF FF 
1479   A2A8 FF FF FF FF 
1479   A2AC FF FF FF FF 
1479   A2B0 FF FF FF FF 
1479   A2B4 FF FF FF FF 
1479   A2B8 FF FF FF FF 
1479   A2BC FF FF FF FF 
1479   A2C0 FF FF FF FF 
1479   A2C4 FF FF FF FF 
1479   A2C8 FF FF FF FF 
1479   A2CC FF FF FF FF 
1479   A2D0 FF FF FF FF 
1479   A2D4 FF FF FF FF 
1479   A2D8 FF FF FF FF 
1479   A2DC FF FF FF FF 
1479   A2E0 FF FF FF FF 
1479   A2E4 FF FF FF FF 
1479   A2E8 FF FF FF FF 
1479   A2EC FF FF FF FF 
1479   A2F0 FF FF FF FF 
1479   A2F4 FF FF FF FF 
1479   A2F8 FF FF FF FF 
1479   A2FC FF FF FF FF 
1479   A300 FF FF FF FF 
1479   A304 FF FF FF FF 
1479   A308 FF FF FF FF 
1479   A30C FF FF FF FF 
1479   A310 FF FF FF FF 
1479   A314 FF FF FF FF 
1479   A318 FF FF FF FF 
1479   A31C FF FF FF FF 
1479   A320 FF FF FF FF 
1479   A324 FF FF FF FF 
1479   A328 FF FF FF FF 
1479   A32C FF FF FF FF 
1479   A330 FF FF FF FF 
1479   A334 FF FF FF FF 
1479   A338 FF FF FF FF 
1479   A33C FF FF FF FF 
1479   A340 FF FF FF FF 
1479   A344 FF FF FF FF 
1479   A348 FF FF FF FF 
1479   A34C FF FF FF FF 
1479   A350 FF FF FF FF 
1479   A354 FF FF FF FF 
1479   A358 FF FF FF FF 
1479   A35C FF FF FF FF 
1479   A360 FF FF FF FF 
1479   A364 FF FF FF FF 
1479   A368 FF FF FF FF 
1479   A36C FF FF FF FF 
1479   A370 FF FF FF FF 
1479   A374 FF FF FF FF 
1479   A378 FF FF FF FF 
1479   A37C FF FF FF FF 
1479   A380 FF FF FF FF 
1479   A384 FF FF FF FF 
1479   A388 FF FF FF FF 
1479   A38C FF FF FF FF 
1479   A390 FF FF FF FF 
1479   A394 FF FF FF FF 
1479   A398 FF FF FF FF 
1479   A39C FF FF FF FF 
1479   A3A0 FF FF FF FF 
1479   A3A4 FF FF FF FF 
1479   A3A8 FF FF FF FF 
1479   A3AC FF FF FF FF 
1479   A3B0 FF FF FF FF 
1479   A3B4 FF FF FF FF 
1479   A3B8 FF FF FF FF 
1479   A3BC FF FF FF FF 
1479   A3C0 FF FF FF FF 
1479   A3C4 FF FF FF FF 
1479   A3C8 FF FF FF FF 
1479   A3CC FF FF FF FF 
1479   A3D0 FF FF FF FF 
1479   A3D4 FF FF FF FF 
1479   A3D8 FF FF FF FF 
1479   A3DC FF FF FF FF 
1479   A3E0 FF FF FF FF 
1479   A3E4 FF FF FF FF 
1479   A3E8 FF FF FF FF 
1479   A3EC FF FF FF FF 
1479   A3F0 FF FF FF FF 
1479   A3F4 FF FF FF FF 
1479   A3F8 FF FF FF FF 
1479   A3FC FF FF FF FF 
1479   A400 FF FF FF FF 
1479   A404 FF FF FF FF 
1479   A408 FF FF FF FF 
1479   A40C FF FF FF FF 
1479   A410 FF FF FF FF 
1479   A414 FF FF FF FF 
1479   A418 FF FF FF FF 
1479   A41C FF FF FF FF 
1479   A420 FF FF FF FF 
1479   A424 FF FF FF FF 
1479   A428 FF FF FF FF 
1479   A42C FF FF FF FF 
1479   A430 FF FF FF FF 
1479   A434 FF FF FF FF 
1479   A438 FF FF FF FF 
1479   A43C FF FF FF FF 
1479   A440 FF FF FF FF 
1479   A444 FF FF FF FF 
1479   A448 FF FF FF FF 
1479   A44C FF FF FF FF 
1479   A450 FF FF FF FF 
1479   A454 FF FF FF FF 
1479   A458 FF FF FF FF 
1479   A45C FF FF FF FF 
1479   A460 FF FF FF FF 
1479   A464 FF FF FF FF 
1479   A468 FF FF FF FF 
1479   A46C FF FF FF FF 
1479   A470 FF FF FF FF 
1479   A474 FF FF FF FF 
1479   A478 FF FF FF FF 
1479   A47C FF FF FF FF 
1479   A480 FF FF FF FF 
1479   A484 FF FF FF FF 
1479   A488 FF FF FF FF 
1479   A48C FF FF FF FF 
1479   A490 FF FF FF FF 
1479   A494 FF FF FF FF 
1479   A498 FF FF FF FF 
1479   A49C FF FF FF FF 
1479   A4A0 FF FF FF FF 
1479   A4A4 FF FF FF FF 
1479   A4A8 FF FF FF FF 
1479   A4AC FF FF FF FF 
1479   A4B0 FF FF FF FF 
1479   A4B4 FF FF FF FF 
1479   A4B8 FF FF FF FF 
1479   A4BC FF FF FF FF 
1479   A4C0 FF FF FF FF 
1479   A4C4 FF FF FF FF 
1479   A4C8 FF FF FF FF 
1479   A4CC FF FF FF FF 
1479   A4D0 FF FF FF FF 
1479   A4D4 FF FF FF FF 
1479   A4D8 FF FF FF FF 
1479   A4DC FF FF FF FF 
1479   A4E0 FF FF FF FF 
1479   A4E4 FF FF FF FF 
1479   A4E8 FF FF FF FF 
1479   A4EC FF FF FF FF 
1479   A4F0 FF FF FF FF 
1479   A4F4 FF FF FF FF 
1479   A4F8 FF FF FF FF 
1479   A4FC FF FF FF FF 
1479   A500 FF FF FF FF 
1479   A504 FF FF FF FF 
1479   A508 FF FF FF FF 
1479   A50C FF FF FF FF 
1479   A510 FF FF FF FF 
1479   A514 FF FF FF FF 
1479   A518 FF FF FF FF 
1479   A51C FF FF FF FF 
1479   A520 FF FF FF FF 
1479   A524 FF FF FF FF 
1479   A528 FF FF FF FF 
1479   A52C FF FF FF FF 
1479   A530 FF FF FF FF 
1479   A534 FF FF FF FF 
1479   A538 FF FF FF FF 
1479   A53C FF FF FF FF 
1479   A540 FF FF FF FF 
1479   A544 FF FF FF FF 
1479   A548 FF FF FF FF 
1479   A54C FF FF FF FF 
1479   A550 FF FF FF FF 
1479   A554 FF FF FF FF 
1479   A558 FF FF FF FF 
1479   A55C FF FF FF FF 
1479   A560 FF FF FF FF 
1479   A564 FF FF FF FF 
1479   A568 FF FF FF FF 
1479   A56C FF FF FF FF 
1479   A570 FF FF FF FF 
1479   A574 FF FF FF FF 
1479   A578 FF FF FF FF 
1479   A57C FF FF FF FF 
1479   A580 FF FF FF FF 
1479   A584 FF FF FF FF 
1479   A588 FF FF FF FF 
1479   A58C FF FF FF FF 
1479   A590 FF FF FF FF 
1479   A594 FF FF FF FF 
1479   A598 FF FF FF FF 
1479   A59C FF FF FF FF 
1479   A5A0 FF FF FF FF 
1479   A5A4 FF FF FF FF 
1479   A5A8 FF FF FF FF 
1479   A5AC FF FF FF FF 
1479   A5B0 FF FF FF FF 
1479   A5B4 FF FF FF FF 
1479   A5B8 FF FF FF FF 
1479   A5BC FF FF FF FF 
1479   A5C0 FF FF FF FF 
1479   A5C4 FF FF FF FF 
1479   A5C8 FF FF FF FF 
1479   A5CC FF FF FF FF 
1479   A5D0 FF FF FF FF 
1479   A5D4 FF FF FF FF 
1479   A5D8 FF FF FF FF 
1479   A5DC FF FF FF FF 
1479   A5E0 FF FF FF FF 
1479   A5E4 FF FF FF FF 
1479   A5E8 FF FF FF FF 
1479   A5EC FF FF FF FF 
1479   A5F0 FF FF FF FF 
1479   A5F4 FF FF FF FF 
1479   A5F8 FF FF FF FF 
1479   A5FC FF FF FF FF 
1479   A600 FF FF FF FF 
1479   A604 FF FF FF FF 
1479   A608 FF FF FF FF 
1479   A60C FF FF FF FF 
1479   A610 FF FF FF FF 
1479   A614 FF FF FF FF 
1479   A618 FF FF FF FF 
1479   A61C FF FF FF FF 
1479   A620 FF FF FF FF 
1479   A624 FF FF FF FF 
1479   A628 FF FF FF FF 
1479   A62C FF FF FF FF 
1479   A630 FF FF FF FF 
1479   A634 FF FF FF FF 
1479   A638 FF FF FF FF 
1479   A63C FF FF FF FF 
1479   A640 FF FF FF FF 
1479   A644 FF FF FF FF 
1479   A648 FF FF FF FF 
1479   A64C FF FF FF FF 
1479   A650 FF FF FF FF 
1479   A654 FF FF FF FF 
1479   A658 FF FF FF FF 
1479   A65C FF FF FF FF 
1479   A660 FF FF FF FF 
1479   A664 FF FF FF FF 
1479   A668 FF FF FF FF 
1479   A66C FF FF FF FF 
1479   A670 FF FF FF FF 
1479   A674 FF FF FF FF 
1479   A678 FF FF FF FF 
1479   A67C FF FF FF FF 
1479   A680 FF FF FF FF 
1479   A684 FF FF FF FF 
1479   A688 FF FF FF FF 
1479   A68C FF FF FF FF 
1479   A690 FF FF FF FF 
1479   A694 FF FF FF FF 
1479   A698 FF FF FF FF 
1479   A69C FF FF FF FF 
1479   A6A0 FF FF FF FF 
1479   A6A4 FF FF FF FF 
1479   A6A8 FF FF FF FF 
1479   A6AC FF FF FF FF 
1479   A6B0 FF FF FF FF 
1479   A6B4 FF FF FF FF 
1479   A6B8 FF FF FF FF 
1479   A6BC FF FF FF FF 
1479   A6C0 FF FF FF FF 
1479   A6C4 FF FF FF FF 
1479   A6C8 FF FF FF FF 
1479   A6CC FF FF FF FF 
1479   A6D0 FF FF FF FF 
1479   A6D4 FF FF FF FF 
1479   A6D8 FF FF FF FF 
1479   A6DC FF FF FF FF 
1479   A6E0 FF FF FF FF 
1479   A6E4 FF FF FF FF 
1479   A6E8 FF FF FF FF 
1479   A6EC FF FF FF FF 
1479   A6F0 FF FF FF FF 
1479   A6F4 FF FF FF FF 
1479   A6F8 FF FF FF FF 
1479   A6FC FF FF FF FF 
1479   A700 FF FF FF FF 
1479   A704 FF FF FF FF 
1479   A708 FF FF FF FF 
1479   A70C FF FF FF FF 
1479   A710 FF FF FF FF 
1479   A714 FF FF FF FF 
1479   A718 FF FF FF FF 
1479   A71C FF FF FF FF 
1479   A720 FF FF FF FF 
1479   A724 FF FF FF FF 
1479   A728 FF FF FF FF 
1479   A72C FF FF FF FF 
1479   A730 FF FF FF FF 
1479   A734 FF FF FF FF 
1479   A738 FF FF FF FF 
1479   A73C FF FF FF FF 
1479   A740 FF FF FF FF 
1479   A744 FF FF FF FF 
1479   A748 FF FF FF FF 
1479   A74C FF FF FF FF 
1479   A750 FF FF FF FF 
1479   A754 FF FF FF FF 
1479   A758 FF FF FF FF 
1479   A75C FF FF FF FF 
1479   A760 FF FF FF FF 
1479   A764 FF FF FF FF 
1479   A768 FF FF FF FF 
1479   A76C FF FF FF FF 
1479   A770 FF FF FF FF 
1479   A774 FF FF FF FF 
1479   A778 FF FF FF FF 
1479   A77C FF FF FF FF 
1479   A780 FF FF FF FF 
1479   A784 FF FF FF FF 
1479   A788 FF FF FF FF 
1479   A78C FF FF FF FF 
1479   A790 FF FF FF FF 
1479   A794 FF FF FF FF 
1479   A798 FF FF FF FF 
1479   A79C FF FF FF FF 
1479   A7A0 FF FF FF FF 
1479   A7A4 FF FF FF FF 
1479   A7A8 FF FF FF FF 
1479   A7AC FF FF FF FF 
1479   A7B0 FF FF FF FF 
1479   A7B4 FF FF FF FF 
1479   A7B8 FF FF FF FF 
1479   A7BC FF FF FF FF 
1479   A7C0 FF FF FF FF 
1479   A7C4 FF FF FF FF 
1479   A7C8 FF FF FF FF 
1479   A7CC FF FF FF FF 
1479   A7D0 FF FF FF FF 
1479   A7D4 FF FF FF FF 
1479   A7D8 FF FF FF FF 
1479   A7DC FF FF FF FF 
1479   A7E0 FF FF FF FF 
1479   A7E4 FF FF FF FF 
1479   A7E8 FF FF FF FF 
1479   A7EC FF FF FF FF 
1479   A7F0 FF FF FF FF 
1479   A7F4 FF FF FF FF 
1479   A7F8 FF FF FF FF 
1479   A7FC FF FF FF FF 
1479   A800 FF FF FF FF 
1479   A804 FF FF FF FF 
1479   A808 FF FF FF FF 
1479   A80C FF FF FF FF 
1479   A810 FF FF FF FF 
1479   A814 FF FF FF FF 
1479   A818 FF FF FF FF 
1479   A81C FF FF FF FF 
1479   A820 FF FF FF FF 
1479   A824 FF FF FF FF 
1479   A828 FF FF FF FF 
1479   A82C FF FF FF FF 
1479   A830 FF FF FF FF 
1479   A834 FF FF FF FF 
1479   A838 FF FF FF FF 
1479   A83C FF FF FF FF 
1479   A840 FF FF FF FF 
1479   A844 FF FF FF FF 
1479   A848 FF FF FF FF 
1479   A84C FF FF FF FF 
1479   A850 FF FF FF FF 
1479   A854 FF FF FF FF 
1479   A858 FF FF FF FF 
1479   A85C FF FF FF FF 
1479   A860 FF FF FF FF 
1479   A864 FF FF FF FF 
1479   A868 FF FF FF FF 
1479   A86C FF FF FF FF 
1479   A870 FF FF FF FF 
1479   A874 FF FF FF FF 
1479   A878 FF FF FF FF 
1479   A87C FF FF FF FF 
1479   A880 FF FF FF FF 
1479   A884 FF FF FF FF 
1479   A888 FF FF FF FF 
1479   A88C FF FF FF FF 
1479   A890 FF FF FF FF 
1479   A894 FF FF FF FF 
1479   A898 FF FF FF FF 
1479   A89C FF FF FF FF 
1479   A8A0 FF FF FF FF 
1479   A8A4 FF FF FF FF 
1479   A8A8 FF FF FF FF 
1479   A8AC FF FF FF FF 
1479   A8B0 FF FF FF FF 
1479   A8B4 FF FF FF FF 
1479   A8B8 FF FF FF FF 
1479   A8BC FF FF FF FF 
1479   A8C0 FF FF FF FF 
1479   A8C4 FF FF FF FF 
1479   A8C8 FF FF FF FF 
1479   A8CC FF FF FF FF 
1479   A8D0 FF FF FF FF 
1479   A8D4 FF FF FF FF 
1479   A8D8 FF FF FF FF 
1479   A8DC FF FF FF FF 
1479   A8E0 FF FF FF FF 
1479   A8E4 FF FF FF FF 
1479   A8E8 FF FF FF FF 
1479   A8EC FF FF FF FF 
1479   A8F0 FF FF FF FF 
1479   A8F4 FF FF FF FF 
1479   A8F8 FF FF FF FF 
1479   A8FC FF FF FF FF 
1479   A900 FF FF FF FF 
1479   A904 FF FF FF FF 
1479   A908 FF FF FF FF 
1479   A90C FF FF FF FF 
1479   A910 FF FF FF FF 
1479   A914 FF FF FF FF 
1479   A918 FF FF FF FF 
1479   A91C FF FF FF FF 
1479   A920 FF FF FF FF 
1479   A924 FF FF FF FF 
1479   A928 FF FF FF FF 
1479   A92C FF FF FF FF 
1479   A930 FF FF FF FF 
1479   A934 FF FF FF FF 
1479   A938 FF FF FF FF 
1479   A93C FF FF FF FF 
1479   A940 FF FF FF FF 
1479   A944 FF FF FF FF 
1479   A948 FF FF FF FF 
1479   A94C FF FF FF FF 
1479   A950 FF FF FF FF 
1479   A954 FF FF FF FF 
1479   A958 FF FF FF FF 
1479   A95C FF FF FF FF 
1479   A960 FF FF FF FF 
1479   A964 FF FF FF FF 
1479   A968 FF FF FF FF 
1479   A96C FF FF FF FF 
1479   A970 FF FF FF FF 
1479   A974 FF FF FF FF 
1479   A978 FF FF FF FF 
1479   A97C FF FF FF FF 
1479   A980 FF FF FF FF 
1479   A984 FF FF FF FF 
1479   A988 FF FF FF FF 
1479   A98C FF FF FF FF 
1479   A990 FF FF FF FF 
1479   A994 FF FF FF FF 
1479   A998 FF FF FF FF 
1479   A99C FF FF FF FF 
1479   A9A0 FF FF FF FF 
1479   A9A4 FF FF FF FF 
1479   A9A8 FF FF FF FF 
1479   A9AC FF FF FF FF 
1479   A9B0 FF FF FF FF 
1479   A9B4 FF FF FF FF 
1479   A9B8 FF FF FF FF 
1479   A9BC FF FF FF FF 
1479   A9C0 FF FF FF FF 
1479   A9C4 FF FF FF FF 
1479   A9C8 FF FF FF FF 
1479   A9CC FF FF FF FF 
1479   A9D0 FF FF FF FF 
1479   A9D4 FF FF FF FF 
1479   A9D8 FF FF FF FF 
1479   A9DC FF FF FF FF 
1479   A9E0 FF FF FF FF 
1479   A9E4 FF FF FF FF 
1479   A9E8 FF FF FF FF 
1479   A9EC FF FF FF FF 
1479   A9F0 FF FF FF FF 
1479   A9F4 FF FF FF FF 
1479   A9F8 FF FF FF FF 
1479   A9FC FF FF FF FF 
1479   AA00 FF FF FF FF 
1479   AA04 FF FF FF FF 
1479   AA08 FF FF FF FF 
1479   AA0C FF FF FF FF 
1479   AA10 FF FF FF FF 
1479   AA14 FF FF FF FF 
1479   AA18 FF FF FF FF 
1479   AA1C FF FF FF FF 
1479   AA20 FF FF FF FF 
1479   AA24 FF FF FF FF 
1479   AA28 FF FF FF FF 
1479   AA2C FF FF FF FF 
1479   AA30 FF FF FF FF 
1479   AA34 FF FF FF FF 
1479   AA38 FF FF FF FF 
1479   AA3C FF FF FF FF 
1479   AA40 FF FF FF FF 
1479   AA44 FF FF FF FF 
1479   AA48 FF FF FF FF 
1479   AA4C FF FF FF FF 
1479   AA50 FF FF FF FF 
1479   AA54 FF FF FF FF 
1479   AA58 FF FF FF FF 
1479   AA5C FF FF FF FF 
1479   AA60 FF FF FF FF 
1479   AA64 FF FF FF FF 
1479   AA68 FF FF FF FF 
1479   AA6C FF FF FF FF 
1479   AA70 FF FF FF FF 
1479   AA74 FF FF FF FF 
1479   AA78 FF FF FF FF 
1479   AA7C FF FF FF FF 
1479   AA80 FF FF FF FF 
1479   AA84 FF FF FF FF 
1479   AA88 FF FF FF FF 
1479   AA8C FF FF FF FF 
1479   AA90 FF FF FF FF 
1479   AA94 FF FF FF FF 
1479   AA98 FF FF FF FF 
1479   AA9C FF FF FF FF 
1479   AAA0 FF FF FF FF 
1479   AAA4 FF FF FF FF 
1479   AAA8 FF FF FF FF 
1479   AAAC FF FF FF FF 
1479   AAB0 FF FF FF FF 
1479   AAB4 FF FF FF FF 
1479   AAB8 FF FF FF FF 
1479   AABC FF FF FF FF 
1479   AAC0 FF FF FF FF 
1479   AAC4 FF FF FF FF 
1479   AAC8 FF FF FF FF 
1479   AACC FF FF FF FF 
1479   AAD0 FF FF FF FF 
1479   AAD4 FF FF FF FF 
1479   AAD8 FF FF FF FF 
1479   AADC FF FF FF FF 
1479   AAE0 FF FF FF FF 
1479   AAE4 FF FF FF FF 
1479   AAE8 FF FF FF FF 
1479   AAEC FF FF FF FF 
1479   AAF0 FF FF FF FF 
1479   AAF4 FF FF FF FF 
1479   AAF8 FF FF FF FF 
1479   AAFC FF FF FF FF 
1479   AB00 FF FF FF FF 
1479   AB04 FF FF FF FF 
1479   AB08 FF FF FF FF 
1479   AB0C FF FF FF FF 
1479   AB10 FF FF FF FF 
1479   AB14 FF FF FF FF 
1479   AB18 FF FF FF FF 
1479   AB1C FF FF FF FF 
1479   AB20 FF FF FF FF 
1479   AB24 FF FF FF FF 
1479   AB28 FF FF FF FF 
1479   AB2C FF FF FF FF 
1479   AB30 FF FF FF FF 
1479   AB34 FF FF FF FF 
1479   AB38 FF FF FF FF 
1479   AB3C FF FF FF FF 
1479   AB40 FF FF FF FF 
1479   AB44 FF FF FF FF 
1479   AB48 FF FF FF FF 
1479   AB4C FF FF FF FF 
1479   AB50 FF FF FF FF 
1479   AB54 FF FF FF FF 
1479   AB58 FF FF FF FF 
1479   AB5C FF FF FF FF 
1479   AB60 FF FF FF FF 
1479   AB64 FF FF FF FF 
1479   AB68 FF FF FF FF 
1479   AB6C FF FF FF FF 
1479   AB70 FF FF FF FF 
1479   AB74 FF FF FF FF 
1479   AB78 FF FF FF FF 
1479   AB7C FF FF FF FF 
1479   AB80 FF FF FF FF 
1479   AB84 FF FF FF FF 
1479   AB88 FF FF FF FF 
1479   AB8C FF FF FF FF 
1479   AB90 FF FF FF FF 
1479   AB94 FF FF FF FF 
1479   AB98 FF FF FF FF 
1479   AB9C FF FF FF FF 
1479   ABA0 FF FF FF FF 
1479   ABA4 FF FF FF FF 
1479   ABA8 FF FF FF FF 
1479   ABAC FF FF FF FF 
1479   ABB0 FF FF FF FF 
1479   ABB4 FF FF FF FF 
1479   ABB8 FF FF FF FF 
1479   ABBC FF FF FF FF 
1479   ABC0 FF FF FF FF 
1479   ABC4 FF FF FF FF 
1479   ABC8 FF FF FF FF 
1479   ABCC FF FF FF FF 
1479   ABD0 FF FF FF FF 
1479   ABD4 FF FF FF FF 
1479   ABD8 FF FF FF FF 
1479   ABDC FF FF FF FF 
1479   ABE0 FF FF FF FF 
1479   ABE4 FF FF FF FF 
1479   ABE8 FF FF FF FF 
1479   ABEC FF FF FF FF 
1479   ABF0 FF FF FF FF 
1479   ABF4 FF FF FF FF 
1479   ABF8 FF FF FF FF 
1479   ABFC FF FF FF FF 
1479   AC00 FF FF FF FF 
1479   AC04 FF FF FF FF 
1479   AC08 FF FF FF FF 
1479   AC0C FF FF FF FF 
1479   AC10 FF FF FF FF 
1479   AC14 FF FF FF FF 
1479   AC18 FF FF FF FF 
1479   AC1C FF FF FF FF 
1479   AC20 FF FF FF FF 
1479   AC24 FF FF FF FF 
1479   AC28 FF FF FF FF 
1479   AC2C FF FF FF FF 
1479   AC30 FF FF FF FF 
1479   AC34 FF FF FF FF 
1479   AC38 FF FF FF FF 
1479   AC3C FF FF FF FF 
1479   AC40 FF FF FF FF 
1479   AC44 FF FF FF FF 
1479   AC48 FF FF FF FF 
1479   AC4C FF FF FF FF 
1479   AC50 FF FF FF FF 
1479   AC54 FF FF FF FF 
1479   AC58 FF FF FF FF 
1479   AC5C FF FF FF FF 
1479   AC60 FF FF FF FF 
1479   AC64 FF FF FF FF 
1479   AC68 FF FF FF FF 
1479   AC6C FF FF FF FF 
1479   AC70 FF FF FF FF 
1479   AC74 FF FF FF FF 
1479   AC78 FF FF FF FF 
1479   AC7C FF FF FF FF 
1479   AC80 FF FF FF FF 
1479   AC84 FF FF FF FF 
1479   AC88 FF FF FF FF 
1479   AC8C FF FF FF FF 
1479   AC90 FF FF FF FF 
1479   AC94 FF FF FF FF 
1479   AC98 FF FF FF FF 
1479   AC9C FF FF FF FF 
1479   ACA0 FF FF FF FF 
1479   ACA4 FF FF FF FF 
1479   ACA8 FF FF FF FF 
1479   ACAC FF FF FF FF 
1479   ACB0 FF FF FF FF 
1479   ACB4 FF FF FF FF 
1479   ACB8 FF FF FF FF 
1479   ACBC FF FF FF FF 
1479   ACC0 FF FF FF FF 
1479   ACC4 FF FF FF FF 
1479   ACC8 FF FF FF FF 
1479   ACCC FF FF FF FF 
1479   ACD0 FF FF FF FF 
1479   ACD4 FF FF FF FF 
1479   ACD8 FF FF FF FF 
1479   ACDC FF FF FF FF 
1479   ACE0 FF FF FF FF 
1479   ACE4 FF FF FF FF 
1479   ACE8 FF FF FF FF 
1479   ACEC FF FF FF FF 
1479   ACF0 FF FF FF FF 
1479   ACF4 FF FF FF FF 
1479   ACF8 FF FF FF FF 
1479   ACFC FF FF FF FF 
1479   AD00 FF FF FF FF 
1479   AD04 FF FF FF FF 
1479   AD08 FF FF FF FF 
1479   AD0C FF FF FF FF 
1479   AD10 FF FF FF FF 
1479   AD14 FF FF FF FF 
1479   AD18 FF FF FF FF 
1479   AD1C FF FF FF FF 
1479   AD20 FF FF FF FF 
1479   AD24 FF FF FF FF 
1479   AD28 FF FF FF FF 
1479   AD2C FF FF FF FF 
1479   AD30 FF FF FF FF 
1479   AD34 FF FF FF FF 
1479   AD38 FF FF FF FF 
1479   AD3C FF FF FF FF 
1479   AD40 FF FF FF FF 
1479   AD44 FF FF FF FF 
1479   AD48 FF FF FF FF 
1479   AD4C FF FF FF FF 
1479   AD50 FF FF FF FF 
1479   AD54 FF FF FF FF 
1479   AD58 FF FF FF FF 
1479   AD5C FF FF FF FF 
1479   AD60 FF FF FF FF 
1479   AD64 FF FF FF FF 
1479   AD68 FF FF FF FF 
1479   AD6C FF FF FF FF 
1479   AD70 FF FF FF FF 
1479   AD74 FF FF FF FF 
1479   AD78 FF FF FF FF 
1479   AD7C FF FF FF FF 
1479   AD80 FF FF FF FF 
1479   AD84 FF FF FF FF 
1479   AD88 FF FF FF FF 
1479   AD8C FF FF FF FF 
1479   AD90 FF FF FF FF 
1479   AD94 FF FF FF FF 
1479   AD98 FF FF FF FF 
1479   AD9C FF FF FF FF 
1479   ADA0 FF FF FF FF 
1479   ADA4 FF FF FF FF 
1479   ADA8 FF FF FF FF 
1479   ADAC FF FF FF FF 
1479   ADB0 FF FF FF FF 
1479   ADB4 FF FF FF FF 
1479   ADB8 FF FF FF FF 
1479   ADBC FF FF FF FF 
1479   ADC0 FF FF FF FF 
1479   ADC4 FF FF FF FF 
1479   ADC8 FF FF FF FF 
1479   ADCC FF FF FF FF 
1479   ADD0 FF FF FF FF 
1479   ADD4 FF FF FF FF 
1479   ADD8 FF FF FF FF 
1479   ADDC FF FF FF FF 
1479   ADE0 FF FF FF FF 
1479   ADE4 FF FF FF FF 
1479   ADE8 FF FF FF FF 
1479   ADEC FF FF FF FF 
1479   ADF0 FF FF FF FF 
1479   ADF4 FF FF FF FF 
1479   ADF8 FF FF FF FF 
1479   ADFC FF FF FF FF 
1479   AE00 FF FF FF FF 
1479   AE04 FF FF FF FF 
1479   AE08 FF FF FF FF 
1479   AE0C FF FF FF FF 
1479   AE10 FF FF FF FF 
1479   AE14 FF FF FF FF 
1479   AE18 FF FF FF FF 
1479   AE1C FF FF FF FF 
1479   AE20 FF FF FF FF 
1479   AE24 FF FF FF FF 
1479   AE28 FF FF FF FF 
1479   AE2C FF FF FF FF 
1479   AE30 FF FF FF FF 
1479   AE34 FF FF FF FF 
1479   AE38 FF FF FF FF 
1479   AE3C FF FF FF FF 
1479   AE40 FF FF FF FF 
1479   AE44 FF FF FF FF 
1479   AE48 FF FF FF FF 
1479   AE4C FF FF FF FF 
1479   AE50 FF FF FF FF 
1479   AE54 FF FF FF FF 
1479   AE58 FF FF FF FF 
1479   AE5C FF FF FF FF 
1479   AE60 FF FF FF FF 
1479   AE64 FF FF FF FF 
1479   AE68 FF FF FF FF 
1479   AE6C FF FF FF FF 
1479   AE70 FF FF FF FF 
1479   AE74 FF FF FF FF 
1479   AE78 FF FF FF FF 
1479   AE7C FF FF FF FF 
1479   AE80 FF FF FF FF 
1479   AE84 FF FF FF FF 
1479   AE88 FF FF FF FF 
1479   AE8C FF FF FF FF 
1479   AE90 FF FF FF FF 
1479   AE94 FF FF FF FF 
1479   AE98 FF FF FF FF 
1479   AE9C FF FF FF FF 
1479   AEA0 FF FF FF FF 
1479   AEA4 FF FF FF FF 
1479   AEA8 FF FF FF FF 
1479   AEAC FF FF FF FF 
1479   AEB0 FF FF FF FF 
1479   AEB4 FF FF FF FF 
1479   AEB8 FF FF FF FF 
1479   AEBC FF FF FF FF 
1479   AEC0 FF FF FF FF 
1479   AEC4 FF FF FF FF 
1479   AEC8 FF FF FF FF 
1479   AECC FF FF FF FF 
1479   AED0 FF FF FF FF 
1479   AED4 FF FF FF FF 
1479   AED8 FF FF FF FF 
1479   AEDC FF FF FF FF 
1479   AEE0 FF FF FF FF 
1479   AEE4 FF FF FF FF 
1479   AEE8 FF FF FF FF 
1479   AEEC FF FF FF FF 
1479   AEF0 FF FF FF FF 
1479   AEF4 FF FF FF FF 
1479   AEF8 FF FF FF FF 
1479   AEFC FF FF FF FF 
1479   AF00 FF FF FF FF 
1479   AF04 FF FF FF FF 
1479   AF08 FF FF FF FF 
1479   AF0C FF FF FF FF 
1479   AF10 FF FF FF FF 
1479   AF14 FF FF FF FF 
1479   AF18 FF FF FF FF 
1479   AF1C FF FF FF FF 
1479   AF20 FF FF FF FF 
1479   AF24 FF FF FF FF 
1479   AF28 FF FF FF FF 
1479   AF2C FF FF FF FF 
1479   AF30 FF FF FF FF 
1479   AF34 FF FF FF FF 
1479   AF38 FF FF FF FF 
1479   AF3C FF FF FF FF 
1479   AF40 FF FF FF FF 
1479   AF44 FF FF FF FF 
1479   AF48 FF FF FF FF 
1479   AF4C FF FF FF FF 
1479   AF50 FF FF FF FF 
1479   AF54 FF FF FF FF 
1479   AF58 FF FF FF FF 
1479   AF5C FF FF FF FF 
1479   AF60 FF FF FF FF 
1479   AF64 FF FF FF FF 
1479   AF68 FF FF FF FF 
1479   AF6C FF FF FF FF 
1479   AF70 FF FF FF FF 
1479   AF74 FF FF FF FF 
1479   AF78 FF FF FF FF 
1479   AF7C FF FF FF FF 
1479   AF80 FF FF FF FF 
1479   AF84 FF FF FF FF 
1479   AF88 FF FF FF FF 
1479   AF8C FF FF FF FF 
1479   AF90 FF FF FF FF 
1479   AF94 FF FF FF FF 
1479   AF98 FF FF FF FF 
1479   AF9C FF FF FF FF 
1479   AFA0 FF FF FF FF 
1479   AFA4 FF FF FF FF 
1479   AFA8 FF FF FF FF 
1479   AFAC FF FF FF FF 
1479   AFB0 FF FF FF FF 
1479   AFB4 FF FF FF FF 
1479   AFB8 FF FF FF FF 
1479   AFBC FF FF FF FF 
1479   AFC0 FF FF FF FF 
1479   AFC4 FF FF FF FF 
1479   AFC8 FF FF FF FF 
1479   AFCC FF FF FF FF 
1479   AFD0 FF FF FF FF 
1479   AFD4 FF FF FF FF 
1479   AFD8 FF FF FF FF 
1479   AFDC FF FF FF FF 
1479   AFE0 FF FF FF FF 
1479   AFE4 FF FF FF FF 
1479   AFE8 FF FF FF FF 
1479   AFEC FF FF FF FF 
1479   AFF0 FF FF FF FF 
1479   AFF4 FF FF FF FF 
1479   AFF8 FF FF FF FF 
1479   AFFC FF FF FF FF 
1479   B000 FF FF FF FF 
1479   B004 FF FF FF FF 
1479   B008 FF FF FF FF 
1479   B00C FF FF FF FF 
1479   B010 FF FF FF FF 
1479   B014 FF FF FF FF 
1479   B018 FF FF FF FF 
1479   B01C FF FF FF FF 
1479   B020 FF FF FF FF 
1479   B024 FF FF FF FF 
1479   B028 FF FF FF FF 
1479   B02C FF FF FF FF 
1479   B030 FF FF FF FF 
1479   B034 FF FF FF FF 
1479   B038 FF FF FF FF 
1479   B03C FF FF FF FF 
1479   B040 FF FF FF FF 
1479   B044 FF FF FF FF 
1479   B048 FF FF FF FF 
1479   B04C FF FF FF FF 
1479   B050 FF FF FF FF 
1479   B054 FF FF FF FF 
1479   B058 FF FF FF FF 
1479   B05C FF FF FF FF 
1479   B060 FF FF FF FF 
1479   B064 FF FF FF FF 
1479   B068 FF FF FF FF 
1479   B06C FF FF FF FF 
1479   B070 FF FF FF FF 
1479   B074 FF FF FF FF 
1479   B078 FF FF FF FF 
1479   B07C FF FF FF FF 
1479   B080 FF FF FF FF 
1479   B084 FF FF FF FF 
1479   B088 FF FF FF FF 
1479   B08C FF FF FF FF 
1479   B090 FF FF FF FF 
1479   B094 FF FF FF FF 
1479   B098 FF FF FF FF 
1479   B09C FF FF FF FF 
1479   B0A0 FF FF FF FF 
1479   B0A4 FF FF FF FF 
1479   B0A8 FF FF FF FF 
1479   B0AC FF FF FF FF 
1479   B0B0 FF FF FF FF 
1479   B0B4 FF FF FF FF 
1479   B0B8 FF FF FF FF 
1479   B0BC FF FF FF FF 
1479   B0C0 FF FF FF FF 
1479   B0C4 FF FF FF FF 
1479   B0C8 FF FF FF FF 
1479   B0CC FF FF FF FF 
1479   B0D0 FF FF FF FF 
1479   B0D4 FF FF FF FF 
1479   B0D8 FF FF FF FF 
1479   B0DC FF FF FF FF 
1479   B0E0 FF FF FF FF 
1479   B0E4 FF FF FF FF 
1479   B0E8 FF FF FF FF 
1479   B0EC FF FF FF FF 
1479   B0F0 FF FF FF FF 
1479   B0F4 FF FF FF FF 
1479   B0F8 FF FF FF FF 
1479   B0FC FF FF FF FF 
1479   B100 FF FF FF FF 
1479   B104 FF FF FF FF 
1479   B108 FF FF FF FF 
1479   B10C FF FF FF FF 
1479   B110 FF FF FF FF 
1479   B114 FF FF FF FF 
1479   B118 FF FF FF FF 
1479   B11C FF FF FF FF 
1479   B120 FF FF FF FF 
1479   B124 FF FF FF FF 
1479   B128 FF FF FF FF 
1479   B12C FF FF FF FF 
1479   B130 FF FF FF FF 
1479   B134 FF FF FF FF 
1479   B138 FF FF FF FF 
1479   B13C FF FF FF FF 
1479   B140 FF FF FF FF 
1479   B144 FF FF FF FF 
1479   B148 FF FF FF FF 
1479   B14C FF FF FF FF 
1479   B150 FF FF FF FF 
1479   B154 FF FF FF FF 
1479   B158 FF FF FF FF 
1479   B15C FF FF FF FF 
1479   B160 FF FF FF FF 
1479   B164 FF FF FF FF 
1479   B168 FF FF FF FF 
1479   B16C FF FF FF FF 
1479   B170 FF FF FF FF 
1479   B174 FF FF FF FF 
1479   B178 FF FF FF FF 
1479   B17C FF FF FF FF 
1479   B180 FF FF FF FF 
1479   B184 FF FF FF FF 
1479   B188 FF FF FF FF 
1479   B18C FF FF FF FF 
1479   B190 FF FF FF FF 
1479   B194 FF FF FF FF 
1479   B198 FF FF FF FF 
1479   B19C FF FF FF FF 
1479   B1A0 FF FF FF FF 
1479   B1A4 FF FF FF FF 
1479   B1A8 FF FF FF FF 
1479   B1AC FF FF FF FF 
1479   B1B0 FF FF FF FF 
1479   B1B4 FF FF FF FF 
1479   B1B8 FF FF FF FF 
1479   B1BC FF FF FF FF 
1479   B1C0 FF FF FF FF 
1479   B1C4 FF FF FF FF 
1479   B1C8 FF FF FF FF 
1479   B1CC FF FF FF FF 
1479   B1D0 FF FF FF FF 
1479   B1D4 FF FF FF FF 
1479   B1D8 FF FF FF FF 
1479   B1DC FF FF FF FF 
1479   B1E0 FF FF FF FF 
1479   B1E4 FF FF FF FF 
1479   B1E8 FF FF FF FF 
1479   B1EC FF FF FF FF 
1479   B1F0 FF FF FF FF 
1479   B1F4 FF FF FF FF 
1479   B1F8 FF FF FF FF 
1479   B1FC FF FF FF FF 
1479   B200 FF FF FF FF 
1479   B204 FF FF FF FF 
1479   B208 FF FF FF FF 
1479   B20C FF FF FF FF 
1479   B210 FF FF FF FF 
1479   B214 FF FF FF FF 
1479   B218 FF FF FF FF 
1479   B21C FF FF FF FF 
1479   B220 FF FF FF FF 
1479   B224 FF FF FF FF 
1479   B228 FF FF FF FF 
1479   B22C FF FF FF FF 
1479   B230 FF FF FF FF 
1479   B234 FF FF FF FF 
1479   B238 FF FF FF FF 
1479   B23C FF FF FF FF 
1479   B240 FF FF FF FF 
1479   B244 FF FF FF FF 
1479   B248 FF FF FF FF 
1479   B24C FF FF FF FF 
1479   B250 FF FF FF FF 
1479   B254 FF FF FF FF 
1479   B258 FF FF FF FF 
1479   B25C FF FF FF FF 
1479   B260 FF FF FF FF 
1479   B264 FF FF FF FF 
1479   B268 FF FF FF FF 
1479   B26C FF FF FF FF 
1479   B270 FF FF FF FF 
1479   B274 FF FF FF FF 
1479   B278 FF FF FF FF 
1479   B27C FF FF FF FF 
1479   B280 FF FF FF FF 
1479   B284 FF FF FF FF 
1479   B288 FF FF FF FF 
1479   B28C FF FF FF FF 
1479   B290 FF FF FF FF 
1479   B294 FF FF FF FF 
1479   B298 FF FF FF FF 
1479   B29C FF FF FF FF 
1479   B2A0 FF FF FF FF 
1479   B2A4 FF FF FF FF 
1479   B2A8 FF FF FF FF 
1479   B2AC FF FF FF FF 
1479   B2B0 FF FF FF FF 
1479   B2B4 FF FF FF FF 
1479   B2B8 FF FF FF FF 
1479   B2BC FF FF FF FF 
1479   B2C0 FF FF FF FF 
1479   B2C4 FF FF FF FF 
1479   B2C8 FF FF FF FF 
1479   B2CC FF FF FF FF 
1479   B2D0 FF FF FF FF 
1479   B2D4 FF FF FF FF 
1479   B2D8 FF FF FF FF 
1479   B2DC FF FF FF FF 
1479   B2E0 FF FF FF FF 
1479   B2E4 FF FF FF FF 
1479   B2E8 FF FF FF FF 
1479   B2EC FF FF FF FF 
1479   B2F0 FF FF FF FF 
1479   B2F4 FF FF FF FF 
1479   B2F8 FF FF FF FF 
1479   B2FC FF FF FF FF 
1479   B300 FF FF FF FF 
1479   B304 FF FF FF FF 
1479   B308 FF FF FF FF 
1479   B30C FF FF FF FF 
1479   B310 FF FF FF FF 
1479   B314 FF FF FF FF 
1479   B318 FF FF FF FF 
1479   B31C FF FF FF FF 
1479   B320 FF FF FF FF 
1479   B324 FF FF FF FF 
1479   B328 FF FF FF FF 
1479   B32C FF FF FF FF 
1479   B330 FF FF FF FF 
1479   B334 FF FF FF FF 
1479   B338 FF FF FF FF 
1479   B33C FF FF FF FF 
1479   B340 FF FF FF FF 
1479   B344 FF FF FF FF 
1479   B348 FF FF FF FF 
1479   B34C FF FF FF FF 
1479   B350 FF FF FF FF 
1479   B354 FF FF FF FF 
1479   B358 FF FF FF FF 
1479   B35C FF FF FF FF 
1479   B360 FF FF FF FF 
1479   B364 FF FF FF FF 
1479   B368 FF FF FF FF 
1479   B36C FF FF FF FF 
1479   B370 FF FF FF FF 
1479   B374 FF FF FF FF 
1479   B378 FF FF FF FF 
1479   B37C FF FF FF FF 
1479   B380 FF FF FF FF 
1479   B384 FF FF FF FF 
1479   B388 FF FF FF FF 
1479   B38C FF FF FF FF 
1479   B390 FF FF FF FF 
1479   B394 FF FF FF FF 
1479   B398 FF FF FF FF 
1479   B39C FF FF FF FF 
1479   B3A0 FF FF FF FF 
1479   B3A4 FF FF FF FF 
1479   B3A8 FF FF FF FF 
1479   B3AC FF FF FF FF 
1479   B3B0 FF FF FF FF 
1479   B3B4 FF FF FF FF 
1479   B3B8 FF FF FF FF 
1479   B3BC FF FF FF FF 
1479   B3C0 FF FF FF FF 
1479   B3C4 FF FF FF FF 
1479   B3C8 FF FF FF FF 
1479   B3CC FF FF FF FF 
1479   B3D0 FF FF FF FF 
1479   B3D4 FF FF FF FF 
1479   B3D8 FF FF FF FF 
1479   B3DC FF FF FF FF 
1479   B3E0 FF FF FF FF 
1479   B3E4 FF FF FF FF 
1479   B3E8 FF FF FF FF 
1479   B3EC FF FF FF FF 
1479   B3F0 FF FF FF FF 
1479   B3F4 FF FF FF FF 
1479   B3F8 FF FF FF FF 
1479   B3FC FF FF FF FF 
1479   B400 FF FF FF FF 
1479   B404 FF FF FF FF 
1479   B408 FF FF FF FF 
1479   B40C FF FF FF FF 
1479   B410 FF FF FF FF 
1479   B414 FF FF FF FF 
1479   B418 FF FF FF FF 
1479   B41C FF FF FF FF 
1479   B420 FF FF FF FF 
1479   B424 FF FF FF FF 
1479   B428 FF FF FF FF 
1479   B42C FF FF FF FF 
1479   B430 FF FF FF FF 
1479   B434 FF FF FF FF 
1479   B438 FF FF FF FF 
1479   B43C FF FF FF FF 
1479   B440 FF FF FF FF 
1479   B444 FF FF FF FF 
1479   B448 FF FF FF FF 
1479   B44C FF FF FF FF 
1479   B450 FF FF FF FF 
1479   B454 FF FF FF FF 
1479   B458 FF FF FF FF 
1479   B45C FF FF FF FF 
1479   B460 FF FF FF FF 
1479   B464 FF FF FF FF 
1479   B468 FF FF FF FF 
1479   B46C FF FF FF FF 
1479   B470 FF FF FF FF 
1479   B474 FF FF FF FF 
1479   B478 FF FF FF FF 
1479   B47C FF FF FF FF 
1479   B480 FF FF FF FF 
1479   B484 FF FF FF FF 
1479   B488 FF FF FF FF 
1479   B48C FF FF FF FF 
1479   B490 FF FF FF FF 
1479   B494 FF FF FF FF 
1479   B498 FF FF FF FF 
1479   B49C FF FF FF FF 
1479   B4A0 FF FF FF FF 
1479   B4A4 FF FF FF FF 
1479   B4A8 FF FF FF FF 
1479   B4AC FF FF FF FF 
1479   B4B0 FF FF FF FF 
1479   B4B4 FF FF FF FF 
1479   B4B8 FF FF FF FF 
1479   B4BC FF FF FF FF 
1479   B4C0 FF FF FF FF 
1479   B4C4 FF FF FF FF 
1479   B4C8 FF FF FF FF 
1479   B4CC FF FF FF FF 
1479   B4D0 FF FF FF FF 
1479   B4D4 FF FF FF FF 
1479   B4D8 FF FF FF FF 
1479   B4DC FF FF FF FF 
1479   B4E0 FF FF FF FF 
1479   B4E4 FF FF FF FF 
1479   B4E8 FF FF FF FF 
1479   B4EC FF FF FF FF 
1479   B4F0 FF FF FF FF 
1479   B4F4 FF FF FF FF 
1479   B4F8 FF FF FF FF 
1479   B4FC FF FF FF FF 
1479   B500 FF FF FF FF 
1479   B504 FF FF FF FF 
1479   B508 FF FF FF FF 
1479   B50C FF FF FF FF 
1479   B510 FF FF FF FF 
1479   B514 FF FF FF FF 
1479   B518 FF FF FF FF 
1479   B51C FF FF FF FF 
1479   B520 FF FF FF FF 
1479   B524 FF FF FF FF 
1479   B528 FF FF FF FF 
1479   B52C FF FF FF FF 
1479   B530 FF FF FF FF 
1479   B534 FF FF FF FF 
1479   B538 FF FF FF FF 
1479   B53C FF FF FF FF 
1479   B540 FF FF FF FF 
1479   B544 FF FF FF FF 
1479   B548 FF FF FF FF 
1479   B54C FF FF FF FF 
1479   B550 FF FF FF FF 
1479   B554 FF FF FF FF 
1479   B558 FF FF FF FF 
1479   B55C FF FF FF FF 
1479   B560 FF FF FF FF 
1479   B564 FF FF FF FF 
1479   B568 FF FF FF FF 
1479   B56C FF FF FF FF 
1479   B570 FF FF FF FF 
1479   B574 FF FF FF FF 
1479   B578 FF FF FF FF 
1479   B57C FF FF FF FF 
1479   B580 FF FF FF FF 
1479   B584 FF FF FF FF 
1479   B588 FF FF FF FF 
1479   B58C FF FF FF FF 
1479   B590 FF FF FF FF 
1479   B594 FF FF FF FF 
1479   B598 FF FF FF FF 
1479   B59C FF FF FF FF 
1479   B5A0 FF FF FF FF 
1479   B5A4 FF FF FF FF 
1479   B5A8 FF FF FF FF 
1479   B5AC FF FF FF FF 
1479   B5B0 FF FF FF FF 
1479   B5B4 FF FF FF FF 
1479   B5B8 FF FF FF FF 
1479   B5BC FF FF FF FF 
1479   B5C0 FF FF FF FF 
1479   B5C4 FF FF FF FF 
1479   B5C8 FF FF FF FF 
1479   B5CC FF FF FF FF 
1479   B5D0 FF FF FF FF 
1479   B5D4 FF FF FF FF 
1479   B5D8 FF FF FF FF 
1479   B5DC FF FF FF FF 
1479   B5E0 FF FF FF FF 
1479   B5E4 FF FF FF FF 
1479   B5E8 FF FF FF FF 
1479   B5EC FF FF FF FF 
1479   B5F0 FF FF FF FF 
1479   B5F4 FF FF FF FF 
1479   B5F8 FF FF FF FF 
1479   B5FC FF FF FF FF 
1479   B600 FF FF FF FF 
1479   B604 FF FF FF FF 
1479   B608 FF FF FF FF 
1479   B60C FF FF FF FF 
1479   B610 FF FF FF FF 
1479   B614 FF FF FF FF 
1479   B618 FF FF FF FF 
1479   B61C FF FF FF FF 
1479   B620 FF FF FF FF 
1479   B624 FF FF FF FF 
1479   B628 FF FF FF FF 
1479   B62C FF FF FF FF 
1479   B630 FF FF FF FF 
1479   B634 FF FF FF FF 
1479   B638 FF FF FF FF 
1479   B63C FF FF FF FF 
1479   B640 FF FF FF FF 
1479   B644 FF FF FF FF 
1479   B648 FF FF FF FF 
1479   B64C FF FF FF FF 
1479   B650 FF FF FF FF 
1479   B654 FF FF FF FF 
1479   B658 FF FF FF FF 
1479   B65C FF FF FF FF 
1479   B660 FF FF FF FF 
1479   B664 FF FF FF FF 
1479   B668 FF FF FF FF 
1479   B66C FF FF FF FF 
1479   B670 FF FF FF FF 
1479   B674 FF FF FF FF 
1479   B678 FF FF FF FF 
1479   B67C FF FF FF FF 
1479   B680 FF FF FF FF 
1479   B684 FF FF FF FF 
1479   B688 FF FF FF FF 
1479   B68C FF FF FF FF 
1479   B690 FF FF FF FF 
1479   B694 FF FF FF FF 
1479   B698 FF FF FF FF 
1479   B69C FF FF FF FF 
1479   B6A0 FF FF FF FF 
1479   B6A4 FF FF FF FF 
1479   B6A8 FF FF FF FF 
1479   B6AC FF FF FF FF 
1479   B6B0 FF FF FF FF 
1479   B6B4 FF FF FF FF 
1479   B6B8 FF FF FF FF 
1479   B6BC FF FF FF FF 
1479   B6C0 FF FF FF FF 
1479   B6C4 FF FF FF FF 
1479   B6C8 FF FF FF FF 
1479   B6CC FF FF FF FF 
1479   B6D0 FF FF FF FF 
1479   B6D4 FF FF FF FF 
1479   B6D8 FF FF FF FF 
1479   B6DC FF FF FF FF 
1479   B6E0 FF FF FF FF 
1479   B6E4 FF FF FF FF 
1479   B6E8 FF FF FF FF 
1479   B6EC FF FF FF FF 
1479   B6F0 FF FF FF FF 
1479   B6F4 FF FF FF FF 
1479   B6F8 FF FF FF FF 
1479   B6FC FF FF FF FF 
1479   B700 FF FF FF FF 
1479   B704 FF FF FF FF 
1479   B708 FF FF FF FF 
1479   B70C FF FF FF FF 
1479   B710 FF FF FF FF 
1479   B714 FF FF FF FF 
1479   B718 FF FF FF FF 
1479   B71C FF FF FF FF 
1479   B720 FF FF FF FF 
1479   B724 FF FF FF FF 
1479   B728 FF FF FF FF 
1479   B72C FF FF FF FF 
1479   B730 FF FF FF FF 
1479   B734 FF FF FF FF 
1479   B738 FF FF FF FF 
1479   B73C FF FF FF FF 
1479   B740 FF FF FF FF 
1479   B744 FF FF FF FF 
1479   B748 FF FF FF FF 
1479   B74C FF FF FF FF 
1479   B750 FF FF FF FF 
1479   B754 FF FF FF FF 
1479   B758 FF FF FF FF 
1479   B75C FF FF FF FF 
1479   B760 FF FF FF FF 
1479   B764 FF FF FF FF 
1479   B768 FF FF FF FF 
1479   B76C FF FF FF FF 
1479   B770 FF FF FF FF 
1479   B774 FF FF FF FF 
1479   B778 FF FF FF FF 
1479   B77C FF FF FF FF 
1479   B780 FF FF FF FF 
1479   B784 FF FF FF FF 
1479   B788 FF FF FF FF 
1479   B78C FF FF FF FF 
1479   B790 FF FF FF FF 
1479   B794 FF FF FF FF 
1479   B798 FF FF FF FF 
1479   B79C FF FF FF FF 
1479   B7A0 FF FF FF FF 
1479   B7A4 FF FF FF FF 
1479   B7A8 FF FF FF FF 
1479   B7AC FF FF FF FF 
1479   B7B0 FF FF FF FF 
1479   B7B4 FF FF FF FF 
1479   B7B8 FF FF FF FF 
1479   B7BC FF FF FF FF 
1479   B7C0 FF FF FF FF 
1479   B7C4 FF FF FF FF 
1479   B7C8 FF FF FF FF 
1479   B7CC FF FF FF FF 
1479   B7D0 FF FF FF FF 
1479   B7D4 FF FF FF FF 
1479   B7D8 FF FF FF FF 
1479   B7DC FF FF FF FF 
1479   B7E0 FF FF FF FF 
1479   B7E4 FF FF FF FF 
1479   B7E8 FF FF FF FF 
1479   B7EC FF FF FF FF 
1479   B7F0 FF FF FF FF 
1479   B7F4 FF FF FF FF 
1479   B7F8 FF FF FF FF 
1479   B7FC FF FF FF FF 
1479   B800 FF FF FF FF 
1479   B804 FF FF FF FF 
1479   B808 FF FF FF FF 
1479   B80C FF FF FF FF 
1479   B810 FF FF FF FF 
1479   B814 FF FF FF FF 
1479   B818 FF FF FF FF 
1479   B81C FF FF FF FF 
1479   B820 FF FF FF FF 
1479   B824 FF FF FF FF 
1479   B828 FF FF FF FF 
1479   B82C FF FF FF FF 
1479   B830 FF FF FF FF 
1479   B834 FF FF FF FF 
1479   B838 FF FF FF FF 
1479   B83C FF FF FF FF 
1479   B840 FF FF FF FF 
1479   B844 FF FF FF FF 
1479   B848 FF FF FF FF 
1479   B84C FF FF FF FF 
1479   B850 FF FF FF FF 
1479   B854 FF FF FF FF 
1479   B858 FF FF FF FF 
1479   B85C FF FF FF FF 
1479   B860 FF FF FF FF 
1479   B864 FF FF FF FF 
1479   B868 FF FF FF FF 
1479   B86C FF FF FF FF 
1479   B870 FF FF FF FF 
1479   B874 FF FF FF FF 
1479   B878 FF FF FF FF 
1479   B87C FF FF FF FF 
1479   B880 FF FF FF FF 
1479   B884 FF FF FF FF 
1479   B888 FF FF FF FF 
1479   B88C FF FF FF FF 
1479   B890 FF FF FF FF 
1479   B894 FF FF FF FF 
1479   B898 FF FF FF FF 
1479   B89C FF FF FF FF 
1479   B8A0 FF FF FF FF 
1479   B8A4 FF FF FF FF 
1479   B8A8 FF FF FF FF 
1479   B8AC FF FF FF FF 
1479   B8B0 FF FF FF FF 
1479   B8B4 FF FF FF FF 
1479   B8B8 FF FF FF FF 
1479   B8BC FF FF FF FF 
1479   B8C0 FF FF FF FF 
1479   B8C4 FF FF FF FF 
1479   B8C8 FF FF FF FF 
1479   B8CC FF FF FF FF 
1479   B8D0 FF FF FF FF 
1479   B8D4 FF FF FF FF 
1479   B8D8 FF FF FF FF 
1479   B8DC FF FF FF FF 
1479   B8E0 FF FF FF FF 
1479   B8E4 FF FF FF FF 
1479   B8E8 FF FF FF FF 
1479   B8EC FF FF FF FF 
1479   B8F0 FF FF FF FF 
1479   B8F4 FF FF FF FF 
1479   B8F8 FF FF FF FF 
1479   B8FC FF FF FF FF 
1479   B900 FF FF FF FF 
1479   B904 FF FF FF FF 
1479   B908 FF FF FF FF 
1479   B90C FF FF FF FF 
1479   B910 FF FF FF FF 
1479   B914 FF FF FF FF 
1479   B918 FF FF FF FF 
1479   B91C FF FF FF FF 
1479   B920 FF FF FF FF 
1479   B924 FF FF FF FF 
1479   B928 FF FF FF FF 
1479   B92C FF FF FF FF 
1479   B930 FF FF FF FF 
1479   B934 FF FF FF FF 
1479   B938 FF FF FF FF 
1479   B93C FF FF FF FF 
1479   B940 FF FF FF FF 
1479   B944 FF FF FF FF 
1479   B948 FF FF FF FF 
1479   B94C FF FF FF FF 
1479   B950 FF FF FF FF 
1479   B954 FF FF FF FF 
1479   B958 FF FF FF FF 
1479   B95C FF FF FF FF 
1479   B960 FF FF FF FF 
1479   B964 FF FF FF FF 
1479   B968 FF FF FF FF 
1479   B96C FF FF FF FF 
1479   B970 FF FF FF FF 
1479   B974 FF FF FF FF 
1479   B978 FF FF FF FF 
1479   B97C FF FF FF FF 
1479   B980 FF FF FF FF 
1479   B984 FF FF FF FF 
1479   B988 FF FF FF FF 
1479   B98C FF FF FF FF 
1479   B990 FF FF FF FF 
1479   B994 FF FF FF FF 
1479   B998 FF FF FF FF 
1479   B99C FF FF FF FF 
1479   B9A0 FF FF FF FF 
1479   B9A4 FF FF FF FF 
1479   B9A8 FF FF FF FF 
1479   B9AC FF FF FF FF 
1479   B9B0 FF FF FF FF 
1479   B9B4 FF FF FF FF 
1479   B9B8 FF FF FF FF 
1479   B9BC FF FF FF FF 
1479   B9C0 FF FF FF FF 
1479   B9C4 FF FF FF FF 
1479   B9C8 FF FF FF FF 
1479   B9CC FF FF FF FF 
1479   B9D0 FF FF FF FF 
1479   B9D4 FF FF FF FF 
1479   B9D8 FF FF FF FF 
1479   B9DC FF FF FF FF 
1479   B9E0 FF FF FF FF 
1479   B9E4 FF FF FF FF 
1479   B9E8 FF FF FF FF 
1479   B9EC FF FF FF FF 
1479   B9F0 FF FF FF FF 
1479   B9F4 FF FF FF FF 
1479   B9F8 FF FF FF FF 
1479   B9FC FF FF FF FF 
1479   BA00 FF FF FF FF 
1479   BA04 FF FF FF FF 
1479   BA08 FF FF FF FF 
1479   BA0C FF FF FF FF 
1479   BA10 FF FF FF FF 
1479   BA14 FF FF FF FF 
1479   BA18 FF FF FF FF 
1479   BA1C FF FF FF FF 
1479   BA20 FF FF FF FF 
1479   BA24 FF FF FF FF 
1479   BA28 FF FF FF FF 
1479   BA2C FF FF FF FF 
1479   BA30 FF FF FF FF 
1479   BA34 FF FF FF FF 
1479   BA38 FF FF FF FF 
1479   BA3C FF FF FF FF 
1479   BA40 FF FF FF FF 
1479   BA44 FF FF FF FF 
1479   BA48 FF FF FF FF 
1479   BA4C FF FF FF FF 
1479   BA50 FF FF FF FF 
1479   BA54 FF FF FF FF 
1479   BA58 FF FF FF FF 
1479   BA5C FF FF FF FF 
1479   BA60 FF FF FF FF 
1479   BA64 FF FF FF FF 
1479   BA68 FF FF FF FF 
1479   BA6C FF FF FF FF 
1479   BA70 FF FF FF FF 
1479   BA74 FF FF FF FF 
1479   BA78 FF FF FF FF 
1479   BA7C FF FF FF FF 
1479   BA80 FF FF FF FF 
1479   BA84 FF FF FF FF 
1479   BA88 FF FF FF FF 
1479   BA8C FF FF FF FF 
1479   BA90 FF FF FF FF 
1479   BA94 FF FF FF FF 
1479   BA98 FF FF FF FF 
1479   BA9C FF FF FF FF 
1479   BAA0 FF FF FF FF 
1479   BAA4 FF FF FF FF 
1479   BAA8 FF FF FF FF 
1479   BAAC FF FF FF FF 
1479   BAB0 FF FF FF FF 
1479   BAB4 FF FF FF FF 
1479   BAB8 FF FF FF FF 
1479   BABC FF FF FF FF 
1479   BAC0 FF FF FF FF 
1479   BAC4 FF FF FF FF 
1479   BAC8 FF FF FF FF 
1479   BACC FF FF FF FF 
1479   BAD0 FF FF FF FF 
1479   BAD4 FF FF FF FF 
1479   BAD8 FF FF FF FF 
1479   BADC FF FF FF FF 
1479   BAE0 FF FF FF FF 
1479   BAE4 FF FF FF FF 
1479   BAE8 FF FF FF FF 
1479   BAEC FF FF FF FF 
1479   BAF0 FF FF FF FF 
1479   BAF4 FF FF FF FF 
1479   BAF8 FF FF FF FF 
1479   BAFC FF FF FF FF 
1479   BB00 FF FF FF FF 
1479   BB04 FF FF FF FF 
1479   BB08 FF FF FF FF 
1479   BB0C FF FF FF FF 
1479   BB10 FF FF FF FF 
1479   BB14 FF FF FF FF 
1479   BB18 FF FF FF FF 
1479   BB1C FF FF FF FF 
1479   BB20 FF FF FF FF 
1479   BB24 FF FF FF FF 
1479   BB28 FF FF FF FF 
1479   BB2C FF FF FF FF 
1479   BB30 FF FF FF FF 
1479   BB34 FF FF FF FF 
1479   BB38 FF FF FF FF 
1479   BB3C FF FF FF FF 
1479   BB40 FF FF FF FF 
1479   BB44 FF FF FF FF 
1479   BB48 FF FF FF FF 
1479   BB4C FF FF FF FF 
1479   BB50 FF FF FF FF 
1479   BB54 FF FF FF FF 
1479   BB58 FF FF FF FF 
1479   BB5C FF FF FF FF 
1479   BB60 FF FF FF FF 
1479   BB64 FF FF FF FF 
1479   BB68 FF FF FF FF 
1479   BB6C FF FF FF FF 
1479   BB70 FF FF FF FF 
1479   BB74 FF FF FF FF 
1479   BB78 FF FF FF FF 
1479   BB7C FF FF FF FF 
1479   BB80 FF FF FF FF 
1479   BB84 FF FF FF FF 
1479   BB88 FF FF FF FF 
1479   BB8C FF FF FF FF 
1479   BB90 FF FF FF FF 
1479   BB94 FF FF FF FF 
1479   BB98 FF FF FF FF 
1479   BB9C FF FF FF FF 
1479   BBA0 FF FF FF FF 
1479   BBA4 FF FF FF FF 
1479   BBA8 FF FF FF FF 
1479   BBAC FF FF FF FF 
1479   BBB0 FF FF FF FF 
1479   BBB4 FF FF FF FF 
1479   BBB8 FF FF FF FF 
1479   BBBC FF FF FF FF 
1479   BBC0 FF FF FF FF 
1479   BBC4 FF FF FF FF 
1479   BBC8 FF FF FF FF 
1479   BBCC FF FF FF FF 
1479   BBD0 FF FF FF FF 
1479   BBD4 FF FF FF FF 
1479   BBD8 FF FF FF FF 
1479   BBDC FF FF FF FF 
1479   BBE0 FF FF FF FF 
1479   BBE4 FF FF FF FF 
1479   BBE8 FF FF FF FF 
1479   BBEC FF FF FF FF 
1479   BBF0 FF FF FF FF 
1479   BBF4 FF FF FF FF 
1479   BBF8 FF FF FF FF 
1479   BBFC FF FF FF FF 
1479   BC00 FF FF FF FF 
1479   BC04 FF FF FF FF 
1479   BC08 FF FF FF FF 
1479   BC0C FF FF FF FF 
1479   BC10 FF FF FF FF 
1479   BC14 FF FF FF FF 
1479   BC18 FF FF FF FF 
1479   BC1C FF FF FF FF 
1479   BC20 FF FF FF FF 
1479   BC24 FF FF FF FF 
1479   BC28 FF FF FF FF 
1479   BC2C FF FF FF FF 
1479   BC30 FF FF FF FF 
1479   BC34 FF FF FF FF 
1479   BC38 FF FF FF FF 
1479   BC3C FF FF FF FF 
1479   BC40 FF FF FF FF 
1479   BC44 FF FF FF FF 
1479   BC48 FF FF FF FF 
1479   BC4C FF FF FF FF 
1479   BC50 FF FF FF FF 
1479   BC54 FF FF FF FF 
1479   BC58 FF FF FF FF 
1479   BC5C FF FF FF FF 
1479   BC60 FF FF FF FF 
1479   BC64 FF FF FF FF 
1479   BC68 FF FF FF FF 
1479   BC6C FF FF FF FF 
1479   BC70 FF FF FF FF 
1479   BC74 FF FF FF FF 
1479   BC78 FF FF FF FF 
1479   BC7C FF FF FF FF 
1479   BC80 FF FF FF FF 
1479   BC84 FF FF FF FF 
1479   BC88 FF FF FF FF 
1479   BC8C FF FF FF FF 
1479   BC90 FF FF FF FF 
1479   BC94 FF FF FF FF 
1479   BC98 FF FF FF FF 
1479   BC9C FF FF FF FF 
1479   BCA0 FF FF FF FF 
1479   BCA4 FF FF FF FF 
1479   BCA8 FF FF FF FF 
1479   BCAC FF FF FF FF 
1479   BCB0 FF FF FF FF 
1479   BCB4 FF FF FF FF 
1479   BCB8 FF FF FF FF 
1479   BCBC FF FF FF FF 
1479   BCC0 FF FF FF FF 
1479   BCC4 FF FF FF FF 
1479   BCC8 FF FF FF FF 
1479   BCCC FF FF FF FF 
1479   BCD0 FF FF FF FF 
1479   BCD4 FF FF FF FF 
1479   BCD8 FF FF FF FF 
1479   BCDC FF FF FF FF 
1479   BCE0 FF FF FF FF 
1479   BCE4 FF FF FF FF 
1479   BCE8 FF FF FF FF 
1479   BCEC FF FF FF FF 
1479   BCF0 FF FF FF FF 
1479   BCF4 FF FF FF FF 
1479   BCF8 FF FF FF FF 
1479   BCFC FF FF FF FF 
1479   BD00 FF FF FF FF 
1479   BD04 FF FF FF FF 
1479   BD08 FF FF FF FF 
1479   BD0C FF FF FF FF 
1479   BD10 FF FF FF FF 
1479   BD14 FF FF FF FF 
1479   BD18 FF FF FF FF 
1479   BD1C FF FF FF FF 
1479   BD20 FF FF FF FF 
1479   BD24 FF FF FF FF 
1479   BD28 FF FF FF FF 
1479   BD2C FF FF FF FF 
1479   BD30 FF FF FF FF 
1479   BD34 FF FF FF FF 
1479   BD38 FF FF FF FF 
1479   BD3C FF FF FF FF 
1479   BD40 FF FF FF FF 
1479   BD44 FF FF FF FF 
1479   BD48 FF FF FF FF 
1479   BD4C FF FF FF FF 
1479   BD50 FF FF FF FF 
1479   BD54 FF FF FF FF 
1479   BD58 FF FF FF FF 
1479   BD5C FF FF FF FF 
1479   BD60 FF FF FF FF 
1479   BD64 FF FF FF FF 
1479   BD68 FF FF FF FF 
1479   BD6C FF FF FF FF 
1479   BD70 FF FF FF FF 
1479   BD74 FF FF FF FF 
1479   BD78 FF FF FF FF 
1479   BD7C FF FF FF FF 
1479   BD80 FF FF FF FF 
1479   BD84 FF FF FF FF 
1479   BD88 FF FF FF FF 
1479   BD8C FF FF FF FF 
1479   BD90 FF FF FF FF 
1479   BD94 FF FF FF FF 
1479   BD98 FF FF FF FF 
1479   BD9C FF FF FF FF 
1479   BDA0 FF FF FF FF 
1479   BDA4 FF FF FF FF 
1479   BDA8 FF FF FF FF 
1479   BDAC FF FF FF FF 
1479   BDB0 FF FF FF FF 
1479   BDB4 FF FF FF FF 
1479   BDB8 FF FF FF FF 
1479   BDBC FF FF FF FF 
1479   BDC0 FF FF FF FF 
1479   BDC4 FF FF FF FF 
1479   BDC8 FF FF FF FF 
1479   BDCC FF FF FF FF 
1479   BDD0 FF FF FF FF 
1479   BDD4 FF FF FF FF 
1479   BDD8 FF FF FF FF 
1479   BDDC FF FF FF FF 
1479   BDE0 FF FF FF FF 
1479   BDE4 FF FF FF FF 
1479   BDE8 FF FF FF FF 
1479   BDEC FF FF FF FF 
1479   BDF0 FF FF FF FF 
1479   BDF4 FF FF FF FF 
1479   BDF8 FF FF FF FF 
1479   BDFC FF FF FF FF 
1479   BE00 FF FF FF FF 
1479   BE04 FF FF FF FF 
1479   BE08 FF FF FF FF 
1479   BE0C FF FF FF FF 
1479   BE10 FF FF FF FF 
1479   BE14 FF FF FF FF 
1479   BE18 FF FF FF FF 
1479   BE1C FF FF FF FF 
1479   BE20 FF FF FF FF 
1479   BE24 FF FF FF FF 
1479   BE28 FF FF FF FF 
1479   BE2C FF FF FF FF 
1479   BE30 FF FF FF FF 
1479   BE34 FF FF FF FF 
1479   BE38 FF FF FF FF 
1479   BE3C FF FF FF FF 
1479   BE40 FF FF FF FF 
1479   BE44 FF FF FF FF 
1479   BE48 FF FF FF FF 
1479   BE4C FF FF FF FF 
1479   BE50 FF FF FF FF 
1479   BE54 FF FF FF FF 
1479   BE58 FF FF FF FF 
1479   BE5C FF FF FF FF 
1479   BE60 FF FF FF FF 
1479   BE64 FF FF FF FF 
1479   BE68 FF FF FF FF 
1479   BE6C FF FF FF FF 
1479   BE70 FF FF FF FF 
1479   BE74 FF FF FF FF 
1479   BE78 FF FF FF FF 
1479   BE7C FF FF FF FF 
1479   BE80 FF FF FF FF 
1479   BE84 FF FF FF FF 
1479   BE88 FF FF FF FF 
1479   BE8C FF FF FF FF 
1479   BE90 FF FF FF FF 
1479   BE94 FF FF FF FF 
1479   BE98 FF FF FF FF 
1479   BE9C FF FF FF FF 
1479   BEA0 FF FF FF FF 
1479   BEA4 FF FF FF FF 
1479   BEA8 FF FF FF FF 
1479   BEAC FF FF FF FF 
1479   BEB0 FF FF FF FF 
1479   BEB4 FF FF FF FF 
1479   BEB8 FF FF FF FF 
1479   BEBC FF FF FF FF 
1479   BEC0 FF FF FF FF 
1479   BEC4 FF FF FF FF 
1479   BEC8 FF FF FF FF 
1479   BECC FF FF FF FF 
1479   BED0 FF FF FF FF 
1479   BED4 FF FF FF FF 
1479   BED8 FF FF FF FF 
1479   BEDC FF FF FF FF 
1479   BEE0 FF FF FF FF 
1479   BEE4 FF FF FF FF 
1479   BEE8 FF FF FF FF 
1479   BEEC FF FF FF FF 
1479   BEF0 FF FF FF FF 
1479   BEF4 FF FF FF FF 
1479   BEF8 FF FF FF FF 
1479   BEFC FF FF FF FF 
1479   BF00 FF FF FF FF 
1479   BF04 FF FF FF FF 
1479   BF08 FF FF FF FF 
1479   BF0C FF FF FF FF 
1479   BF10 FF FF FF FF 
1479   BF14 FF FF FF FF 
1479   BF18 FF FF FF FF 
1479   BF1C FF FF FF FF 
1479   BF20 FF FF FF FF 
1479   BF24 FF FF FF FF 
1479   BF28 FF FF FF FF 
1479   BF2C FF FF FF FF 
1479   BF30 FF FF FF FF 
1479   BF34 FF FF FF FF 
1479   BF38 FF FF FF FF 
1479   BF3C FF FF FF FF 
1479   BF40 FF FF FF FF 
1479   BF44 FF FF FF FF 
1479   BF48 FF FF FF FF 
1479   BF4C FF FF FF FF 
1479   BF50 FF FF FF FF 
1479   BF54 FF FF FF FF 
1479   BF58 FF FF FF FF 
1479   BF5C FF FF FF FF 
1479   BF60 FF FF FF FF 
1479   BF64 FF FF FF FF 
1479   BF68 FF FF FF FF 
1479   BF6C FF FF FF FF 
1479   BF70 FF FF FF FF 
1479   BF74 FF FF FF FF 
1479   BF78 FF FF FF FF 
1479   BF7C FF FF FF FF 
1479   BF80 FF FF FF FF 
1479   BF84 FF FF FF FF 
1479   BF88 FF FF FF FF 
1479   BF8C FF FF FF FF 
1479   BF90 FF FF FF FF 
1479   BF94 FF FF FF FF 
1479   BF98 FF FF FF FF 
1479   BF9C FF FF FF FF 
1479   BFA0 FF FF FF FF 
1479   BFA4 FF FF FF FF 
1479   BFA8 FF FF FF FF 
1479   BFAC FF FF FF FF 
1479   BFB0 FF FF FF FF 
1479   BFB4 FF FF FF FF 
1479   BFB8 FF FF FF FF 
1479   BFBC FF FF FF FF 
1479   BFC0 FF FF FF FF 
1479   BFC4 FF FF FF FF 
1479   BFC8 FF FF FF FF 
1479   BFCC FF FF FF FF 
1479   BFD0 FF FF FF FF 
1479   BFD4 FF FF FF FF 
1479   BFD8 FF FF FF FF 
1479   BFDC FF FF FF FF 
1479   BFE0 FF FF FF FF 
1479   BFE4 FF FF FF FF 
1479   BFE8 FF FF FF FF 
1479   BFEC FF FF FF FF 
1479   BFF0 FF FF FF FF 
1479   BFF4 FF FF FF FF 
1479   BFF8 FF FF FF FF 
1479   BFFC FF FF FF FF 
1479   C000 FF FF FF FF 
1479   C004 FF FF FF FF 
1479   C008 FF FF FF FF 
1479   C00C FF FF FF FF 
1479   C010 FF FF FF FF 
1479   C014 FF FF FF FF 
1479   C018 FF FF FF FF 
1479   C01C FF FF FF FF 
1479   C020 FF FF FF FF 
1479   C024 FF FF FF FF 
1479   C028 FF FF FF FF 
1479   C02C FF FF FF FF 
1479   C030 FF FF FF FF 
1479   C034 FF FF FF FF 
1479   C038 FF FF FF FF 
1479   C03C FF FF FF FF 
1479   C040 FF FF FF FF 
1479   C044 FF FF FF FF 
1479   C048 FF FF FF FF 
1479   C04C FF FF FF FF 
1479   C050 FF FF FF FF 
1479   C054 FF FF FF FF 
1479   C058 FF FF FF FF 
1479   C05C FF FF FF FF 
1479   C060 FF FF FF FF 
1479   C064 FF FF FF FF 
1479   C068 FF FF FF FF 
1479   C06C FF FF FF FF 
1479   C070 FF FF FF FF 
1479   C074 FF FF FF FF 
1479   C078 FF FF FF FF 
1479   C07C FF FF FF FF 
1479   C080 FF FF FF FF 
1479   C084 FF FF FF FF 
1479   C088 FF FF FF FF 
1479   C08C FF FF FF FF 
1479   C090 FF FF FF FF 
1479   C094 FF FF FF FF 
1479   C098 FF FF FF FF 
1479   C09C FF FF FF FF 
1479   C0A0 FF FF FF FF 
1479   C0A4 FF FF FF FF 
1479   C0A8 FF FF FF FF 
1479   C0AC FF FF FF FF 
1479   C0B0 FF FF FF FF 
1479   C0B4 FF FF FF FF 
1479   C0B8 FF FF FF FF 
1479   C0BC FF FF FF FF 
1479   C0C0 FF FF FF FF 
1479   C0C4 FF FF FF FF 
1479   C0C8 FF FF FF FF 
1479   C0CC FF FF FF FF 
1479   C0D0 FF FF FF FF 
1479   C0D4 FF FF FF FF 
1479   C0D8 FF FF FF FF 
1479   C0DC FF FF FF FF 
1479   C0E0 FF FF FF FF 
1479   C0E4 FF FF FF FF 
1479   C0E8 FF FF FF FF 
1479   C0EC FF FF FF FF 
1479   C0F0 FF FF FF FF 
1479   C0F4 FF FF FF FF 
1479   C0F8 FF FF FF FF 
1479   C0FC FF FF FF FF 
1479   C100 FF FF FF FF 
1479   C104 FF FF FF FF 
1479   C108 FF FF FF FF 
1479   C10C FF FF FF FF 
1479   C110 FF FF FF FF 
1479   C114 FF FF FF FF 
1479   C118 FF FF FF FF 
1479   C11C FF FF FF FF 
1479   C120 FF FF FF FF 
1479   C124 FF FF FF FF 
1479   C128 FF FF FF FF 
1479   C12C FF FF FF FF 
1479   C130 FF FF FF FF 
1479   C134 FF FF FF FF 
1479   C138 FF FF FF FF 
1479   C13C FF FF FF FF 
1479   C140 FF FF FF FF 
1479   C144 FF FF FF FF 
1479   C148 FF FF FF FF 
1479   C14C FF FF FF FF 
1479   C150 FF FF FF FF 
1479   C154 FF FF FF FF 
1479   C158 FF FF FF FF 
1479   C15C FF FF FF FF 
1479   C160 FF FF FF FF 
1479   C164 FF FF FF FF 
1479   C168 FF FF FF FF 
1479   C16C FF FF FF FF 
1479   C170 FF FF FF FF 
1479   C174 FF FF FF FF 
1479   C178 FF FF FF FF 
1479   C17C FF FF FF FF 
1479   C180 FF FF FF FF 
1479   C184 FF FF FF FF 
1479   C188 FF FF FF FF 
1479   C18C FF FF FF FF 
1479   C190 FF FF FF FF 
1479   C194 FF FF FF FF 
1479   C198 FF FF FF FF 
1479   C19C FF FF FF FF 
1479   C1A0 FF FF FF FF 
1479   C1A4 FF FF FF FF 
1479   C1A8 FF FF FF FF 
1479   C1AC FF FF FF FF 
1479   C1B0 FF FF FF FF 
1479   C1B4 FF FF FF FF 
1479   C1B8 FF FF FF FF 
1479   C1BC FF FF FF FF 
1479   C1C0 FF FF FF FF 
1479   C1C4 FF FF FF FF 
1479   C1C8 FF FF FF FF 
1479   C1CC FF FF FF FF 
1479   C1D0 FF FF FF FF 
1479   C1D4 FF FF FF FF 
1479   C1D8 FF FF FF FF 
1479   C1DC FF FF FF FF 
1479   C1E0 FF FF FF FF 
1479   C1E4 FF FF FF FF 
1479   C1E8 FF FF FF FF 
1479   C1EC FF FF FF FF 
1479   C1F0 FF FF FF FF 
1479   C1F4 FF FF FF FF 
1479   C1F8 FF FF FF FF 
1479   C1FC FF FF FF FF 
1479   C200 FF FF FF FF 
1479   C204 FF FF FF FF 
1479   C208 FF FF FF FF 
1479   C20C FF FF FF FF 
1479   C210 FF FF FF FF 
1479   C214 FF FF FF FF 
1479   C218 FF FF FF FF 
1479   C21C FF FF FF FF 
1479   C220 FF FF FF FF 
1479   C224 FF FF FF FF 
1479   C228 FF FF FF FF 
1479   C22C FF FF FF FF 
1479   C230 FF FF FF FF 
1479   C234 FF FF FF FF 
1479   C238 FF FF FF FF 
1479   C23C FF FF FF FF 
1479   C240 FF FF FF FF 
1479   C244 FF FF FF FF 
1479   C248 FF FF FF FF 
1479   C24C FF FF FF FF 
1479   C250 FF FF FF FF 
1479   C254 FF FF FF FF 
1479   C258 FF FF FF FF 
1479   C25C FF FF FF FF 
1479   C260 FF FF FF FF 
1479   C264 FF FF FF FF 
1479   C268 FF FF FF FF 
1479   C26C FF FF FF FF 
1479   C270 FF FF FF FF 
1479   C274 FF FF FF FF 
1479   C278 FF FF FF FF 
1479   C27C FF FF FF FF 
1479   C280 FF FF FF FF 
1479   C284 FF FF FF FF 
1479   C288 FF FF FF FF 
1479   C28C FF FF FF FF 
1479   C290 FF FF FF FF 
1479   C294 FF FF FF FF 
1479   C298 FF FF FF FF 
1479   C29C FF FF FF FF 
1479   C2A0 FF FF FF FF 
1479   C2A4 FF FF FF FF 
1479   C2A8 FF FF FF FF 
1479   C2AC FF FF FF FF 
1479   C2B0 FF FF FF FF 
1479   C2B4 FF FF FF FF 
1479   C2B8 FF FF FF FF 
1479   C2BC FF FF FF FF 
1479   C2C0 FF FF FF FF 
1479   C2C4 FF FF FF FF 
1479   C2C8 FF FF FF FF 
1479   C2CC FF FF FF FF 
1479   C2D0 FF FF FF FF 
1479   C2D4 FF FF FF FF 
1479   C2D8 FF FF FF FF 
1479   C2DC FF FF FF FF 
1479   C2E0 FF FF FF FF 
1479   C2E4 FF FF FF FF 
1479   C2E8 FF FF FF FF 
1479   C2EC FF FF FF FF 
1479   C2F0 FF FF FF FF 
1479   C2F4 FF FF FF FF 
1479   C2F8 FF FF FF FF 
1479   C2FC FF FF FF FF 
1479   C300 FF FF FF FF 
1479   C304 FF FF FF FF 
1479   C308 FF FF FF FF 
1479   C30C FF FF FF FF 
1479   C310 FF FF FF FF 
1479   C314 FF FF FF FF 
1479   C318 FF FF FF FF 
1479   C31C FF FF FF FF 
1479   C320 FF FF FF FF 
1479   C324 FF FF FF FF 
1479   C328 FF FF FF FF 
1479   C32C FF FF FF FF 
1479   C330 FF FF FF FF 
1479   C334 FF FF FF FF 
1479   C338 FF FF FF FF 
1479   C33C FF FF FF FF 
1479   C340 FF FF FF FF 
1479   C344 FF FF FF FF 
1479   C348 FF FF FF FF 
1479   C34C FF FF FF FF 
1479   C350 FF FF FF FF 
1479   C354 FF FF FF FF 
1479   C358 FF FF FF FF 
1479   C35C FF FF FF FF 
1479   C360 FF FF FF FF 
1479   C364 FF FF FF FF 
1479   C368 FF FF FF FF 
1479   C36C FF FF FF FF 
1479   C370 FF FF FF FF 
1479   C374 FF FF FF FF 
1479   C378 FF FF FF FF 
1479   C37C FF FF FF FF 
1479   C380 FF FF FF FF 
1479   C384 FF FF FF FF 
1479   C388 FF FF FF FF 
1479   C38C FF FF FF FF 
1479   C390 FF FF FF FF 
1479   C394 FF FF FF FF 
1479   C398 FF FF FF FF 
1479   C39C FF FF FF FF 
1479   C3A0 FF FF FF FF 
1479   C3A4 FF FF FF FF 
1479   C3A8 FF FF FF FF 
1479   C3AC FF FF FF FF 
1479   C3B0 FF FF FF FF 
1479   C3B4 FF FF FF FF 
1479   C3B8 FF FF FF FF 
1479   C3BC FF FF FF FF 
1479   C3C0 FF FF FF FF 
1479   C3C4 FF FF FF FF 
1479   C3C8 FF FF FF FF 
1479   C3CC FF FF FF FF 
1479   C3D0 FF FF FF FF 
1479   C3D4 FF FF FF FF 
1479   C3D8 FF FF FF FF 
1479   C3DC FF FF FF FF 
1479   C3E0 FF FF FF FF 
1479   C3E4 FF FF FF FF 
1479   C3E8 FF FF FF FF 
1479   C3EC FF FF FF FF 
1479   C3F0 FF FF FF FF 
1479   C3F4 FF FF FF FF 
1479   C3F8 FF FF FF FF 
1479   C3FC FF FF FF FF 
1479   C400 FF FF FF FF 
1479   C404 FF FF FF FF 
1479   C408 FF FF FF FF 
1479   C40C FF FF FF FF 
1479   C410 FF FF FF FF 
1479   C414 FF FF FF FF 
1479   C418 FF FF FF FF 
1479   C41C FF FF FF FF 
1479   C420 FF FF FF FF 
1479   C424 FF FF FF FF 
1479   C428 FF FF FF FF 
1479   C42C FF FF FF FF 
1479   C430 FF FF FF FF 
1479   C434 FF FF FF FF 
1479   C438 FF FF FF FF 
1479   C43C FF FF FF FF 
1479   C440 FF FF FF FF 
1479   C444 FF FF FF FF 
1479   C448 FF FF FF FF 
1479   C44C FF FF FF FF 
1479   C450 FF FF FF FF 
1479   C454 FF FF FF FF 
1479   C458 FF FF FF FF 
1479   C45C FF FF FF FF 
1479   C460 FF FF FF FF 
1479   C464 FF FF FF FF 
1479   C468 FF FF FF FF 
1479   C46C FF FF FF FF 
1479   C470 FF FF FF FF 
1479   C474 FF FF FF FF 
1479   C478 FF FF FF FF 
1479   C47C FF FF FF FF 
1479   C480 FF FF FF FF 
1479   C484 FF FF FF FF 
1479   C488 FF FF FF FF 
1479   C48C FF FF FF FF 
1479   C490 FF FF FF FF 
1479   C494 FF FF FF FF 
1479   C498 FF FF FF FF 
1479   C49C FF FF FF FF 
1479   C4A0 FF FF FF FF 
1479   C4A4 FF FF FF FF 
1479   C4A8 FF FF FF FF 
1479   C4AC FF FF FF FF 
1479   C4B0 FF FF FF FF 
1479   C4B4 FF FF FF FF 
1479   C4B8 FF FF FF FF 
1479   C4BC FF FF FF FF 
1479   C4C0 FF FF FF FF 
1479   C4C4 FF FF FF FF 
1479   C4C8 FF FF FF FF 
1479   C4CC FF FF FF FF 
1479   C4D0 FF FF FF FF 
1479   C4D4 FF FF FF FF 
1479   C4D8 FF FF FF FF 
1479   C4DC FF FF FF FF 
1479   C4E0 FF FF FF FF 
1479   C4E4 FF FF FF FF 
1479   C4E8 FF FF FF FF 
1479   C4EC FF FF FF FF 
1479   C4F0 FF FF FF FF 
1479   C4F4 FF FF FF FF 
1479   C4F8 FF FF FF FF 
1479   C4FC FF FF FF FF 
1479   C500 FF FF FF FF 
1479   C504 FF FF FF FF 
1479   C508 FF FF FF FF 
1479   C50C FF FF FF FF 
1479   C510 FF FF FF FF 
1479   C514 FF FF FF FF 
1479   C518 FF FF FF FF 
1479   C51C FF FF FF FF 
1479   C520 FF FF FF FF 
1479   C524 FF FF FF FF 
1479   C528 FF FF FF FF 
1479   C52C FF FF FF FF 
1479   C530 FF FF FF FF 
1479   C534 FF FF FF FF 
1479   C538 FF FF FF FF 
1479   C53C FF FF FF FF 
1479   C540 FF FF FF FF 
1479   C544 FF FF FF FF 
1479   C548 FF FF FF FF 
1479   C54C FF FF FF FF 
1479   C550 FF FF FF FF 
1479   C554 FF FF FF FF 
1479   C558 FF FF FF FF 
1479   C55C FF FF FF FF 
1479   C560 FF FF FF FF 
1479   C564 FF FF FF FF 
1479   C568 FF FF FF FF 
1479   C56C FF FF FF FF 
1479   C570 FF FF FF FF 
1479   C574 FF FF FF FF 
1479   C578 FF FF FF FF 
1479   C57C FF FF FF FF 
1479   C580 FF FF FF FF 
1479   C584 FF FF FF FF 
1479   C588 FF FF FF FF 
1479   C58C FF FF FF FF 
1479   C590 FF FF FF FF 
1479   C594 FF FF FF FF 
1479   C598 FF FF FF FF 
1479   C59C FF FF FF FF 
1479   C5A0 FF FF FF FF 
1479   C5A4 FF FF FF FF 
1479   C5A8 FF FF FF FF 
1479   C5AC FF FF FF FF 
1479   C5B0 FF FF FF FF 
1479   C5B4 FF FF FF FF 
1479   C5B8 FF FF FF FF 
1479   C5BC FF FF FF FF 
1479   C5C0 FF FF FF FF 
1479   C5C4 FF FF FF FF 
1479   C5C8 FF FF FF FF 
1479   C5CC FF FF FF FF 
1479   C5D0 FF FF FF FF 
1479   C5D4 FF FF FF FF 
1479   C5D8 FF FF FF FF 
1479   C5DC FF FF FF FF 
1479   C5E0 FF FF FF FF 
1479   C5E4 FF FF FF FF 
1479   C5E8 FF FF FF FF 
1479   C5EC FF FF FF FF 
1479   C5F0 FF FF FF FF 
1479   C5F4 FF FF FF FF 
1479   C5F8 FF FF FF FF 
1479   C5FC FF FF FF FF 
1479   C600 FF FF FF FF 
1479   C604 FF FF FF FF 
1479   C608 FF FF FF FF 
1479   C60C FF FF FF FF 
1479   C610 FF FF FF FF 
1479   C614 FF FF FF FF 
1479   C618 FF FF FF FF 
1479   C61C FF FF FF FF 
1479   C620 FF FF FF FF 
1479   C624 FF FF FF FF 
1479   C628 FF FF FF FF 
1479   C62C FF FF FF FF 
1479   C630 FF FF FF FF 
1479   C634 FF FF FF FF 
1479   C638 FF FF FF FF 
1479   C63C FF FF FF FF 
1479   C640 FF FF FF FF 
1479   C644 FF FF FF FF 
1479   C648 FF FF FF FF 
1479   C64C FF FF FF FF 
1479   C650 FF FF FF FF 
1479   C654 FF FF FF FF 
1479   C658 FF FF FF FF 
1479   C65C FF FF FF FF 
1479   C660 FF FF FF FF 
1479   C664 FF FF FF FF 
1479   C668 FF FF FF FF 
1479   C66C FF FF FF FF 
1479   C670 FF FF FF FF 
1479   C674 FF FF FF FF 
1479   C678 FF FF FF FF 
1479   C67C FF FF FF FF 
1479   C680 FF FF FF FF 
1479   C684 FF FF FF FF 
1479   C688 FF FF FF FF 
1479   C68C FF FF FF FF 
1479   C690 FF FF FF FF 
1479   C694 FF FF FF FF 
1479   C698 FF FF FF FF 
1479   C69C FF FF FF FF 
1479   C6A0 FF FF FF FF 
1479   C6A4 FF FF FF FF 
1479   C6A8 FF FF FF FF 
1479   C6AC FF FF FF FF 
1479   C6B0 FF FF FF FF 
1479   C6B4 FF FF FF FF 
1479   C6B8 FF FF FF FF 
1479   C6BC FF FF FF FF 
1479   C6C0 FF FF FF FF 
1479   C6C4 FF FF FF FF 
1479   C6C8 FF FF FF FF 
1479   C6CC FF FF FF FF 
1479   C6D0 FF FF FF FF 
1479   C6D4 FF FF FF FF 
1479   C6D8 FF FF FF FF 
1479   C6DC FF FF FF FF 
1479   C6E0 FF FF FF FF 
1479   C6E4 FF FF FF FF 
1479   C6E8 FF FF FF FF 
1479   C6EC FF FF FF FF 
1479   C6F0 FF FF FF FF 
1479   C6F4 FF FF FF FF 
1479   C6F8 FF FF FF FF 
1479   C6FC FF FF FF FF 
1479   C700 FF FF FF FF 
1479   C704 FF FF FF FF 
1479   C708 FF FF FF FF 
1479   C70C FF FF FF FF 
1479   C710 FF FF FF FF 
1479   C714 FF FF FF FF 
1479   C718 FF FF FF FF 
1479   C71C FF FF FF FF 
1479   C720 FF FF FF FF 
1479   C724 FF FF FF FF 
1479   C728 FF FF FF FF 
1479   C72C FF FF FF FF 
1479   C730 FF FF FF FF 
1479   C734 FF FF FF FF 
1479   C738 FF FF FF FF 
1479   C73C FF FF FF FF 
1479   C740 FF FF FF FF 
1479   C744 FF FF FF FF 
1479   C748 FF FF FF FF 
1479   C74C FF FF FF FF 
1479   C750 FF FF FF FF 
1479   C754 FF FF FF FF 
1479   C758 FF FF FF FF 
1479   C75C FF FF FF FF 
1479   C760 FF FF FF FF 
1479   C764 FF FF FF FF 
1479   C768 FF FF FF FF 
1479   C76C FF FF FF FF 
1479   C770 FF FF FF FF 
1479   C774 FF FF FF FF 
1479   C778 FF FF FF FF 
1479   C77C FF FF FF FF 
1479   C780 FF FF FF FF 
1479   C784 FF FF FF FF 
1479   C788 FF FF FF FF 
1479   C78C FF FF FF FF 
1479   C790 FF FF FF FF 
1479   C794 FF FF FF FF 
1479   C798 FF FF FF FF 
1479   C79C FF FF FF FF 
1479   C7A0 FF FF FF FF 
1479   C7A4 FF FF FF FF 
1479   C7A8 FF FF FF FF 
1479   C7AC FF FF FF FF 
1479   C7B0 FF FF FF FF 
1479   C7B4 FF FF FF FF 
1479   C7B8 FF FF FF FF 
1479   C7BC FF FF FF FF 
1479   C7C0 FF FF FF FF 
1479   C7C4 FF FF FF FF 
1479   C7C8 FF FF FF FF 
1479   C7CC FF FF FF FF 
1479   C7D0 FF FF FF FF 
1479   C7D4 FF FF FF FF 
1479   C7D8 FF FF FF FF 
1479   C7DC FF FF FF FF 
1479   C7E0 FF FF FF FF 
1479   C7E4 FF FF FF FF 
1479   C7E8 FF FF FF FF 
1479   C7EC FF FF FF FF 
1479   C7F0 FF FF FF FF 
1479   C7F4 FF FF FF FF 
1479   C7F8 FF FF FF FF 
1479   C7FC FF FF FF FF 
1479   C800 FF FF FF FF 
1479   C804 FF FF FF FF 
1479   C808 FF FF FF FF 
1479   C80C FF FF FF FF 
1479   C810 FF FF FF FF 
1479   C814 FF FF FF FF 
1479   C818 FF FF FF FF 
1479   C81C FF FF FF FF 
1479   C820 FF FF FF FF 
1479   C824 FF FF FF FF 
1479   C828 FF FF FF FF 
1479   C82C FF FF FF FF 
1479   C830 FF FF FF FF 
1479   C834 FF FF FF FF 
1479   C838 FF FF FF FF 
1479   C83C FF FF FF FF 
1479   C840 FF FF FF FF 
1479   C844 FF FF FF FF 
1479   C848 FF FF FF FF 
1479   C84C FF FF FF FF 
1479   C850 FF FF FF FF 
1479   C854 FF FF FF FF 
1479   C858 FF FF FF FF 
1479   C85C FF FF FF FF 
1479   C860 FF FF FF FF 
1479   C864 FF FF FF FF 
1479   C868 FF FF FF FF 
1479   C86C FF FF FF FF 
1479   C870 FF FF FF FF 
1479   C874 FF FF FF FF 
1479   C878 FF FF FF FF 
1479   C87C FF FF FF FF 
1479   C880 FF FF FF FF 
1479   C884 FF FF FF FF 
1479   C888 FF FF FF FF 
1479   C88C FF FF FF FF 
1479   C890 FF FF FF FF 
1479   C894 FF FF FF FF 
1479   C898 FF FF FF FF 
1479   C89C FF FF FF FF 
1479   C8A0 FF FF FF FF 
1479   C8A4 FF FF FF FF 
1479   C8A8 FF FF FF FF 
1479   C8AC FF FF FF FF 
1479   C8B0 FF FF FF FF 
1479   C8B4 FF FF FF FF 
1479   C8B8 FF FF FF FF 
1479   C8BC FF FF FF FF 
1479   C8C0 FF FF FF FF 
1479   C8C4 FF FF FF FF 
1479   C8C8 FF FF FF FF 
1479   C8CC FF FF FF FF 
1479   C8D0 FF FF FF FF 
1479   C8D4 FF FF FF FF 
1479   C8D8 FF FF FF FF 
1479   C8DC FF FF FF FF 
1479   C8E0 FF FF FF FF 
1479   C8E4 FF FF FF FF 
1479   C8E8 FF FF FF FF 
1479   C8EC FF FF FF FF 
1479   C8F0 FF FF FF FF 
1479   C8F4 FF FF FF FF 
1479   C8F8 FF FF FF FF 
1479   C8FC FF FF FF FF 
1479   C900 FF FF FF FF 
1479   C904 FF FF FF FF 
1479   C908 FF FF FF FF 
1479   C90C FF FF FF FF 
1479   C910 FF FF FF FF 
1479   C914 FF FF FF FF 
1479   C918 FF FF FF FF 
1479   C91C FF FF FF FF 
1479   C920 FF FF FF FF 
1479   C924 FF FF FF FF 
1479   C928 FF FF FF FF 
1479   C92C FF FF FF FF 
1479   C930 FF FF FF FF 
1479   C934 FF FF FF FF 
1479   C938 FF FF FF FF 
1479   C93C FF FF FF FF 
1479   C940 FF FF FF FF 
1479   C944 FF FF FF FF 
1479   C948 FF FF FF FF 
1479   C94C FF FF FF FF 
1479   C950 FF FF FF FF 
1479   C954 FF FF FF FF 
1479   C958 FF FF FF FF 
1479   C95C FF FF FF FF 
1479   C960 FF FF FF FF 
1479   C964 FF FF FF FF 
1479   C968 FF FF FF FF 
1479   C96C FF FF FF FF 
1479   C970 FF FF FF FF 
1479   C974 FF FF FF FF 
1479   C978 FF FF FF FF 
1479   C97C FF FF FF FF 
1479   C980 FF FF FF FF 
1479   C984 FF FF FF FF 
1479   C988 FF FF FF FF 
1479   C98C FF FF FF FF 
1479   C990 FF FF FF FF 
1479   C994 FF FF FF FF 
1479   C998 FF FF FF FF 
1479   C99C FF FF FF FF 
1479   C9A0 FF FF FF FF 
1479   C9A4 FF FF FF FF 
1479   C9A8 FF FF FF FF 
1479   C9AC FF FF FF FF 
1479   C9B0 FF FF FF FF 
1479   C9B4 FF FF FF FF 
1479   C9B8 FF FF FF FF 
1479   C9BC FF FF FF FF 
1479   C9C0 FF FF FF FF 
1479   C9C4 FF FF FF FF 
1479   C9C8 FF FF FF FF 
1479   C9CC FF FF FF FF 
1479   C9D0 FF FF FF FF 
1479   C9D4 FF FF FF FF 
1479   C9D8 FF FF FF FF 
1479   C9DC FF FF FF FF 
1479   C9E0 FF FF FF FF 
1479   C9E4 FF FF FF FF 
1479   C9E8 FF FF FF FF 
1479   C9EC FF FF FF FF 
1479   C9F0 FF FF FF FF 
1479   C9F4 FF FF FF FF 
1479   C9F8 FF FF FF FF 
1479   C9FC FF FF FF FF 
1479   CA00 FF FF FF FF 
1479   CA04 FF FF FF FF 
1479   CA08 FF FF FF FF 
1479   CA0C FF FF FF FF 
1479   CA10 FF FF FF FF 
1479   CA14 FF FF FF FF 
1479   CA18 FF FF FF FF 
1479   CA1C FF FF FF FF 
1479   CA20 FF FF FF FF 
1479   CA24 FF FF FF FF 
1479   CA28 FF FF FF FF 
1479   CA2C FF FF FF FF 
1479   CA30 FF FF FF FF 
1479   CA34 FF FF FF FF 
1479   CA38 FF FF FF FF 
1479   CA3C FF FF FF FF 
1479   CA40 FF FF FF FF 
1479   CA44 FF FF FF FF 
1479   CA48 FF FF FF FF 
1479   CA4C FF FF FF FF 
1479   CA50 FF FF FF FF 
1479   CA54 FF FF FF FF 
1479   CA58 FF FF FF FF 
1479   CA5C FF FF FF FF 
1479   CA60 FF FF FF FF 
1479   CA64 FF FF FF FF 
1479   CA68 FF FF FF FF 
1479   CA6C FF FF FF FF 
1479   CA70 FF FF FF FF 
1479   CA74 FF FF FF FF 
1479   CA78 FF FF FF FF 
1479   CA7C FF FF FF FF 
1479   CA80 FF FF FF FF 
1479   CA84 FF FF FF FF 
1479   CA88 FF FF FF FF 
1479   CA8C FF FF FF FF 
1479   CA90 FF FF FF FF 
1479   CA94 FF FF FF FF 
1479   CA98 FF FF FF FF 
1479   CA9C FF FF FF FF 
1479   CAA0 FF FF FF FF 
1479   CAA4 FF FF FF FF 
1479   CAA8 FF FF FF FF 
1479   CAAC FF FF FF FF 
1479   CAB0 FF FF FF FF 
1479   CAB4 FF FF FF FF 
1479   CAB8 FF FF FF FF 
1479   CABC FF FF FF FF 
1479   CAC0 FF FF FF FF 
1479   CAC4 FF FF FF FF 
1479   CAC8 FF FF FF FF 
1479   CACC FF FF FF FF 
1479   CAD0 FF FF FF FF 
1479   CAD4 FF FF FF FF 
1479   CAD8 FF FF FF FF 
1479   CADC FF FF FF FF 
1479   CAE0 FF FF FF FF 
1479   CAE4 FF FF FF FF 
1479   CAE8 FF FF FF FF 
1479   CAEC FF FF FF FF 
1479   CAF0 FF FF FF FF 
1479   CAF4 FF FF FF FF 
1479   CAF8 FF FF FF FF 
1479   CAFC FF FF FF FF 
1480   CB00             newCode     .org    $CB00
1481   CB00~            #ifdef batteryGauge
1482   CB00~            battGauge   ldab    battRaw                   ; b=battery voltage
1483   CB00~                        subb    #$8C                      ; remove 10.262V
1484   CB00~                        lsrb                              ;
1485   CB00~                        lsrb                              ;
1486   CB00~                        tba                               ;
1487   CB00~                        lsrb                              ;
1488   CB00~                        aba                               ;
1489   CB00~                        tab                               ; b = 3/8*(Vbatt-10.262v), gives a effective range of 10.262V to 14.95V (0 to 24 in boost gauge range)
1490   CB00~                        rts
1491   CB00             #endif
1492   CB00             
1493   CB00             
1494   CB00             
1495   CB00             ;******************************************************************
1496   CB00             ;
1497   CB00             ;
1498   CB00             ; Empty space
1499   CB00             ;
1500   CB00             ;
1501   CB00             ;******************************************************************
1502   CB00 FF FF FF FF             .fill   codeStart-$, $ff
1502   CB04 FF FF FF FF 
1502   CB08 FF FF FF FF 
1502   CB0C FF FF FF FF 
1502   CB10 FF FF FF FF 
1502   CB14 FF FF FF FF 
1502   CB18 FF FF FF FF 
1502   CB1C FF FF FF FF 
1502   CB20 FF FF FF FF 
1502   CB24 FF FF FF FF 
1502   CB28 FF FF FF FF 
1502   CB2C FF FF FF FF 
1502   CB30 FF FF FF FF 
1502   CB34 FF FF FF FF 
1502   CB38 FF FF FF FF 
1502   CB3C FF FF FF FF 
1502   CB40 FF FF FF FF 
1502   CB44 FF FF FF FF 
1502   CB48 FF FF FF FF 
1502   CB4C FF FF FF FF 
1502   CB50 FF FF FF FF 
1502   CB54 FF FF FF FF 
1502   CB58 FF FF FF FF 
1502   CB5C FF FF FF FF 
1502   CB60 FF FF FF FF 
1502   CB64 FF FF FF FF 
1502   CB68 FF FF FF FF 
1502   CB6C FF FF FF FF 
1502   CB70 FF FF FF FF 
1502   CB74 FF FF FF FF 
1502   CB78 FF FF FF FF 
1502   CB7C FF FF FF FF 
1502   CB80 FF FF FF FF 
1502   CB84 FF FF FF FF 
1502   CB88 FF FF FF FF 
1502   CB8C FF FF FF FF 
1502   CB90 FF FF FF FF 
1502   CB94 FF FF FF FF 
1502   CB98 FF FF FF FF 
1502   CB9C FF FF FF FF 
1502   CBA0 FF FF FF FF 
1502   CBA4 FF FF FF FF 
1502   CBA8 FF FF FF FF 
1502   CBAC FF FF FF FF 
1502   CBB0 FF FF FF FF 
1502   CBB4 FF FF FF FF 
1502   CBB8 FF FF FF FF 
1502   CBBC FF FF FF FF 
1502   CBC0 FF FF FF FF 
1502   CBC4 FF FF FF FF 
1502   CBC8 FF FF FF FF 
1502   CBCC FF FF FF FF 
1502   CBD0 FF FF FF FF 
1502   CBD4 FF FF FF FF 
1502   CBD8 FF FF FF FF 
1502   CBDC FF FF FF FF 
1502   CBE0 FF FF FF FF 
1502   CBE4 FF FF FF FF 
1502   CBE8 FF FF FF FF 
1502   CBEC FF FF FF FF 
1502   CBF0 FF FF FF FF 
1502   CBF4 FF FF FF FF 
1502   CBF8 FF FF FF FF 
1502   CBFC FF FF FF FF 
1502   CC00 FF FF FF FF 
1502   CC04 FF FF FF FF 
1502   CC08 FF FF FF FF 
1502   CC0C FF FF FF FF 
1502   CC10 FF FF FF FF 
1502   CC14 FF FF FF FF 
1502   CC18 FF FF FF FF 
1502   CC1C FF FF FF FF 
1502   CC20 FF FF FF FF 
1502   CC24 FF FF FF FF 
1502   CC28 FF FF FF FF 
1502   CC2C FF FF FF FF 
1502   CC30 FF FF FF FF 
1502   CC34 FF FF FF FF 
1502   CC38 FF FF FF FF 
1502   CC3C FF FF FF FF 
1502   CC40 FF FF FF FF 
1502   CC44 FF FF FF FF 
1502   CC48 FF FF FF FF 
1502   CC4C FF FF FF FF 
1502   CC50 FF FF FF FF 
1502   CC54 FF FF FF FF 
1502   CC58 FF FF FF FF 
1502   CC5C FF FF FF FF 
1502   CC60 FF FF FF FF 
1502   CC64 FF FF FF FF 
1502   CC68 FF FF FF FF 
1502   CC6C FF FF FF FF 
1502   CC70 FF FF FF FF 
1502   CC74 FF FF FF FF 
1502   CC78 FF FF FF FF 
1502   CC7C FF FF FF FF 
1502   CC80 FF FF FF FF 
1502   CC84 FF FF FF FF 
1502   CC88 FF FF FF FF 
1502   CC8C FF FF FF FF 
1502   CC90 FF FF FF FF 
1502   CC94 FF FF FF FF 
1502   CC98 FF FF FF FF 
1502   CC9C FF FF FF FF 
1502   CCA0 FF FF FF FF 
1502   CCA4 FF FF FF FF 
1502   CCA8 FF FF FF FF 
1502   CCAC FF FF FF FF 
1502   CCB0 FF FF FF FF 
1502   CCB4 FF FF FF FF 
1502   CCB8 FF FF FF FF 
1502   CCBC FF FF FF FF 
1502   CCC0 FF FF FF FF 
1502   CCC4 FF FF FF FF 
1502   CCC8 FF FF FF FF 
1502   CCCC FF FF FF FF 
1502   CCD0 FF FF FF FF 
1502   CCD4 FF FF FF FF 
1502   CCD8 FF FF FF FF 
1502   CCDC FF FF FF FF 
1502   CCE0 FF FF FF FF 
1502   CCE4 FF FF FF FF 
1502   CCE8 FF FF FF FF 
1502   CCEC FF FF FF FF 
1502   CCF0 FF FF FF FF 
1502   CCF4 FF FF FF FF 
1502   CCF8 FF FF FF FF 
1502   CCFC FF FF FF FF 
1502   CD00 FF FF FF FF 
1502   CD04 FF FF FF FF 
1502   CD08 FF FF FF FF 
1502   CD0C FF FF FF FF 
1502   CD10 FF FF FF FF 
1502   CD14 FF FF FF FF 
1502   CD18 FF FF FF FF 
1502   CD1C FF FF FF FF 
1502   CD20 FF FF FF FF 
1502   CD24 FF FF FF FF 
1502   CD28 FF FF FF FF 
1502   CD2C FF FF FF FF 
1502   CD30 FF FF FF FF 
1502   CD34 FF FF FF FF 
1502   CD38 FF FF FF FF 
1502   CD3C FF FF FF FF 
1502   CD40 FF FF FF FF 
1502   CD44 FF FF FF FF 
1502   CD48 FF FF FF FF 
1502   CD4C FF FF FF FF 
1502   CD50 FF FF FF FF 
1502   CD54 FF FF FF FF 
1502   CD58 FF FF FF FF 
1502   CD5C FF FF FF FF 
1502   CD60 FF FF FF FF 
1502   CD64 FF FF FF FF 
1502   CD68 FF FF FF FF 
1502   CD6C FF FF FF FF 
1502   CD70 FF FF FF FF 
1502   CD74 FF FF FF FF 
1502   CD78 FF FF FF FF 
1502   CD7C FF FF FF FF 
1502   CD80 FF FF FF FF 
1502   CD84 FF FF FF FF 
1502   CD88 FF FF FF FF 
1502   CD8C FF FF FF FF 
1502   CD90 FF FF FF FF 
1502   CD94 FF FF FF FF 
1502   CD98 FF FF FF FF 
1502   CD9C FF FF FF FF 
1502   CDA0 FF FF FF FF 
1502   CDA4 FF FF FF FF 
1502   CDA8 FF FF FF FF 
1502   CDAC FF FF FF FF 
1502   CDB0 FF FF FF FF 
1502   CDB4 FF FF FF FF 
1502   CDB8 FF FF FF FF 
1502   CDBC FF FF FF FF 
1502   CDC0 FF FF FF FF 
1502   CDC4 FF FF FF FF 
1502   CDC8 FF FF FF FF 
1502   CDCC FF FF FF FF 
1502   CDD0 FF FF FF FF 
1502   CDD4 FF FF FF FF 
1502   CDD8 FF FF FF FF 
1502   CDDC FF FF FF FF 
1502   CDE0 FF FF FF FF 
1502   CDE4 FF FF FF FF 
1502   CDE8 FF FF FF FF 
1502   CDEC FF FF FF FF 
1502   CDF0 FF FF FF FF 
1502   CDF4 FF FF FF FF 
1502   CDF8 FF FF FF FF 
1502   CDFC FF FF FF FF 
1502   CE00 FF FF FF FF 
1502   CE04 FF FF FF FF 
1502   CE08 FF FF FF FF 
1502   CE0C FF FF FF FF 
1502   CE10 FF FF FF FF 
1502   CE14 FF FF FF FF 
1502   CE18 FF FF FF FF 
1502   CE1C FF FF FF FF 
1502   CE20 FF FF FF FF 
1502   CE24 FF FF FF FF 
1502   CE28 FF FF FF FF 
1502   CE2C FF FF FF FF 
1502   CE30 FF FF FF FF 
1502   CE34 FF FF FF FF 
1502   CE38 FF FF FF FF 
1502   CE3C FF FF FF FF 
1502   CE40 FF FF FF FF 
1502   CE44 FF FF FF FF 
1502   CE48 FF FF FF FF 
1502   CE4C FF FF FF FF 
1502   CE50 FF FF FF FF 
1502   CE54 FF FF FF FF 
1502   CE58 FF FF FF FF 
1502   CE5C FF FF FF FF 
1502   CE60 FF FF FF FF 
1502   CE64 FF FF FF FF 
1502   CE68 FF FF FF FF 
1502   CE6C FF FF FF FF 
1502   CE70 FF FF FF FF 
1502   CE74 FF FF FF FF 
1502   CE78 FF FF FF FF 
1502   CE7C FF FF FF FF 
1502   CE80 FF FF FF FF 
1502   CE84 FF FF FF FF 
1502   CE88 FF FF FF FF 
1502   CE8C FF FF FF FF 
1502   CE90 FF FF FF FF 
1502   CE94 FF FF FF FF 
1502   CE98 FF FF FF FF 
1502   CE9C FF FF FF FF 
1502   CEA0 FF FF FF FF 
1502   CEA4 FF FF FF FF 
1502   CEA8 FF FF FF FF 
1502   CEAC FF FF FF FF 
1502   CEB0 FF FF FF FF 
1502   CEB4 FF FF FF FF 
1502   CEB8 FF FF FF FF 
1502   CEBC FF FF FF FF 
1502   CEC0 FF FF FF FF 
1502   CEC4 FF FF FF FF 
1502   CEC8 FF FF FF FF 
1502   CECC FF FF FF FF 
1502   CED0 FF FF FF FF 
1502   CED4 FF FF FF FF 
1502   CED8 FF FF FF FF 
1502   CEDC FF FF FF FF 
1502   CEE0 FF FF FF FF 
1502   CEE4 FF FF FF FF 
1502   CEE8 FF FF FF FF 
1502   CEEC FF FF FF FF 
1502   CEF0 FF FF FF FF 
1502   CEF4 FF FF FF FF 
1502   CEF8 FF FF FF FF 
1502   CEFC FF FF FF 
1503   CEFF             
1504   CEFF             
1505   CEFF             
1506   CEFF             ;******************************************************************
1507   CEFF             ;
1508   CEFF             ;
1509   CEFF             ; Start of code after reset
1510   CEFF             ;
1511   CEFF             ;
1512   CEFF             ;******************************************************************
1513   CEFF             codeStart   .ORG    $ceff-codeOffset
1514   CEFF 7E D0 3E                jmp     reset
1515   CF02             
1516   CF02             
1517   CF02             ;******************************************************************
1518   CF02             ;
1519   CF02             ;
1520   CF02             ; Empty space
1521   CF02             ;
1522   CF02             ;
1523   CF02             ;******************************************************************
1524   CF02 FF FF FF FF empty2      .fill   obdTable-empty2, $ff
1524   CF06 FF FF FF FF 
1524   CF0A FF FF FF FF 
1524   CF0E FF FF FF FF 
1524   CF12 FF FF FF FF 
1524   CF16 FF FF FF FF 
1524   CF1A FF FF FF FF 
1524   CF1E FF FF FF FF 
1524   CF22 FF FF FF FF 
1524   CF26 FF FF FF FF 
1524   CF2A FF FF FF FF 
1524   CF2E FF FF FF FF 
1524   CF32 FF FF FF FF 
1524   CF36 FF FF FF FF 
1524   CF3A FF FF FF FF 
1524   CF3E FF FF FF FF 
1524   CF42 FF FF FF FF 
1524   CF46 FF FF FF FF 
1524   CF4A FF FF FF FF 
1524   CF4E FF FF FF FF 
1524   CF52 FF FF FF FF 
1524   CF56 FF FF FF FF 
1524   CF5A FF FF FF FF 
1524   CF5E FF FF FF FF 
1524   CF62 FF FF FF FF 
1524   CF66 FF FF FF FF 
1524   CF6A FF FF FF FF 
1524   CF6E FF FF FF FF 
1524   CF72 FF FF FF FF 
1524   CF76 FF FF FF FF 
1524   CF7A FF FF FF FF 
1524   CF7E FF FF FF FF 
1524   CF82 FF FF FF FF 
1524   CF86 FF FF FF FF 
1524   CF8A FF FF FF FF 
1524   CF8E FF FF FF FF 
1524   CF92 FF FF FF FF 
1524   CF96 FF FF FF FF 
1524   CF9A FF FF FF FF 
1524   CF9E FF FF FF FF 
1524   CFA2 FF FF FF FF 
1524   CFA6 FF FF FF FF 
1524   CFAA FF FF FF FF 
1524   CFAE FF FF FF FF 
1524   CFB2 FF FF FF FF 
1524   CFB6 FF FF FF FF 
1524   CFBA FF FF FF FF 
1524   CFBE FF FF FF FF 
1524   CFC2 FF FF FF FF 
1524   CFC6 FF FF FF FF 
1524   CFCA FF FF FF FF 
1524   CFCE FF FF FF FF 
1524   CFD2 FF FF FF FF 
1524   CFD6 FF FF FF FF 
1524   CFDA FF FF FF FF 
1524   CFDE FF FF FF FF 
1524   CFE2 FF FF FF FF 
1524   CFE6 FF FF FF FF 
1524   CFEA FF FF FF FF 
1524   CFEE FF FF FF FF 
1524   CFF2 FF FF FF FF 
1524   CFF6 FF FF FF FF 
1524   CFFA FF FF FF FF 
1524   CFFE FF FF 
1525   D000             
1526   D000             
1527   D000             
1528   D000             ;******************************************************************
1529   D000             ;*
1530   D000             ;* OBD interface queries, commands
1531   D000             ;*
1532   D000             ;*   Codes from $00 to $3d: Regular queries, return the value of the
1533   D000             ;*                variables showed in obdTable located below, 
1534   D000             ;*                see each variable definition... First value in table 
1535   D000             ;*                correspond to obd query code $00, increases by 1 
1536   D000             ;*                for each table value
1537   D000             ;*     
1538   D000             ;*   Codes from $3e to $3f: Converted to $3d, see that obd code
1539   D000             ;*
1540   D000             ;*   Codes from $40 to $c9: Returns what is stored in that ram address
1541   D000             ;*
1542   D000             ;*   Codes from $ca to $ca:: Erase all fault codes and returns $00 if
1543   D000             ;*                           engine not rotating. If engine is rotating, all 
1544   D000             ;*                           actuators/injector commands are reset and $ff
1545   D000             ;*                           is returned.
1546   D000             ;* 
1547   D000             ;*   Codes from $cb to $f0: Returns what is stored in that ram address
1548   D000             ;*
1549   D000             ;*   Codes from $f1 to $fc: Injector/actuators commands, returns $ff if 
1550   D000             ;*                          successfull
1551   D000             ;*         
1552   D000             ;*         $f1: Activate boost control solenoid
1553   D000             ;*         $f2: Unused in code        
1554   D000             ;*         $f3: Activate egr solemoid          
1555   D000             ;*         $f4: Activate fuel pressure solenoid
1556   D000             ;*         $f5: Activate purge solenoid       
1557   D000             ;*         $f6: Turn on fuel pump     
1558   D000             ;*         $f7: Disable injector #6 (inoperative in code)  
1559   D000             ;*         $f8: Disable injector #5 (inoperative in code)  
1560   D000             ;*         $f9: Disable injector #4 
1561   D000             ;*         $fa: Disable injector #3 
1562   D000             ;*         $fb: Disable injector #2 
1563   D000             ;*         $fc: Disable injector #1 
1564   D000             ;*
1565   D000             ;*   Codes from $f1 to $ff: Special queries
1566   D000             ;*
1567   D000             ;*         $fd: Serial link test, returns $b5 (E931) or $b7 (E932)
1568   D000             ;*         $fe: resistor strapping low word from t_strap3
1569   D000             ;*         $ff: resistor strapping high word from t_strap3
1570   D000             ;*     
1571   D000             ;******************************************************************
1572   D000                         .org $d000-codeOffset
1573   D000 02 03 06 07 obdTable    .byte   port1,         port2,       port3,       port4            ; obd $00 to $03 
1574   D004 16 2F 8A CB             .byte   port5,         port6,       timingAdv,   ectRaw           ; obd $04 to $07
1575   D008 44 ED 46 EE             .byte   isc0,          iscY0,       isc1,        iscY1            ; obd $08 to $0b
1576   D00C 40 41 42 E9             .byte   ftrim_low,     ftrim_mid,   ftrim_hi,    o2Fbk            ; obd $0c to $0f
1577   D010 D3 D4 CF CE             .byte   ectFiltered,   iatChecked,  egrtRaw,     o2Raw            ; obd $10 to $13
1578   D014 D0 CD 49 D2             .byte   battRaw,       baroRaw,     iscStepCurr, tpsRaw           ; obd $14 to $17
1579   D018 E8 E5 E4 40             .byte   closedLpFlags, ftrimFlags,  mafRaw,      ftrim_low        ; obd $18 to $1b
1580   D01C E0 A1 E6 40             .byte   airVol,        accEnr,      state1,      ftrim_low        ; obd $1c to $1f
1581   D020 DC DD F1 F3             .byte   rpm8,          rpm31,       port3Snap1,  iscLrnFlags      ; obd $20 to $23
1582   D024 FE FD 8B D7             .byte   idleSpdTarg,   iscStepTarg, knockSum,    port3Snap0       ; obd $24 to $27
1583   D028 D8 A7 A8 89             .byte   port4Snap,     injPw,       injPw+1,     enerLen          ; obd $28 to $2b
1584   D02C 8D 8E A3 A4             .byte   airCnt0,       airCnt1,     injFactor,   injFactor+1      ; obd $2c to $2f
1585   D030 4B 57 58 59             .byte   iscFlags0,     temp1,       temp2,       temp3            ; obd $30 to $33
1586   D034 5A 5B 50 51             .byte   temp4,         temp5,       o2BadCnt,    egrtBadCnt       ; obd $34 to $37
1587   D038 4E 4F CC 4C             .byte   faultHi,       faultLo,     iatRaw,      stFaultHi        ; obd $38 to $3b
1588   D03C 4D 40                   .byte   stFaultLo,     ftrim_low                                  ; obd $3c to $3d
1589   D03E             
1590   D03E             
1591   D03E             
1592   D03E             ;******************************************************************
1593   D03E             ;
1594   D03E             ;
1595   D03E             ; Code executed after reset
1596   D03E             ;
1597   D03E             ;
1598   D03E             ;******************************************************************
1599   D03E 8E 01 BF    reset       lds     #stack                    ; Set the stack pointer                                       
1600   D041 8D 0F                   bsr     ecuInit                   ; Initialization branch                                       
1601   D043                                                                                        
1602   D043                         ;---------------------------------------------                                                       
1603   D043                         ; Main ECU loop executed in low priority
1604   D043                         ; (compared to interrupt code). Loop will
1605   D043                         ; execute slower when the computing load
1606   D043                         ; increases...A minimum of 20Hz is monitored
1607   D043                         ; by the COP function? 
1608   D043                         ;---------------------------------------------                                                       
1609   D043 BD D1 7D    L1001       jsr     subroutine1                ; 
1610   D046 BD DF 71                jsr     subroutine2                ; 
1611   D049 BD DD 9C                jsr     subroutine3                ; 
1612   D04C BD E5 6D                jsr     subroutine4                ; 
1613   D04F 7E D0 43                jmp     L1001                      ; 
1614   D052             
1615   D052             
1616   D052             
1617   D052             ;******************************************************************
1618   D052             ;
1619   D052             ;
1620   D052             ; Initialization subroutine
1621   D052             ;
1622   D052             ;
1623   D052             ;******************************************************************
1624   D052                         ;------------------------------------------------------------------                       
1625   D052                         ; Init all outputs  (port1, port2 port5 and port6) to known states
1626   D052                         ;------------------------------------------------------------------                       
1627   D052 CC BF 0F    ecuInit     ldd     #$bf0f                    ;                               
1628   D055 DD 02                   std     port1                     ; port1 = 1011 1111, port2 = 0000 ffff                             
1629   D057 03 16 FF                orm     port5, #$ff               ; port5 = 1111 1111
1630   D05A 02 2F 00                andm    port6, #$00               ; port6 = 0000 0000
1631   D05D             
1632   D05D                         ;-------------------------------------------------------------                       
1633   D05D                         ; Init port1 through port5 data direction registers
1634   D05D                         ; Init real time interrupt frequency
1635   D05D                         ; Init L000f, L0017 and L0024 to 0 (never used in the code???)
1636   D05D                         ;-------------------------------------------------------------                       
1637   D05D BD EA 30                jsr     initFunc1                 ;                                  
1638   D060 CC 1B 3D                ldd     #$1b3d                    ;                               
1639   D063 97 08                   staa    t1_csr                    ; t1_csr = 0001 1011, enable injectors and cas interrupts, disable injectors, set cas detection edge polarity?
1640   D065 D7 18                   stab    t2_csr                    ;                               
1641   D067 CC 5E 0A                ldd     #$5e0a                    ;                               
1642   D06A DD 19                   std     t3_csr0                   ; t3_csr0 = 0101 1110, t3_csr1 = 0000 1010, both coils not energized                             
1643   D06C BD D1 62                jsr     init_t1_t2                ;                                   
1644   D06F                                                                                    
1645   D06F                         ;-----------------------------------------------------------                       
1646   D06F                         ; Clear RAM from ramClearStart to ramClearEnd inclusively   
1647   D06F                         ;-----------------------------------------------------------                       
1648   D06F             #ifndef noRamReset
1649   D06F CD CE 00 57             ldy     #ramClearStart            ;                             
1650   D073 4F                      clra                              ;                             
1651   D074 5F                      clrb                              ;                             
1652   D075 ED 80       L1003       std     $00,y                     ; Operation does y = y + 2                                               
1653   D077 CD 8C 01 91             cmpy    #ramClearEnd+1            ;                                             
1654   D07B 25 F8                   bcs     L1003                     ;                              
1655   D07D             #endif
1656   D07D                                                                                    
1657   D07D                         ;------------------------------------------------
1658   D07D                         ; Read all 8 ADC ports values and store in ram
1659   D07D                         ;------------------------------------------------
1660   D07D CD CE 00 CB             ldy     #ectRaw                   ;                                
1661   D081 86 08                   ldaa    #$08                      ; start with port 0 and start bit set ($08)                          
1662   D083 36          L1004       psha                              ;                           
1663   D084 BD EC 17                jsr     readAdc2                  ;                              
1664   D087 E7 80                   stab    $00,y                     ; y = y + 1                          
1665   D089 32                      pula                              ;                           
1666   D08A 4C                      inca                              ;                           
1667   D08B 81 10                   cmpa    #$10                      ;                           
1668   D08D 25 F4                   bcs     L1004                     ;                           
1669   D08F             
1670   D08F                         ;-------------------------------------------------------
1671   D08F                         ; Check if all ISC variables are initialized properly
1672   D08F                         ; If not then re-initialize ECU from scratch
1673   D08F                         ;-------------------------------------------------------
1674   D08F CE B0 00                ldx     #$b000                    ;                           
1675   D092 9C 44                   cpx     isc0                      ;                          
1676   D094 25 20                   bcs     L1005                     ; Branch to re-initialize ECU from scratch 
1677   D096 9C 46                   cpx     isc1                      ;                             
1678   D098 25 1C                   bcs     L1005                     ; Branch to re-initialize ECU from scratch                             
1679   D09A CE 6C 00                ldx     #$6c00                    ;                               
1680   D09D 9C 44                   cpx     isc0                      ;                             
1681   D09F 22 15                   bhi     L1005                     ; Branch to re-initialize ECU from scratch                              
1682   D0A1 9C 46                   cpx     isc1                      ;                             
1683   D0A3 22 11                   bhi     L1005                     ; Branch to re-initialize ECU from scratch                             
1684   D0A5 96 49                   ldaa    iscStepCurr               ;                                    
1685   D0A7 81 87                   cmpa    #$87                      ;                             
1686   D0A9 22 0B                   bhi     L1005                     ; Branch to re-initialize ECU from scratch                             
1687   D0AB 43                      coma                              ;                             
1688   D0AC 84 7F                   anda    #$7f                      ;                             
1689   D0AE 91 48                   cmpa    iscStepCom                ;                                   
1690   D0B0 26 04                   bne     L1005                     ; Branch to re-initialize ECU from scratch                             
1691   D0B2             
1692   D0B2                         ;-----------------------------------------------------------
1693   D0B2                         ; All ISC variables look OK
1694   D0B2                         ; Check if ram control register was erased (loss of power)
1695   D0B2                         ;-----------------------------------------------------------
1696   D0B2 D6 14                   ldab    ramControl                ;                              
1697   D0B4~            #ifdef octaneReset                            ;
1698   D0B4~                        bmi     L1006a                    ;
1699   D0B4             #else                                         
1700   D0B4 2B 2C                   bmi     L1006                     ; Branch if ramControl.7 set, i.e. we already did a fresh reset and power was not lost
1701   D0B6             #endif
1702   D0B6                                                                         
1703   D0B6                         ;------------------------------------------------------
1704   D0B6                         ; Perform a fresh reset, i.e. init ECU from scratch
1705   D0B6                         ;------------------------------------------------------
1706   D0B6                         ;---------------------------------------
1707   D0B6                         ; Reset all faults and fault counters
1708   D0B6                         ;---------------------------------------
1709   D0B6 4F          L1005       clra                              ;                             
1710   D0B7 5F                      clrb                              ;                             
1711   D0B8 DD 4C                   std     stFaultHi                 ;                                  
1712   D0BA DD 4E                   std     faultHi                   ;                                
1713   D0BC DD 50                   std     o2BadCnt                  ;                                 
1714   D0BE             
1715   D0BE                         ;--------------------
1716   D0BE                         ; Init ISC variables
1717   D0BE                         ;--------------------
1718   D0BE 86 80                   ldaa    #$80                      ;                             
1719   D0C0 97 4B                   staa    iscFlags0                 ; iscFlags0 = $80, isc max calibration is requested                                 
1720   D0C2 4F                      clra                              ;                             
1721   D0C3 BD E4 B6                jsr     iscStepComp               ; iscStepCurr = $0, iscStepCom = (~$0 & 7F)                                    
1722   D0C6 CC 8C 00                ldd     #$8c00                    ;                               
1723   D0C9 DD 44                   std     isc0                      ; isc0 = $8c                            
1724   D0CB DD 46                   std     isc1                      ; isc1 = $00
1725   D0CD             
1726   D0CD                         ;-------------------------------------------------------------                                      
1727   D0CD                         ; Set isc coil pattern and pattern index to t_iscPattern(0)
1728   D0CD                         ;-------------------------------------------------------------                                      
1729   D0CD C6 04                   ldab    #$04                      ;                             
1730   D0CF D7 4A                   stab    iscPatrnIdx               ; iscPatrnIdx = $04 (lower two bits = 00b)                              
1731   D0D1 03 16 80                orm     port5, #$80               ; ISC coil pattern bit 6 and 7 = 10b = t_iscPattern(0)                               
1732   D0D4 02 16 BF                andm    port5, #$bf               ; ISC coil pattern bit 6 and 7 = 10b = t_iscPattern(0)                               
1733   D0D7             
1734   D0D7                         ;-------------------------------------------------------------                                      
1735   D0D7                         ; Init fuel trim to 100% and ftrimCntr to $80 
1736   D0D7                         ;-------------------------------------------------------------                                      
1737   D0D7 86 80                   ldaa    #$80                                                 
1738   D0D9 16                      tab                                                          
1739   D0DA DD 40                   std     ftrim_low                                                 
1740   D0DC DD 42                   std     ftrim_hi                                                 
1741   D0DE             
1742   D0DE                         ;------------------------------------
1743   D0DE                         ; Init octane to max, i.e. good fuel
1744   D0DE                         ;------------------------------------
1745   D0DE 86 FF       L1006a      ldaa    #$ff                    ; Reset octane value to max value (good fuel, no knock)
1746   D0E0 97 52                   staa    octane                                                 
1747   D0E2             
1748   D0E2                         ;-------------------------------------------------
1749   D0E2                         ; Set the ramControl flag bits since 
1750   D0E2                         ; fresh reset steps are (or were already) done
1751   D0E2                         ;-------------------------------------------------
1752   D0E2 86 C0       L1006       ldaa    #$c0                    ;                             
1753   D0E4 97 14                   staa    ramControl              ;              
1754   D0E6                                              
1755   D0E6                         ;-----------------------------------------
1756   D0E6                         ; Init timing/knock variables to defaults
1757   D0E6                         ;-----------------------------------------
1758   D0E6 CC FF A0                ldd     #$ffa0                  ;                               
1759   D0E9 97 64                   staa    TcasLast0               ;                                  
1760   D0EB B7 01 77                staa    knockTimer              ;                                   
1761   D0EE D7 88                   stab    tim61Tot0               ;                                  
1762   D0F0 B6 FE A7                ldaa    t_enerLen               ;                                  
1763   D0F3 97 89                   staa    enerLen                 ;                                
1764   D0F5             
1765   D0F5                         ;-----------------------------------------
1766   D0F5                         ; Init air count variables to default 
1767   D0F5                         ;-----------------------------------------
1768   D0F5 F6 FB A7                ldab    t_airCntMax             ; b = t_airCntMax(0)                              
1769   D0F8 D7 A0                   stab    airCntMax               ;                                  
1770   D0FA 86 08                   ldaa    #$08                    ;                             
1771   D0FC 3D                      mul                             ; d = 8 * airCntMax                            
1772   D0FD DD 8D                   std     airCnt0                 ;                                
1773   D0FF DD 92                   std     oldAirCnt0              ;                                   
1774   D101             
1775   D101                         ;-----------------------------------------
1776   D101                         ; Init engine state flags to notRotating
1777   D101                         ;-----------------------------------------
1778   D101 86 10                   ldaa    #$10                    ;                             
1779   D103 97 A2                   staa    state3                  ; engine notRotating                               
1780   D105 97 E6                   staa    state1                  ; engine notRotating 
1781   D107             
1782   D107                         ;---------------------------------------------
1783   D107                         ; Init cas flags, current cylinder to default
1784   D107                         ;---------------------------------------------
1785   D107 CC 05 03                ldd     #$0503                  ;                               
1786   D10A 97 B3                   staa    tdcCasFlags             ; Why not use std??? I guess it is not obvious taht they are not contiguous just by looking at variable names...                             
1787   D10C D7 B4                   stab    casCylIndex             ;                              
1788   D10E             
1789   D10E                         ;----------------------
1790   D10E                         ; More init to default
1791   D10E                         ;----------------------
1792   D10E 86 FF                   ldaa    #$ff                    ;                             
1793   D110 97 BA                   staa    obdInjCmd               ; No obd injector command                                  
1794   D112 B7 01 74                staa    coilChkCnt              ;                                   
1795   D115 B7 01 35                staa    T2_EcuPower             ;                                    
1796   D118 97 C6                   staa    vss                     ; speed = 0                           
1797   D11A             
1798   D11A                         ;-----------------------------------------------------
1799   D11A                         ; Init reed switch flag to current reed switch value
1800   D11A                         ; and init 40Hz bit to 1
1801   D11A                         ;-----------------------------------------------------
1802   D11A 96 02                   ldaa    port1                   ;                              
1803   D11C 84 80                   anda    #$80                    ; Keep only reed switch bit                             
1804   D11E 4C                      inca                            ;                             
1805   D11F 97 BD                   staa    rtiReedFlags            ; Store latest Reed switch in bit 7 and set bit 1 for 40Hz based events
1806   D121             
1807   D121                         ;---------------------------------------------
1808   D121                         ; More init to default
1809   D121                         ;---------------------------------------------
1810   D121 86 06                   ldaa    #$06                    ; 30ms                             
1811   D123 97 C2                   staa    T200_cop                ;                                  
1812   D125 97 BE                   staa    T200_40Hz               ;                                  
1813   D127 97 CA                   staa    L00ca                   ; Never used in the code??????????????                             
1814   D129             
1815   D129                         ;---------------------------------------------
1816   D129                         ; More init to default
1817   D129                         ;---------------------------------------------
1818   D129 96 D2                   ldaa    tpsRaw                  ;                               
1819   D12B 97 C7                   staa    oldTps2                 ;                              
1820   D12D 86 0E                   ldaa    #$0e                    ;                             
1821   D12F B7 01 1B                staa    T40_baro                ;                              
1822   D132 CC 14 50                ldd     #$1450                  ;                               
1823   D135 B7 01 17                staa    T40_2hz                 ;                              
1824   D138 F7 01 18                stab    T40_0p5hz               ;                              
1825   D13B             
1826   D13B                         ;--------------------------------------------------
1827   D13B                         ; Reset all iscFlags0 and 
1828   D13B                         ; If either min or max isc calibration flag was set
1829   D13B                         ; set iscStepCurr = 0 and request max calibration
1830   D13B                         ; else set flag indicating max calibration is done???
1831   D13B                         ;--------------------------------------------------
1832   D13B 86 40                   ldaa    #$40                    ; Assume max calibration flag is set                             
1833   D13D 8F 4B A0 06             brclr   iscFlags0, #$a0, L1007  ; branch if both max and min calibration flags are clear (1010 0000)
1834   D141 4F                      clra                            ;                             
1835   D142 BD E4 B6                jsr     iscStepComp             ; iscStepCurr = $00, iscStepCom = (~$00 & 7F) 
1836   D145 86 80                   ldaa    #$80                    ;                             
1837   D147 97 4B       L1007       staa    iscFlags0               ; iscFlags0 = $40 or $80
1838   D149             
1839   D149                         ;--------------
1840   D149                         ; Init timer
1841   D149                         ;--------------
1842   D149 86 05                   ldaa    #$05                    ;                             
1843   D14B B7 01 24                staa    T40_noPower             ;                                    
1844   D14E             
1845   D14E                         ;------------------------------------------
1846   D14E                         ; Init TDC and injector testing valriables
1847   D14E                         ;------------------------------------------
1848   D14E C6 08                   ldab    #$08                    ; b = 0000 1000                            
1849   D150 D7 B6                   stab    tdcCheck                ; tdcCheck = 0000 1000                            
1850   D152 D7 B8                   stab    injToTest               ; injToTest = 0000 1000                              
1851   D154             
1852   D154                         ;----------------------------------------------------------------------
1853   D154                         ; Load the ECU configuration variables according to resistor strapping
1854   D154                         ;----------------------------------------------------------------------
1855   D154 BD EA 21                jsr     loadConfig              ;                              
1856   D157             
1857   D157                         ;----------------------
1858   D157                         ; re-enable interrupts
1859   D157                         ;----------------------
1860   D157 0E                      cli                             ;
1861   D158                                                   
1862   D158                         ;-----------------------
1863   D158                         ; More init to defaults
1864   D158                         ;-----------------------
1865   D158 5F                      clrb                            ;                             
1866   D159 F7 01 21                stab    T40_mas                 ;                                 
1867   D15C F7 01 20                stab    T40_engRot              ;                                   
1868   D15F             
1869   D15F                         ;-------------------------------------
1870   D15F                         ; Init Tcas and TcasOld to max value 
1871   D15F                         ; since engine is not rotating
1872   D15F                         ;-------------------------------------
1873   D15F 8D 11                   bsr     init_Tcas               ;                              
1874   D161 39                      rts                                                          
1875   D162                         
1876   D162                         
1877   D162             
1878   D162             ;******************************************************************
1879   D162             ;
1880   D162             ; Initialize timer 1 and 2
1881   D162             ;
1882   D162             ;
1883   D162             ;
1884   D162             ;******************************************************************
1885   D162 03 08 09    init_t1_t2  orm     t1_csr, #$09             ; Deactivate injector 1 and enable injector 1 output compare interrupts
1886   D165 03 18 3D                orm     t2_csr, #$3d             ; Deactivate injector 3,2,4 and enable injector 3,2,4 output compare interrupts
1887   D168             
1888   D168                         ;---------------------------------------------------
1889   D168                         ; Schedule interrupt in 11us for t1 and t2
1890   D168                         ; i.e. Make sure injectors are actually deactivated
1891   D168                         ;---------------------------------------------------
1892   D168 DC 09                   ldd     t1t2_clk                                                 
1893   D16A C3 00 0B                addd    #$000b                                                 
1894   D16D DD 0B                   std     t1_outCmpWr                                                 
1895   D16F DD 1B                   std     t2_outCmpWr                                                 
1896   D171 39                      rts                                                          
1897   D172             
1898   D172             
1899   D172             
1900   D172             ;******************************************************************
1901   D172             ;
1902   D172             ; Initialize Tcas and TcasOld to $7fff (infinite, not rotating...)
1903   D172             ;
1904   D172             ;
1905   D172             ;
1906   D172             ;******************************************************************
1907   D172 CE 01 45    init_Tcas   ldx     #Tcas                                                 
1908   D175 CC 7F FF                ldd     #$7fff                                                 
1909   D178 ED 00                   std     $00,x                                                 
1910   D17A ED 02                   std     $02,x                                                 
1911   D17C 39                      rts                                                          
1912   D17D             
1913   D17D             
1914   D17D             
1915   D17D             ;******************************************************************
1916   D17D             ;
1917   D17D             ;
1918   D17D             ; First subroutine
1919   D17D             ;
1920   D17D             ;
1921   D17D             ;******************************************************************
1922   D17D                         ;----------------------------------------------
1923   D17D                         ; Clear counter state flag and check if 40Hz
1924   D17D                         ; flag was set by real time interrupt
1925   D17D                         ;----------------------------------------------
1926   D17D 4F          subroutine1 clra                              ; a=0, used to accumulate various conditions in code below                             
1927   D17E 8F BD 01 3B             brclr   rtiReedFlags, #$01, L1013 ; Branch if 40Hz flag is not yet set (flag is set at ~40Hz in RT interrupt)
1928   D182 02 BD FE                andm    rtiReedFlags, #$fe        ; Reset bit
1929   D185                         
1930   D185                         ;---------------------------------------------------------------
1931   D185                         ; 40Hz flag is set, process it (code executed 40 times a second,
1932   D185                         ; at the most...)
1933   D185                         ;---------------------------------------------------------------
1934   D185                         ;---------------------------------------------------------------
1935   D185                         ; Decrement all 40Hz timers (min of 0) from $0117 to $0132
1936   D185                         ;---------------------------------------------------------------
1937   D185 CE 01 17                ldx     #T40_2hz                ;                               
1938   D188 C6 1C                   ldab    #$1c                    ;                             
1939   D18A BD EC 02                jsr     decTable                ;                                 
1940   D18D 4C                      inca                            ; a.0=1, set at 40Hz 
1941   D18E             
1942   D18E                         ;------------------------------------------
1943   D18E                         ; Update 10Hz flag based on T40_2hz 
1944   D18E                         ;------------------------------------------
1945   D18E F6 01 17                ldab    T40_2hz                 ; 
1946   D191 C5 03                   bitb    #$03                    ;                              
1947   D193 26 02                   bne     L1011                   ; Branch 3 times out of 4???
1948   D195 8A 02                   oraa    #$02                    ; a.1=1, set at ~10Hz
1949   D197             
1950   D197                         ;----------------------------------------------------------
1951   D197                         ; Check T40_2hz, loops at $14 (20d), which produces 2Hz
1952   D197                         ;----------------------------------------------------------
1953   D197 5D          L1011       tstb                            ;                             
1954   D198 26 0F                   bne     L1012                   ; Branch if T40_2hz is not null yet (takes ~0.5sec)
1955   D19A             
1956   D19A                         ;----------------------------------------------------------------------
1957   D19A                         ; Decrement all 2Hz timers (min of 0) from $0134 to $13f
1958   D19A                         ;----------------------------------------------------------------------
1959   D19A CE 01 34                ldx     #T2_crank               ;                                  
1960   D19D C6 0C                   ldab    #$0c                    ;                             
1961   D19F BD EC 02                jsr     decTable                ;                                 
1962   D1A2 8A 04                   oraa    #$04                    ; a.2=1, set at 2Hz 
1963   D1A4             
1964   D1A4                         ;-----------------
1965   D1A4                         ; Re-init counter
1966   D1A4                         ;-----------------
1967   D1A4 C6 14                   ldab    #$14                    ;                             
1968   D1A6 F7 01 17                stab    T40_2hz                 ;
1969   D1A9                                                         ;                 
1970   D1A9                         ;---------------------------------------------------------
1971   D1A9                         ; Check T40_0p5hz, loops at $50 (80d), which produces 0.5Hz
1972   D1A9                         ;---------------------------------------------------------
1973   D1A9 F6 01 18    L1012       ldab    T40_0p5hz               ;                              
1974   D1AC 26 0F                   bne     L1013                   ; Branch if T40_0p5hz is not null yet (takes ~2sec)                           
1975   D1AE             
1976   D1AE                         ;----------------------------------------------------------------
1977   D1AE                         ; Decrement all 0.5Hz timers (stop at 0) from $140 to $145
1978   D1AE                         ;----------------------------------------------------------------
1979   D1AE CE 01 40                ldx     #T0p5_crank1            ;                                
1980   D1B1 C6 05                   ldab    #$05                    ;                             
1981   D1B3 BD EC 02                jsr     decTable                ;                                 
1982   D1B6 8A 08                   oraa    #$08                    ; a.3=1
1983   D1B8             
1984   D1B8                         ;-----------------
1985   D1B8                         ; Re-init counter
1986   D1B8                         ;-----------------
1987   D1B8 C6 50                   ldab    #$50                    ;                             
1988   D1BA F7 01 18                stab    T40_0p5hz               ; Re-init T40_0p5hz with $50 (2sec)
1989   D1BD                         
1990   D1BD                         ;--------------------------------------------------------
1991   D1BD                         ; At this point, accum. A contains state of counters updated
1992   D1BD                         ; in the above code, store it in Tclocks                               
1993   D1BD                         ;--------------------------------------------------------
1994   D1BD 97 D9       L1013       staa    Tclocks                                                 
1995   D1BF             
1996   D1BF                         ;----------------------------------------------------------------------
1997   D1BF                         ; Re-init T40_crank, T2_crank, T0p5_crank1 to max if startingToCrank  
1998   D1BF                         ;----------------------------------------------------------------------
1999   D1BF 86 FF                   ldaa    #$ff                    ; a = $ff                             
2000   D1C1 8F E6 01 09             brclr   state1, #$01, L1014     ; Branch if startingToCrank is clear
2001   D1C5 B7 01 1A                staa    T40_crank               ; Engine startingToCrank, reset a few timers
2002   D1C8 B7 01 34                staa    T2_crank                ; 
2003   D1CB B7 01 40                staa    T0p5_crank1             ;                               
2004   D1CE             
2005   D1CE                         ;----------------------------------
2006   D1CE                         ; Re-init T40_start if key is in start
2007   D1CE                         ;----------------------------------
2008   D1CE 87 D7 40 03 L1014       brset   port3Snap0, #$40, L1015 ; Branch if key is not in start
2009   D1D2 B7 01 19                staa    T40_start               ; Key in start, re-init counter                             
2010   D1D5             
2011   D1D5                         ;-------------------------------------------------------------------
2012   D1D5                         ; Load config1 and config2 memories depending on config resistors
2013   D1D5                         ;-------------------------------------------------------------------
2014   D1D5 BD EA 21    L1015       jsr     loadConfig                   
2015   D1D8             
2016   D1D8                         ;-------------------------------------------------------
2017   D1D8                         ; Reset counter T200_cop to $0a (on every loop,
2018   D1D8                         ; will reach 0 only if main loop takes more
2019   D1D8                         ; than 50ms=10/200Hz, i.e. main loop slower than 20Hz)
2020   D1D8                         ; Could be used as a COP monitor to reset ECU???
2021   D1D8                         ;-------------------------------------------------------
2022   D1D8 86 0A                   ldaa    #$0a                    ; 50ms or 20Hz                             
2023   D1DA 97 C2                   staa    T200_cop                ; Re-init counter                               
2024   D1DC BD EA 30                jsr     initFunc1               ; Re-init ports and other stuff on every loop???, maybe used in conjunction with T200_cop timer...??? 
2025   D1DF             
2026   D1DF                         ;----------------------------------------
2027   D1DF                         ; Re-init timer 1 and 2 and t3_csr0 
2028   D1DF                         ;----------------------------------------
2029   D1DF 0F                      sei                             ;                             
2030   D1E0 02 08 1B                andm    t1_csr, #$1b            ;                                 
2031   D1E3 03 08 18                orm     t1_csr, #$18            ;                                 
2032   D1E6 03 18 18                orm     t2_csr, #$18            ;                                 
2033   D1E9 02 19 5E                andm    t3_csr0, #$5e           ;                                
2034   D1EC 03 19 42                orm     t3_csr0, #$42           ;                                
2035   D1EF 0E                      cli
2036   D1F0             
2037   D1F0                         ;---------------------------------------------------------
2038   D1F0                         ; Re-init some stuff in case the engine is not rotating
2039   D1F0                         ;---------------------------------------------------------
2040   D1F0 0F                      sei                             ;                             
2041   D1F1 F6 01 20                ldab    T40_engRot              ;                                     
2042   D1F4 26 0D                   bne     L1016                   ; Branch if T40_engRot not expired                             
2043   D1F6 CC 05 03                ldd     #$0503                  ; T40_engRot reached 0, re-init stuff since engine not rotating
2044   D1F9 97 B3                   staa    tdcCasFlags             ;                              
2045   D1FB D7 B4                   stab    casCylIndex             ; Why not std?                             
2046   D1FD 7F 00 A7                clr     injPw                   ;                              
2047   D200 BD D1 62                jsr     init_t1_t2              ;                         
2048   D203                              
2049   D203                         ;---------------------------------------------------------
2050   D203                         ; Re-init cas related controls if T40s_casInt is expired 
2051   D203                         ; i.e. no CAS interrupts received for over 1.275sec
2052   D203                         ;---------------------------------------------------------
2053   D203 87 84 FF 0C L1016       brset   T40s_casInt, #$ff, L1017 ; Branch if T40s_casInt not expired (not 0)                               
2054   D207 7F 00 83                clr     tdcCasCount              ; tdcCasCount = 0                                    
2055   D20A 03 19 0C                orm     t3_csr0, #$0c            ; set 0000 1111, disable both power transistor coils and ???
2056   D20D 03 1A 0A                orm     t3_csr1, #$0a            ; set 0000 1010,                                                                   
2057   D210 4F                      clra                             ;                                                                   
2058   D211 97 63                   staa    enerFlags                ;                                                                    
2059   D213 0E          L1017       cli                              ;                                                                 
2060   D214             
2061   D214                         ;------------------------------
2062   D214                         ; Check if ECU is in test mode
2063   D214                         ;------------------------------
2064   D214 87 07 08 12             brset   port4, #$08, L1018       ; Branch if ECU test mode terminal is grounded
2065   D218             
2066   D218                         ;--------------------------------------
2067   D218                         ; Not in test mode, Reset serial comm.
2068   D218                         ;--------------------------------------
2069   D218 DC 11                   ldd     sci_scr                          ; Read serial port at address 0011 (status) and 0012 (data) (clears it)?       
2070   D21A CC 06 00                ldd     #($0400 |((baudRate & $03)<<8))  ; A=06, B=00                                                                    
2071   D21D DD 10                   std     sci_baud                         ; set serial port mode, sci_rate=06, sci_cr=00                                                          
2072   D21F 03 BA 3F                orm     obdInjCmd, #$3f                  ; Reset all injector off commands                                                                         
2073   D222 7F 00 FB                clr     obdActCmd                        ; Reset all actuator on commands
2074   D225 02 FA 3C                andm    obdFlags, #$3c                   ; Reset stored serial port state to 00xxxx00?, FA.0 and FA.1 are reset to 0                                  
2075   D228 20 26                   bra     L1022                                                      
2076   D22A                         
2077   D22A                         ;------------------------------------
2078   D22A                         ; At this point, we are in test mode
2079   D22A                         ;------------------------------------
2080   D22A 87 FA 02 06 L1018       brset   obdFlags, #$02, L1019     ; Check if port2.4 initialized to 1 (output to serial connector)?                                                 
2081   D22E 03 03 10                orm     port2, #$10               ; Set output to serial port to 1 (heart beat level on diagnostic port if TE not enabled)                          
2082   D231 03 FA 02                orm     obdFlags, #$02            ; Set $FA.1 indicating we initialized default serial port output                                                   
2083   D234 87 FA 01 0F L1019       brset   obdFlags, #$01, L1020     ; branch if FA.0 is 1? (FA.0 seems to be toggled on every loop)                                                   
2084   D238             
2085   D238                         ;---------------------------------------------------------------------------------
2086   D238                         ; At this point serial tx was previously enabled, reset all parameters anyway
2087   D238                         ; Code is executed only after tx is enabled on first loop at (preamble is sent, 
2088   D238                         ; we don't want to receive the echo...) and then at 1/2 loop frequency
2089   D238                         ;---------------------------------------------------------------------------------
2090   D238 86 06                   ldaa    #($04 | (baudRate & $03)) ;
2091   D23A D6 11                   ldab    sci_scr                   ;                              
2092   D23C C4 FA                   andb    #$fa                      ;                           
2093   D23E CA 18                   orab    #$18                      ;                           
2094   D240 DD 10                   std     sci_baud                  ; Set baud rate and serial port mode                               
2095   D242 03 FA 01                orm     obdFlags, #$01            ;                                 
2096   D245 20 06                   bra     L1021                     ;                            
2097   D247 03 11 02    L1020       orm     sci_scr, #$02             ;                                
2098   D24A 02 FA FE                andm    obdFlags, #$fe            ;                                 
2099   D24D 7F 01 7C    L1021       clr     errCodeProc               ; Reset code (no code...) being output to test connector (heart beat mode)                                    
2100   D250             
2101   D250                         ;------------------------------------------------
2102   D250                         ; Build port3Snap0 from port3
2103   D250                         ;------------------------------------------------
2104   D250 96 06       L1022       ldaa    port3                   ; a = port3                              
2105   D252 84 FB                   anda    #$fb                    ; Reset 0000 0100
2106   D254~            #ifdef E932
2107   D254~                        ldab    T40_start               ;                              
2108   D254~                        addb    #$3c                    ; add 1.5s                            
2109   D254~                        bcc     L1023                   ; branch if key was out of start for more than than 1.5s                            
2110   D254             #endif
2111   D254 8A 20                   oraa    #$20                    ; force setting of park/neutral flag                             
2112   D256 F6 01 1A    L1023       ldab    T40_crank               ;                                   
2113   D259 CB AC                   addb    #$ac                    ; 4.3s                             
2114   D25B 24 02                   bcc     L1024                   ; branch if engine stopped "startingToCrank" more than 4.3s ago                              
2115   D25D 8A 10                   oraa    #$10                    ; Force setting of A/C switch flag                             
2116   D25F 8F E6 11 02 L1024       brclr   state1, #$11, L1025     ; Branch if both notRotating and startingToCrank clear
2117   D263 8A 30                   oraa    #$30                    ; engine is either notRotating or startingToCrank, force setting of both A/C switch  and park/neutral flags                              
2118   D265 D6 D3       L1025       ldab    ectFiltered             ;                              
2119   D267 C1 9B                   cmpb    #$9b                    ; 10.2degC                              
2120   D269 25 02                   bcs     L1026                   ; Branch if ECT temperature lower than threshold                             
2121   D26B 84 F7                   anda    #$f7                    ; Reset $08, power steering flag                            
2122   D26D 97 D7       L1026       staa    port3Snap0               ;                              
2123   D26F             
2124   D26F                         ;----------------------------
2125   D26F                         ; Build port4Snap from port4
2126   D26F                         ;----------------------------
2127   D26F 96 07                   ldaa    port4                   ;                              
2128   D271 84 78                   anda    #$78                    ; Only keep 01111000                             
2129   D273 97 D8                   staa    port4Snap               ;                              
2130   D275             
2131   D275                         ;------------------------------------------
2132   D275                         ; Read some ADC inputs 
2133   D275                         ;     ECT (engine coolant temp)
2134   D275                         ;     IAT (intake air temp)
2135   D275                         ;     BARO
2136   D275                         ;     O2
2137   D275                         ;     EGRT
2138   D275                         ;------------------------------------------
2139   D275 CD CE 00 CB             ldy     #$00cb                  ;                               
2140   D279 86 08                   ldaa    #$08                    ;                             
2141   D27B 36          L1027       psha                            ;                             
2142   D27C BD EC 16                jsr     readAdc1                ;                                 
2143   D27F 0E                      cli                             ;                             
2144   D280 E7 80                   stab    $00,y                   ; y = y + 1                              
2145   D282 32                      pula                            ;                             
2146   D283 4C                      inca                            ;                             
2147   D284 81 0D                   cmpa    #$0d                    ;                             
2148   D286 25 F3                   bcs     L1027                   ;       
2149   D288                                                
2150   D288                         ;------------------------------------------------------
2151   D288                         ; Validate and condition raw engine coolant temperature
2152   D288                         ;------------------------------------------------------
2153   D288 02 D6 F0                andm    state2, #$f0            ; Reset error flags before update below                                 
2154   D28B D6 CB                   ldab    ectRaw                  ; b = ectRaw                              
2155   D28D C1 05                   cmpb    #$05                    ; 141degC                            
2156   D28F 25 04                   bcs     L1028                   ;                              
2157   D291 C1 EC                   cmpb    #$ec                    ; -52degC                             
2158   D293 23 05                   bls     L1029                   ;                              
2159   D295 C6 1E       L1028       ldab    #$1e                    ; Use default of 83degC
2160   D297 03 D6 01                orm     state2, #$01            ; Set error flag                                
2161   D29A             
2162   D29A                         ;-------------------------------------------------
2163   D29A                         ; Check some conditions for filtered ECT update
2164   D29A                         ;-------------------------------------------------
2165   D29A 8F D6 10 02 L1029       brclr   state2, #$10, L1030     ;                                
2166   D29E C6 1E                   ldab    #$1e                    ; Use default of 83degC
2167   D2A0 87 E6 10 1C L1030       brset   state1, #$10, L1033     ; Branch if notRotating                                
2168   D2A4 8F D9 04 1F             brclr   Tclocks, #$04, L1035    ; Branch if 2Hz signal not set
2169   D2A8             
2170   D2A8                         ;----------------------------------------------------
2171   D2A8                         ; At this point 2 Hz signal is set and  b = validated ECT
2172   D2A8                         ;
2173   D2A8                         ; Filter the validated ECT
2174   D2A8                         ;
2175   D2A8                         ; This section of code computes ectFiltered which
2176   D2A8                         ; is basically the same as validated ECT except
2177   D2A8                         ; that it can only increase by 3 units every 0.5s...
2178   D2A8                         ; or decrease by 1 unit every 0.5s
2179   D2A8                         ;----------------------------------------------------
2180   D2A8 96 D3                   ldaa    ectFiltered             ; a = ectFiltered
2181   D2AA 10                      sba                             ; a = a-b = ectFiltered - validated ECT = ECTdiff
2182   D2AB 24 09                   bcc     L1031                   ; Branch if ectFiltered >= validated ECT (new temp is higher than old one, which is normal case when warming...)
2183   D2AD D6 D3                   ldab    ectFiltered             ; ectFiltered < validated ECT (temperatured lowered...)                             
2184   D2AF C1 54                   cmpb    #$54                    ; 41degC                             
2185   D2B1 27 12                   beq     L1034                   ; branch if equal to this temp????                            
2186   D2B3 5C                      incb                            ; else increment validated ECT (decrease temp) by 1 at a time (slowly change it to reflect sensor value...)
2187   D2B4 20 0A                   bra     L1033                   ;
2188   D2B6             
2189   D2B6 81 03       L1031       cmpa    #$03                    ; Check ECT difference
2190   D2B8 23 02                   bls     L1032                   ; Branch if ECT difference <= 3  (5F)                             
2191   D2BA 86 03                   ldaa    #$03                    ; Difference higher than 3, use 3                            
2192   D2BC 90 D3       L1032       suba    ectFiltered             ;                              
2193   D2BE 40                      nega                            ; a = ectFiltered-min(ECTdiff,3) =  ectFiltered - min(ectFiltered-validatedECT, 3) = validatedECT if difference smaller than 3, else it lags behind... 
2194   D2BF 16                      tab                             ; b = ectFiltered-min(ECTdiff,3)
2195   D2C0             
2196   D2C0 86 96       L1033       ldaa    #$96                    ; 300s (5 minutes!!!)                              
2197   D2C2 B7 01 44                staa    T0p5_ect                ; Reset counter                               
2198   D2C5 D7 D3       L1034       stab    ectFiltered             ; ectFiltered = filtered and validated ECT
2199   D2C7             
2200   D2C7                         ;----------------------------------------------------------
2201   D2C7                         ; Compute ectCond which is used for table interpolation
2202   D2C7                         ; Limit max value to $e0 (min temp of -29degC) 
2203   D2C7                         ; Scale by 8 below $20 (temp above 80degC) 
2204   D2C7                         ;
2205   D2C7                         ;     ectFiltered          ectFiltered        ectCond
2206   D2C7                         ;  -31degC to -59degC          $e1-$ff   ->   $e0        
2207   D2C7                         ;   80degC to -29degC          $20-$e0   ->   $20-$e0    
2208   D2C7                         ;   81.3degC                       $1f   ->   $18        
2209   D2C7                         ;   82.8degC                       $1e   ->   $10        
2210   D2C7                         ;   84.3degC                       $1d   ->   $08        
2211   D2C7                         ;   158degC to 85.9degC        $00-$1c   ->   $00        
2212   D2C7                         ;----------------------------------------------------------
2213   D2C7 D6 D3       L1035       ldab    ectFiltered             ;                                    
2214   D2C9 C1 E0                   cmpb    #$e0                    ; -29degC                            
2215   D2CB 23 02                   bls     L1036                   ; Branch if ectFiltered <= $e0
2216   D2CD C6 E0                   ldab    #$e0                    ; Use max of $e0
2217   D2CF C1 20       L1036       cmpb    #$20                    ; 80degC  
2218   D2D1 24 08                   bcc     L1038                   ; Branch if ectFiltered >= $20
2219   D2D3 C0 1C                   subb    #$1c                    ; b = ectFiltered - $1c
2220   D2D5 24 01                   bcc     L1037                   ; Branch if no underflow
2221   D2D7 5F                      clrb                            ; underflow, use 0 
2222   D2D8 58          L1037       aslb                            ;                             
2223   D2D9 58                      aslb                            ;                             
2224   D2DA 58                      aslb                            ; b = (ectFiltered-$1c)*8 
2225   D2DB F7 01 4E    L1038       stab    ectCond                 ; Store conditionned ect          
2226   D2DE                                  
2227   D2DE                         ;-------------------------------------------------
2228   D2DE                         ; Validate/condition raw intake air temperature
2229   D2DE                         ;-------------------------------------------------
2230   D2DE D6 CC                   ldab    iatRaw                  ;                               
2231   D2E0 C1 0E                   cmpb    #$0e                    ; 122degC
2232   D2E2 25 04                   bcs     L1039                   ; Branch if temp > 122degC
2233   D2E4 C1 EA                   cmpb    #$ea                    ; -49degC                            
2234   D2E6 23 05                   bls     L1040                   ; Branch if temp > -49degC                              
2235   D2E8 03 D6 02    L1039       orm     state2, #$02            ; Set fault code                                
2236   D2EB C6 7B                   ldab    #$7b                    ; Use 25degC
2237   D2ED D7 D4       L1040       stab    iatChecked              ;                 
2238   D2EF                          
2239   D2EF                         ;-----------------------------------------------------------
2240   D2EF                         ; Compute conditionned IAT for later table interpolation
2241   D2EF                         ;-----------------------------------------------------------
2242   D2EF CE E0 20                ldx     #$e020                  ; Load x with max/offset (max=$e0)                              
2243   D2F2 BD EB C4                jsr     clipOffset              ; b = max(min(b,$e0)-$20,0)-> offset and clip temp, returns b=$00 to $c0
2244   D2F5 F7 01 4F                stab    iatCond                 ; Conditionned IAT
2245   D2F8                                                      
2246   D2F8                         ;-------------------------------------------------
2247   D2F8                         ; Compute air density factor based on air temperature
2248   D2F8                         ;-------------------------------------------------
2249   D2F8 CE FC 1C                ldx     #t_airDens              ;                               
2250   D2FB BD EB 44                jsr     iatCInterp              ;                              
2251   D2FE F7 01 5F                stab    iatCompFact             ; Air density factor                             
2252   D301             
2253   D301                         ;---------------------------------------------------
2254   D301                         ; Check battery voltage for baro sensor validation
2255   D301                         ;---------------------------------------------------
2256   D301 96 D0                   ldaa    battRaw                   ;                                 
2257   D303 81 6D                   cmpa    #$6d                      ; 8V
2258   D305 24 05                   bcc     L1042                     ; Branch if more than 8V                             
2259   D307 86 0E                   ldaa    #$0e                      ; battery voltage too low, start timer??? (0.35sec)                            
2260   D309 B7 01 1B                staa    T40_baro                  ;                              
2261   D30C             
2262   D30C                         ;------------------------------------------------------------
2263   D30C                         ; Validate baro range, T40_baro is used to ignore baroRaw
2264   D30C                         ; When battery<8v (and 0.35s after it is >8V)
2265   D30C                         ;------------------------------------------------------------
2266   D30C D6 CD       L1042       ldab    baroRaw                   ; 
2267   D30E B6 01 1B                ldaa    T40_baro                  ;                                                                 
2268   D311 26 0B                   bne     L1044                     ; Branch if battery voltage was too low                                                                
2269   D313 C1 E4                   cmpb    #$e4                      ; 1.1 bar                                                       
2270   D315 24 04                   bcc     L1043                     ; branch if baroRaw > 1.1
2271   D317 C1 64                   cmpb    #$64                      ; .49 bar                                                       
2272   D319 24 05                   bcc     L1045                     ; branch if baroRaw > .49
2273   D31B 03 D6 04    L1043       orm     state2, #$04              ; Set error flag
2274   D31E C6 CD       L1044       ldab    #$cd                      ; Use 1.0 bar                                           
2275   D320 D7 D5       L1045       stab    baroChecked               ;                                                                
2276   D322             
2277   D322                         ;-----------------------------------------------------
2278   D322                         ; Compute conditionned baro for table interpolation
2279   D322                         ;-----------------------------------------------------
2280   D322 CE BD 5D                ldx     #$bd5d                    ;                                                                  
2281   D325 BD EB C4                jsr     clipOffset                ; b = max(min(b,$bd)-$5d,0)-> offset and clip baro, returns b = $00 to $60  (0.45bar to 0.92bar???)                                           
2282   D328 C1 40                   cmpb    #$40                      ;                                                                
2283   D32A 25 03                   bcs     L1046                     ; branch if b < $40 
2284   D32C 58                      aslb                              ; else mult by 2                                                
2285   D32D C0 40                   subb    #$40                      ; and sub 40 -> 1:1 scale for $00 to $40 and 2:1 scale for $40 to $60, new max is $80, not $60                                                   
2286   D32F F7 01 52    L1046       stab    baroCond                  ; Conditionned baro used in table lookup
2287   D332             
2288   D332                         ;----------------------------------------------------
2289   D332                         ; Compute barometric pressure factor for fuel inj.
2290   D332                         ;----------------------------------------------------
2291   D332 D6 D5                   ldab    baroChecked               ;                                                 
2292   D334 86 A0                   ldaa    #$a0                      ;                                                                
2293   D336 3D                      mul                               ; baroChecked*160                                                              
2294   D337 58                      aslb                              ;                                                                
2295   D338 89 00                   adca    #$00                      ; round-up                                                              
2296   D33A B7 01 60                staa    baroFact                  ; barometric pressure factor = rounded baroChecked*160/256 -> pressure is (baroFact/128) bar, i.e. $80 = 1 bar                                                    
2297   D33D             
2298   D33D                         ;-------------------------------------------------------------
2299   D33D                         ; Transfer tpsDiffMax1 to tpsDiffMax2 and reset tpsDiffMax1 
2300   D33D                         ;-------------------------------------------------------------
2301   D33D 0F                      sei                               ;                                                              
2302   D33E 96 C8                   ldaa    tpsDiffMax1               ;                                  
2303   D340 7F 00 C8                clr     tpsDiffMax1               ;                                  
2304   D343 0E                      cli                               ;                           
2305   D344 B7 01 4D                staa    tpsDiffMax2               ;     
2306   D347                                                      
2307   D347                         ;-----------------------------------------------------------
2308   D347                         ; If engine is not rotating, re-init Tcas and use rpm = 0
2309   D347                         ;-----------------------------------------------------------
2310   D347 8F E6 10 07             brclr   state1, #$10, L1047       ; Branch if notRotating clear
2311   D34B BD D1 72                jsr     init_Tcas                 ; engine is notRotating, re-init Tcas
2312   D34E 4F                      clra                              ;                              
2313   D34F 5F                      clrb                              ; use d = rpm = 0 for below                             
2314   D350 20 06                   bra     L1048                     ;                              
2315   D352             
2316   D352                         ;------------------------------------------------------------------------
2317   D352                         ; Update rpm variables from Tcas (Tcas is obtained from CAS interrupt)
2318   D352                         ;------------------------------------------------------------------------
2319   D352 FC 01 45    L1047       ldd     Tcas                      ;                               
2320   D355 BD EA 50                jsr     calcFreq                  ; D = $EA600/Tcas = 960000/Tcas = 960000/(125000/2/(rpm/60)) = 0.256*rpm                                
2321   D358 DD DA       L1048       std     rpm4                      ; RPM4 = #$EA600/Tcas = 0.256*rpm                                                                    
2322   D35A BD EB B9                jsr     scale2m                   ; scale D by 2                                                                                           
2323   D35D D7 DC                   stab    rpm8                      ; rpm8 = #$EA600/Tcas/2 = rpm/7.8125                                                              
2324   D35F DC DA                   ldd     rpm4                      ; D = #$EA600/Tcas                                                                                     
2325   D361 BD EB B7                jsr     scale8m                   ; D = #$EA600/Tcas/8 = rpm/31.25                                                                       
2326   D364 D7 DD                   stab    rpm31                     ; rpm31 = #$EA600/Tcas/8 = #$EA600 / (125000/2/(rpm/60)) / 8 = rpm/31.25.                              
2327   D366             
2328   D366                         ;------------------------------------------------------
2329   D366                         ; Compute rpmIndex1 for eventual map interpolation 
2330   D366                         ;------------------------------------------------------
2331   D366 86 90                   ldaa    #$90                      ; a=$90 (4500rpm)                            
2332   D368 BD EC 27                jsr     rpmRange                  ; get rpm for map interpolation, b = min(max(RPM31p25-#$10, 0), $90) = min(max(RPM31p25-500rpm,0),4500rpm)  
2333   D36B F7 01 51                stab    rpmIndex1                 ; rpmIndex1
2334   D36E                                                      
2335   D36E                         ;-------------------------------------------------------------
2336   D36E                         ; if notRotating or startingToCrank. Use rpmX4Filt = 16*rpm4
2337   D36E                         ;-------------------------------------------------------------
2338   D36E 8F E6 11 0B             brclr   state1, #$11, L1049       ; branch if notRotating and startingToCrank clear 
2339   D372 DC DA                   ldd     rpm4                      ; engine is either notRotating or startingToCrank                               
2340   D374 05                      asld                              ;                             
2341   D375 05                      asld                              ;                             
2342   D376 05                      asld                              ;                             
2343   D377 05                      asld                              ; d = 16*rpm4                              
2344   D378 02 9E FE                andm    masCasFlags, #$fe         ; reset masCasFlags.1                                
2345   D37B 20 32                   bra     L1050                     ; 
2346   D37D                                                      
2347   D37D                         ;-----------------------------------------------------------------
2348   D37D                         ; Engine is running, Use rpmX4Filt = filtered(16*rpm4)
2349   D37D                         ; Update only when masCasFlags.1 was set by interrupt 
2350   D37D                         ;
2351   D37D                         ; rpmX4Filt is basically the filtered version of rpm4 where 
2352   D37D                         ; an exponential averaging filter is used
2353   D37D                         ;
2354   D37D                         ; rpmX4Filt = $e8/256 * oldrpmX4Filt + $18/256   * 16*rpm4
2355   D37D                         ;              alpha * oldrpmX4Filt + (1-alpha) * 16*rpm4
2356   D37D                         ;
2357   D37D                         ; where alpha = 0.90625
2358   D37D                         ;-----------------------------------------------------------------
2359   D37D 8F 9E 01 31 L1049       brclr   masCasFlags, #$01, L1051  ; Branch if flag not set                              
2360   D381 02 9E FE                andm    masCasFlags, #$fe         ; Reset the flag
2361   D384 FE 01 84                ldx     rpmX4Filt                 ; x = rpmX4Filt                             
2362   D387 C6 E8                   ldab    #$e8                      ; b = $e8                            
2363   D389 BD EA 7D                jsr     mul816b                   ; d = $e8/256 * rpmX4Filt, temp3 = lower 8 bits of result                                 
2364   D38C FD 01 84                std     rpmX4Filt                 ; rpmX4Filt = $e8/256 * rpmX4Filt                             
2365   D38F 96 59                   ldaa    temp3                     ; 
2366   D391 97 5A                   staa    temp4                     ; temp4 = temp3 = lower 8 bits of ($e8/256 * old rpmX4Filt)                              
2367   D393 DC DA                   ldd     rpm4                      ;                             
2368   D395 05                      asld                              ;                             
2369   D396 05                      asld                              ;                             
2370   D397 05                      asld                              ;                             
2371   D398 05                      asld                              ; d = 16 * rpm4                            
2372   D399 1A                      xgdx                              ; x = 16 * rpm4                             
2373   D39A C6 E8                   ldab    #$e8                      ; b = $e8                            
2374   D39C 50                      negb                              ; b = -$e8 = $18 (why not load it directly, maybe mitsu compiler stuff...?)                            
2375   D39D BD EA 7D                jsr     mul816b                   ; d = $18/256 * 16 * rpm4                                
2376   D3A0 1A                      xgdx                              ; x = $18/256 * 16 * rpm4                             
2377   D3A1 5F                      clrb                              ; b = 0                            
2378   D3A2 96 59                   ldaa    temp3                     ; a = lower 8 bits of ($18/256 * 16 * rpm4)                              
2379   D3A4 9B 5A                   adda    temp4                     ; a = lower 8 bits of ($18/256 * 16 * rpm4) + lower 8 bits of ($e8/256 * old rpmX4Filt)                             
2380   D3A6 59                      rolb                              ; b = carry bit (if a carry was generated) from that addition                             
2381   D3A7 49                      rola                              ; a = a*2 (shift upper bit for roundoff purposes)                           
2382   D3A8 C9 00                   adcb    #$00                      ; Round off. At this point, b contains the rounded-up highest bit of the addition of the lowest 8 bits
2383   D3AA 3A                      abx                               ; x = $18/256 * 16 * rpm4 + rounded lower 1 bit                                                                               
2384   D3AB 1A                      xgdx                              ; d = $18/256 * 16 * rpm4 + rounded lower 1 bit                                                                                 
2385   D3AC F3 01 84                addd    rpmX4Filt                 ; d = $18/256 * 16 * rpm4 + $e8/256 * old rpmX4Filt                                                                                   
2386   D3AF FD 01 84    L1050       std     rpmX4Filt                 ; Store new value                            
2387   D3B2                                                                
2388   D3B2                         ;-------------------------------------------------------------
2389   D3B2                         ; Restart T40_mas if engine notRotating or startingToCrank 
2390   D3B2                         ;-------------------------------------------------------------
2391   D3B2 8F E6 11 05 L1051       brclr   state1, #$11, L1052       ; branch if notRotating and startingToCrank clear
2392   D3B6 86 0C                   ldaa    #$0c                      ; Engine is either notRotating or startingToCrank                                                                              
2393   D3B8 B7 01 21                staa    T40_mas                   ; Restart timer at 0.3s 
2394   D3BB             
2395   D3BB                         ;-----------------------------------------
2396   D3BB                         ; Set state2 mas flag if T40_mas expired
2397   D3BB                         ;-----------------------------------------
2398   D3BB B6 01 21    L1052       ldaa    T40_mas                   ; 
2399   D3BE 26 03                   bne     L1053                     ; Branch if counter not yet 0                                                                               
2400   D3C0 03 D6 08                orm     state2, #$08              ; Set bit indicating timer expired
2401   D3C3             
2402   D3C3                         ;---------------------------------------------------------------------------
2403   D3C3                         ; Compute mafRaw16 and mafRaw from airCnt0:airCnt1 
2404   D3C3                         ;
2405   D3C3                         ; Since airCnt0:airCnt1 is filtered airCntNew0:airCntNew1, we have
2406   D3C3                         ;
2407   D3C3                         ;   mafRaw = $200d * airCnt0 / Tcas / 64  
2408   D3C3                         ;          = 8205 * airCntNew0 / Tcas / 64          
2409   D3C3                         ;          = 8205 * (N+r) * $9c / Tcas / 64        (see airCntNew0 definition)
2410   D3C3                         ;          = 8205 * (N+r) * $9c / (125000*TcasInSeconds) / 64
2411   D3C3                         ;          = (N+r)/TcasInSeconds/6.25
2412   D3C3                         ;          = "number of airflow sensor pulse per sec" / 6.25
2413   D3C3                         ;
2414   D3C3                         ; Where:
2415   D3C3                         ; 
2416   D3C3                         ;     -Tcas is the time required for 1 cas interrupt (there are 4 cas 
2417   D3C3                         ;      interrupts for every 2 rotations which basically means 1 cas 
2418   D3C3                         ;      interrupt for every complete cycle of one cylinder)
2419   D3C3                         ;     -(N+r) is the number of air sensor pulses received during
2420   D3C3                         ;            one cas interrupt, r<1 is the fractional part. See
2421   D3C3                         ;            the mas interrupt for assumptions...
2422   D3C3                         ;     -Tcas is the cas interrupt period measured at 125KHz 
2423   D3C3                         ;
2424   D3C3                         ;---------------------------------------------------------------------------
2425   D3C3 FC 01 45    L1053       ldd     Tcas                      ; d = Tcas                                                                                        
2426   D3C6 DD 5A                   std     temp4                     ;                                                                                       
2427   D3C8 CC 20 0D                ldd     #$200d                    ; d = $200d = 8205d                                                                                      
2428   D3CB DE 8D                   ldx     airCnt0                   ;                                                                                          
2429   D3CD DF 5C                   stx     temp6                     ;                                                                                       
2430   D3CF BD EA 90                jsr     mul1616                   ; d = d * temp6:temp7 = ($200d * airCnt0)/65536 = 0.125198*airCnt0
2431   D3D2 BD EA BE                jsr     div3216                   ; d = 65536*0.125198*airCnt0/Tcas = 8205 * airCnt0/Tcas                                                                  
2432   D3D5 FD 01 4B                std     mafRaw16                  ; 16 bit mafRaw                                                                                      
2433   D3D8~            #ifdef masLog2X                               ;                        
2434   D3D8~                        jsr     scale128m                 ;                                              
2435   D3D8             #else                                         ;            
2436   D3D8 BD EB B4                jsr     scale64m                  ; d = 8205*airCnt0/Tcas/64, result is in B...                                 
2437   D3DB             #endif                                        
2438   D3DB 87 E6 10 04             brset   state1, #$10, L1054       ; Branch if engine notRotating
2439   D3DF 8F D6 08 01             brclr   state2, #$08, L1055       ; Branch if pulse accumulator interrupts received
2440   D3E3 5F          L1054       clrb                              ; No interrupts or notRotating, use 0 air flow                            
2441   D3E4 D7 E4       L1055       stab    mafRaw                    ; Store 8 bit mafRaw =  8205*airCnt0/Tcas/64
2442   D3E6             
2443   D3E6                         ;----------------------------------------------------------------------
2444   D3E6                         ; Compute airCntMax (max air count as a function of rpm, ect and iat)
2445   D3E6                         ;----------------------------------------------------------------------
2446   D3E6 DC DA                   ldd     rpm4                      ; d = rpm4                                                                       
2447   D3E8 81 03                   cmpa    #$03                      ; compare high part to 3 -> compare D to 768                                       
2448   D3EA 25 03                   bcs     L1057                     ; Branch if RPM < 3000                                                              
2449   D3EC CC 03 00                ldd     #$0300                    ; RPM >=3000 -> use 3000                                                             
2450   D3EF 05          L1057       asld                              ;                                                                                  
2451   D3F0 05                      asld                              ; scale rpm
2452   D3F1 CE FB A7                ldx     #t_airCntMax              ;                                                                                   
2453   D3F4 BD EB 52                jsr     interp1                   ; b = t_airCntMax[rpm]
2454   D3F7 4F                      clra                              ;                                                                                  
2455   D3F8 DD 5C                   std     temp6                     ; temp6:temp7 = t_airCntMax[rpm]
2456   D3FA CE FB B4                ldx     #L1990                    ;                               
2457   D3FD B6 01 4E                ldaa    ectCond                   ;                                
2458   D400 BD EB 68                jsr     interp32mul               ; D = t_airCntMax[rpm] * L1990[ectCond]
2459   D403 CE FB BC                ldx     #L1991                    ;                               
2460   D406 B6 01 4F                ldaa    iatCond                   ;                                
2461   D409 BD EB 68                jsr     interp32mul               ; D = t_airCntMax[rpm] * L1990[ectCond] * L1991[iatCond]
2462   D40C BD EB BE                jsr     ovfCheck                  ; Check for overflow                              
2463   D40F D7 A0                   stab    airCntMax                 ; airCntMax = t_airCntMax[rpm] * L1990[ectCond] * L1991[iatCond]
2464   D411                                                       
2465   D411                         ;------------------------------------------------
2466   D411                         ; Store airCntMax in airCnt0 and oldAirCnt0 
2467   D411                         ; when engine is notRotating or startingToCrank
2468   D411                         ;------------------------------------------------
2469   D411 8F E6 11 08             brclr   state1, #$11, L1060       ; branch if notRotating and startingToCrank clear   
2470   D415 4F                      clra                              ; engine is either notRotating or startingToCrank                                
2471   D416 05                      asld                              ;                           
2472   D417 05                      asld                              ;                           
2473   D418 05                      asld                              ; d = airCntMax*8                             
2474   D419 DD 8D                   std     airCnt0                   ; airCnt0:airCnt1 = airCntMax*8                                 
2475   D41B DD 92                   std     oldAirCnt0                ; oldAirCnt0 = airCntMax*8                              
2476   D41D             
2477   D41D                         ;----------------------------------------------
2478   D41D                         ; Compute airCntDef, default airCnt0 value 
2479   D41D                         ; when no mas interrupts are being received 
2480   D41D                         ;----------------------------------------------
2481   D41D CD CE FF CB L1060       ldy     #L2053                    ;                               
2482   D421 BD EB F4                jsr     rpmPwise                  ; b = F(rpm4), see L2053 table                                
2483   D424 37                      pshb                              ;                             
2484   D425 CE FE FC                ldx     #L2036                    ;                               
2485   D428 BD EB 3A                jsr     interpEct                 ;                                  
2486   D42B DB D2                   addb    tpsRaw                    ; b = tpsRaw + L2036[ect]                            
2487   D42D 24 02                   bcc     L1062                     ; overflow check                              
2488   D42F C6 FF                   ldab    #$ff                      ; Use max                            
2489   D431 CE BA 1A    L1062       ldx     #$ba1a                    ;                               
2490   D434 BD EB C4                jsr     clipOffset                ; offset and clip b, b = max(min(tpsRaw + L2036[ect],$ba)-$1a,0)
2491   D437 54                      lsrb                              ; b = b/2                           
2492   D438 32                      pula                              ; a = F(rpm4)                            
2493   D439 CE FB 50                ldx     #L1986                    ;                               
2494   D43C CD CE 05 00             ldy     #$0500                    ;                               
2495   D440 BD EA E3                jsr     lookup2D2                 ; b = L1986[a,b], 2D interpolated air count since stored in airCntDef which is stored in airCnt0 under some cases??? 
2496   D443 86 57                   ldaa    #$57                      ;                             
2497   D445 3D                      mul                               ; b = $57*L1986[a,b]                            
2498   D446 BD EB B3                jsr     scale128m                 ; b = $57*L1986[a,b]/128                                 
2499   D449 D7 FF                   stab    airCntDef                 ; airCntDef = $57*L1986[a,b]/128                             
2500   D44B                         
2501   D44B                         ;------------------------------------------------------
2502   D44B                         ; Re-init airFiltFact (airflow filtering factor)
2503   D44B                         ;
2504   D44B                         ; Filtering factor depends on current conditions???
2505   D44B                         ;------------------------------------------------------
2506   D44B             #ifdef E931
2507   D44B 86 B3                   ldaa    #$b3                       ; Value to use if timer T40_ftrim2 is expired                             
2508   D44D F6 01 1F                ldab    T40_ftrim2                 ;                               
2509   D450 27 08                   beq     L1064                      ;                               
2510   D452             #endif                                         
2511   D452 86 D1                   ldaa    #$d1                       ;                             
2512   D454 87 F3 10 02             brset   iscLrnFlags, #$10, L1064   ; Branch if conditions are good to update isc variables                              
2513   D458 86 E4                   ldaa    #$e4                       ;                             
2514   D45A 97 9F       L1064       staa    airFiltFact             
2515   D45C             
2516   D45C                         ;-------------------------------------------------------------
2517   D45C                         ; Transfer airDiffPos:airDiffNeg to airDiffPos1:airDiffNeg1
2518   D45C                         ; and re-init airDiffPos:airDiffNeg to 0                                    
2519   D45C                         ;-------------------------------------------------------------
2520   D45C 4F                      clra                              ;                             
2521   D45D 5F                      clrb                              ;                             
2522   D45E 0F                      sei                               ;
2523   D45F DE 94                   ldx     airDiffPos                ;                                   
2524   D461 DD 94                   std     airDiffPos                ;                                   
2525   D463 0E                      cli                               ;                             
2526   D464 FF 01 49                stx     airDiffPos1               ;                              
2527   D467             
2528   D467                         ;-----------------------------------------------------------------------------------------
2529   D467                         ; Compute airCntMin0 (minimum value of airCntNew0 before it is used for airCnt0 calc)
2530   D467                         ;-----------------------------------------------------------------------------------------
2531   D467 4F                      clra                            ;                             
2532   D468 5F                      clrb                            ; d = 0                            
2533   D469 87 E6 11 23             brset   state1, #$11, L1065     ; branch if engine notRotating or startingToCrank (use minimum of 0)
2534   D46D 86 10                   ldaa    #$10                    ;                               
2535   D46F             #ifdef E931
2536   D46F C6 81                   ldab    #$81                                                 
2537   D471~            #else
2538   D471~                        ldab    #$91                                                 
2539   D471             #endif
2540   D471 3D                      mul                             ;                            
2541   D472 FE 01 45                ldx     Tcas                    ;                               
2542   D475 DF 5C                   stx     temp6                   ;                              
2543   D477 BD EA 90                jsr     mul1616                 ;                                
2544   D47A CE 40 00                ldx     #$4000                  ;                               
2545   D47D DF 5C                   stx     temp6                   ;                              
2546   D47F BD EA 90                jsr     mul1616                 ;                                
2547   D482 1A                      xgdx                            ;
2548   D483             #ifdef E931
2549   D483 F6 01 60                ldab    baroFact                ;                                 
2550   D486~            #else
2551   D486~                        ldab    #$80                    ; Use 1.0 bar
2552   D486~                        nop                                                          
2553   D486             #endif
2554   D486 B6 01 5F                ldaa    iatCompFact             ;                                    
2555   D489 3D                      mul                             ;                             
2556   D48A DD 5A                   std     temp4                   ;                              
2557   D48C 1A                      xgdx                            ;                             
2558   D48D BD EA BE                jsr     div3216                 ;                                
2559   D490 FD 01 87    L1065       std     airCntMin0              ; Store "min" used in air count calc                              
2560   D493             
2561   D493                         ;---------------------------------------------------------------
2562   D493                         ; Compute airVol16 and airVol from [airCnt0:airCnt1]*masScalar
2563   D493                         ;---------------------------------------------------------------
2564   D493 4F                      clra                            ;                             
2565   D494 5F                      clrb                            ;                             
2566   D495 87 E6 10 0A             brset   state1, #$10, L1066     ; Branch if engine notRotating                                
2567   D499 CC 5E 86                ldd     #masScalar              ; 16 bit MAS scalar ($5e86 for 1G, $7A03 for 2g), seem to correspond to (masComp+t_mascomp(72Hz))/512*65536   
2568   D49C DD 5C                   std     temp6                   ; Store for 16 multi.                                               
2569   D49E DC 8D                   ldd     airCnt0                 ; MAS air count                                                          
2570   D4A0 BD EA 90                jsr     mul1616                 ; d = masScalar/65536 * [airCnt0:airCnt1]
2571   D4A3 DD 5C       L1066       std     temp6                   ; temp6:temp7 = masScalar/65536 * [airCnt0:airCnt1]
2572   D4A5 DD DE                   std     airVol16                ; airVol16 = masScalar/65536 * [airCnt0:airCnt1]
2573   D4A7 BD EB B9                jsr     scale2m                 ; b = masScalar/65536 * airCnt0 / 2 with overflow check
2574   D4AA D7 E0                   stab    airVol                  ; airVol = masScalar/65536*[airCnt0:airCnt1]/2 (8 bit airflow)                                                     
2575   D4AC             
2576   D4AC                         ;--------------------
2577   D4AC                         ; Compute airVolCond 
2578   D4AC                         ;--------------------
2579   D4AC 17                      tba                             ; a = airVol                             
2580   D4AD BD EC 3C                jsr     L1647                   ; b = Apply offset and scaling to airVol???                              
2581   D4B0 F7 01 50                stab    airVolCond              ;                              
2582   D4B3             
2583   D4B3                         ;----------------------------------------
2584   D4B3                         ; At this point [temp6:temp7] = airVol16  
2585   D4B3                         ;
2586   D4B3                         ; Compute airVolT, airVolTB and airVolB
2587   D4B3                         ;----------------------------------------
2588   D4B3 F6 01 5F                ldab    iatCompFact             ;                                    
2589   D4B6 BD EA 5F                jsr     mul816_256              ; b = airVol16/2 * iatCompFact/128; [temp6:temp7] = airVol16 * iatCompFact/128
2590   D4B9 D7 E1                   stab    airVolT                 ; airVolT =  airVol16/2 * iatCompFact/128
2591   D4BB BD EA 5C                jsr     mul816_baro             ;  
2592   D4BE D7 E2                   stab    airVolTB                ; airVolTB = airVol16/2 * iatCompFact/128 * baroFact/128; 
2593   D4C0 DC DE                   ldd     airVol16                ; d = airVol16                                 
2594   D4C2 DD 5C                   std     temp6                   ;                              
2595   D4C4 BD EA 5C                jsr     mul816_baro             ;                              
2596   D4C7 D7 E3                   stab    airVolB                 ; airVolB = airVol16/2 * baroFact/128                               
2597   D4C9                         
2598   D4C9             #ifdef E931       
2599   D4C9                         ;---------------------------------------------------                          
2600   D4C9                         ; Set ftrimFlags.3 if speed exceed threshold (with
2601   D4C9                         ; hysteresis) and port3.0 is set?????????
2602   D4C9                         ;---------------------------------------------------                          
2603   D4C9 02 E5 F7                andm    ftrimFlags, #$f7         ; Assume we reset flag $08, updated below                                 
2604   D4CC 86 18                   ldaa    #$18                     ; speed threshold = $18                            
2605   D4CE 8F E5 04 02             brclr    ftrimFlags, #$04, Md4d4 ; branch is flag not yet set                                
2606   D4D2 86 1C                   ldaa    #$1c                     ; Flag already set, use higher threshold (lower speed threshold)                             
2607   D4D4 02 E5 FB    Md4d4       andm    ftrimFlags, #$fb         ; Assume we reset $04                                 
2608   D4D7 91 C6                   cmpa    vss                      ; 
2609   D4D9 25 0D                   bcs     L1067                    ; Bail if speed < 24km/h (vss=1/speed...)
2610   D4DB 03 E5 04                orm     ftrimFlags, #$04         ; speed > 24km/h, set "threshold exceeded" bit
2611   D4DE 96 D7                   ldaa    port3Snap0               ; Get stored port3                                  
2612   D4E0 94 06                   anda    port3                    ; Confirm bit is still set with current value                              
2613   D4E2 44                      lsra                             ; Get confirmed bit 0 in carry                              
2614   D4E3 24 03                   bcc     L1067                    ; Branch if bit was not set                              
2615   D4E5 03 E5 08                orm     ftrimFlags, #$08         ; Bit was still set, set flag bit                                 
2616   D4E8             #endif
2617   D4E8             
2618   D4E8                         ;-----------------------------------------------
2619   D4E8                         ; Set ftrimFlags.4 if rpm exceeds 
2620   D4E8                         ; threshold (around 1000rpm), with hysteresis
2621   D4E8                         ;-----------------------------------------------
2622   D4E8 CE FB 3E    L1067       ldx     #L1983                  ; x points to initial threshold                               
2623   D4EB 8F E5 10 01             brclr   ftrimFlags, #$10, L1068 ; Branch if flag not yet set                              
2624   D4EF 08                      inx                             ; Flag is set, go to next value (hysteresis)
2625   D4F0             L1068       .equ    $
2626   D4F0~            #ifdef E932
2627   D4F0~                        brset   port3Snap0, #$20, L1069 ; branch if Park/neutral                               
2628   D4F0~                        inx                             ; even more threshold hysteresis...                            
2629   D4F0~                        inx                             ; even more threshold hysteresis...                            
2630   D4F0             #endif        
2631   D4F0 96 DD       L1069       ldaa    rpm31                   ;                              
2632   D4F2 02 E5 EF                andm    ftrimFlags, #$ef        ; Assume we reset $10                               
2633   D4F5 A1 00                   cmpa    $00,x                   ; Compare rpm to treshold
2634   D4F7 25 03                   bcs     L1070                   ; branch if rpm31 < L1983(flags...)                              
2635   D4F9 03 E5 10                orm     ftrimFlags, #$10        ; set flag indicating we are above rpm threshold                                
2636   D4FC             
2637   D4FC                         ;----------------------------------------------------------------------------------------
2638   D4FC                         ; Update the fuel trim range (low, mid, high)  according to mafRaw16. Table 
2639   D4FC                         ; t_ftrimRg provides the 2 thresholds with some hysteresis (+/-6Hz)
2640   D4FC                         ; The trim range is stored in L00e3.0.1 (lowest 2 bits)
2641   D4FC                         ;
2642   D4FC                         ; old L00e3.0.1    resulting X       new L00e3.0.1
2643   D4FC                         ;   00              t_ftrimRg        00 if maf < t_ftrimRg(00) otherwise 01
2644   D4FC                         ;   01              t_ftrimRg        00 if maf < t_ftrimRg(01) otherwise 01 if maf < t_ftrimRg(02) otherwise 10
2645   D4FC                         ;   10              t_ftrimRg+1      01 if maf < t_ftrimRg(03) otherwise 10 
2646   D4FC                         ;   11              t_ftrimRg+1      01 if maf < t_ftrimRg(03) otherwise 10 
2647   D4FC                         ;
2648   D4FC                         ;  L00e3.0.1        meaning
2649   D4FC                         ;     00        low trim (below first threshold)
2650   D4FC                         ;     01        mid trim (between first and second threshold)
2651   D4FC                         ;     10        high trim (above second threshold)
2652   D4FC                         ;     11        Never used I think
2653   D4FC                         ;----------------------------------------------------------------------------------------
2654   D4FC CE FB 3A    L1070       ldx     #t_ftrimRg              ; X pointx to t_ftrimRg min1                                  
2655   D4FF FC 01 4B                ldd     mafRaw16                ; d = mafRaw16                                
2656   D502 BD EB B4                jsr     scale64m                ; d = mafRaw16/64 (thats equal to mafRaw...?)                                
2657   D505 17                      tba                             ; a = mafRaw16/64 = mafRaw (6.25x)Hz                            
2658   D506 5F                      clrb                            ; b=0                            
2659   D507 8F E5 03 11             brclr   ftrimFlags, #$03, L1074 ;                               
2660   D50B 8F E5 02 03             brclr   ftrimFlags, #$02, L1071 ;                               
2661   D50F 08                      inx                             ; X pointx to t_ftrimRg+1
2662   D510 20 04                   bra     L1073                   ;                              
2663   D512 A1 01       L1071       cmpa    $01,x                   ;                              
2664   D514 25 0E                   bcs     L1077                   ; Branch if mafRaw16/64 < t_ftrimRg                              
2665   D516 A1 02       L1073       cmpa    $02,x                   ;                             
2666   D518 25 09                   bcs     L1076                   ; Branch if mafRaw16/64 < t_ftrimRg                             
2667   D51A 20 06                   bra     L1075                   ;                              
2668   D51C A1 00       L1074       cmpa    $00,x                   ;                              
2669   D51E 25 04                   bcs     L1077                   ; Branch if mafRaw16/64 < t_ftrimRg                             
2670   D520 20 01                   bra     L1076                   ;                               
2671   D522 5C          L1075       incb                            ;                             
2672   D523 5C          L1076       incb    
2673   D524 96 E5       L1077       ldaa    ftrimFlags              ; a = ftrimFlags
2674   D526 84 FC                   anda    #$fc                    ; Reset trim range 
2675   D528 1B                      aba                             ; Add new trim range                            
2676   D529 97 E5                   staa    ftrimFlags              ; Update ftrimFlags
2677   D52B                     
2678   D52B                         ;---------------------------------------------------
2679   D52B                         ; Restart timer T40_ftrim2 on E931 if 
2680   D52B                         ;
2681   D52B                         ;     rpm > 1953rpm 
2682   D52B                         ;  or speed > 15 km/h    
2683   D52B                         ;  or speed < 2.5 km/h    
2684   D52B                         ;  or vss*rpm/15.625 < $cd8   (note speed ~ 1/vss)
2685   D52B                         ;  or airVol > $38 
2686   D52B                         ;  or tpsDiffMax2 > $04
2687   D52B                         ;---------------------------------------------------
2688   D52B             #ifdef E931
2689   D52B DC DA                   ldd     rpm4                    ;                              
2690   D52D BD EB B8                jsr     scale4m                 ;                                 
2691   D530 C1 7D                   cmpb    #$7d                    ; 1953rpm                             
2692   D532 24 1D                   bcc     Md551                   ; Branch if rpm>1953rpm                              
2693   D534 96 C6                   ldaa    vss                     ;                             
2694   D536 81 26                   cmpa    #$26                    ; ~15km/h                                
2695   D538 25 17                   bcs     Md551                   ; Branch if speed>15km/h                                           
2696   D53A 81 E2                   cmpa    #$e2                    ; ~2.5km/h                                 
2697   D53C 24 13                   bcc     Md551                   ; Branch if speed<2.5km/h                             
2698   D53E 3D                      mul                             ;                              
2699   D53F 1C 0C D8                cmpd    #$0cd8                  ; d = vss*rpm/15.625                               
2700   D542 25 0D                   bcs     Md551                   ; branch if vss*rpm/15.625 < $cd8                              
2701   D544 96 E0                   ldaa    airVol                  ;                                
2702   D546 81 38                   cmpa    #$38                    ;                              
2703   D548 24 07                   bcc     Md551                   ; Branch if airVol > $38                              
2704   D54A B6 01 4D                ldaa    tpsDiffMax2             ;                                     
2705   D54D 81 04                   cmpa    #$04                    ;                              
2706   D54F 25 05                   bcs     L1078                   ; Branch if tpsDiffMax2 < $04                              
2707   D551 86 78       Md551       ldaa    #$78                    ; 3 sec                              
2708   D553 B7 01 1F                staa    T40_ftrim2              ;                               
2709   D556             #endif        
2710   D556             
2711   D556                         ;---------------------------------------------------
2712   D556                         ; Reload T40s_Idle as long as idle switch is off
2713   D556                         ;---------------------------------------------------
2714   D556 87 D7 80 05 L1078       brset   port3Snap0, #$80, L1079 ; Branch if idle position switch on                                
2715   D55A 86 1E                   ldaa    #$1e                    ;                             
2716   D55C B7 01 33                staa    T40s_Idle               ; Reload down counter (~0.75sec)                             
2717   D55F             
2718   D55F                         ;---------------------------------------------------------------------
2719   D55F                         ; Check for airVolT threshold with hysteresis and update T2_airVolT
2720   D55F                         ; ftrimFlags is set when airVolT > 24 and is reset when airVolT <= 15
2721   D55F                         ;---------------------------------------------------------------------
2722   D55F 86 0F       L1079       ldaa    #$0f                    ; Threshold min                            
2723   D561 87 E5 80 02             brset   ftrimFlags, #$80, L1080 ;                                
2724   D565 86 18                   ldaa    #$18                    ; Threshold max
2725   D567 02 E5 7F    L1080       andm    ftrimFlags, #$7f        ; 
2726   D56A 91 E1                   cmpa    airVolT                 ; Compare current air volume                                
2727   D56C 24 08                   bcc     L1081                   ; Branch if airVolT <= threshold                              
2728   D56E 03 E5 80                orm     ftrimFlags, #$80        ; airVolT > threshold, set bit
2729   D571 86 0A                   ldaa    #$0a                    ; reset timer to 5 seconds                            
2730   D573 B7 01 39                staa    T2_airVolT              ;                            
2731   D576 87 D6 08 23 L1081       brset   state2, #$08, L1083     ; Branch if no pulse accumulator interrupts received
2732   D57A 87 E6 10 1F             brset   state1, #$10, L1083     ; Branch if engine notRotating                               
2733   D57E             
2734   D57E                         ;-----------------------------------------------------------
2735   D57E                         ; Compute air volume used in fuel cut comparison
2736   D57E                         ; it uses 16 bits since 8 bit air volume saturate at ~1g of air/cas
2737   D57E                         ;-----------------------------------------------------------
2738   D57E DC DE                   ldd     airVol16                ; d = airVol16
2739   D580 BD EB B8                jsr     scale4m                 ; b = airVol16/4 (makes sure it fits in b only...)
2740   D583~            #ifdef extLoadRange                         ;
2741   D583~                        stab    L0054                   ;                              
2742   D583             #else                                       ;
2743   D583 D7 57                   stab    temp1                   ; temp1 = airVol16/4
2744   D585             #endif                                      ;
2745   D585 B6 01 5F                ldaa    iatCompFact             ; Correct for air temp                              
2746   D588 3D                      mul                             ;                             
2747   D589 BD EB B3                jsr     scale128m               ; d = airVol16/4 * iatCompFact/128 
2748   D58C B6 01 60                ldaa    baroFact                ; a = baroFact
2749   D58F 3D                      mul                             ;                             
2750   D590 BD EB B3                jsr     scale128m               ; d = airVol16/4 * iatCompFact/128 * baroFact/128 (fits in b only)
2751   D593             
2752   D593                         ;---------------------------------------------------------------------------------------
2753   D593                         ; Keep the minimum of airVol16/4 and airVol16/4 * iatCompFact/128 * baroFact/128 
2754   D593                         ;---------------------------------------------------------------------------------------
2755   D593~            #ifdef extLoadRange
2756   D593~                        cmpb    L0054                   ;
2757   D593~                        bcs     L1082                   ;                              
2758   D593~                        ldab    L0054                   ;
2759   D593             #else
2760   D593 D1 57                   cmpb    temp1                   ;                               
2761   D595 25 02                   bcs     L1082                   ; Branch if airVol16/4 * iatCompFact/128 * baroFact/128 <= airVol16/4 
2762   D597 D6 57                   ldab    temp1                   ; Use max of airVol16/4
2763   D599             #endif
2764   D599             
2765   D599                         ;------------------------------------------------------------------------------
2766   D599                         ; Check air volume for eventual fuel cut 
2767   D599                         ; When air volume exceeds a threshold, Timer T40_fuelCut 
2768   D599                         ; is not re-initialized on every loop (to 1s) and therefore starts 
2769   D599                         ; counting down. when it reaches 0, fuel cut is applied, see L1090 below
2770   D599                         ;------------------------------------------------------------------------------
2771   D599 C1 A0       L1082       cmpb    #fuelCutVal             ; Air volume based fuel cut value    $a0 = 1.25g/cas
2772   D59B~            #ifdef noFuelCut
2773   D59B~                        brn     L1084                   ;
2774   D59B             #else
2775   D59B 24 05                   bcc     L1084                   ; Branch if air volume>=threshold                
2776   D59D             #endif
2777   D59D C6 28       L1083       ldab    #$28                    ; 1 sec
2778   D59F F7 01 22                stab    T40_fuelCut             ; Re-init counter to 1 sec (Apply fuel cut only after threshold is exceeded for more than 1s)
2779   D5A2             
2780   D5A2                         ;-----------------------------------------------------------------
2781   D5A2                         ; Section to update the state1 flags from various conditions 
2782   D5A2                         ;
2783   D5A2                         ; Bits in b are used to accumulate various loads and states
2784   D5A2                         ; In this section, b is only set in case we have 
2785   D5A2                         ; to bail to the state1 flag setting section
2786   D5A2                         ;-----------------------------------------------------------------
2787   D5A2 C6 30       L1084       ldab    #$30                    ; Starting "state1" value, b=00110000 (not rotating)                          
2788   D5A4 8F E6 20 0A             brclr   state1, #$20, L1085     ; Bail if this is the first time we compute state1??                               
2789   D5A8 B6 01 20                ldaa    T40_engRot              ;                                     
2790   D5AB 27 05                   beq     L1085                   ; Bail if engine not rotating                             
2791   D5AD B6 01 24                ldaa    T40_noPower             ;                               
2792   D5B0 26 03                   bne     L1086                   ; Don't bail if timer not expired???                             
2793   D5B2 7E D6 3B    L1085       jmp     L1100                   ; bail
2794   D5B5                                                  
2795   D5B5                         ;----------------------------------------------------
2796   D5B5                         ; Engine rotating, check if key is in "start"
2797   D5B5                         ; In this section, b is only set in case we have 
2798   D5B5                         ; to bail to the state1 flag setting section
2799   D5B5                         ;----------------------------------------------------
2800   D5B5 C6 21       L1086       ldab    #$21                     ; pre-load new state1 in case we have to bail, b=00100001 (startingToCrank)                           
2801   D5B7 87 D7 40 12             brset   port3Snap0, #$40, L1089  ; branch to next state if key not in start???
2802   D5BB             
2803   D5BB                         ;----------------------------------------------------
2804   D5BB                         ; Key is in "start", check if rpm is higher than
2805   D5BB                         ; threshold (engine running?)
2806   D5BB                         ;----------------------------------------------------
2807   D5BB 86 0E                   ldaa    #$0e                    ; starting rpm value (RPM/31.25) $0e = 437.25
2808   D5BD 87 E6 01 02             brset   state1, #$01, L1087     ; Branch if engine rotating bit was previously set
2809   D5C1 86 0B                   ldaa    #$0b                    ; $0b = 343.75RPM                             
2810   D5C3 8F E7 20 02 L1087       brclr   injFlags0, #$20, L1088  ; Branch if temperature(ectFiltered) >= -8degC
2811   D5C7 8B 02                   adda    #$02                    ; temperature(ectFiltered) < -8degC, add 62.5 RPM                             
2812   D5C9 91 DD       L1088       cmpa    rpm31                   ; compare threshold to current engine speed                              
2813   D5CB 22 E5                   bhi     L1085                   ; Bail if engine rpm lower than calculated value                             
2814   D5CD             
2815   D5CD                         ;---------------------------------------------------------------------
2816   D5CD                         ; At this point, 
2817   D5CD                         ; key is in "start" or engine rpm is higher than minimum threshold, 
2818   D5CD                         ; minimum conditions are therefore met for the engine to start or be started?
2819   D5CD                         ; 
2820   D5CD                         ; Use this state to check if we should get fuel injection. If we get stuck in
2821   D5CD                         ; this state it means engine is rotating but something is wrong...
2822   D5CD                         ;---------------------------------------------------------------------
2823   D5CD                         ;---------------------------------------------------------------------
2824   D5CD                         ; If enough time has elapsed, check if CAS is working normally
2825   D5CD                         ;---------------------------------------------------------------------
2826   D5CD C6 28       L1089       ldab    #$28                    ; pre-load new state1 in case we have to bail, b=00101000  (trying to start but something is wrong...)                          
2827   D5CF B6 01 19                ldaa    T40_start               ;                              
2828   D5D2 8B 50                   adda    #$50                    ; add 2s                            
2829   D5D4 25 0A                   bcs     L1090                   ; Branch if key was out of start for less than 2s (when engine was upgraded from startingToCrank),                             
2830   D5D6 8F 4E 80 06             brclr   faultHi, #$80, L1090    ; Its been more than ~2s since key was out of start, ECU has had enough time to check if CAS was working, check it, branch if no fault on CAS
2831   D5DA 96 83                   ldaa    tdcCasCount             ; Fault code set...                             
2832   D5DC 81 04                   cmpa    #$04                    ;                             
2833   D5DE 25 D2                   bcs     L1085                   ; Bail if tdcCasCount<4, this should not have happened at this time since engine has been rotating for a while                           
2834   D5E0             
2835   D5E0                         ;----------------------------------------------------------------------
2836   D5E0                         ; Bail if fuel cut is active (T40_fuelCut=0)
2837   D5E0                         ;----------------------------------------------------------------------
2838   D5E0 B6 01 22    L1090       ldaa    T40_fuelCut             ; Fuel cut timer                              
2839   D5E3 27 CD                   beq     L1085                   ; Bail if timer 0 (fuel cut is active)                             
2840   D5E5             
2841   D5E5                         ;-----------------------------------------------
2842   D5E5                         ; Bail if ECU is about to be shutoff????
2843   D5E5                         ;-----------------------------------------------
2844   D5E5 87 06 02 C9             brset   port3, #$02, L1085      ; Bail if IG1 at 0V, ECU is about to turn off after delay...?
2845   D5E9             
2846   D5E9                         ;-------------------------------------------------------------------------
2847   D5E9                         ; At this point, minimum conditions are met for the engine 
2848   D5E9                         ; to start or run (rpm>thresh or start switch on), CAS is working,
2849   D5E9                         ; there is no fuel cut and the ECU is not being turned off
2850   D5E9                         ;
2851   D5E9                         ; Basically we know that we should be injecting fuel, do a little more check below...
2852   D5E9                         ;
2853   D5E9                         ;
2854   D5E9                         ; Calculate a maximum rpm that we should have based on maxRpm = baseRpm + rpmOffset
2855   D5E9                         ; where rpmOffset is additional loads that we calculate below
2856   D5E9                         ;
2857   D5E9                         ; Below, a will contain baseRpm and b will be used to accumulate the additional loads as flags...
2858   D5E9                         ;-------------------------------------------------------------------------
2859   D5E9                         ;-----------------------------------------------
2860   D5E9                         ; Get Initial RPM from ECT interpolated table
2861   D5E9                         ;-----------------------------------------------
2862   D5E9 CE FB 40                ldx     #t_rpmEct               ;                                 
2863   D5EC BD EB 3A                jsr     interpEct               ;                                    
2864   D5EF 17                      tba                             ; a = initial rpm idle speed, will be changed below (L1095)                               
2865   D5F0 5F                      clrb                            ; b = 00000000, no additionnal loads yet
2866   D5F1             
2867   D5F1                         ;-----------------------------------------------------------------
2868   D5F1                         ; Check if T40s_Idle timer expired
2869   D5F1                         ; (when idle position switch has been on for more than 0.75s)
2870   D5F1                         ;-----------------------------------------------------------------
2871   D5F1 7D 01 33                tst     T40s_Idle               ;                                
2872   D5F4 27 0D                   beq     L1091                   ; Branch if T40s_Idle already at zero (idle position switch on for more than 0.75s)                               
2873   D5F6             
2874   D5F6                         ;----------------------------------------------------------------
2875   D5F6                         ; Timer not expired, decrement it at 40Hz
2876   D5F6                         ;----------------------------------------------------------------
2877   D5F6 8F D9 01 09             brclr   Tclocks, #$01, L1091    ; Branch if basic 40Hz signal not set
2878   D5FA 7A 01 33                dec     T40s_Idle               ; Decrement timer       
2879   D5FD 87 D7 20 02             brset   port3Snap0, #$20, L1091  ; Ignore timer if in Park or Neutral (no transmission load)                                
2880   D601 27 04                   beq     L1092                   ; Branch if T40s_Idle reached 0 this time 
2881   D603             
2882   D603                         ;-------------------------
2883   D603                         ; Add a load when ???
2884   D603                         ;-------------------------
2885   D603 8F E6 04 01 L1091       brclr   state1, #$04, L1093     ; Branch if state1.2 (idle too fast) was not previously set
2886   D607 5C          L1092       incb                            ; Add load
2887   D608             L1093       .equ    $
2888   D608             
2889   D608                         ;--------------------------
2890   D608                         ; Add "transmission" load
2891   D608                         ;--------------------------
2892   D608~            #ifdef E932
2893   D608~                        brset   port3Snap0, #$20, L1094  ; Branch if in Park or Neutral                              
2894   D608~                        addb    #$02                    ; Set flag indicating "transmission load"
2895   D608             #endif
2896   D608                         ;--------------------------
2897   D608                         ; Add "A/C" load
2898   D608                         ;--------------------------
2899   D608 87 D7 10 02 L1094       brset   port3Snap0, #$10, L1095  ; Branch if air conditioning switch is off (reverse logic)                            
2900   D60C CB 04                   addb    #$04                    ; A/C on, set flag b += 00000100                                
2901   D60E             
2902   D60E                         ;---------------------------------------------------------
2903   D60E                         ; Compute total rpm threshold from  baseRpm+rpmOffset
2904   D60E                         ;---------------------------------------------------------
2905   D60E CE FB 48    L1095       ldx     #t_rpmEctOff            ; x points to table of offsets                              
2906   D611 3A                      abx                             ; c points to desired offset
2907   D612 AB 00                   adda    $00,x                   ; a = baseRpm+rpmOffset
2908   D614             
2909   D614                         ;---------------------------------------------------------------------
2910   D614                         ; Based on that threshold, compute which state we will end-up with
2911   D614                         ;---------------------------------------------------------------------
2912   D614                         ;--------------------------------------------------------
2913   D614                         ; If current rpm<threshold, use state1=00100000 (normal)
2914   D614                         ;--------------------------------------------------------
2915   D614 91 DD                   cmpa    rpm31                   ; compare to current rpm
2916   D616 22 21                   bhi     L1099                   ; Branch if current rpm lower than calculated value (engine is running normally?)
2917   D618             #ifdef E931
2918   D618 87 E5 08 1D             brset   ftrimFlags, #$08, L1099 ; RPM is higher than threshold, branch anyway if speed>24km/h and IG2 related signal is set on E931??????
2919   D61C             #endif
2920   D61C             
2921   D61C                         ;-----------------------------------------------------
2922   D61C                         ; rpm > threshold 
2923   D61C                         ; if air volume low, use state1=00101100 
2924   D61C                         ; i.e. runningFast and rotatingStopInj
2925   D61C                         ;-----------------------------------------------------
2926   D61C 87 D6 08 05             brset   state2, #$08, L1096     ; Skip airVolT check / branch if no pulse accumulator interrupts received (mas broken, skip airFlow check?)
2927   D620 B6 01 39                ldaa    T2_airVolT              ;                             
2928   D623 27 10                   beq     L1098                   ; Branch if airVolT below threshold for more than 5s 
2929   D625             
2930   D625                         ;-----------------------------------------------------
2931   D625                         ; rpm > threshold and air volume high
2932   D625                         ; If engine was started less than 5s ago, use state1=00100000 (normal)
2933   D625                         ; i.e. high rev upon startup is normal
2934   D625                         ;-----------------------------------------------------
2935   D625 B6 01 34    L1096       ldaa    T2_crank                 ;                             
2936   D628 8B 0A                   adda    #$0a                     ;                              
2937   D62A 25 0D                   bcs     L1099                    ; branch if engine stopped "startingToCrank" less than 5s ago...
2938   D62C 87 F3 20 09             brset   iscLrnFlags, #$20, L1099 ; branch if iscStStall has been updated
2939   D630             
2940   D630                         ;------------------------------------------------------------------------------
2941   D630                         ; rpm > threshold and air volume high and engine started more than 10s ago
2942   D630                         ; If idle switch is off, use state1=00100000 (normal)
2943   D630                         ; i.e. we are stepping on the gas...
2944   D630                         ;------------------------------------------------------------------------------
2945   D630 B6 01 33                ldaa    T40s_Idle               ;                              
2946   D633 26 04                   bne     L1099                   ; Branch if timer not yet 0, idle switch not on for more than 0.75s
2947   D635             
2948   D635                         ;---------------------------------------------------------------------------------
2949   D635                         ; rpm > threshold and air volume high and engine started more than 10s ago 
2950   D635                         ; and idle switch has been on for more than 0.75s
2951   D635                         ; use state1 = 00101100
2952   D635                         ; i.e. runningFast and rotatingStopInj
2953   D635                         ;---------------------------------------------------------------------------------
2954   D635 C6 2C       L1098       ldab    #$2c                    ; b=00101100, this means the engine is running too fast                              
2955   D637 20 02                   bra     L1100                   ;                              
2956   D639 C6 20       L1099       ldab    #$20                    ; use b=00100000 (normal)
2957   D63B             
2958   D63B                         ;-------------------------------------------------------------
2959   D63B                         ; Set state1 flag if we are not receiving mas interrupts
2960   D63B                         ;-------------------------------------------------------------
2961   D63B 8F D6 08 02 L1100       brclr   state2, #$08, L1101     ; Branch if pulse accumulator interrupts received
2962   D63F CA 02                   orab    #$02                    ; Set flag indicating we are not receiving pulse accumulator interrupts received
2963   D641             
2964   D641                         ;------------------------------------------------
2965   D641                         ; At this point b has been set in preceeding 
2966   D641                         ; code to indicate current state, update state1
2967   D641                         ;------------------------------------------------
2968   D641 96 E6       L1101       ldaa    state1                  ;                               
2969   D643 84 80                   anda    #$80                    ; Reset all except closed loop mode flag
2970   D645 1B                      aba                             ; Tranfser other flags set in code above                            
2971   D646 97 E6                   staa    state1                  ; Store new state                               
2972   D648             
2973   D648                         ;------------------------------------------------------
2974   D648                         ; Compute index into maf compensation table t_masComp
2975   D648                         ; since the values it contains are not equally spaced.
2976   D648                         ; Basically remaps mafRaw16...
2977   D648                         ;
2978   D648                         ; Note that this mapping is the same for 1G and 2G
2979   D648                         ; maf such that it doesn't need to be changed in case
2980   D648                         ; 2G maf is used in 1G...
2981   D648                         ;------------------------------------------------------
2982   D648 FC 01 4B                ldd     mafRaw16                ; d = 16 bit mafRaw (a=mafRaw16/256)                                
2983   D64B CD CE FF D3             ldy     #L2054                  ;                               
2984   D64F BD EB D2                jsr     pwiseLin                ; d = T(L2054, mafRaw16) (a=T(L2054, mafRaw16/256))                                  
2985   D652 DD 58                   std     temp2                   ; temp2:temp3 = T(L2054, mafRaw16)                              
2986   D654 BD EB B6                jsr     scale16m                ; d = T(L2054, mafRaw16)/16 (b=16*T(L2054, mafRaw16/256))                               
2987   D657 C1 80                   cmpb    #$80                    ; Check for max of $80. Since max(T(L2054, mafRaw16/256))=20=1600Hz, we trim at $80/16=8=200Hz! 
2988   D659 25 02                   bcs     L1103                   ;                              
2989   D65B C6 80                   ldab    #$80                    ; Use max of $80       
2990   D65D                         
2991   D65D                         ;------------------------------------------------------------
2992   D65D                         ; Compute total maf compensation = masComp + t_masComp(Hz)
2993   D65D                         ;------------------------------------------------------------
2994   D65D D7 5B       L1103       stab    temp5                   ; temp5 = T(L2054, mafRaw16)/16 with max of $80                              
2995   D65F CE FB 6E                ldx     #t_masComp              ; x point to masCompensation table                                   
2996   D662 DC 58                   ldd     temp2                   ; d = T(L2054, mafRaw16)                              
2997   D664 BD EB 52                jsr     interp1                 ;                                
2998   D667 4F                      clra                            ; d = t_masComp(T(L2054, mafRaw16))
2999   D668 CB 64                   addb    #masComp                ; b = masComp + t_masComp(T(L2054, mafRaw16))                                 
3000   D66A 49                      rola                            ; propagate carry bit in a,
3001   D66B DD 5C                   std     temp6                   ; temp6:temp7 = d = t_masComp(T(L2054, mafRaw16)) = total MAS compensation                              
3002   D66D             
3003   D66D                         ;-------------------------------------------------------------------------
3004   D66D                         ; Compute conditioned L1992(iat) and compensate for barometric pressure
3005   D66D                         ;-------------------------------------------------------------------------
3006   D66D CE FB C3                ldx     #L1992                  ;                               
3007   D670 BD EB 44                jsr     iatCInterp              ; b = L1992(iat)                                  
3008   D673 86 CD                   ldaa    #$cd                    ; $cd is 1 bar for baroChecked                            
3009   D675 3D                      mul                             ; d = $cd*L1992(iat)                           
3010   D676 05                      asld                            ; d = 2*$cd*L1992(iat)                            
3011   D677 15 D5                   div     baroChecked             ; d = 2*$cd*L1992(iat)/baroChecked                                   
3012   D679 54                      lsrb                            ; b = $cd*L1992(iat)/baroChecked = L1992(iat) * $cd/baroChecked = L1992(iat)*baroFactor where baroFactor=$cd/baroChecked equals 1.0 if baroChecked=1bar                              
3013   D67A C9 00                   adcb    #$00                    ; Round up result
3014   D67C CE 52 22                ldx     #$5222                  ;                               
3015   D67F BD EB C4                jsr     clipOffset              ; b = max(min(L1992(iat)*baroFactor,$52)-$22,0)                                   
3016   D682             
3017   D682                         ;-----------------------------------------------------------------------
3018   D682                         ; Compute airflow sensor linearity compensation factor from 2D table t_masLin 
3019   D682                         ; using max(min(L1992(iat)*baroFactor,$52)-$22,0)/16 for rows 
3020   D682                         ; and T(L2054, mafRaw16)/16 for columns, see t_masLin description
3021   D682                         ;-----------------------------------------------------------------------
3022   D682 CE FB 83                ldx     #t_masLin               ;                                     
3023   D685 CD CE 09 00             ldy     #$0900                  ;                               
3024   D689 96 5B                   ldaa    temp5                   ;                              
3025   D68B BD EA E3                jsr     lookup2D2               ; a = b = 2D interpolated t_masLin                                  
3026   D68E F7 01 57                stab    masLinComp              ; 
3027   D691 BD EB 6A                jsr     mul816_128              ; d = masLinComp * (masComp+t_masComp(xx))/128
3028   D694 FD 01 55                std     totMasComp              ; totMasComp =(masComp+t_masComp(xx)) *  t_masLin(xx)/128
3029   D697             
3030   D697                         ;-------------------------------------------------------------
3031   D697                         ; Section to check if the o2 sensor is operating normally
3032   D697                         ;-------------------------------------------------------------
3033   D697                         ;-------------------------------------------------------------
3034   D697                         ; If engine is notRotating, init rich/lean flag 
3035   D697                         ; and o2 sensor bad flag to default values 
3036   D697                         ;-------------------------------------------------------------
3037   D697 8F E6 10 0E             brclr   state1, #$10, L1106     ; Branch if notRotating clear 
3038   D69B 03 E8 C0                orm     closedLpFlags, #$c0     ; Assume o2Raw is rich and o2 sensor bad
3039   D69E 96 CE                   ldaa    o2Raw                   ; a = o2Raw                              
3040   D6A0 81 1F                   cmpa    #$1f                    ;                             
3041   D6A2 24 03                   bcc     L1105                   ; Branch if o2Raw >= 0.6v (rich)                            
3042   D6A4 02 E8 7F                andm    closedLpFlags, #$7f     ; o2Raw is lean, reset bit                                
3043   D6A7 20 39       L1105       bra     L1114                   ; Bail                              
3044   D6A9             
3045   D6A9                         ;-------------------------------------------------------
3046   D6A9                         ; Choose how long to wait to check o2 sensor voltage 
3047   D6A9                         ; depending on ect (o2 sensor warm-up time...)
3048   D6A9                         ;-------------------------------------------------------
3049   D6A9 B6 01 34    L1106       ldaa    T2_crank                ; a = T2_crank                                 
3050   D6AC D6 D3                   ldab    ectFiltered             ;                                    
3051   D6AE C1 54                   cmpb    #$54                    ; 41degC                             
3052   D6B0 25 04                   bcs     L1108                   ; Branch if temperature(ectFiltered) > 41degC                              
3053   D6B2 8B 58                   adda    #$58                    ; a = T2_crank + $58  (44sec)                           
3054   D6B4 20 02                   bra     L1109                   ;                              
3055   D6B6 8B 1E       L1108       adda    #$1e                    ; a = T2_crank + $1e  (15sec)                          
3056   D6B8             
3057   D6B8                         ;---------------------------------------------------------------------------------------
3058   D6B8                         ; Update the rich/lean flag if sufficient time has elapsed since car was started 
3059   D6B8                         ;---------------------------------------------------------------------------------------
3060   D6B8 25 28       L1109       bcs     L1114                   ; bail if engine stopped "startingToCrank" less than 44 or 15 sec ago (depending en ect).                               
3061   D6BA 96 E8                   ldaa    closedLpFlags           ; a = old closedLpFlags                               
3062   D6BC 03 E8 80                orm     closedLpFlags, #$80     ; Assume result will be rich
3063   D6BF D6 CE                   ldab    o2Raw                   ; b = o2Raw                              
3064   D6C1 C1 1F                   cmpb    #$1f                    ;                              
3065   D6C3 24 03                   bcc     L1111                   ; Branch if o2Raw >= 0.6v (rich)                              
3066   D6C5 02 E8 7F                andm    closedLpFlags, #$7f     ; o2Raw is lean, Reset flag                                 
3067   D6C8             
3068   D6C8                         ;--------------------------------------------------------
3069   D6C8                         ; Check if flag value changed compared to the last time
3070   D6C8                         ;--------------------------------------------------------
3071   D6C8 98 E8       L1111       eora    closedLpFlags           ; Compare old closedLpFlags t new one                              
3072   D6CA 2B 0E                   bmi     L1112                   ; Branch if rich/lean flag changed (reset o2 bad flag)                             
3073   D6CC             
3074   D6CC                         ;-----------------------------------
3075   D6CC                         ; Rich/lean flag did not change
3076   D6CC                         ;-----------------------------------
3077   D6CC 8F E6 80 0D             brclr   state1, #$80, L1113     ; Reset timer and bail if open loop mode
3078   D6D0             
3079   D6D0                         ;----------------------------------------------
3080   D6D0                         ; Closed loop mode and flag did not change yet
3081   D6D0                         ; Check if timer is expired which would mean that
3082   D6D0                         ; something is wrong (in closed loop mode, o2 sensor
3083   D6D0                         ; voltage should have changed by now...)
3084   D6D0                         ;----------------------------------------------
3085   D6D0 B6 01 37                ldaa    T2_o2Sensor             ;                             
3086   D6D3 26 0D                   bne     L1114                   ; Bail if timer not yet expired                             
3087   D6D5 03 E8 40                orm     closedLpFlags, #$40     ; Timer expired, set o2 bad flag                               
3088   D6D8 20 08                   bra     L1114                   ; Bail
3089   D6DA                                                      
3090   D6DA                         ;------------------------------
3091   D6DA                         ; Reset flag and restart timer
3092   D6DA                         ;------------------------------
3093   D6DA 02 E8 BF    L1112       andm    closedLpFlags, #$bf     ; reset o2 bad flag                               
3094   D6DD 86 28       L1113       ldaa    #$28                    ; 20sec                            
3095   D6DF B7 01 37                staa    T2_o2Sensor             ; re-init timer to 20sec                             
3096   D6E2             
3097   D6E2                         ;--------------------------------------------------------------
3098   D6E2                         ; Re-init T40_stInj0 to 1 sec if engine is not rotatingStopInj
3099   D6E2                         ; This means that T40_stInj0 starts counting when state 
3100   D6E2                         ; changes to rotatingStopInj
3101   D6E2                         ;--------------------------------------------------------------
3102   D6E2 87 E6 08 07 L1114       brset   state1, #$08, L1115     ; Branch if engine rotatingStopInj?                                
3103   D6E6 86 28                   ldaa    #$28                    ; 1 sec                            
3104   D6E8 B7 01 1C                staa    T40_stInj0              ;                              
3105   D6EB 20 0A                   bra     L1116                   ;                              
3106   D6ED             
3107   D6ED                         ;----------------------------------------------------------------
3108   D6ED                         ; Re-init timer T40_stInj1 to 2 sec if engine 
3109   D6ED                         ; is rotatingStopInj and T40_stInj0 expired
3110   D6ED                         ; This means that T40_stInj1 is only init when rotatingStopInj
3111   D6ED                         ; has been active for more than 1 sec and will start counting
3112   D6ED                         ; when rotatingStopInj is no more active. Will expire 2sec later.
3113   D6ED                         ;----------------------------------------------------------------
3114   D6ED B6 01 1C    L1115       ldaa    T40_stInj0                ;                              
3115   D6F0 26 05                   bne     L1116                     ; Branch if timer not expired                             
3116   D6F2 86 50                   ldaa    #$50                      ;                             
3117   D6F4 B7 01 1D                staa    T40_stInj1                ;
3118   D6F7                                                       
3119   D6F7                         ;-------------------------------------------------------------
3120   D6F7                         ; Section to decide between closed loop and open loop mode
3121   D6F7                         ; (set/reset state1.7)
3122   D6F7                         ;-------------------------------------------------------------
3123   D6F7                         ;-------------------------------------------------------------
3124   D6F7                         ; Have y point to airVol or airVolTB depending on baroChecked 
3125   D6F7                         ;-------------------------------------------------------------
3126   D6F7 CD CE 00 E0 L1116       ldy     #airVol                   ;                               
3127   D6FB 96 D5                   ldaa    baroChecked               ;                                    
3128   D6FD 81 9C                   cmpa    #$9c                      ;                             
3129   D6FF 25 04                   bcs     L1117                     ; Branch if baroChecked<0.76bar (I think??)                               
3130   D701 CD CE 00 E2             ldy     #airVolTB                 ;                               
3131   D705             
3132   D705                         ;--------------------------------------------------------
3133   D705                         ; Check airVolTB for first threshold (with hysteresis)
3134   D705                         ;--------------------------------------------------------
3135   D705 CE FB CA    L1117       ldx     #t_closedLp1               ;
3136   D708 BD EB 3F                jsr     interp16rpm                ; b = t_closedLp1(rpm)                                    
3137   D70B 8F E8 01 05             brclr   closedLpFlags, #$01, L1118 ; Branch if we were not above the threshold the last time we checked                              
3138   D70F C0 06                   subb    #$06                       ; b =  t_closedLp1(rpm)-6 (hysteresis)                              
3139   D711 24 01                   bcc     L1118                      ; Branch if no underflow                             
3140   D713 5F                      clrb                               ; Use min of 0                            
3141   D714 02 E8 FC    L1118       andm    closedLpFlags, #$fc        ; Reset 000000011                               
3142   D717 E1 80                   cmpb    $00,y                      ; Notice implicit y = y + 1 here!!!!!!!!!!!
3143   D719 23 07                   bls     L1119                      ; Branch if t_closedLp1(rpm) <= airVol or airVolTB                              
3144   D71B                                                           
3145   D71B                         ;---------------------------------------------------------
3146   D71B                         ; airVolTB smaller than threshold, closed loop is 
3147   D71B                         ; therefore an option. Re-init timer T2_closedLp to 20sec 
3148   D71B                         ; or 12sec and then continue trying to go to closed loop
3149   D71B                         ;---------------------------------------------------------
3150   D71B             #ifdef E931
3151   D71B 86 28                   ldaa    #$28                      ; 20 sec                            
3152   D71D~            #else                                        
3153   D71D~                        ldaa    #$18                      ; 12 sec                           
3154   D71D             #endif                                       
3155   D71D B7 01 36                staa    T2_closedLp                                                   
3156   D720 20 1D                   bra     L1122                     ; Branch to continue closed loop checking                              
3157   D722             
3158   D722                         ;--------------------------------------------------------------------------------
3159   D722                         ; At this point airVolTB is higher than first threshold. Normally, 
3160   D722                         ; the airflow is too high to be in closed loop mode but in order to account
3161   D722                         ; for variations, we will remain in closed loop for a certain time
3162   D722                         ; (T2_closedLp) as long as we are below a second threshold t_closedLp2(rpm). If 
3163   D722                         ; we go over that second threshold, we go to open loop immediatly. This is 
3164   D722                         ; implementing aiflow hysteresis under specific rpm conditions
3165   D722                         ;
3166   D722                         ; Check if airVolTB higher than second threshold (with an hysteresis of 6)
3167   D722                         ;--------------------------------------------------------------------------------
3168   D722 03 E8 01    L1119       orm     closedLpFlags, #$01       ; Set flag indicating we are above the first threshold                               
3169   D725             #ifdef E931                                   
3170   D725 CE FB D4                ldx     #t_closedLp2              ;                                     
3171   D728 BD EB 3F                jsr     interp16rpm               ; b = t_closedLp2(rpm)
3172   D72B~            #else                                         
3173   D72B~                        jmp     L1978                     ; Jump to code patch for E932 rpm calculation..., jumps back here afterwards...                             
3174   D72B~            L1120       jsr     interp16b                 ;                                  
3175   D72B             #endif                                        
3176   D72B 87 E6 80 05             brset   state1, #$80, L1121       ; Branch if closed loop mode
3177   D72F C0 06                   subb    #$06                      ; b = t_closedLp2(rpm)-6 (threshold hysteresis)
3178   D731 24 01                   bcc     L1121                     ; Branch if underflow                             
3179   D733 5F                      clrb                              ; Use min of 0                            
3180   D734 CD 09       L1121       decy                              ; y points back to airVol or airVolTB (implicit y=y+1 above...)                             
3181   D736 E1 80                   cmpb    $00,y                     ; Notice implicit y = y+1 here!!!!!!!!!!!
3182   D738 23 3B                   bls     L1126                     ; Use open loop if airVolTB higher than second threshold
3183   D73A             
3184   D73A                         ;---------------------------------------------------------
3185   D73A                         ; airVolTB smaller than second threshold, we could 
3186   D73A                         ; therefore remain in closed loop if timer not expired
3187   D73A                         ;
3188   D73A                         ; Check if T2_closedLp timer is expired
3189   D73A                         ;---------------------------------------------------------
3190   D73A B6 01 36                ldaa    T2_closedLp               ;                             
3191   D73D 27 36                   beq     L1126                     ; Use open loop mode if T2_closedLp expired                             
3192   D73F             
3193   D73F                         ;----------------------------------------------------
3194   D73F                         ; Check tspRaw threshold with hysteresis to know 
3195   D73F                         ; if closed loop is an option
3196   D73F                         ;
3197   D73F                         ; Go to open loop if 
3198   D73F                         ;       tpsRaw >= t_closedLp3(rpm)
3199   D73F                         ; Closed loop is possible if 
3200   D73F                         ;       tpsRaw < t_closedLp3(rpm)-$0d (hysteresis)
3201   D73F                         ;
3202   D73F                         ;----------------------------------------------------
3203   D73F CE FB DE    L1122       ldx     #t_closedLp3              ; x = t_closedLp3                                    
3204   D742 BD EB 3F                jsr     interp16rpm               ; b = t_closedLp3(rpm)                                   
3205   D745 87 E6 80 05             brset   state1, #$80, L1124       ; Branch if closed loop mode
3206   D749 C0 0D                   subb    #$0d                      ; b = t_closedLp3(rpm) - $0d                            
3207   D74B 24 01                   bcc     L1124                     ; Branch if no underflow                             
3208   D74D 5F                      clrb                              ; Use min of 0
3209   D74E D1 D2       L1124       cmpb    tpsRaw                    ;                               
3210   D750 23 23                   bls     L1126                     ; Branch to use open loop if  t_closedLp3(rpm)<= tpsRaw                             
3211   D752             
3212   D752                         ;-----------------------------------------------------
3213   D752                         ; We could use closed loop, check a few more things
3214   D752                         ;-----------------------------------------------------
3215   D752 87 E6 1B 1F             brset   state1, #$1b, L1126        ; Use open loop if engine is either notRotating or rotatingStopInj or runningFast
3216   D756 87 85 80 1B             brset   coilChkFlags, #$80, L1126  ; Use open loop if ignition problem is detected                               
3217   D75A 8F E5 80 17             brclr   ftrimFlags, #$80, L1126    ; Use open loop if airVolT < threshold (15 or 24, used for fTrim...). Means airflow is too low???                               
3218   D75E 03 E8 02                orm     closedLpFlags, #$02        ; Set flag indicating we should be using closed loop mode????                                
3219   D761 B6 01 1D                ldaa    T40_stInj1                 ;                                     
3220   D764 26 0F                   bne     L1126                      ; Use open loop if rotatingStopInj has been active for more than 1 sec (and 2 sec after)                             
3221   D766 87 E8 40 0B             brset   closedLpFlags, #$40, L1126 ; Use open loop if o2 sensor is bad                                
3222   D76A 96 D3                   ldaa    ectFiltered                ;                                  
3223   D76C             #ifdef E931
3224   D76C 81 6A                   cmpa    #$6a                       ; 31degC                             
3225   D76E~            #else
3226   D76E~                        cmpa    #$70                       ; 28degC                             
3227   D76E             #endif
3228   D76E             
3229   D76E~            #ifdef noClosedLoop
3230   D76E~                        bra     L1126                      ; 
3231   D76E             #else
3232   D76E 22 05                   bhi     L1126                      ; Use open loop if temperature(ectFiltered) < 31degC                              
3233   D770             #endif
3234   D770             
3235   D770                         ;-----------------------------------------------------
3236   D770                         ; Use closed loop mode, set flag
3237   D770                         ;-----------------------------------------------------
3238   D770 03 E6 80                orm     state1, #$80              ; Go into closed loop mode
3239   D773 20 03                   bra     L1127                     ; Bail                             
3240   D775             
3241   D775                         ;---------------------------------
3242   D775                         ; Use open loop mode, reset flag
3243   D775                         ;---------------------------------
3244   D775 02 E6 7F    L1126       andm    state1, #$7f              ; Go into open loop mode
3245   D778             
3246   D778                         ;-----------------------------------
3247   D778                         ; Reset o2Fbk in some cases
3248   D778                         ; open loop for instance...
3249   D778                         ;-----------------------------------
3250   D778 87 F9 04 08 L1127       brset   fpsBcsFlags, #$04, L1129  ; Branch to reset if the fuel pressure solenoid was just deactivated                               
3251   D77C 87 F8 02 09             brset   varFlags0, #$02, L1130    ; Bail if hot start flag is set                              
3252   D780 87 E6 80 05             brset   state1, #$80, L1130       ; Bail if closed loop mode
3253   D784 CC 80 80    L1129       ldd     #$8080                    ;                               
3254   D787 DD E9                   std     o2Fbk                     ;                              
3255   D789             
3256   D789                         ;--------------------------------------------------
3257   D789                         ; Re-init timer T40_o2Fbk to 4 sec if 
3258   D789                         ; currentTrimRange!=low (or high speed, E931 only)
3259   D789                         ;
3260   D789                         ; T40_o2Fbk will be 0 when the low trim range will 
3261   D789                         ; will have been used for more than 4 sec
3262   D789                         ;--------------------------------------------------
3263   D789 8F E5 13 05 L1130       brclr   ftrimFlags, #$13, L1131   ; Branch if currentTrimRange=low and rpm<threshold
3264   D78D 86 A0                   ldaa    #$a0                      ; 4sec                            
3265   D78F B7 01 1E                staa    T40_o2Fbk                 ; T40_o2Fbk = 4sec                             
3266   D792             
3267   D792                         ;--------------------------------------------------------------------
3268   D792                         ; Find which table we should be using depending on config resistors
3269   D792                         ; (one of L1999, L2000, L2001, L2002)
3270   D792                         ;--------------------------------------------------------------------
3271   D792 CE FB 2A    L1131       ldx     #t_strap2                 ;                                  
3272   D795 BD EC 0D                jsr     cfgLookup16               ; x =  t_strap2(2*(config2 & $03)) = tableAddress
3273   D798             
3274   D798                         ;----------------------------------------------------------
3275   D798                         ; Use o2Fbk_dec:o2Fbk_inc = t_o2Fbk1 if timer expired 
3276   D798                         ; i.e. we have been in low trim range for more than 4sec
3277   D798                         ;----------------------------------------------------------
3278   D798 B6 01 1E                ldaa    T40_o2Fbk                 ;                                
3279   D79B 26 05                   bne     L1132                     ; Branch if timer not expired                             
3280   D79D FC FB EA                ldd     t_o2Fbk1                  ; Timer expired, use t_o2Fbk1                              
3281   D7A0 20 2D                   bra     L1138                     ; Bail to store                             
3282   D7A2             
3283   D7A2                         ;--------------------------------------------------------------------------
3284   D7A2                         ; Timer not expired, compute values for o2Fbk_dec:o2Fbk_inc
3285   D7A2                         ; from table pointed by x (see above, one of L1999, L2000, L2001, L2002)
3286   D7A2                         ; Use b as index into table. Start with b = 0
3287   D7A2                         ;--------------------------------------------------------------------------
3288   D7A2 5F          L1132       clrb                              ; b = 0                            
3289   D7A3             
3290   D7A3                         ;-------------------------------------------------------------
3291   D7A3                         ; b = b+1 if airVolTB >= threshold
3292   D7A3                         ; Threshold based on config resistors (AWD vs FWD???)
3293   D7A3                         ;-------------------------------------------------------------
3294   D7A3 96 E2                   ldaa    airVolTB                  ; a = airVolTB                                
3295   D7A5             #ifdef E931                                   
3296   D7A5 81 40                   cmpa    #$40                      ;                             
3297   D7A7 8F 56 80 02             brclr   config2, #$80, L1133      ; Branch if ??? (same as branching if FWD)                                
3298   D7AB 81 40                   cmpa    #$40                      ;                             
3299   D7AD~            #else                                         
3300   D7AD~                        cmpa    #$48                      ;                             
3301   D7AD~                        brclr   config2, #$80, L1133      ;                                 
3302   D7AD~                        cmpa    #$50                      ;                             
3303   D7AD             #endif                                        
3304   D7AD 25 01       L1133       bcs     L1134                     ; Branch if airVolTB < threshold                             
3305   D7AF 5C                      incb                              ; airVolTB > threshold, b +=1 (go to next value)                            
3306   D7B0             
3307   D7B0                         ;-------------------------------------------------------------
3308   D7B0                         ; b = b+2 if rpm31 >= (1500rpm or 1406rpm)
3309   D7B0                         ;     b+4 if rpm31 >= (2094rpm or 2313rpm)
3310   D7B0                         ;-------------------------------------------------------------
3311   D7B0 96 DD       L1134       ldaa    rpm31                     ;                              
3312   D7B2 81 2D                   cmpa    #$2d                      ;                             
3313   D7B4 8F 56 80 02             brclr   config2, #$80, L1135      ;  Branch if ??? (same as branching if FWD)
3314   D7B8             #ifdef E931                                   
3315   D7B8 81 30                   cmpa    #$30                      ;                             
3316   D7BA~            #else                                         
3317   D7BA~                        cmpa    #$2d                      ;                             
3318   D7BA             #endif                                        
3319   D7BA 25 0E       L1135       bcs     L1137                     ; Branch if rpm31 < threshold (1500rpm or 1406rpm)                              
3320   D7BC CB 02                   addb    #$02                      ; rpm31 > (1500rpm or 1406rpm, b += 2
3321   D7BE 81 43                   cmpa    #$43                      ; 2094rpm                            
3322   D7C0 8F 56 80 02             brclr   config2, #$80, L1136      ; Branch if ??? (same as branching if FWD)
3323   D7C4             #ifdef E931                                   
3324   D7C4 81 4A                   cmpa    #$4a                      ; 2313rpm                             
3325   D7C6~            #else                                         
3326   D7C6~                        cmpa    #$43                      ; 2094rpm                            
3327   D7C6             #endif                                        
3328   D7C6 25 02       L1136       bcs     L1137                     ;                              
3329   D7C8 CB 02                   addb    #$02                      ; rpm31 > (2313rpm or 2094rpm, b += 2
3330   D7CA             
3331   D7CA                         ;---------------------------------------------
3332   D7CA                         ; interpolate table from x+b
3333   D7CA                         ; (x is one of L1999, L2000, L2001, L2002)
3334   D7CA                         ;---------------------------------------------
3335   D7CA 3A          L1137       abx                               ;                             
3336   D7CB A6 00                   ldaa    $00,x                     ;                              
3337   D7CD E6 06                   ldab    $06,x                     ; ???????????                             
3338   D7CF                                                           
3339   D7CF                         ;------------------------------------------------
3340   D7CF                         ; Update o2Fbk_dec and o2Fbk_inc with new values
3341   D7CF                         ;------------------------------------------------
3342   D7CF DD EB       L1138       std     o2Fbk_dec                                                 
3343   D7D1             
3344   D7D1                         ;-------------------------------------------------------------
3345   D7D1                         ; If we are in closed loop mode, limit the range of o2Fbk
3346   D7D1                         ; depending on ect and then compute o2FuelAdj (how much 
3347   D7D1                         ; fuel to add/remove based on o2 sensor in closed loop....)
3348   D7D1                         ;
3349   D7D1                         ; Notice that part of the code has been located somewhere 
3350   D7D1                         ; else... (L1973)
3351   D7D1                         ;-------------------------------------------------------------
3352   D7D1 86 80                   ldaa    #$80                    ; pre-load default value of $80 (no fuel adjustment)                            
3353   D7D3 8F E6 80 37             brclr   state1, #$80, L1148     ; Branch if open loop mode
3354   D7D7             
3355   D7D7                         ;----------------------------------------------------
3356   D7D7                         ; We are in closed loop mode, limit the range
3357   D7D7                         ; of o2Fbk to $4d-$d6 or $2a-$d6 depending on ect 
3358   D7D7                         ;----------------------------------------------------
3359   D7D7 7E FA EC                jmp     L1973                   ; Jump to code snipet for closed loop mode, will jump back to main code as appropriate                             
3360   D7DA 01                      nop                                                          
3361   D7DB             
3362   D7DB                         ;------------------------------------------------
3363   D7DB                         ; Continuation of code...
3364   D7DB                         ;------------------------------------------------
3365   D7DB                         ;---------------------------------------
3366   D7DB                         ; temperature(ectFiltered) > 86degC
3367   D7DB                         ; Check for min and max of $2a and $d6
3368   D7DB                         ;---------------------------------------
3369   D7DB 24 04       L1140       bcc     L1141                   ; Branch if o2Fbk >= $2a
3370   D7DD 86 2A                   ldaa    #$2a                    ; Use min of $2a                            
3371   D7DF 20 06                   bra     L1142                   ;                              
3372   D7E1 81 D6       L1141       cmpa    #$d6                    ;                             
3373   D7E3 25 05                   bcs     L1143                   ; Branch if o2Fbk < $d6
3374   D7E5 86 D6                   ldaa    #$d6                    ; Use max of $d6                            
3375   D7E7             
3376   D7E7                         ;--------------------------
3377   D7E7                         ; Store new value of o2Fbk  
3378   D7E7                         ;--------------------------
3379   D7E7 5F          L1142       clrb                            ; Set lower 8 bit of o2Fbk                             
3380   D7E8 DD E9                   std     o2Fbk                   ;                              
3381   D7EA             
3382   D7EA                         ;-----------------------------------------------------------------------------
3383   D7EA                         ; Compute o2FuelAdj = o2Fbk +/-  t_closedLpV1(xx) or t_closedLpV2(xx) or $02
3384   D7EA                         ; where +/- depends on o2Raw (lean or rich). 
3385   D7EA                         ;-----------------------------------------------------------------------------
3386   D7EA 36          L1143       psha                            ; st0 = o2Fbk high byte
3387   D7EB             #ifdef E931                                 ;
3388   D7EB C6 02                   ldab    #$02                    ; b = $02                              
3389   D7ED B6 01 1F                ldaa    T40_ftrim2              ; a = T40_ftrim2                                   
3390   D7F0 27 0A                   beq     L1146                   ; Branch if timer expired, use $02 instead of table values if conditions are stable on E931                             
3391   D7F2~            #else                                       ;
3392   D7F2~                        ldx     #t_closedLpV2           ; x = t_closedLpV2                              
3393   D7F2~                        brset   port3Snap0, #$20, L1144 ; branch if Park/neutral                               
3394   D7F2             #endif
3395   D7F2 CE FB E8                ldx     #t_closedLpV1           ; x = t_closedLpV1                                
3396   D7F5 8F E5 13 01 L1144       brclr   ftrimFlags, #$13, L1145 ; branch if trim range is low and rpm<threshold???
3397   D7F9 08                      inx                             ; go to next value in table                             
3398   D7FA E6 00       L1145       ldab    $00,x                   ; b = = t_closedLpV1(xx) or t_closedLpV2(xx)                               
3399   D7FC 96 CE       L1146       ldaa    o2Raw                   ; a = o2Raw
3400   D7FE 81 1A                   cmpa    #$1a                    ; 0.5V
3401   D800 32                      pula                            ; a = o2Fbk                             
3402   D801 24 07                   bcc     L1147                   ; Branch if o2Raw > 0.5V
3403   D803 1B                      aba                             ; o2 lean, a = o2Fbk + t_closedLpV1(xx) or t_closedLpV2(xx)
3404   D804 24 08                   bcc     L1148                   ; branch if no overflow                              
3405   D806 86 FF                   ldaa    #$ff                    ; Use max in case of overflow                            
3406   D808 20 04                   bra     L1148                   ; Branch to store o2FuelAdj
3407   D80A                                                      
3408   D80A 10          L1147       sba                             ; o2 rich, a = o2Fbk -  t_closedLpV1(xx) or t_closedLpV2(xx)
3409   D80B 24 01                   bcc     L1148                   ; branch if no underflow
3410   D80D 4F                      clra                            ; Use min value of 0
3411   D80E             
3412   D80E                         ;---------------------
3413   D80E                         ; Store new o2FuelAdj
3414   D80E                         ;---------------------
3415   D80E B7 01 5A    L1148       staa    o2FuelAdj               ; o2Fbk +/- table value for fuel compensation in closed loop                              
3416   D811             
3417   D811                         ;-------------------------------------------------------------
3418   D811                         ; Transfer ftrimFlags to oldFtrimFlg, a = old oldFtrimFlg
3419   D811                         ;-------------------------------------------------------------
3420   D811 B6 01 02                ldaa    oldFtrimFlg             ;                                    
3421   D814 D6 E5                   ldab    ftrimFlags              ;                                   
3422   D816 F7 01 02                stab    oldFtrimFlg             ;                                    
3423   D819             
3424   D819                         ;--------------------------------------------------------------
3425   D819                         ; Section to check whether conditions are sufficiently 
3426   D819                         ; stable to update fuel trims. Fuel trims are updated 
3427   D819                         ; only if T40_ftrim = 0
3428   D819                         ;
3429   D819                         ; Restart timer T40_ftrim at 5s under all the following conditions
3430   D819                         ;
3431   D819                         ;       if  fuel trim range changed
3432   D819                         ;       or  open loop mode
3433   D819                         ;       or  airVolTB too high
3434   D819                         ;       or  ectRaw malfunction
3435   D819                         ;       or  iatRaw malfunction
3436   D819                         ;       or  baroRaw malfunction
3437   D819                         ;       or  temperature(ectFiltered) < 86degC
3438   D819                         ;       or  temperature(iatChecked) >= 50degC
3439   D819                         ;       or  baroChecked < 0.76bar
3440   D819                         ;       or  baroChecked >= 1.05bar
3441   D819                         ;       or  accEnr not 0
3442   D819                         ;       or  airDiffNeg1 >= accEnrDiffT 
3443   D819                         ;       or  airVolT too small
3444   D819                         ;       or  purge solenoid activated
3445   D819                         ;       or  fuel pressure solenoid activated
3446   D819                         ;       or  T40_ftrim2 expired (E931)
3447   D819                         ;       or  T0p5_crCold not expired
3448   D819                         ;
3449   D819                         ;--------------------------------------------------------------
3450   D819 98 E5                   eora    ftrimFlags              ;                               
3451   D81B 84 03                   anda    #$03                    ; a = (oldFtrimFlg eor ftrimFlags) & $03
3452   D81D 26 46                   bne     L1150                   ; Branch if trim rancge changed                             
3453   D81F 8F E6 80 42             brclr   state1, #$80, L1150     ; Branch if open loop mode                                
3454   D823 87 E8 01 3E             brset   closedLpFlags, #$01, L1150      ; Branch if airVolTB too high                              
3455   D827 87 D6 07 3A             brset   state2, #$07, L1150     ; Branch if ectRaw, iatRaw or baroRaw in error                               
3456   D82B 96 D3                   ldaa    ectFiltered             ;                                    
3457   D82D             #ifdef E931
3458   D82D 81 1C                   cmpa    #$1c                    ; 86degC                             
3459   D82F~            #else
3460   D82F~                        cmpa    #$1b                    ; 88degC                            
3461   D82F             #endif
3462   D82F 22 34                   bhi     L1150                   ; Branch if temperature(ectFiltered) < 86degC                             
3463   D831 96 D4                   ldaa    iatChecked              ;                                   
3464   D833 81 49                   cmpa    #$49                    ;                             
3465   D835 23 2E                   bls     L1150                   ; Branch if temperature(iatChecked) >= 50degC                              
3466   D837 96 D5                   ldaa    baroChecked             ;                                    
3467   D839 81 9C                   cmpa    #$9c                    ;                             
3468   D83B 25 28                   bcs     L1150                   ; Branch if baroChecked < 0.76bar?                              
3469   D83D 81 D8                   cmpa    #$d8                    ;                             
3470   D83F 24 24                   bcc     L1150                   ; Branch if baroChecked >= 1.05bar?                             
3471   D841 96 A1                   ldaa    accEnr                  ;                               
3472   D843 26 20                   bne     L1150                   ; Branch if accEnr not 0 (we are applying enrichment during acceleration)                              
3473   D845 B6 01 4A                ldaa    airDiffNeg1             ;                                    
3474   D848 B1 01 0C                cmpa    accEnrDiffT             ;                                    
3475   D84B 24 18                   bcc     L1150                   ; Branch if airDiffNeg1 >= accEnrDiffT (we will apply decceleration enrichment????)                             
3476   D84D 96 E1                   ldaa    airVolT                 ;                                
3477   D84F 81 18                   cmpa    #$18                    ;                             
3478   D851 25 12                   bcs     L1150                   ; Branch if airVolT < $18 (air volume too low)                             
3479   D853 8F 2F 10 0E             brclr   port6, #$10, L1150      ; Branch if purge solenoid activated
3480   D857 8F 16 10 0A             brclr   port5, #$10, L1150      ; Branch if fuel pressure solenoid activated                              
3481   D85B             #ifdef E931
3482   D85B B6 01 1F                ldaa    T40_ftrim2              ;                                    
3483   D85E 27 05                   beq     L1150                   ; Branch if timer T40_ftrim2 expired on E931???                               
3484   D860             #endif
3485   D860 B6 01 41                ldaa    T0p5_crCold             ;                               
3486   D863 27 05                   beq     L1151                   ; Branch if T0p5_crCold expired, meaning its been more than 120sec since we started a cold engine (we can update trims...)
3487   D865                                                       
3488   D865                         ;-----------------------------------------------------
3489   D865                         ; Conditions not stable, Re-init T40_ftrim at 5 sec
3490   D865                         ;-----------------------------------------------------
3491   D865 86 C8       L1150       ldaa    #$c8                    ; 5 sec                             
3492   D867 B7 01 23                staa    T40_ftrim               ;                               
3493   D86A             
3494   D86A                         ;------------------------------------------------------------------
3495   D86A                         ; Get current fuel trim value according to current fuel trim range 
3496   D86A                         ;------------------------------------------------------------------
3497   D86A CE 00 40    L1151       ldx     #ftrim_low              ;                               
3498   D86D D6 E5                   ldab    ftrimFlags              ;                              
3499   D86F C4 03                   andb    #$03                    ; Get current fuel trim range to update                            
3500   D871 3A                      abx                             ; X point to fuel trim                             
3501   D872 A6 00                   ldaa    $00,x                   ; a = fuelTrim                             
3502   D874 C6 80                   ldab    #$80                    ; pre-load $80 in case we bail                     
3503   D876                               
3504   D876                         ;----------------------------------------------
3505   D876                         ; Don't update trim if T40_ftrim not yet expired
3506   D876                         ;----------------------------------------------
3507   D876 7D 01 23                tst     T40_ftrim               ;                               
3508   D879 26 18                   bne     L1153                   ;                              
3509   D87B             
3510   D87B                         ;-------------------------------------------------------------------------------
3511   D87B                         ; Update fuel trim at 40Hz
3512   D87B                         ; fuel trim is actually increased/decreased by 1 at 40Hz/(256/5) = 0.78125Hz
3513   D87B                         ;-------------------------------------------------------------------------------
3514   D87B 8F D9 01 16             brclr   Tclocks, #$01, L1154    ; Branch if 40Hz signal not set                                   
3515   D87F D6 E9                   ldab    o2Fbk                   ; b = o2Fbk
3516   D881 C1 80                   cmpb    #$80                    ; 
3517   D883 27 10                   beq     L1154                   ; branch if o2Fbk = 100% (no update)
3518   D885 D6 43                   ldab    ftrimCntr               ; b = ftrimCntr                             
3519   D887 25 06                   bcs     L1152                   ; branch if o2Fbk < 100%
3520   D889 CB 05                   addb    #$05                    ; b = ftrimCntr + 5
3521   D88B 89 00                   adca    #$00                    ; a = fuelTrim+1 if ftrimCntr rolled over (o2Fbk + 5)>255
3522   D88D 20 04                   bra     L1153                   ;
3523   D88F C0 05       L1152       subb    #$05                    ; b = ftrimCntr - 5
3524   D891 82 00                   sbca    #$00                    ; a = fuelTrim-1 if ftrimCntr rolled under (o2Fbk - 5)<0
3525   D893             
3526   D893                         ;------------------------------
3527   D893                         ; Update ftrimCntr with new value
3528   D893                         ;------------------------------
3529   D893 D7 43       L1153       stab    ftrimCntr               ;                              
3530   D895             
3531   D895                         ;------------------------------------------------
3532   D895                         ; Check a = updated trim value for min/max values
3533   D895                         ;------------------------------------------------
3534   D895 81 68       L1154       cmpa    #$68                    ; 
3535   D897 24 02                   bcc     L1155                   ; Branch if new fuelTrim > $68 (81%)
3536   D899 86 68                   ldaa    #$68                    ; use min
3537   D89B 81 B3       L1155       cmpa    #ftrimMax               ;                                  
3538   D89D 23 02                   bls     L1156                   ; Branch if new fuelTrim <= max (~140%)
3539   D89F 86 B3                   ldaa    #ftrimMax               ; use max
3540   D8A1             
3541   D8A1                         ;---------------------------------------------------------------
3542   D8A1                         ; Update the stored fuel trim with updated value (in a) and decide
3543   D8A1                         ; whether we will apply the fuel trim to injector pulse width
3544   D8A1                         ;---------------------------------------------------------------
3545   D8A1 A7 00       L1156       staa    $00,x                      ; Store new fuel trim value
3546   D8A3 86 80                   ldaa    #$80                       ; Assume we won't apply fuel trim, a = $80 (100% fuel trim) 
3547   D8A5 87 D6 08 06             brset   state2, #$08, L1157        ; Branch to use 100% if pulse accumulator interrupts are not being  received
3548   D8A9 87 E8 01 02             brset   closedLpFlags, #$01, L1157 ; Branch to use 100% if the "air volume (airVolTB) is too high to use closed loop mode (first threshold)"
3549   D8AD A6 00                   ldaa    $00,x                      ; Load fuel trim from the current range                                                
3550   D8AF B7 01 5B    L1157       staa    workFtrim                  ; Store working fuel trim
3551   D8B2             
3552   D8B2                         ;--------------------------------------------------------
3553   D8B2                         ; Compute coldTempEnr, fuel enrichment factor when engine
3554   D8B2                         ; is cold...Depends on ect and airflow 
3555   D8B2                         ;
3556   D8B2                         ; coldTempEnr/$80 = 1 + (f1-1)*f2 
3557   D8B2                         ;                   1 + ectNetEnrichment*f2 
3558   D8B2                         ;
3559   D8B2                         ;       where f1 is t_ectEnr(ectCond)/$80, f1>=1.0
3560   D8B2                         ;             f2 is t_airEnr(airVolCond)/$80, f2>=1.0
3561   D8B2                         ;
3562   D8B2                         ; Basically this factor adds fuel enrichment under 
3563   D8B2                         ; cold temperature which is reduced down to no enrichement
3564   D8B2                         ; (coldTempEnr/$80=1.0) as airVolCond increases, i.e. fuel
3565   D8B2                         ; enrichement is only required under low temperature and 
3566   D8B2                         ; low airflow
3567   D8B2                         ;--------------------------------------------------------
3568   D8B2 CE FC 2F                ldx     #t_ectEnr               ;                               
3569   D8B5 BD EB 3A                jsr     interpEct               ; b = t_ectEnr(ectCond)                                 
3570   D8B8 4F                      clra                            ;                             
3571   D8B9 C0 80                   subb    #$80                    ; d = t_ectEnr(ectCond)-$80                             
3572   D8BB 24 01                   bcc     L1158                   ; Branch if no overflow                             
3573   D8BD 5F                      clrb                            ; Use min of 0                            
3574   D8BE DD 5C       L1158       std     temp6                   ; temp6:temp7 = t_ectEnr(ectCond)-$80  
3575   D8C0 CE FC 23                ldx     #t_airEnr               ;                               
3576   D8C3 B6 01 50                ldaa    airVolCond              ;                                   
3577   D8C6 BD EB 49                jsr     interp16b               ; b = t_airEnr(airVolCond)                                  
3578   D8C9 96 DD                   ldaa    rpm31                   ;                              
3579   D8CB 81 30                   cmpa    #$30                    ;                             
3580   D8CD 24 02                   bcc     L1159                   ;                              
3581   D8CF C6 80                   ldab    #$80                    ; Use b=$80 if rpm<1500 
3582   D8D1 BD EB 6A    L1159       jsr     mul816_128              ; d = t_airEnr(airVolCond) * (t_ectEnr(ectCond)-$80)/$80 
3583   D8D4 CB 80                   addb    #$80                    ; b =  t_airEnr(airVolCond)*(t_ectEnr(ectCond)-$80)/$80 + $80                             
3584   D8D6 F7 01 5C                stab    coldTempEnr             ; coldTempEnr = t_airEnr(airVolCond) * (t_ectEnr(ectCond)-$80)/$80 + $80
3585   D8D9                                                         
3586   D8D9                                                      
3587   D8D9                         ;----------------------------------------------------------------
3588   D8D9                         ; Section to update openLoopEnr enrichment factor if in open loop
3589   D8D9                         ;----------------------------------------------------------------
3590   D8D9 C6 80                   ldab    #$80                    ; Assume an enrichement factor of 1.0                            
3591   D8DB 87 E6 80 58             brset   state1, #$80, L1167     ; Branch if closed loop mode     
3592   D8DF                         
3593   D8DF                         ;-------------------------------------------------------------
3594   D8DF                         ; Open loop
3595   D8DF                         ; Compute conditionned rpm and load for 2D map interpolation                           
3596   D8DF                         ;-------------------------------------------------------------
3597   D8DF D6 DD                   ldab    rpm31                   ; b = rpm31
3598   D8E1 86 D0                   ldaa    #$d0                    ; 6500 RPM                                                                
3599   D8E3 BD EC 27                jsr     rpmRange                ; get rpm for map interpolation, b = min(max(RPM31p25-#$10, 0), $d0) = min(max(RPM31p25-500rpm,0),6500rpm)  
3600   D8E6 D7 5C                   stab    temp6                   ; temp6 = conditionned rpm
3601   D8E8 BD EC 31                jsr     getLoadForMaps          ; get the load value for map interpolation                                                      
3602   D8EB D7 5D                   stab    temp7                   ; temp7 = conditionned load                              
3603   D8ED             
3604   D8ED                         ;----------------------------------------------
3605   D8ED                         ; Get basic fuel enrichement from 2D fuel map
3606   D8ED                         ;----------------------------------------------
3607   D8ED CE FC 3F                ldx     #t_fuelMap              ;                                   
3608   D8F0 CD CE 0E 00             ldy     #$0e00                  ;                               
3609   D8F4 BD EA E1                jsr     lookup2D                ; a = b = 2D interpolated fuel map value from temp6 (rpm) and temp7 (load)                               
3610   D8F7             
3611   D8F7                         ;----------------------------------------
3612   D8F7                         ; Check airVol vs. RPM (deceleration???)
3613   D8F7                         ;----------------------------------------
3614   D8F7 96 E0                   ldaa    airVol                  ;                                
3615   D8F9 81 AF                   cmpa    #$af                    ;                             
3616   D8FB 25 0D                   bcs     L1162                   ; branch if airVol<$af                              
3617   D8FD 96 DD                   ldaa    rpm31                   ;                              
3618   D8FF             #ifdef E931
3619   D8FF 81 46                   cmpa    #$46                    ; 2187rpm                            
3620   D901~            #else
3621   D901~                        cmpa    #$53                    ; 2594rpm                            
3622   D901             #endif
3623   D901 25 07                   bcs     L1162                   ; branch if current rpm smaller than threshold                              
3624   D903 B6 01 61                ldaa    timFuelEnr              ; a = timing/knock based fuel enrichement                              
3625   D906 1B                      aba                             ; a = basicFuelEnrichement + timingKnockFuelEnrichment
3626   D907 25 05                   bcs     L1163                   ; branch if overflow                             
3627   D909 16                      tab                             ; b = basicFuelEnrichement + timingKnockFuelEnrichment
3628   D90A             
3629   D90A                         ;-----------------------------------------------------------------------
3630   D90A                         ; Check  fuel compensation + timing/knock based enrichment for max value
3631   D90A                         ;-----------------------------------------------------------------------
3632   D90A C1 CA       L1162       cmpb    #fuelMapClip            ; 
3633   D90C 23 02                   bls     L1164                   ; Branch if below max                              
3634   D90E C6 CA       L1163       ldab    #fuelMapClip            ; Use max                            
3635   D910 37          L1164       pshb                            ; Store  basicFuelEnrichement + timingKnockFuelEnrichment on stack
3636   D911                                         
3637   D911                         ;-----------------------------------
3638   D911                         ; Compute TPS based fuel enrichment
3639   D911                         ;-----------------------------------
3640   D911 D6 D2                   ldab    tpsRaw                  ;
3641   D913 CE B0 80                ldx     #$b080                  ;                                
3642   D916 BD EB C4                jsr     clipOffset              ; b = max(min(tpsRaw,$b0)-$80,0)-> returns b = $00 to $30  (50% to 69%)                                           
3643   D919 17                      tba                             ; a = conditionned TPS for table interpolation                            
3644   D91A CE FF 04                ldx     #t_tpsEnr               ;                                
3645   D91D BD EB 49                jsr     interp16b               ; a = t_tpsEnr(tpsRaw)                                 
3646   D920             
3647   D920                         ;-----------------------------------------------------------------------------------------
3648   D920                         ; Keep the highest of t_tpsEnr(tpsRaw) and  "basicFuelEnrichement + timingKnockFuelEnrichment"
3649   D920                         ;-----------------------------------------------------------------------------------------
3650   D920 33                      pulb                            ; b = basicFuelEnrichement + timingKnockFuelEnrichment
3651   D921 11                      cba                             ;                              
3652   D922 25 01                   bcs     L1165                   ; branch if basicFuelEnrichement + timingKnockFuelEnrichment
3653   D924 16                      tab                             ; b = max(t_tpsEnr(tpsRaw), basicFuelEnrichement + timingKnockFuelEnrichment)
3654   D925             
3655   D925                                                       
3656   D925                         ;-----------------------------------------------------------
3657   D925                         ; Compute timer T2_hotEnrich based fuel enrichement if required
3658   D925                         ;-----------------------------------------------------------
3659   D925 8F F8 02 0E L1165       brclr   varFlags0, #$02, L1167  ; Bail if "hot start" flag was not set                              
3660   D929 37                      pshb                            ; save on stack                             
3661   D92A C6 30                   ldab    #$30                    ; 
3662   D92C B6 01 38                ldaa    T2_hotEnrich            ;                             
3663   D92F 3D                      mul                             ;                             
3664   D930 8B 80                   adda    #$80                    ; d = T2_hotEnrich*$30 + $80                            
3665   D932             
3666   D932                         ;---------------------
3667   D932                         ; Keep the highest
3668   D932                         ;---------------------
3669   D932 33                      pulb                            ; b = max(t_tpsEnr(tpsRaw), basicFuelEnrichement + timingKnockFuelEnrichment)
3670   D933 11                      cba                             ;                             
3671   D934 23 01                   bls     L1167                   ;                              
3672   D936 16                      tab                             ; max(T2_hotEnrich*$30 + $80, t_tpsEnr(tpsRaw), basicFuelEnrichement + timingKnockFuelEnrichment)
3673   D937                         
3674   D937                         ;-------------------------------------------
3675   D937                         ; Update openLoopEnr with the above result
3676   D937                         ;-------------------------------------------
3677   D937 F7 01 59    L1167       stab    openLoopEnr             ; Store final value                               
3678   D93A             
3679   D93A                         ;------------------------------------------------------------------
3680   D93A                         ; Update T2_hotEnrich and varFlags0.1 (hot start) used in timer based enrichement above
3681   D93A                         ;------------------------------------------------------------------
3682   D93A 8F E6 90 06             brclr   state1, #$90, L1168     ; Branch if notRotating and closed loop clear
3683   D93E 02 F8 FD                andm    varFlags0, #$fd         ; closedLoop or notRotating, reset flag and reset timer
3684   D941 4F                      clra                            ; a = 0                             
3685   D942 20 1B                   bra     L1169                   ; Update timer with 0
3686   D944             
3687   D944 8F E6 01 1A L1168       brclr   state1, #$01, L1171     ; open loop and at least rotating, Bail if startingToCrank clear
3688   D948 96 D4                   ldaa    iatChecked              ; Engine startingToCrank, a = iatChecked
3689   D94A 81 3A                   cmpa    #$3a                    ;                             
3690   D94C 22 14                   bhi     L1171                   ; Bail if temperature(iatChecked) < 60degC
3691   D94E 96 D3                   ldaa    ectFiltered             ;                                    
3692   D950 81 18                   cmpa    #$18                    ; 93degC                            
3693   D952 22 0E                   bhi     L1171                   ; Bail if temperature(ectFiltered) < 93degC                             
3694   D954             
3695   D954                         ;-----------------------------------------------------------------------------
3696   D954                         ; At this point, engine is startingToCrank and we are in open loop 
3697   D954                         ; and temperature(iatChecked) >= 60degC and  
3698   D954                         ; temperature(ectFiltered) >= 93degC (hot start)                              
3699   D954                         ;
3700   D954                         ; Set hot start flag, init o2Fbk to lean(??) and re-init T2_hotEnrich timer to 120sec  
3701   D954                         ;-----------------------------------------------------------------------------
3702   D954 03 F8 02                orm     varFlags0, #$02         ; Set varFlags0.1 flag (hot start)
3703   D957 86 D6                   ldaa    #$d6                    ;                             
3704   D959 C6 80                   ldab    #$80                    ;                             
3705   D95B DD E9                   std     o2Fbk                   ; o2Fbk = $d680 (lean?)                             
3706   D95D 86 F0                   ldaa    #$f0                    ; Re-init timer with 120sec                            
3707   D95F B7 01 38    L1169       staa    T2_hotEnrich            ;                             
3708   D962             
3709   D962                         ;----------------------------------------------
3710   D962                         ; Update enrWarmup when engine startingToCrank
3711   D962                         ; get enrWarmup timer value from table
3712   D962                         ;----------------------------------------------
3713   D962 5F          L1171       clrb                            ;                             
3714   D963 87 E6 10 0A             brset   state1, #$10, L1172     ; Branch if notRotating
3715   D967 8F E6 01 0B             brclr   state1, #$01, L1173     ; Branch if startingToCrank clear
3716   D96B CE FC 37                ldx     #t_enrWarmup            ;                               
3717   D96E BD EB 3A                jsr     interpEct               ;                                  
3718   D971 F7 01 5D    L1172       stab    enrWarmup               ;                              
3719   D974 20 11                   bra     L1174                   ;
3720   D976                                                       
3721   D976                         ;-----------------------------------------------------------------------------------------
3722   D976                         ; Update enrWarmup at 40Hz
3723   D976                         ;
3724   D976                         ; T_enrWarm is decremented at 40Hz and loops at 2 if enrWarmup>$1a or loops 
3725   D976                         ; at $18 otherwise decrement enrWarmup each time T_enrWarm reaches 0
3726   D976                         ;
3727   D976                         ; This allows to have rapid lowering of enrWarmup at first and then slow one
3728   D976                         ; enrWarmup is decremented at 20Hz until it reached $1a (fuel enrichment factor of 141%) 
3729   D976                         ; and then at 1.67Hz 
3730   D976                         ;-----------------------------------------------------------------------------------------
3731   D976 8F D9 01 1B L1173       brclr   Tclocks, #$01, L1176    ; Bail if 40Hz signal not set 
3732   D97A B6 01 5D                ldaa    enrWarmup               ;                              
3733   D97D 27 16                   beq     L1176                   ;                              
3734   D97F 7A 01 5E                dec     T_enrWarm               ;                              
3735   D982 26 11                   bne     L1176                   ;                              
3736   D984 7A 01 5D                dec     enrWarmup               ;                              
3737   D987             
3738   D987 86 02       L1174       ldaa    #$02                    ;                             
3739   D989 F6 01 5D                ldab    enrWarmup               ;                              
3740   D98C C1 1A                   cmpb    #$1a                    ;                             
3741   D98E 22 02                   bhi     L1175                   ; Branch if enrWarmup>$1a                             
3742   D990 86 18                   ldaa    #$18                    ; Reset T_enrWarm counter to $18                            
3743   D992 B7 01 5E    L1175       staa    T_enrWarm               ;                              
3744   D995             
3745   D995             
3746   D995                         ;------------------------------------------------
3747   D995                         ; Section to compute injFactor 
3748   D995                         ; start with basic value of totMasComp*16  
3749   D995                         ;------------------------------------------------
3750   D995 FC 01 55    L1176       ldd     totMasComp              ; d = totMasComp                                   
3751   D998 05                      asld                            ;                             
3752   D999 05                      asld                            ;                             
3753   D99A 05                      asld                            ;                             
3754   D99B 05                      asld                            ;                             
3755   D99C DD 5C                   std     temp6                   ; temp6:temp7 = totMasComp*16
3756   D99E             
3757   D99E                         ;---------------------------------------
3758   D99E                         ; Factor in injector size compensation
3759   D99E                         ;---------------------------------------
3760   D99E C6 4A                   ldab    #injComp                ; Injector size compensation factor ($80 = 100% = no compensation, referenced at 260cc, 36psi)                                
3761   D9A0 BD EB 6A                jsr     mul816_128              ; d = [temp6:temp7] = totMasComp*16 * injComp /128                                   
3762   D9A3 FD 01 53                std     injMasComp              ; injMasComp = totMasComp*16 * injComp/128                              
3763   D9A6             
3764   D9A6                         ;-------------------------------------------------------
3765   D9A6                         ; Factor in working fuel trim and 02 fuel adjustment
3766   D9A6                         ; Done this way, total range is limited to [50%,150%]
3767   D9A6                         ; when both workFtrim and o2FuelAdj are at $00 or $ff  
3768   D9A6                         ;-------------------------------------------------------
3769   D9A6 4F                      clra                              ; a=0                            
3770   D9A7 F6 01 5B                ldab    workFtrim                 ; d = working fuel trim ($80=100%)                             
3771   D9AA C3 01 00                addd    #$0100                    ; d = workFtrim + 2*$80                               
3772   D9AD FB 01 5A                addb    o2FuelAdj                 ; Add o2 adjustment (Add/remove fuel based on o2 sensor voltage/feedback, $80=100%->no fuel adjustment)                              
3773   D9B0 89 00                   adca    #$00                      ; propagate carry, d = workFtrim + o2FuelAdj + 2*$80                            
3774   D9B2 BD EB 84                jsr     mul1616_512               ; D = [temp6:temp7] = [workFtrim + o2FuelAdj + 2*$80]/512 * [temp6:temp7]
3775   D9B5             
3776   D9B5                         ;-----------------------------------
3777   D9B5                         ; Factor-in air temp, baro, etc...
3778   D9B5                         ;-----------------------------------
3779   D9B5 F6 01 5F                ldab    iatCompFact               ; Correct for air temperature (air density)                                    
3780   D9B8 BD EB 6A                jsr     mul816_128                ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
3781   D9BB F6 01 60                ldab    baroFact                  ; Correct for barometric pressure (air density)                                 
3782   D9BE BD EB 6A                jsr     mul816_128                ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
3783   D9C1 F6 01 59                ldab    openLoopEnr               ; Apply the open loop enrichment factor, based on timing/knock, tps and timer
3784   D9C4 BD EB 6A                jsr     mul816_128                ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
3785   D9C7 F6 01 5C                ldab    coldTempEnr               ; Add fuel enrichement under cold engine temperature and low airflow
3786   D9CA BD EB 6A                jsr     mul816_128                ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
3787   D9CD F6 01 5D                ldab    enrWarmup                 ; b = enrichment during warmup/startup, from t_enrWarmup(ECT), can reach 300% in very cold temp but is decreased to 140% very rapidly
3788   D9D0 4F                      clra                              ; a=0                            
3789   D9D1 05                      asld                              ; d = 2*enrWarmup                            
3790   D9D2 C3 00 80                addd    #$0080                    ; d = 2*enrWarmup + $80 
3791   D9D5 BD EB 82                jsr     mul1616_128               ; Apply (2*enrWarmup+$80) enrichment factor
3792   D9D8 DD A3                   std     injFactor                 ; Store final result in injFactor (global injector factor)                            
3793   D9DA             
3794   D9DA                         ;----------------------------
3795   D9DA                         ; Compute injector deadTime
3796   D9DA                         ;----------------------------
3797   D9DA CE FC E5                ldx     #t_deadtime-2                                            
3798   D9DD 96 D0                   ldaa    battRaw                                                 
3799   D9DF BD EB 4C                jsr     interp32                                                 
3800   D9E2 D7 A6                   stab    deadTime
3801   D9E4                         
3802   D9E4                         ;-----------------------------------------
3803   D9E4                         ; Update injFlags0.2 (set but not reset???) 
3804   D9E4                         ;-----------------------------------------
3805   D9E4 96 DD                   ldaa    rpm31                                                 
3806   D9E6 81 0E                   cmpa    #$0e                                                 
3807   D9E8 25 03                   bcs     L1178                     ; branch if rpm < 437.5                              
3808   D9EA 03 E7 04                orm     injFlags0, #$04           ; rpm >= 437.5, set bit                               
3809   D9ED             
3810   D9ED                         ;-----------------------------------------------
3811   D9ED                         ; Update injFlags0.1.3.5 if engine notRotating
3812   D9ED                         ;-----------------------------------------------
3813   D9ED 8F E6 10 13 L1178       brclr   state1, #$10, L1180       ; Branch if notRotating clear
3814   D9F1 02 E7 DF                andm    injFlags0, #$df           ; assume we reset 00100000, updated below
3815   D9F4 96 D3                   ldaa    ectFiltered               ;                                    
3816   D9F6 81 C2                   cmpa    #$c2                      ; -8degC                            
3817   D9F8 25 03                   bcs     L1179                     ; Branch if temperature(ectFiltered) > -8degC                              
3818   D9FA 03 E7 20                orm     injFlags0, #$20           ; temperature(ectFiltered) <= -8degC, set bit                                 
3819   D9FD 8F E7 04 03 L1179       brclr   injFlags0, #$04, L1180    ; Branch if rpm<437.5                                
3820   DA01 02 E7 FA                andm    injFlags0, #$fa           ; Reset 0000 0101                                
3821   DA04             
3822   DA04                         ;------------------------------------------------------------------------------------
3823   DA04                         ; Section to compute injPwStart, the injector pulsewidth when engine "startingToCrank" 
3824   DA04                         ;
3825   DA04                         ;  startingToCrank   "cold engine"   injPwStart       injFlags0.7 (startingToCrankColdEngine)
3826   DA04                         ;          0             0               0                0
3827   DA04                         ;          0             1               0                0
3828   DA04                         ;          1             0            pulseWidth*4        0
3829   DA04                         ;          1             1             pulseWidth         1
3830   DA04                         ;------------------------------------------------------------------------------------
3831   DA04                         ;--------------------------------
3832   DA04                         ; Get starting value from L2008
3833   DA04                         ;--------------------------------
3834   DA04 4F          L1180       clra                                                         
3835   DA05 8F E6 01 66             brclr   state1, #$01, L1191     ; Bail to end of section if startingToCrank clear
3836   DA09 CE FC EE                ldx     #L2008                  ; Engine is startingToCrank                               
3837   DA0C BD EB 28                jsr     interpEct2              ; b = L2008(ectCond)                                   
3838   DA0F 86 80                   ldaa    #$80                    ; a = $80                            
3839   DA11 3D                      mul                             ;                             
3840   DA12 04                      lsrd                            ; d = $80*L2008(ectCond)                           
3841   DA13 DD 5C                   std     temp6                   ; [temp6:temp7] = $80*L2008(ectCond)                            
3842   DA15             
3843   DA15                         ;--------------------------------------------
3844   DA15                         ; Factor-in some enrichement if injCount<5 
3845   DA15                         ; This only adds more fuel when starting to 
3846   DA15                         ; crank for the first time under very cold 
3847   DA15                         ; temperature (-16degC). Not sure as to 
3848   DA15                         ; exactly why but at -16degC, I guess 
3849   DA15                         ; it just might help???
3850   DA15                         ;--------------------------------------------
3851   DA15 B6 01 86                ldaa    injCount                  ;                              
3852   DA18 81 05                   cmpa    #$05                      ;                              
3853   DA1A 24 0D                   bcc     L1182                     ; Branch if injCount>=5                              
3854   DA1C CE FF 2E                ldx     #L2042                    ;                               
3855   DA1F BD EB 28                jsr     interpEct2                ; b=L2042(ectCond)                                  
3856   DA22 4F                      clra                              ;                             
3857   DA23 C3 00 80                addd    #$0080                    ; d = L2042(ectCond) + $80                               
3858   DA26 BD EB 82                jsr     mul1616_128               ; [temp6:temp7] = [temp6:temp7] * (L2042(ectCond)+$80)/128
3859   DA29             
3860   DA29                         ;------------------------------------------------------------
3861   DA29                         ; Factor in an rpm dependent correction factor if rpm >125???
3862   DA29                         ;------------------------------------------------------------
3863   DA29 96 DC       L1182       ldaa    rpm8                      ; a = rpm8                            
3864   DA2B 81 40                   cmpa    #$40                      ;                             
3865   DA2D 25 02                   bcs     L1183                     ; Branch if rpm < max of 500                              
3866   DA2F 86 40                   ldaa    #$40                      ; rpm>500, use max of 500rpm                            
3867   DA31                                                           
3868   DA31 80 10       L1183       suba    #$10                      ; a = rpm8-$10                             
3869   DA33 25 10                   bcs     L1185                     ; Bail if rpm8<125rpm                             
3870   DA35 48                      asla                              ; a = 2*(rpm8-$10)                             
3871   DA36             #ifdef E931                                   
3872   DA36 C6 56                   ldab    #$56                      ;                             
3873   DA38~            #else                                         
3874   DA38~                        ldab    #$57                      ;                             
3875   DA38             #endif                                        
3876   DA38 3D                      mul                               ; d = $56*2*(rpm8-$10)                             
3877   DA39 05                      asld                              ;                             
3878   DA3A 16                      tab                               ; b = 2*$56*2*(rpm8-$10)/256                            
3879   DA3B 86 80                   ldaa    #$80                      ; a = $80                            
3880   DA3D 10                      sba                               ; a = $80 - $56*2*(rpm8-$10)/128                             
3881   DA3E 24 01                   bcc     L1184                     ; Branch if no underflow                             
3882   DA40 4F                      clra                              ; Use min of 0                            
3883   DA41 16          L1184       tab                               ; b = $80 - $56*2*(rpm8-$10)/128                            
3884   DA42 BD EB 6A                jsr     mul816_128                ; [temp6:temp7] = [temp6:temp7] * ($80 - $56*2*(rpm8-$10)/128)/128
3885   DA45                                                           
3886   DA45             
3887   DA45                         ;------------------------------------------------------------------
3888   DA45                         ; Check current value for minimum, keep min
3889   DA45                         ; minimum is L2008(0) -> starting value at 86degC (hot engine)
3890   DA45                         ;------------------------------------------------------------------
3891   DA45 F6 FC EE    L1185       ldab    L2008                   ; b = L2008(0)                              
3892   DA48 86 80                   ldaa    #$80                    ; a = $80                            
3893   DA4A 3D                      mul                             ; d = $80*L2008(0)                            
3894   DA4B 04                      lsrd                            ; d = $80*L2008(0)/2                            
3895   DA4C 1D 5C                   cmpd1   temp6                   ;                              
3896   DA4E 25 02                   bcs     L1187                   ; branch if current value >                             
3897   DA50 DD 5C                   std     temp6                   ;  
3898   DA52                                                     
3899   DA52                         ;--------------------------------
3900   DA52                         ; Factor-in barometric pressure
3901   DA52                         ;--------------------------------
3902   DA52 F6 01 60    L1187       ldab    baroFact                ;                                 
3903   DA55 BD EB 6A                jsr     mul816_128              ; d = pulseWidth = [temp6:temp7] = [temp6:temp7] * baroFact/128
3904   DA58             
3905   DA58                         ;-----------------------------------------
3906   DA58                         ; Multiply by 2 and check for overflow
3907   DA58                         ;-----------------------------------------
3908   DA58 05                      asld                            ; pulseWidth = d = 2*[temp6:temp7]                            
3909   DA59 24 02                   bcc     L1188                   ; Branch if no overflow                              
3910   DA5B 86 FF                   ldaa    #$ff                    ; Use max                             
3911   DA5D             
3912   DA5D                         ;--------------------------------------------------------------
3913   DA5D                         ; At this point d = pulseWidth
3914   DA5D                         ;
3915   DA5D                         ; Set startingToCrankColdEngine flag if pulseWidth > threshold
3916   DA5D                         ; or reset it (with hysteresis) 
3917   DA5D                         ;
3918   DA5D                         ; Note that pulseWidth will be larger when the engine is cold, also rpm dependent...
3919   DA5D                         ;--------------------------------------------------------------
3920   DA5D 37          L1188       pshb                            ; Put b on stack for temp calculation
3921   DA5E C6 35                   ldab    #$35                    ; b = $35 = 13.6ms =threshold
3922   DA60 8F E7 80 02             brclr   injFlags0, #$80, L1190  ; Branch if startingToCrankColdEngine was not previously set
3923   DA64 C6 30                   ldab    #$30                    ; Flag was set, use lower threshold (hysteresis) b=$30 = 12.3ms
3924   DA66 03 E7 80    L1190       orm     injFlags0, #$80         ; By default, assume startingToCrankColdEngine flag set
3925   DA69 11                      cba                             ; 
3926   DA6A 33                      pulb                            ; restore b (lower part of pulseWidth)                             
3927   DA6B 24 05                   bcc     L1192                   ; Branch if pulseWidth/256 >= threshold (flag already set), we are startingToCrankColdEngine
3928   DA6D             
3929   DA6D                         ;-------------------------------------------------------------------------
3930   DA6D                         ; pulseWidth < threshold, engine is therefore startingToCrank
3931   DA6D                         ; but the engine is not cold 
3932   DA6D                         ; Multiply pulseWidth by 4?????? and reset the flag
3933   DA6D                         ;-------------------------------------------------------------------------
3934   DA6D 05                      asld                            ;                               
3935   DA6E 05                      asld                            ; d =  d * 4                              
3936   DA6F 02 E7 7F    L1191       andm    injFlags0, #$7f         ; Reset startingToCrankColdEngine flag                                 
3937   DA72 1A          L1192       xgdx                            ; x = pulseWidth
3938   DA73                                                                      
3939   DA73                         ;-----------------------------------------------------
3940   DA73                         ; Store injPwStart and update state3.7 from injFlags0.7
3941   DA73                         ; (done this way since used in interrupts)
3942   DA73                         ;-----------------------------------------------------
3943   DA73 96 E7                   ldaa    injFlags0               ;                               
3944   DA75 84 80                   anda    #$80                    ; a = injFlags0 & $80, keep only that bit                             
3945   DA77 0F                      sei                             ;                              
3946   DA78 FF 01 00                stx     injPwStart              ; injPwStart = pulseWidth
3947   DA7B D6 A2                   ldab    state3                                                 
3948   DA7D C4 7F                   andb    #$7f                    ;                             
3949   DA7F 1B                      aba                             ; b = b&$7f + injFlags0&$80                             
3950   DA80 97 A2                   staa    state3                  ; Update state3
3951   DA82                              
3952   DA82                         ;----------------------------------------                         
3953   DA82                         ; Update state3 from state1
3954   DA82                         ;----------------------------------------                         
3955   DA82 96 E6                   ldaa    state1                  ;                               
3956   DA84 84 1B                   anda    #$1b                    ; Keep 00011011
3957   DA86 8F E6 08 06             brclr   state1, #$08, L1193     ; Branch if rotatingStopInj clear                                 
3958   DA8A 87 E6 04 02             brset   state1, #$04, L1193     ; Engine rotatingStopInj, branch if runningFast                                 
3959   DA8E 8A 20                   oraa    #$20                    ; Engine rotatingStopInj but not runningFast, set bit                              
3960   DA90 D6 A2       L1193       ldab    state3                  ;                              
3961   DA92 C4 C4                   andb    #$c4                    ; Keep 11000100                             
3962   DA94 1B                      aba                             ;                             
3963   DA95 97 A2                   staa    state3                  ;                               
3964   DA97             
3965   DA97                         ;--------------------------------------------------------------------------
3966   DA97                         ; If engine is just startingToCrank and this is the first time we are here
3967   DA97                         ; then compute sInjPw and schedule an interrupt to activate simultaneous 
3968   DA97                         ; injection (if no injector is currently active)
3969   DA97                         ;--------------------------------------------------------------------------
3970   DA97 0E                      cli                             ;                             
3971   DA98 8F E6 01 1A             brclr   state1, #$01, L1195     ; Bail if startingToCrank clear 
3972   DA9C 87 E7 01 16             brset   injFlags0, #$01, L1195  ; Engine startingToCrank, bail if injFlags0.0 already set, meaning we were already here before and                               
3973   DAA0 03 E7 01                orm     injFlags0, #$01         ; Set flag                                
3974   DAA3 86 0C                   ldaa    #$0c                    ; a = $0c                            
3975   DAA5 5F                      clrb                            ; d = $0c00                            
3976   DAA6 0F                      sei                             ;                             
3977   DAA7 FD 01 14                std     sInjPw                  ; sInjPw = $0c00 = 3.072ms                              
3978   DAAA 87 B2 0F 07             brset   injToAct, #$0f, L1194   ; Bail if any injector is active                                 
3979   DAAE DC 09                   ldd     t1t2_clk                ; No injector flag set, schedule interrupt
3980   DAB0 C3 00 14                addd    #$0014                  ; 20us                              
3981   DAB3 DD 0B                   std     t1_outCmpWr             ; schedule interrupt in 20us
3982   DAB5             
3983   DAB5                         ;----------------------
3984   DAB5                         ; Compute accEnrFact
3985   DAB5                         ;----------------------
3986   DAB5 0E          L1194       cli                             ;                             
3987   DAB6 CE FF BB    L1195       ldx     #L2051                  ; x point to L2051                              
3988   DAB9 BD EB 3A                jsr     interpEct               ; b = L2051(ect)                                 
3989   DABC CE FC FF                ldx     #t_accEnr1              ; x point to t_accEnr1                               
3990   DABF CD CE FC F7             ldy     #t_accEnr2a             ;                               
3991   DAC3 FB 01 34                addb    T2_crank                ;                             
3992   DAC6 24 04                   bcc     L1196                   ; branch if engine stopped "startingToCrank" more than L2051(ect)/2 sec ago.
3993   DAC8 CD CE FF AB             ldy     #t_accEnr2b             ;                               
3994   DACC BD EA 65    L1196       jsr     L1577                   ;                              
3995   DACF FD 01 08                std     accEnrFact              ; [accEnrFact:accEnrFact+1] = 8 * injMasComp * t_accEnr1(rpm)/128 * [t_accEnr2a(ect) or t_accEnr2b(ect)]/128 * baroFact/128
3996   DAD2             
3997   DAD2                         ;-----------------------
3998   DAD2                         ; Compute accEnrDecay 
3999   DAD2                         ;-----------------------
4000   DAD2 CE FD 09                ldx     #t_accEnrDecay          ;                               
4001   DAD5 BD EB 3A                jsr     interpEct               ;                                  
4002   DAD8 F7 01 03                stab    accEnrDecay             ; accEnrDecay = t_accEnrDecay(ect)
4003   DADB                                                                        
4004   DADB                         ;---------------------
4005   DADB                         ; Compute accEnrMinAf 
4006   DADB                         ;---------------------
4007   DADB CE FF 12                ldx     #L2039                                                 
4008   DADE BD EB 3F                jsr     interp16rpm             ; a = L2039(rpm)                                    
4009   DAE1 C6 57                   ldab    #$57                    ;                              
4010   DAE3 3D                      mul                             ; d = $57*L2039(rpm)                             
4011   DAE4 BD EB A3                jsr     scale16                 ; d = $57*L2039(rpm)/16                               
4012   DAE7 FD 01 05                std     accEnrMinAf             ; accEnrMinAf:L0106 = $57*L2039(rpm)/16                            
4013   DAEA             
4014   DAEA                         ;---------------------
4015   DAEA                         ; Compute decEnrFact 
4016   DAEA                         ;---------------------          ;
4017   DAEA B6 01 1A                ldaa    T40_crank               ;                              
4018   DAED 8B 78                   adda    #$78                    ; 3s                            
4019   DAEF 24 04                   bcc     L1197                   ; branch if engine stopped "startingToCrank" more than 3s ago 
4020   DAF1 4F                      clra                            ;                             
4021   DAF2 5F                      clrb                            ;                             
4022   DAF3 20 0A                   bra     L1199                   ;                              
4023   DAF5 CE FD 3E    L1197       ldx     #t_decEnr1              ;                                   
4024   DAF8 CD CE FD 36             ldy     #t_decEnr2              ;                                   
4025   DAFC BD EA 65                jsr     L1577                   ;                              
4026   DAFF FD 01 0A    L1199       std     decEnrFact              ; [decEnrFact:decEnrFact+1] = 8 * injMasComp * t_decEnr1(rpm)/128 * t_decEnr2/128 * baroFact/128
4027   DB02             
4028   DB02                                                            
4029   DB02                         ;-------------------------------------------------------------------------
4030   DB02                         ; Compute sInjEnrInc   
4031   DB02                         ; Parameters related to adding fuel during simultaneous injection mode
4032   DB02                         ;-------------------------------------------------------------------------
4033   DB02 CE FF BB                ldx     #L2051                  ; 
4034   DB05 BD EB 3A                jsr     interpEct               ; b = L2051(ect)                                
4035   DB08 CE FD 1A                ldx     #L2013                  ;                              
4036   DB0B FB 01 34                addb    T2_crank                ; b = L2051(ect) + T2_crank                            
4037   DB0E 24 03                   bcc     L1202                   ; branch if engine stopped "startingToCrank" more than L2051(ect)/2 sec ago
4038   DB10 CE FF B3                ldx     #L2050                  ; Overflow, change table                             
4039   DB13 BD EB 3A    L1202       jsr     interpEct               ; b = L2050(ect) or L2013(ect)                                
4040   DB16 37                      pshb                            ; st0 = L2050(ect) or L2013(ect)                            
4041   DB17 CE FD 2C                ldx     #L2015                  ;                              
4042   DB1A BD EB 3F                jsr     interp16rpm             ; b = L2015(rpm)                                   
4043   DB1D 32                      pula                            ; a = L2050(ect) or L2013(ect)                           
4044   DB1E 1B                      aba                             ; a = L2050(ect) or L2013(ect) +  L2015(rpm)                           
4045   DB1F 24 02                   bcc     L1205                   ; Branch if no overflow                            
4046   DB21 86 FF                   ldaa    #$ff                    ; Overflow, use max                      
4047   DB23 B7 01 16    L1205       staa    sInjEnrInc              ; sInjEnrInc = L2050(ect) or L2013(ect) +  L2015(rpm)
4048   DB26             
4049   DB26                         ;-------------------------------------------------------------------------
4050   DB26                         ; Compute sInjEnrMax = sInjEnrInc/4   
4051   DB26                         ; Parameters related to adding fuel during simultaneous injection mode
4052   DB26                         ;-------------------------------------------------------------------------
4053   DB26 C6 20                   ldab    #$20                    ; b = $20                           
4054   DB28 3D                      mul                             ; d = $20 * sInjEnrInc
4055   DB29 BD EB B3                jsr     scale128m               ; d = $20/128 * sInjEnrInc = 1/4 * sInjEnrInc, also check for max of 255...
4056   DB2C F7 01 12                stab    sInjEnrMax              ; sInjEnrMax = 1/4 * sInjEnrInc = 1/4 * (L2051(ect) + T2_crank or L2050(ect) +  L2015(rpm))
4057   DB2F             
4058   DB2F                         ;---------------------------------------------------------------------------------
4059   DB2F                         ; Compute sInjTpsMax, threshold used to increase fuel in simulateneous injection
4060   DB2F                         ;---------------------------------------------------------------------------------
4061   DB2F CE FD 22                ldx     #t_sInjTpsMax           ;                              
4062   DB32 BD EB 3F                jsr     interp16rpm             ;                                   
4063   DB35 F7 01 13                stab    sInjTpsMax              ; sInjTpsMax = t_sInjTpsMax(rpm)
4064   DB38                                                                          
4065   DB38                         ;---------------------------------
4066   DB38                         ; Decrement T40s_casInt at 40Hz
4067   DB38                         ;---------------------------------
4068   DB38 CE 00 84                ldx     #T40s_casInt                                                 
4069   DB3B BD EB FC                jsr     decX40Hz                ; Decrement T40s_casInt at 40Hz
4070   DB3E             
4071   DB3E                         ;-------------------------------------------------------------------------
4072   DB3E                         ; Set the timing adjustment flag (timAdjFlags.7) if the timing 
4073   DB3E                         ; adjustment terminal is grounded but the ECU test mode terminal is not
4074   DB3E                         ;-------------------------------------------------------------------------
4075   DB3E 8F D8 10 0D             brclr   port4Snap, #$10, L1209    ; Branch if stored timing terminal not grounded?                                   
4076   DB42 8F 07 10 09             brclr   port4, #$10, L1209        ; Branch if timing terminal not grounded?                               
4077   DB46 87 D8 08 05             brset   port4Snap, #$08, L1209    ; Branch if ECU test mode terminal grounded?                                   
4078   DB4A 03 87 80                orm     timAdjFlags, #$80         ; Set flag, timing terminal grounded but ECU test mode terminal NOT grounded
4079   DB4D 20 03                   bra     L1210                     ; Bail                             
4080   DB4F 02 87 7F    L1209       andm    timAdjFlags, #$7f         ; Reset flag       
4081   DB52                                     
4082   DB52                         ;-----------------------------------------------------
4083   DB52                         ; Re-init knockTimer to $ff if engine notRotating  
4084   DB52                         ;-----------------------------------------------------
4085   DB52 8F E6 10 05 L1210       brclr   state1, #$10, L1212       ; Branch if notRotating clear
4086   DB56 86 FF                   ldaa    #$ff                      ; Engine notRotating                             
4087   DB58 B7 01 77                staa    knockTimer                                                 
4088   DB5B             
4089   DB5B                         ;-----------------------------------------------------
4090   DB5B                         ; Update the "knock sensor bad" flag if 
4091   DB5B                         ; engine was started more than 1 sec ago
4092   DB5B                         ;-----------------------------------------------------
4093   DB5B 87 E6 11 13 L1212       brset   state1, #$11, L1214       ; Branch if notRotating or startingToCrank
4094   DB5F B6 01 1A                ldaa    T40_crank                 ; Engine is running                              
4095   DB62 8B 28                   adda    #$28                      ; 
4096   DB64 25 0C                   bcs     L1214                     ; branch if engine stopped "startingToCrank" less than 1s ago (don't check knock sensor yet)
4097   DB66 03 53 40                orm     knockFlags, #$40          ; Set flag indicating "engine running for more than 1 sec"???                               
4098   DB69 87 D8 20 08             brset   port4Snap, #$20, L1215    ; Branch if knock sensor is OK???                                   
4099   DB6D 03 D6 20                orm     state2, #$20              ; Set flag indicating knock sensor is bad                                
4100   DB70 20 06                   bra     L1217                     ; Bail                             
4101   DB72 02 53 BF    L1214       andm    knockFlags, #$bf          ; Reset flag indicating "engine running for more than 1 sec"???                                
4102   DB75 02 D6 DF    L1215       andm    state2, #$df              ; Reset bad knock sensor flag                                
4103   DB78             
4104   DB78                         ;---------------------------------------------------------------------------------
4105   DB78                         ; Update  knockFlags.7 (airVol threshold flag) and T200s_knock if below threshold  
4106   DB78                         ;---------------------------------------------------------------------------------
4107   DB78 D6 E0       L1217       ldab    airVol                    ; b=airVol
4108   DB7A C1 49                   cmpb    #$49                      ; 
4109   DB7C 24 08                   bcc     L1218                     ; branch if airVol>$49
4110   DB7E 02 8C 03                andm    T200s_knock, #$03         ; airVol<$49, reset T200s_knock to a more reasonable value
4111   DB81 02 53 7F                andm    knockFlags, #$7f          ; clear knockFlags.7                                                                 
4112   DB84 20 03                   bra     L1219                     ; branch LDB89                                                             
4113   DB86 03 53 80    L1218       orm     knockFlags, #$80          ; set knockFlags.7                                                                   
4114   DB89             
4115   DB89                         ;-----------------------------------------------------
4116   DB89                         ; Something activated at 4595rpm with hysteresis??????
4117   DB89                         ; Could be related to knock since we are in the area...
4118   DB89                         ; Maybe knock sensor filter parameter being changed???
4119   DB89                         ;-----------------------------------------------------
4120   DB89 86 96       L1219       ldaa    #$96                      ; 4688rpm                                                                          
4121   DB8B 8F 2F 02 02             brclr   port6, #$02, L1220        ; branch if ??? not yet activated???                                 
4122   DB8F 86 90                   ldaa    #$90                      ; 4500rpm                                                                          
4123   DB91 91 DD       L1220       cmpa    rpm31                     ;                                                                           
4124   DB93 22 05                   bhi     L1221                     ;  Branch if rpm lower than threshold                                                                           
4125   DB95 03 2F 02                orm     port6, #$02               ; rpm higher than threshold, Activate ???
4126   DB98 20 03                   bra     L1222                     ;                                                                           
4127   DB9A 02 2F FD    L1221       andm    port6, #$fd               ; De-activate ???
4128   DB9D             
4129   DB9D                         ;----------------------------
4130   DB9D                         ; Section to update octane
4131   DB9D                         ;----------------------------
4132   DB9D                         ;--------------------------------------------------
4133   DB9D                         ; Skip octane update if temp(ectFiltered) < 80degC
4134   DB9D                         ;--------------------------------------------------
4135   DB9D 96 D3       L1222       ldaa    ectFiltered                                                 
4136   DB9F 81 20                   cmpa    #$20                    ; 80degC                            
4137   DBA1 22 50                   bhi     L1227                   ; Bail if temp(ectFiltered) < 80degC                               
4138   DBA3             
4139   DBA3                         ;-----------------------------------------
4140   DBA3                         ; temp(ectFiltered) >= 80degC
4141   DBA3                         ; Skip octane update under more cases... 
4142   DBA3                         ;-----------------------------------------
4143   DBA3 87 D6 28 4C             brset   state2, #$28, L1227     ; Bail if no pulse accumulator interrupts or if knock sensor not working?
4144   DBA7 8F 53 40 48             brclr   knockFlags, #$40, L1227 ; Bail if engine has not been running for more than 1 sec                               
4145   DBAB CD CE FF C3             ldy     #L2052                  ; Engine has been running for more than 1 sec                               
4146   DBAF BD EB F4                jsr     rpmPwise                ; b = piecewise(rpm4) for table interpolation                                  
4147   DBB2 86 B0                   ldaa    #$b0                    ; a = $b0                             
4148   DBB4 BD EC 2C                jsr     abmin                   ; Apply max to b, b = min($b0,piecewise(rpm4))                             
4149   DBB7 17                      tba                             ; a = min($b0,piecewise(rpm4))                            
4150   DBB8 CE FF 22                ldx     #L2041                  ; x points to L2041                               
4151   DBBB BD EB 49                jsr     interp16b               ; a = L2041(rpm4)                                  
4152   DBBE 91 E0                   cmpa    airVol                  ;                                
4153   DBC0 24 31                   bcc     L1227                   ; Bail if airVol <= L2041(rpm4)                              
4154   DBC2             
4155   DBC2                         ;---------------------------------------------
4156   DBC2                         ; airVol > L2041(rpm4), skip octane update 
4157   DBC2                         ; if 3<=knockSum<=5 (hysteresis zone...)
4158   DBC2                         ;---------------------------------------------
4159   DBC2 96 8B                   ldaa    knockSum                ;                                 
4160   DBC4 81 03                   cmpa    #$03                    ;                             
4161   DBC6 25 04                   bcs     L1223                   ; Branch if knockSum <3                             
4162   DBC8 81 05                   cmpa    #$05                    ;                             
4163   DBCA 23 27                   bls     L1227                   ; Bail if knockSum <=5                             
4164   DBCC             
4165   DBCC                         ;-------------------------------------------------------------
4166   DBCC                         ; knockSum<3 or knockSum>5, we can update octane at 2.5Hz
4167   DBCC                         ;-------------------------------------------------------------
4168   DBCC 46          L1223       rora                            ; shift in carry bit, rest of a = knockSum/2                            
4169   DBCD             
4170   DBCD                         ;-----------------------------------------------------------
4171   DBCD                         ; Decrement T40s_octane at 40Hz (loops at $10)
4172   DBCD                         ; and update octane if timer is expired (at 2.5Hz)
4173   DBCD                         ;-----------------------------------------------------------
4174   DBCD 8F D9 01 22             brclr   Tclocks, #$01, L1227    ; Bail if 40Hz signal no set                                   
4175   DBD1 F6 01 76                ldab    T40s_octane             ; b = T40s_octane                             
4176   DBD4 27 05                   beq     L1224                   ; Branch if timer expired                             
4177   DBD6 7A 01 76                dec     T40s_octane             ; Update timer                             
4178   DBD9 26 18                   bne     L1227                   ; Bail if timer not yet expired
4179   DBDB             
4180   DBDB                         ;-------------------------------------
4181   DBDB                         ; T40s_octane expired, update octane
4182   DBDB                         ;-------------------------------------
4183   DBDB D6 52       L1224       ldab    octane                  ; b = octane                               
4184   DBDD 4D                      tsta                            ;                             
4185   DBDE 2A 08                   bpl     L1225                   ; Branch if knockSum >=3 (see carry bit shited-in above)
4186   DBE0             
4187   DBE0                         ;--------------------------------------------------
4188   DBE0                         ; knockSum <3, increment octane by 1 (max 255)
4189   DBE0                         ;--------------------------------------------------
4190   DBE0 86 10                   ldaa    #$10                    ; pre-load timer value                             
4191   DBE2 5C                      incb                            ; b = octane+1                             
4192   DBE3 26 09                   bne     L1226                   ; Branf if no rollover                             
4193   DBE5 5A                      decb                            ; Rollover, use max of 255                             
4194   DBE6 20 06                   bra     L1226                   ; Bail to store                             
4195   DBE8             
4196   DBE8                         ;--------------------------------------------------
4197   DBE8                         ; knockSum >=3, decrement octane by 1 (min 0)
4198   DBE8                         ;--------------------------------------------------
4199   DBE8 86 10       L1225       ldaa    #$10                    ; pre-load timer value                             
4200   DBEA 5D                      tstb                            ;                             
4201   DBEB 27 01                   beq     L1226                   ; Branch if octane already 0                             
4202   DBED 5A                      decb                            ; b = octane - 1                            
4203   DBEE D7 52       L1226       stab    octane                  ; update octane
4204   DBF0 B7 01 76                staa    T40s_octane             ; Re-init T40s_octane with $10                              
4205   DBF3             
4206   DBF3                         ;-------------------------------------------------------------------------------------------------
4207   DBF3                         ; Section to compute timingOct, the timing interpolated from the 
4208   DBF3                         ; two timing maps (timing under high octane and low octane) according 
4209   DBF3                         ; to the current octane value
4210   DBF3                         ;
4211   DBF3                         ;       timingOct = alpha * t_timingHiOct(rpm, load) + (1-alpha) * t_timingLoOct(rpm, load)
4212   DBF3                         ;
4213   DBF3                         ; where alpha = octane/255, 0<= alpha <=1
4214   DBF3                         ;-------------------------------------------------------------------------------------------------
4215   DBF3                         ;-------------------------------------------------
4216   DBF3                         ; Compute rpm and load for 2D map interpolation                           
4217   DBF3                         ;-------------------------------------------------
4218   DBF3 CD CE FF C3 L1227       ldy     #L2052                  ;
4219   DBF7 BD EB F4                jsr     rpmPwise                ; b = rpm                                
4220   DBFA D7 5C                   stab    temp6                   ; temp6 = rpm                              
4221   DBFC BD EC 31                jsr     getLoadForMaps          ; b = load                                      
4222   DBFF D7 5D                   stab    temp7                   ; temp7 = load                             
4223   DC01             
4224   DC01                         ;--------------------------------------
4225   DC01                         ; Get timing value from t_timingHiOct
4226   DC01                         ;--------------------------------------
4227   DC01 CE FD 48                ldx     #t_timingHiOct          ; x points to t_timingHiOct                                  
4228   DC04 CD CE 10 00             ldy     #$1000                  ;                               
4229   DC08 BD EA E1                jsr     lookup2D                ; b = t_timingHiOct(rpm,load)
4230   DC0B F7 01 61                stab    timFuelEnr              ; timFuelEnr = t_timingHiOct(rpm,load)
4231   DC0E             
4232   DC0E                         ;------------------------------------------------------------------------------------
4233   DC0E                         ; Change load value for t_timingLoOct map interpolation (first three row missing)
4234   DC0E                         ;------------------------------------------------------------------------------------
4235   DC0E 96 5D                   ldaa    temp7                   ; a = load                             
4236   DC10 80 30                   suba    #$30                    ; a = load - $30                            
4237   DC12 25 22                   bcs     L1229                   ; branch if load <$30 (no interpolation,  use t_timingHiOct(rpm,load)
4238   DC14 97 5D                   staa    temp7                   ; temp7 = load-$30                             
4239   DC16             
4240   DC16                         ;------------------------------------------------------
4241   DC16                         ; Compute t_timingHiOct(rpm,load) * octane and put it on stack
4242   DC16                         ;------------------------------------------------------
4243   DC16 BD DD 94                jsr     getOctane               ; a = validated octane                                   
4244   DC19 3D                      mul                             ; d = t_timingHiOct(rpm,load) * octane                             
4245   DC1A 36                      psha                            ; put on stack                             
4246   DC1B 37                      pshb                            ; put on stack
4247   DC1C                                                     
4248   DC1C                         ;-------------------------------------
4249   DC1C                         ; Get timing value from t_timingLoOct
4250   DC1C                         ;-------------------------------------
4251   DC1C CE FE 08                ldx     #t_timingLoOct          ; x points to t_timingLoOct                                 
4252   DC1F CD CE 10 00             ldy     #$1000                  ;                               
4253   DC23 BD EA E1                jsr     lookup2D                ; b = t_timingLoOct(rpm, load)
4254   DC26             
4255   DC26                         ;-----------------------------------------------------------------------------------------------------------
4256   DC26                         ; Compute 
4257   DC26                         ;       timingOct = octane/255 * t_timingHiOct(rpm,load) + (255 - octane)/255 * t_timingLoOct(rpm, load)
4258   DC26                         ;                 = alpha * t_timingHiOct(rpm,load) + (1-alpha) * t_timingLoOct(rpm, load)
4259   DC26                         ;-----------------------------------------------------------------------------------------------------------
4260   DC26 BD DD 94                jsr     getOctane               ; a = octane                                   
4261   DC29 43                      coma                            ; a = not(octane) = 255 - octane                             
4262   DC2A 3D                      mul                             ; d = (255 - octane) * t_timingLoOct(rpm, load)
4263   DC2B DD 5C                   std     temp6                   ; temp6:temp7 = (255 - octane) * t_timingLoOct(rpm, load)
4264   DC2D 33                      pulb                            ;                             
4265   DC2E 32                      pula                            ; d = octane * t_timingHiOct(rpm,load) 
4266   DC2F D3 5C                   addd    temp6                   ; d = octane * t_timingHiOct(rpm,load) + (255 - octane) *  t_timingLoOct(rpm, load)
4267   DC31 14 FF                   div     #$ff                    ; a = remainder, b = octane/255 * t_timingHiOct(rpm,load) + (255 - octane)/255 *  t_timingLoOct(rpm, load)
4268   DC33 49                      rola                            ; Put remainder high bit in carry
4269   DC34 C9 00                   adcb    #$00                    ; roundup b with remainder
4270   DC36 F7 01 70    L1229       stab    timingOct               ; timingOct = octane/255 * t_timingHiOct(rpm,load) + (255 - octane)/255 *  t_timingLoOct(rpm, load)
4271   DC39                                       
4272   DC39                         ;--------------------------------------------------------------------------------------------------
4273   DC39                         ; Compute timFuelEnr = $4b/256 * ($b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum - 5)
4274   DC39                         ; timFuelEnr is a fuel enrichment based on timing, octane and knockSum
4275   DC39                         ;--------------------------------------------------------------------------------------------------
4276   DC39 B6 01 61                ldaa    timFuelEnr              ; a = t_timingHiOct(rpm,load)
4277   DC3C B0 01 70                suba    timingOct               ; a = t_timingHiOct(rpm,load) - timingOct
4278   DC3F 24 01                   bcc     L1230                   ; Branch if result positive                              
4279   DC41 4F                      clra                            ; Use min of 0                            
4280   DC42 C6 B6       L1230       ldab    #$b6                    ; b = $b6                            
4281   DC44 3D                      mul                             ; d = $b6 * (t_timingHiOct(rpm,load) - timingOct)
4282   DC45 BD EB A1                jsr     scale64                 ; b = $b6/64 * (t_timingHiOct(rpm,load) - timingOct)
4283   DC48 DB 8B                   addb    knockSum                ; b = $b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum 
4284   DC4A 24 02                   bcc     L1232                   ; Branch if no overflow                             
4285   DC4C C6 FF                   ldab    #$ff                    ; Overflow, use max of 255                            
4286   DC4E C0 05       L1232       subb    #$05                    ; b = $b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum - 5                            
4287   DC50 24 01                   bcc     L1233                   ; Branch if result positive                             
4288   DC52 5F                      clrb                            ; Use min of 0                            
4289   DC53             #ifdef E931                                 
4290   DC53 86 4B       L1233       ldaa    #$4b                    ; a = $4b                            
4291   DC55~            #else                                       
4292   DC55~            L1233       ldaa    #$86                    ; a = $86                            
4293   DC55             #endif                                      
4294   DC55 3D                      mul                             ; d =  $4b*($b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum - 5)                            
4295   DC56 B7 01 61                staa    timFuelEnr              ; timFuelEnr = $4b/256 * ($b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum - 5)                                 
4296   DC59             
4297   DC59                         ;---------------------------------------
4298   DC59                         ; Section to update maxAdv for E931
4299   DC59                         ;---------------------------------------
4300   DC59             #ifdef E931
4301   DC59 87 E6 04 1D             brset   state1, #$04, Mdc7a     ; Branch if engine runningFast                                 
4302   DC5D 87 E6 10 15             brset   state1, #$10, Mdc76     ; Branch if notRotating
4303   DC61 96 DC                   ldaa    rpm8                    ; 
4304   DC63 B1 FE C0                cmpa    t_idleSpd               ;                                   
4305   DC66 25 0E                   bcs     Mdc76                   ; Branch if rpm8 < t_idleSpd (normal idle speed)                             
4306   DC68 B6 01 4D                ldaa    tpsDiffMax2             ; 
4307   DC6B 81 03                   cmpa    #$03                    ;                              
4308   DC6D 24 07                   bcc     Mdc76                   ; Branch if tpsDiffMax2 >= 3 (pedal is moving forward...)
4309   DC6F B6 01 49                ldaa    airDiffPos1             ;                                     
4310   DC72 81 0A                   cmpa    #$0a                    ;                              
4311   DC74 25 1C                   bcs     L1234                   ; Bail (dont even update maxAdv) if airDiffPos1 < $0a (airflow decrease or small airflow increase)
4312   DC76                                                                      
4313   DC76                         ;----------------------------------------
4314   DC76                         ; Use max of $80 (maxAdv=$80, no limit?)  
4315   DC76                         ; if notRotating
4316   DC76                         ;    or rpm8 < t_idleSpd
4317   DC76                         ;    or tpsDiffMax2 >= 3
4318   DC76                         ;    or airDiffPos1 >= $0a
4319   DC76                         ;----------------------------------------
4320   DC76 86 80       Mdc76       ldaa    #$80                    ; Use default of $80 (no limit)                              
4321   DC78 20 16                   bra     Mdc90                   ; Branch to store
4322   DC7A                                                        
4323   DC7A                         ;--------------------------------------------------------------------
4324   DC7A                         ; Engine runningFast, compute maxAdv which will reduce the 
4325   DC7A                         ; timing advance by 13deg or limit it to 12deg
4326   DC7A                         ;---------------------------------------------------------------------
4327   DC7A 96 C4       Mdc7a       ldaa    vssCnt1                 ;                                 
4328   DC7C 27 14                   beq     L1234                   ; Bail if car not moving                               
4329   DC7E 86 05                   ldaa    #$05                    ;                              
4330   DC80 97 F5                   staa    T_maxAdv                ; Init timer T_maxAdv = 5 ?
4331   DC82 B6 01 70                ldaa    timingOct               ;                                   
4332   DC85 80 0D                   suba    #$0d                    ;                             
4333   DC87 24 01                   bcc     Mdc8a                   ; Branch if timingOct - $0d positive                              
4334   DC89 4F                      clra                            ; Use min of 0                             
4335   DC8A C6 12       Mdc8a       ldab    #$12                    ; b = $12                             
4336   DC8C 11                      cba                             ;                              
4337   DC8D 24 01                   bcc     Mdc90                   ; Branch if timingOct-$0d >= $12                              
4338   DC8F 17                      tba                             ; Use max of $12 degrees                             
4339   DC90 97 F6       Mdc90       staa    maxAdv                  ; maxAdv = max(timingOct - $0d, 12)                                
4340   DC92             #endif
4341   DC92             
4342   DC92                         ;-------------------------------------------------
4343   DC92                         ; Set timAdjFlags.1 flag if rpm>2000rpm or reset it
4344   DC92                         ;-------------------------------------------------
4345   DC92 C6 40       L1234       ldab    #$40                     ; assume b = threshold = 2000rpm                           
4346   DC94 8F 87 01 02             brclr   timAdjFlags, #$01, L1235 ; Branch if flag clear                              
4347   DC98 C6 3A                   ldab    #$3a                     ; Flag was previously set, use a lower threshold of 1813rpm (hysteresis)                             
4348   DC9A 02 87 FE    L1235       andm    timAdjFlags, #$fe        ; Reset flag                               
4349   DC9D D1 DD                   cmpb    rpm31                    ;                              
4350   DC9F 24 03                   bcc     L1237                    ; Branch if rpm31 <= threshold (2000rpm or 1813rpm)
4351   DCA1 03 87 01                orm     timAdjFlags, #$01        ; rpm31 > threshold, set flag                              
4352   DCA4             
4353   DCA4                         ;------------------------------------------------------------------------
4354   DCA4                         ; Compute advRpm under some conditions (low rpm, idle switch off, etc.)
4355   DCA4                         ; advRpm is an rpm based timing advance/retard with +/-8deg max
4356   DCA4                         ;------------------------------------------------------------------------
4357   DCA4 86 80       L1237       ldaa    #$80                     ; preload a = $80 = default value (no timing change)                             
4358   DCA6 87 87 01 48             brset   timAdjFlags, #$01, L1243 ; Bail if rpm31 > 2000rpm (with hysteresis)                              
4359   DCAA 87 4B 04 44             brset   iscFlags0, #$04, L1243   ; Bail if basic idle speed adjustment mode is active (no timing change)                              
4360   DCAE 87 E6 19 40             brset   state1, #$19, L1243      ; Bail if notRotating or startingToCrank or rotatingStopInj
4361   DCB2 8F D7 80 3C             brclr   port3Snap0, #$80, L1243  ; Bail if idle switch on                                   
4362   DCB6 D6 C4                   ldab    vssCnt1                 ;                                
4363   DCB8 21 38                   brn     L1243                   ; Branch never (?)                              
4364   DCBA CE 00 00                ldx     #$0000                  ; x = 0                              
4365   DCBD 5F                      clrb                            ; b = 0                            
4366   DCBE 96 FE                   ldaa    idleSpdTarg             ; d = 256*idleSpdTarg                             
4367   DCC0             #ifdef E931                                 ;
4368   DCC0 80 06                   suba    #$06                    ; d = 256*(idleSpdTarg - 6)      (-47rpm)                   
4369   DCC2~            #else                                       ;
4370   DCC2~                        suba    #$04                    ;                             
4371   DCC2             #endif                                      ;
4372   DCC2 24 01                   bcc     L1238                   ; Branch if no underflow                              
4373   DCC4 4F                      clra                            ; Underflow, use min of 0                            
4374   DCC5 BD EB A4    L1238       jsr     scale8                  ; a = 256/8 * (idleSpdTarg - 6) = 32*(idleSpdTarg - 6)                              
4375   DCC8 1F 01 84                cmpd    rpmX4Filt               ;                                 
4376   DCCB 24 03                   bcc     L1239                   ; Branch if 32*(idleSpdTarg - 6) >= rpmX4Filt                             
4377   DCCD FC 01 84                ldd     rpmX4Filt               ; use min of rpmX4Filt                                 
4378   DCD0 BD EB A3    L1239       jsr     scale16                 ; d = 2*(idleSpdTarg - 6)
4379   DCD3 93 DA                   subd    rpm4                    ; d = 2*(idleSpdTarg - 6) - rpm4 
4380   DCD5 24 06                   bcc     L1240                   ; Branch if positive                             
4381   DCD7 08                      inx                             ; result negative, x = 1                            
4382   DCD8 43                      coma                            ;                             
4383   DCD9 53                      comb                            ;                             
4384   DCDA C3 00 01                addd    #$0001                  ; d =  rpm4 - 2*(idleSpdTarg - 6)
4385   DCDD BD EB BE    L1240       jsr     ovfCheck                ; b = result = abs(rpm4 - 2*(idleSpdTarg - 6))
4386   DCE0 86 68                   ldaa    #$68                    ; a = $68                            
4387   DCE2 3D                      mul                             ; d = $68 * abs(rpm4 - 2*(idleSpdTarg - 6))
4388   DCE3 BD EB AC                jsr     round256                ; a = $68/256 * abs(rpm4 - 2*(idleSpdTarg - 6))
4389   DCE6 81 08                   cmpa    #$08                    ;                             
4390   DCE8 23 02                   bls     L1241                   ; Branch if a <= 8 (+/-8 degrees advance or retard)
4391   DCEA 86 08                   ldaa    #$08                    ; Use max of 8                            
4392   DCEC 09          L1241       dex                             ; x = x-1                            
4393   DCED 26 01                   bne     L1242                   ; Branch if we did not have a negative result earlier                            
4394   DCEF 40                      nega                            ; Result was negative, negate again to restore it...                             
4395   DCF0 8B 80       L1242       adda    #$80                    ; a =  $80 + $68/256 * (rpm4 - 2*(idleSpdTarg - 6))
4396   DCF2 B7 01 73    L1243       staa    advRpm                  ; advRpm = $80 + $68/256 * (rpm4 - 2*(idleSpdTarg - 6))
4397   DCF5             
4398   DCF5                         ;--------------------------------------------------
4399   DCF5                         ; Compute advEct, ect based timing advance/retard
4400   DCF5                         ;--------------------------------------------------
4401   DCF5 CE FE 98                ldx     #L2020                                                 
4402   DCF8 BD EB 3A                jsr     interpEct                                                 
4403   DCFB F7 01 71                stab    advEct                  ; advEct = L2020(ect)                              
4404   DCFE             
4405   DCFE                         ;---------------------------------------------------------------
4406   DCFE                         ; Compute advIat iat based advance/retard under low load
4407   DCFE                         ;---------------------------------------------------------------
4408   DCFE CE FF 08                ldx     #L2038                  ;                               
4409   DD01 BD EB 3F                jsr     interp16rpm             ; b = L2038(rpm)                                    
4410   DD04 91 E3                   cmpa    airVolB                 ;                                
4411   DD06 23 04                   bls     L1244                   ; Branch if L2038(rpm) <= airVolB                             
4412   DD08 86 80                   ldaa    #$80                    ; Use default value of $80 under high load                            
4413   DD0A 20 06                   bra     L1245                   ;                              
4414   DD0C CE FE A0    L1244       ldx     #L2021                  ; L2038(rpm) <= airVolB                              
4415   DD0F BD EB 44                jsr     iatCInterp              ;                                   
4416   DD12 B7 01 72    L1245       staa    advIat                  ; advIat = L2021(iat)
4417   DD15             
4418   DD15                         ;----------------------------------------------------------------------------------
4419   DD15                         ; Compute advTotal = min(timingOct, maxAdv) + advEct  + advIat + advRpm - $0180
4420   DD15                         ;                  = min(timingOct, maxAdv) + (advEct-$80)  + (advIat-$80) + (advRpm-$80)
4421   DD15                         ;----------------------------------------------------------------------------------
4422   DD15 CE 01 6F                ldx     #advTotal               ; x points to advTotal (table of timing related value)                             
4423   DD18 E6 01                   ldab    $01,x                   ; b = timingOct (timing corrected for current octane)                               
4424   DD1A             #ifdef E931
4425   DD1A D1 F6                   cmpb    maxAdv                  ;                               
4426   DD1C 23 02                   bls     L1246                   ; branch if timingOct<=maxAdv                               
4427   DD1E D6 F6                   ldab    maxAdv                  ; Use max of maxAdv                                
4428   DD20             #endif
4429   DD20 4F          L1246       clra                            ; d = min(timingOct, maxAdv) (a = 0...)                            
4430   DD21 CD 1A                   xgdy                            ; y =  min(timingOct, maxAdv)                            
4431   DD23 E6 02                   ldab    $02,x                   ; b = advEct                              
4432   DD25 CD 3A                   aby                             ; y = min(timingOct, maxAdv) + advEct                            
4433   DD27 E6 03                   ldab    $03,x                   ; b = advIat                             
4434   DD29 CD 3A                   aby                             ; y = min(timingOct, maxAdv) + advEct  + advIat                             
4435   DD2B E6 04                   ldab    $04,x                   ; b = advRpm
4436   DD2D CD 3A                   aby                             ; y = min(timingOct, maxAdv) + advEct  + advIat + advRpm
4437   DD2F CD 1A                   xgdy                            ; d = min(timingOct, maxAdv) + advEct  + advIat + advRpm
4438   DD31 1C 01 BC                cmpd    #$01bc                  ;                               
4439   DD34 23 03                   bls     L1247                   ; Branch if min(timingOct, maxAdv) + advEct  + advIat + advRpm <= $01bc
4440   DD36 CC 01 BC                ldd     #$01bc                  ; Use max of $01bc
4441   DD39                                                       
4442   DD39 1C 01 80    L1247       cmpd    #$0180                  ;                               
4443   DD3C 24 03                   bcc     L1248                   ; Branch if min(timingOct, maxAdv) + advEct  + advIat + advRpm >= $0180
4444   DD3E CC 01 80                ldd     #$0180                  ; Use min of $0180
4445   DD41                                                       
4446   DD41 83 01 80    L1248       subd    #$0180                  ; d = min(timingOct, maxAdv) + advEct  + advIat + advRpm - $0180
4447   DD44 E7 00                   stab    $00,x                   ; advTotal = min(timingOct, maxAdv) + advEct  + advIat + advRpm - $0180
4448   DD46             
4449   DD46                         ;----------------------------------------------------------
4450   DD46                         ; Compute tim61Tot0 = $e7 - $b6/64 * (advTotal + $0a) 
4451   DD46                         ;                   = 256 * (61deg - (advTotal-10deg)) / 90
4452   DD46                         ;
4453   DD46                         ; This is timing referenced to -61deg BTDC
4454   DD46                         ; -10deg is because advTotal is shifted by 10deg (timingOct 
4455   DD46                         ; is from the timing maps which are shifted by 10 deg...)
4456   DD46                         ;----------------------------------------------------------
4457   DD46 CB 0A                   addb    #$0a                    ; b = advTotal + $0a
4458   DD48 86 B6                   ldaa    #$b6                    ; a = $b6                             
4459   DD4A 3D                      mul                             ; d = $b6 * (advTotal + $0a)                            
4460   DD4B BD EB A1                jsr     scale64                 ; d = $b6/64 *  (advTotal + $0a)
4461   DD4E 86 E7                   ldaa    #$e7                    ; a = $e7                            
4462   DD50 10                      sba                             ; a = $e7 - $b6/64 *  (advTotal + $0a)
4463   DD51 97 88                   staa    tim61Tot0               ; tim61Tot0 = $e7 - $b6/64 *  (advTotal + $0a)
4464   DD53             
4465   DD53                         ;-------------------------------
4466   DD53                         ; Compute timingAdv from tim61
4467   DD53                         ;-------------------------------
4468   DD53 86 A0                   ldaa    #$a0                    ; a = $a0 (default when engine not running)                           
4469   DD55 87 E6 11 02             brset   state1, #$11, L1249     ; Branch if notRotating or startingToCrank
4470   DD59 96 7D                   ldaa    tim61                   ; a = tim61                             
4471   DD5B C6 5A       L1249       ldab    #$5a                    ; b = $5a                            
4472   DD5D 3D                      mul                             ; d = $5a * tim61
4473   DD5E BD EB AC                jsr     round256                ; a = $5a * tim61/256
4474   DD61 40                      nega                            ; a = -($5a * tim61/256)
4475   DD62 8B 47                   adda    #$47                    ; a = -($5a * tim61/256) + $47 = $47 - $5a * tim61/256 
4476   DD64 97 8A                   staa    timingAdv               ; timingAdv = $147 - $5a * tim61/256
4477   DD66             
4478   DD66                         ;-------------------
4479   DD66                         ; Compute enerLen
4480   DD66                         ;-------------------
4481   DD66 96 D0                   ldaa    battRaw                 ;                                
4482   DD68 80 80                   suba    #$80                    ; a = battRaw - $80  (9.38v)                          
4483   DD6A 24 01                   bcc     L1250                   ; branch if underflow                              
4484   DD6C 4F                      clra                            ; Use min of 0                            
4485   DD6D 97 5B       L1250       staa    temp5                   ; temp5 = max(0,battRaw - $80)                             
4486   DD6F CE FE A7                ldx     #t_enerLen              ; x points to t_enerLen                               
4487   DD72 BD EB 49                jsr     interp16b               ; b = t_enerLen(battRaw)                                 
4488   DD75 D7 89                   stab    enerLen                 ; enerLen = t_enerLen(battRaw)                             
4489   DD77             
4490   DD77                         ;-------------------------------------------------
4491   DD77                         ; Update coilChkFlags.5 flag, Set bit if engine 
4492   DD77                         ; running and rpm<5000 and 8V<=battRaw<=18V
4493   DD77                         ;-------------------------------------------------
4494   DD77 87 E6 11 15             brset   state1, #$11, L1253     ; Branch if notRotating or startingToCrank 
4495   DD7B 96 DD                   ldaa    rpm31                   ; a = rpm31                              
4496   DD7D 81 A0                   cmpa    #$a0                    ;                             
4497   DD7F 24 0F                   bcc     L1253                   ; Branch if rpm31 >= 5000rpm                             
4498   DD81 96 D0                   ldaa    battRaw                 ; a = battRaw                               
4499   DD83 81 F5                   cmpa    #$f5                    ; 18V                             
4500   DD85 22 09                   bhi     L1253                   ; Branch if battRaw > 18V                              
4501   DD87 81 6D                   cmpa    #$6d                    ; 8V                             
4502   DD89 25 05                   bcs     L1253                   ; Branch if battRaw < 8V                              
4503   DD8B 03 85 20                orm     coilChkFlags, #$20      ; At this point voltage is between 8V and 18V, set bit
4504   DD8E 20 03                   bra     L1255                   ;                              
4505   DD90 02 85 DF    L1253       andm    coilChkFlags, #$df      ; Reset bit 
4506   DD93             
4507   DD93                         ;------
4508   DD93                         ; Exit
4509   DD93                         ;------
4510   DD93 39          L1255       rts                             ;                             
4511   DD94             
4512   DD94             
4513   DD94             
4514   DD94             ;******************************************************************
4515   DD94             ;
4516   DD94             ; Return the octane value if sensors look ok, 0 otherwise 
4517   DD94             ; (very low octane to be on the safe side)
4518   DD94             ;
4519   DD94             ;
4520   DD94             ;
4521   DD94             ;******************************************************************
4522   DD94 4F          getOctane   clra                                                         
4523   DD95 87 D6 28 02             brset   state2, #$28, L1257     ; Branch if no pulse accumulator interrupts or knock sensor not working 
4524   DD99 96 52                   ldaa    octane                                                 
4525   DD9B 39          L1257       rts                                                          
4526   DD9C             
4527   DD9C             
4528   DD9C             
4529   DD9C             ;******************************************************************
4530   DD9C             ;
4531   DD9C             ;
4532   DD9C             ; Third subroutine
4533   DD9C             ;
4534   DD9C             ;
4535   DD9C             ;******************************************************************
4536   DD9C                         ;-------------------------------------------
4537   DD9C                         ; Update fuel pump activation/deactivation
4538   DD9C                         ;-------------------------------------------
4539   DD9C 8F E6 10 09 subroutine3 brclr   state1, #$10, L1259     ; Branch if notRotating clear
4540   DDA0 87 FB 02 05             brset   obdActCmd, #$02, L1259  ; Engine notRotating, branch if fuel pump is being actuated through OBD command
4541   DDA4 03 02 10                orm     port1, #$10             ; De-activate fuel pump relay
4542   DDA7 20 03                   bra     L1260                   ; Bail                                                                                          
4543   DDA9 02 02 EF    L1259       andm    port1, #$ef             ; activate fuel pump relay
4544   DDAC             
4545   DDAC                         ;------------------------------------------------------------------------
4546   DDAC                         ; Re-init T40_acOn if A/C switch on is off
4547   DDAC                         ; (implement a min delay before turning A/C on after button is pressed)
4548   DDAC                         ;------------------------------------------------------------------------
4549   DDAC CE 01 2E    L1260       ldx     #T40_acOn                ; X points to 40Hz timer T40_acOn                                                                                           
4550   DDAF 8F D7 10 04             brclr   port3Snap0, #$10, L1261  ; Branch if A/C switch flag off (switch is on?)                                                                                         
4551   DDB3 86 18                   ldaa    #$18                     ; Switch is off, init timer                                                                                        
4552   DDB5 A7 00                   staa    $00,x                    ; Re-init T40_acOn with $18 (0.6s, min time before activating A/C)                                                                                         
4553   DDB7             
4554   DDB7                         ;---------------------------------------------------------------------------------
4555   DDB7                         ; Re-init T40_acOnRpm if rpm<438
4556   DDB7                         ; (implement a min delay before turning A/C on after RPM > 438 (after start-up)
4557   DDB7                         ;---------------------------------------------------------------------------------
4558   DDB7 96 DD       L1261       ldaa    rpm31                   ; a = rpm                                                                               
4559   DDB9 81 0E                   cmpa    #$0e                    ; 438rpm                                                                                
4560   DDBB 22 04                   bhi     L1262                   ; Branch if rpm > 438                                                                   
4561   DDBD 86 20                   ldaa    #$20                    ; rpm lower than 438, init timer
4562   DDBF A7 01                   staa    $01,x                   ; rpm<438 -> Re-init timer #T40_acOnRpm with $20 (0.8s)
4563   DDC1                                           
4564   DDC1                         ;--------------------------------------------------------------
4565   DDC1                         ; For AT, decide if we will turn A/C on/off based on TPS...
4566   DDC1                         ;--------------------------------------------------------------
4567   DDC1             L1262       .equ    $                       ;
4568   DDC1~            #ifdef E932    
4569   DDC1~                        ;-----------------------------------------------------------------
4570   DDC1~                        ; Load TPS value of 78% or 82% (80% target with +/-2% hysteresis) 
4571   DDC1~                        ;-----------------------------------------------------------------
4572   DDC1~                        ldaa    #$d2                    ; Load 82% threshold                            
4573   DDC1~                        brclr   varFlags0, #$01, L1263  ; Do not branch if TPS was higher than 82% the previous time we were here                             
4574   DDC1~                        ldaa    #$c7                    ; Use 78% threshold instead (hysteresis)              
4575   DDC1~                        
4576   DDC1~                        ;-----------------------------------------------------------------
4577   DDC1~                        ; Check if TPS is above/below threshold and set varFlags0 accordingly
4578   DDC1~                        ;-----------------------------------------------------------------
4579   DDC1~            L1263       orm     varFlags0, #$01         ; Assume this bit will be set (reset below)                               
4580   DDC1~                        cmpa    tpsRaw                  ;                            
4581   DDC1~                        bls     L1264                   ; Branch if threshold smaller than TPS (TPS higher than threshold)
4582   DDC1~            
4583   DDC1~                        ;----------------------------------------------------------------------------------
4584   DDC1~                        ; TPS lower than threshold, reset varFlags0.0 flag and set timer T40_acCut to 5s
4585   DDC1~                        ;----------------------------------------------------------------------------------
4586   DDC1~                        andm    varFlags0, #$fe         ; TPS lower than threshold, reset varFlags0.0                               
4587   DDC1~                        ldaa    #$c8                    ; 5s at 40Hz                            
4588   DDC1~                        staa    $02,x                   ; Init T40_acCut to 5s (delay before turning A/C back on)                             
4589   DDC1             #endif
4590   DDC1             
4591   DDC1                         ;---------------------------------------------------------------------------
4592   DDC1                         ; Make sure both T40_acOn and T40_acOnRpm are 0 before attempting to turn A/C on
4593   DDC1                         ; Implement a min delay before engaging A/C 
4594   DDC1                         ; clutch once car has started or A/C button is pressed
4595   DDC1                         ;---------------------------------------------------------------------------
4596   DDC1 A6 00       L1264       ldaa    $00,x                   ; a = T40_acOn
4597   DDC3 AA 01                   oraa    $01,x                   ; a = T40_acOn | T40_acOnRpm                                                  
4598   DDC5 26 05                   bne     L1266                   ; Branch if at least one timert not yet 0 (turn A/C off)                                       
4599   DDC7                         
4600   DDC7                         ;-----------------------------------------------------------------------------
4601   DDC7                         ; At this point, both T40_acOn and T40_acOnRpm timers are at 0, we can turn A/C on
4602   DDC7                         ;-----------------------------------------------------------------------------
4603   DDC7~            #ifdef E932
4604   DDC7~                        ;--------------------------------------------------------------
4605   DDC7~                        ; For AT, decide if we will turn A/C on/off based on TPS...
4606   DDC7~                        ; Seems A/C is cutoff for a maximum of 5 seconds when TPS>80%
4607   DDC7~                        ; but it is turned back on whenever TPS goes below 80% (no delay)
4608   DDC7~                        ; It would probably be better to turn-it off for 5s anyway...
4609   DDC7~                        ;--------------------------------------------------------------
4610   DDC7~                        brclr   varFlags0, #$01, L1265  ; Branch if TPS was lower than threshold (turn it back on immediately, not the best????)
4611   DDC7~                        brset   port3Snap0, #$20, L1265 ; TPS is higher than threshold, branch if Park/neutral flag is set (no need to cutoff if in park)
4612   DDC7~                        ldaa    $02,x                   ; Get T40_acCut value to see if we can turn A/C back on (5 second delay)                              
4613   DDC7~                        bne     L1266                   ; Branch if timer not expired                            
4614   DDC7             #endif
4615   DDC7             
4616   DDC7                         ;----------------
4617   DDC7                         ; Turn A/C on 
4618   DDC7                         ;----------------
4619   DDC7 02 02 DF    L1265       andm    port1, #$df             ; Turn A/C clutch bit to 0 
4620   DDCA 20 03                   bra     L1267    
4621   DDCC                                                                                                   
4622   DDCC                         ;----------------
4623   DDCC                         ; Turn A/C off
4624   DDCC                         ;----------------
4625   DDCC 03 02 20    L1266       orm     port1, #$20             ; Turn A/C clutch bit to 1 
4626   DDCF             
4627   DDCF                         ;--------------------------------------------------------------
4628   DDCF                         ; Section to update the purge solenoid activation/deactivation
4629   DDCF                         ;--------------------------------------------------------------
4630   DDCF                         ;------------------------------------------------------------
4631   DDCF                         ; Reset forced activation and forced deactivation flags 
4632   DDCF                         ; since we are going to update them
4633   DDCF                         ;------------------------------------------------------------
4634   DDCF 02 F8 9F    L1267       andm    varFlags0, #$9f         ; Reset bits 01100000 ($20 and $40)
4635   DDD2             
4636   DDD2                         ;-----------------------------------
4637   DDD2                         ; Branch according to engine state
4638   DDD2                         ;-----------------------------------
4639   DDD2 8F E6 10 0E             brclr   state1, #$10, L1270     ; Branch if notRotating clear
4640   DDD6             
4641   DDD6                         ;-----------------------------------------------------------
4642   DDD6                         ; Engine notRotating, check if an OBD command is ongoing
4643   DDD6                         ; to activate solenoid, set flags in consequence
4644   DDD6                         ;-----------------------------------------------------------
4645   DDD6 87 FB 01 05             brset   obdActCmd, #$01, L1269  ; Branch if purge solenoid is actuated by OBD
4646   DDDA 03 F8 20                orm     varFlags0, #$20         ; Set "forced deactivation flag" 
4647   DDDD 20 46                   bra     L1276                   ; Branch to continue                             
4648   DDDF 03 F8 40    L1269       orm     varFlags0, #$40         ; Set "forced activation" flag
4649   DDE2 20 41                   bra     L1276                   ; Branch to reset pulsewidth modulation flag since engine not rotating...  
4650   DDE4                                                     
4651   DDE4                         ;----------------------------------------------------------------
4652   DDE4                         ; Engine rotating
4653   DDE4                         ; Check if minimum conditions are met to activate purge solenoid
4654   DDE4                         ;----------------------------------------------------------------
4655   DDE4 B6 01 34    L1270       ldaa    T2_crank                ; a = T2_crank                                 
4656   DDE7 8B 78                   adda    #$78                    ;                             
4657   DDE9 25 0A                   bcs     L1271                   ; Branch if engine stopped "startingToCrank" less than 60 sec ago.
4658   DDEB 8F E5 03 06             brclr   ftrimFlags, #$03, L1271 ; Branch if current trim range is "low"                                    
4659   DDEF 96 D3                   ldaa    ectFiltered             ; a = ectFiltered                                    
4660   DDF1 81 2D                   cmpa    #$2d                    ; 66degC                            
4661   DDF3 23 05                   bls     L1272                   ; Branch if temperature(ectFiltered) >= 66degC                             
4662   DDF5             
4663   DDF5                         ;-----------------------------------------------------------
4664   DDF5                         ; Conditions are not good to activate purge solenoid
4665   DDF5                         ; Set "forced deactivation" flag
4666   DDF5                         ;-----------------------------------------------------------
4667   DDF5 03 F8 20    L1271       orm     varFlags0, #$20         ; Set flag                               
4668   DDF8 20 13                   bra     L1274                   ; Branch to continue        
4669   DDFA                                              
4670   DDFA                         ;---------------------------------------------------------------
4671   DDFA                         ; Minimum condition for activation are met, check if there are
4672   DDFA                         ; special conditions where we should always activate???
4673   DDFA                         ;---------------------------------------------------------------
4674   DDFA 8F E6 80 0C L1272       brclr   state1, #$80, L1273     ; Branch to activate if open loop mode is active
4675   DDFE                         
4676   DDFE                         ;------------------------------
4677   DDFE                         ; We are in closed loop mode
4678   DDFE                         ;------------------------------
4679   DDFE 96 D5                   ldaa    baroChecked             ; a = baroChecked
4680   DE00 81 9C                   cmpa    #$9c                    ; 1 bar                            
4681   DE02 25 06                   bcs     L1273                   ; Branch to activate if baroChecked < 0.76 bar, activate if baro is very low?                             
4682   DE04 96 D4                   ldaa    iatChecked              ; a = iatChecked                                  
4683   DE06 81 49                   cmpa    #$49                    ; 50degC                            
4684   DE08 22 03                   bhi     L1274                   ; Branch if temperature(iatChecked) < 50degC                              
4685   DE0A             
4686   DE0A                         ;--------------------------------------------------------------------------------
4687   DE0A                         ; At this point, min conditions are met and either
4688   DE0A                         ;   open loop mode is active 
4689   DE0A                         ; or 
4690   DE0A                         ;   closed loop mode is active  and (baroChecked < 0.76 or temperature(iatChecked) >= 50degC)
4691   DE0A                         ;
4692   DE0A                         ; Set "forced activation" flag indicating 
4693   DE0A                         ; we should activate purge solenoid 
4694   DE0A                         ;--------------------------------------------------------------------------------
4695   DE0A 03 F8 40    L1273       orm     varFlags0, #$40         ; Set flag                                
4696   DE0D             
4697   DE0D                         ;----------------------------------------------------------------
4698   DE0D                         ; Continuation from code flows above when engine is rotating...
4699   DE0D                         ; Update varFlags0.7 deactivation flag if its timer is expired
4700   DE0D                         ;
4701   DE0D                         ; varFlags0.7 deactivation flag is used to activate/deactivate 
4702   DE0D                         ; solenoid when none of the other two flags are set. Flag 
4703   DE0D                         ; stays set for 24sec and stays reset for 212 sec. Toggled 
4704   DE0D                         ; between the two states, basically implementing pulsewidth 
4705   DE0D                         ; modulation with a very long period...
4706   DE0D                         ;----------------------------------------------------------------
4707   DE0D B6 01 42    L1274       ldaa    T0p5_purge              ; a = T0p5_purge                                  
4708   DE10 26 1B                   bne     L1278                   ; Bail to activate/deactivate if timer not expired                             
4709   DE12             
4710   DE12                         ;-----------------------------------------------------------------
4711   DE12                         ; Timer is expired, time to toggle the flag, 
4712   DE12                         ; branch to appropriate section depending on current flag value
4713   DE12                         ;-----------------------------------------------------------------
4714   DE12 87 F8 80 0B             brset   varFlags0, #$80, L1275  ; Branch if deactivation flag was set previously
4715   DE16             
4716   DE16                         ;-----------------------------------------------------------------------
4717   DE16                         ; Flag is not set, first check if "forced activation" is requested
4718   DE16                         ; in that case we just bail since it doesn't matter anymore...
4719   DE16                         ;-----------------------------------------------------------------------
4720   DE16 87 F8 40 13             brset   varFlags0, #$40, L1278  ; Bail to activate if solenoid needs "forced activation"                              
4721   DE1A             
4722   DE1A                         ;-----------------------------------------------------------------------
4723   DE1A                         ; Time has come to toggle the flag to 1 and reset the timer to 24sec
4724   DE1A                         ;-----------------------------------------------------------------------
4725   DE1A 86 0C                   ldaa    #$0c                    ; a = 24s                            
4726   DE1C 03 F8 80                orm     varFlags0, #$80         ; Set flag                               
4727   DE1F 20 09                   bra     L1277                   ; Branch to update timer and activate/deactivate    
4728   DE21             
4729   DE21                         ;-----------------------------------------------------------------------
4730   DE21                         ; Flag is set, first check if "forced deactivation" is requested
4731   DE21                         ; in that case we just bail since it doesn't matter anymore...
4732   DE21                         ;-----------------------------------------------------------------------
4733   DE21 87 F8 20 08 L1275       brset   varFlags0, #$20, L1278  ; Bail to activate/deactivate if "forced deactivation" flag is set                              
4734   DE25             
4735   DE25                         ;-----------------------------------------------------------------------
4736   DE25                         ; Time has come to toggle the flag to 0 and reset the timer to 212sec
4737   DE25                         ;-----------------------------------------------------------------------
4738   DE25 86 6A       L1276       ldaa    #$6a                    ; 212s
4739   DE27 02 F8 7F                andm    varFlags0, #$7f         ; Reset flag                               
4740   DE2A B7 01 42    L1277       staa    T0p5_purge              ; T0p5_purge = 212sec         
4741   DE2D                                   
4742   DE2D                         ;------------------------------------------------------------------
4743   DE2D                         ; Continuation from all code flows above...
4744   DE2D                         ; Based on flags, decide to activate or deactivate purge solenoid
4745   DE2D                         ; Flags are tested in priority order...
4746   DE2D                         ;------------------------------------------------------------------
4747   DE2D 87 F8 40 08 L1278       brset   varFlags0, #$40, L1279      ; 1st priority, branch to activate if forced activation is set
4748   DE31 87 F8 20 09             brset   varFlags0, #$20, L1280      ; 2nd priority, branch to deactivate if forced deactivation is set                              
4749   DE35 87 F8 80 05             brset   varFlags0, #$80, L1280      ; 3rd priority, branch to deactivate if pulswidth modulation flag is set                              
4750   DE39             
4751   DE39                         ;---------------------------
4752   DE39                         ; Activate purge solenoid
4753   DE39                         ;---------------------------
4754   DE39 02 2F EF    L1279       andm    port6, #$ef             ; Activate purge solenoid
4755   DE3C 20 03                   bra     L1281                   ;                              
4756   DE3E             
4757   DE3E                         ;----------------------------
4758   DE3E                         ; Deactivate purge solenoid
4759   DE3E                         ;----------------------------
4760   DE3E 03 2F 10    L1280       orm     port6, #$10             ; Deactivate purge solenoid
4761   DE41             
4762   DE41             
4763   DE41                         ;--------------------------------------------------------------
4764   DE41                         ; Section to update the EGR solenoid activation/deactivation
4765   DE41                         ;--------------------------------------------------------------
4766   DE41                         ;----------------------------------------------------------------
4767   DE41                         ; Compute egr duty cycle factor 
4768   DE41                         ; as a function of rpm and airVol from 2D table t_egrDutyFact 
4769   DE41                         ;----------------------------------------------------------------
4770   DE41 F6 01 51    L1281       ldab    rpmIndex1               ;                              
4771   DE44 86 70                   ldaa    #$70                    ; max of rpm                            
4772   DE46 BD EC 2C                jsr     abmin                   ; b = max(rpmIndex1, $70)                             
4773   DE49 D7 5C                   stab    temp6                   ; column index is rpm                             
4774   DE4B D6 E0                   ldab    airVol                  ;                               
4775   DE4D 86 80                   ldaa    #$80                    ; max of airVol
4776   DE4F BD EC 27                jsr     rpmRange                ;                                 
4777   DE52 D7 5D                   stab    temp7                   ; row index is airVol                        
4778   DE54 C6 80                   ldab    #$80                    ; b = 100% duty cycle                            
4779   DE56 8F E6 10 04             brclr   state1, #$10, L1282     ; Branch if notRotating clear
4780   DE5A 87 FB 08 1F             brset   obdActCmd, #$08, L1283  ; Engine notRotating, branch if EGR solenoid actuated (by OBD) -> use 100% duty
4781   DE5E 5F          L1282       clrb                            ; b = 0% duty cycle                           
4782   DE5F 87 D6 08 1A             brset   state2, #$08, L1283     ; Branch if no pulse accumulator interrupts  -> use 0% duty cycle                                
4783   DE63 87 E6 11 16             brset   state1, #$11, L1283     ; Branch if notRotating or startingToCrank -> use 0% duty cycle
4784   DE67 CE FF 40                ldx     #t_egrDutyFact          ;                               
4785   DE6A CD CE 08 00             ldy     #$0800                  ;                               
4786   DE6E BD EA E1                jsr     lookup2D                ; b = t_egrDutyFact(rpm, airVol)                                 
4787   DE71 4F                      clra                            ;                             
4788   DE72 DD 5C                   std     temp6                   ; temp6:temp7 = t_egrDutyFact(rpm,airVol)                              
4789   DE74             
4790   DE74                         ;---------------------------------------------------------------------------------
4791   DE74                         ; Get EGR solenoid duty cycle from t_egrDuty and apply factor from above
4792   DE74                         ;---------------------------------------------------------------------------------
4793   DE74 CE FF 88                ldx     #t_egrDuty              ;                                   
4794   DE77 B6 01 4E                ldaa    ectCond                 ;                                
4795   DE7A BD EB 68                jsr     interp32mul             ; b = t_egrDutyFact(rpm,airVol) * t_egrDuty(ect)                                   
4796   DE7D F7 01 7D    L1283       stab    egrDuty128              ; egrDuty128 = t_egrDutyFact(rpm,airVol) * t_egrDuty(ect) with $80=100%                                   
4797   DE80                         
4798   DE80                         ;-------------------------------------
4799   DE80                         ; Scale duty factor to 00 - $30 range
4800   DE80                         ;-------------------------------------
4801   DE80 86 30                   ldaa    #$30                    ; 
4802   DE82 3D                      mul                             ;                             
4803   DE83 BD EB A0                jsr     scale128                ; b = $30 * egrDuty128/128                              
4804   DE86 F7 01 7E                stab    egrDuty                 ; egrDuty with max of $30=100%
4805   DE89             
4806   DE89                         ;--------------------------------------------------------------------
4807   DE89                         ; Re-Init T2_EcuPower to $ff if T40_noPower expired
4808   DE89                         ; (T2_EcuPower will start counting from $ff when power is back on...
4809   DE89                         ;--------------------------------------------------------------------
4810   DE89 B6 01 24                ldaa    T40_noPower             ;                                    
4811   DE8C 26 05                   bne     L1284                   ; Branch if ECU still has power                             
4812   DE8E 86 FF                   ldaa    #$ff                    ; ECU about to loose power, reset T2_EcuPower to max (127.5sec)                               
4813   DE90 B7 01 35                staa    T2_EcuPower             ;
4814   DE93                                                                 
4815   DE93                         ;-----------------------------------------------------------
4816   DE93                         ; Section to update boost control solenoid duty cycle
4817   DE93                         ;-----------------------------------------------------------
4818   DE93                         ;-----------------------------------------------------------
4819   DE93                         ; Check if time has come, section is updated at ~40Hz
4820   DE93                         ;-----------------------------------------------------------
4821   DE93 8F D9 01 5A L1284       brclr   Tclocks, #$01, L1298    ; Bail of section if 40Hz signal no set                                   
4822   DE97 D6 F9                   ldab    fpsBcsFlags             ; b = old fpsBcsFlags                              
4823   DE99 02 F9 8F                andm    fpsBcsFlags, #$8f       ; Assume those three flags are reset, updated below (0111 0000)
4824   DE9C             
4825   DE9C                         ;-------------------------------------------------------------------
4826   DE9C                         ; Check if octane is above/below threshold with hysteresis 
4827   DE9C                         ; (high $c0, low $9a) and update fpsBcsFlags.5 flag (reset above) 
4828   DE9C                         ;-------------------------------------------------------------------
4829   DE9C 86 9A                   ldaa    #$9a                    ; start with low threshold, a = $9a
4830   DE9E C5 20                   bitb    #$20                    ; test bit                                                                   
4831   DEA0 26 02                   bne     L1285                   ; Branch if old fpsBcsFlags.5 was set                                     
4832   DEA2 86 C0                   ldaa    #$c0                    ; bit was not set, use higher threshold a = $c0
4833   DEA4 91 52       L1285       cmpa    octane                  ; 
4834   DEA6 24 03                   bcc     L1286                   ; Branch if octane <= threshold
4835   DEA8 03 F9 20                orm     fpsBcsFlags, #$20       ; set flag since we are above threshold 
4836   DEAB             
4837   DEAB                         ;-------------------------------------------------------------------
4838   DEAB                         ; Check if mafRaw16 is above/below threshold with hysteresis 
4839   DEAB                         ; (high $4e, low $38) and update fpsBcsFlags.4 flag (reset above) 
4840   DEAB                         ;-------------------------------------------------------------------
4841   DEAB 86 38       L1286       ldaa    #$38                    ; a = #0038                                                        
4842   DEAD C5 10                   bitb    #$10                    ;                                                                  
4843   DEAF 26 02                   bne     L1287                   ; Branch if old fpsBcsFlags.4 was set  
4844   DEB1             #ifdef E931                                  
4845   DEB1 86 4E                   ldaa    #$4e                    ; a = #004e
4846   DEB3~            #else
4847   DEB3~                        ldaa    #$4a                    ;                             
4848   DEB3             #endif
4849   DEB3 B1 01 4B    L1287       cmpa    mafRaw16                ; 
4850   DEB6 24 03                   bcc     L1288                   ; branch if mafRaw16 <= threshold
4851   DEB8 03 F9 10                orm     fpsBcsFlags, #$10       ; set flag since we are above threshold 
4852   DEBB             
4853   DEBB             
4854   DEBB                         ;-------------------------------------------------
4855   DEBB                         ; Branch to proper section if engine not running
4856   DEBB                         ;-------------------------------------------------
4857   DEBB 8F E6 10 04 L1288       brclr   state1, #$10, L1289     ; Branch if notRotating clear 
4858   DEBF 87 FB 20 23             brset   obdActCmd, #$20, L1295  ; Engine notRotating, branch if boost solenoid actuated (by OBD command I assume)
4859   DEC3 87 E6 11 1A L1289       brset   state1, #$11, L1293     ; branch if notRotating or startingToCrank
4860   DEC7             
4861   DEC7                         ;----------------------------------------------------
4862   DEC7                         ; Engine is running...
4863   DEC7                         ; Check if time has come to update
4864   DEC7                         ;----------------------------------------------------
4865   DEC7 B6 01 80                ldaa    T40s_bcs                ; 
4866   DECA 26 21                   bne     L1297                   ; Branch if timer not expired                             
4867   DECC             
4868   DECC                         ;----------------------------------------------------
4869   DECC                         ; Timer expired, time to update has come (~2Hz)
4870   DECC                         ;
4871   DECC                         ; By default, increase bcsDuty by 8 and test if we
4872   DECC                         ; should not reduce it instead
4873   DECC                         ;----------------------------------------------------
4874   DECC F6 01 81                ldab    bcsDuty                  ; b = bcsDuty
4875   DECF CB 08                   addb    #$08                     ; b = bcsDuty + 8
4876   DED1 87 D6 28 08             brset   state2, #$28, L1292      ; Branch if no pulse accumulator interrupts being received or knock sensor not working
4877   DED5 87 F9 10 04             brset   fpsBcsFlags, #$10, L1292 ; Branch if mafRaw16 above threshold 
4878   DED9 87 F9 20 05             brset   fpsBcsFlags, #$20, L1294 ; Branch if octane above threshold 
4879   DEDD             
4880   DEDD                         ;--------------------------------------------------------------
4881   DEDD                         ; At this point, knock sensor is not working or we are not
4882   DEDD                         ; receiving airflow sensor interrupts or mafRaw16 is above
4883   DEDD                         ; threshold or octane is below threshold, basically these
4884   DEDD                         ; are onditions where we would want to reduce turbo pressure 
4885   DEDD                         ;
4886   DEDD                         ; Reduce bcsDuty by 2 instead of increasing by 8 
4887   DEDD                         ;--------------------------------------------------------------
4888   DEDD C0 10       L1292       subb    #$10                     ; b = bcsDuty + 8 - 10 = bcsDuty - 2
4889   DEDF 24 01                   bcc     L1294                    ; Branch if no underflow                             
4890   DEE1 5F          L1293       clrb                             ; Use min of 0                            
4891   DEE2             
4892   DEE2                         ;---------------------------------------
4893   DEE2                         ; Check new bcsDuty for max of $30, 
4894   DEE2                         ; store new value and update the timer
4895   DEE2                         ;---------------------------------------
4896   DEE2 C1 30       L1294       cmpb    #$30                     ;                             
4897   DEE4 25 02                   bcs     L1296                    ; Branch if new bcsDuty < $30                               
4898   DEE6 C6 30       L1295       ldab    #$30                     ; Use max of $30
4899   DEE8 F7 01 81    L1296       stab    bcsDuty                  ; Store new bcsDuty
4900   DEEB 86 14                   ldaa    #$14                     ; Re-init timer to 20 (0.5sec)                            
4901   DEED 4A          L1297       deca                             ; Decrement timer                            
4902   DEEE B7 01 80                staa    T40s_bcs                 ; Store updated timer                             
4903   DEF1             
4904   DEF1             
4905   DEF1                         ;-------------------------------------
4906   DEF1                         ; Decrement T40s_tps at 40Hz
4907   DEF1                         ;-------------------------------------
4908   DEF1 0F          L1298       sei                             ;                             
4909   DEF2 CE 01 82                ldx     #T40s_tps               ;                               
4910   DEF5 BD EB FC                jsr     decX40Hz                ; Decrement T40s_tps at 40Hz 
4911   DEF8 0E                      cli                             ;                             
4912   DEF9             
4913   DEF9                         ;------------------------------------
4914   DEF9                         ; Compute the boost gauge duty cycle 
4915   DEF9                         ; depending on current conditions
4916   DEF9                         ;------------------------------------
4917   DEF9 5F                      clrb                            ; load default duty cycle of b = 0                             
4918   DEFA B6 01 24                ldaa    T40_noPower             ;                               
4919   DEFD 27 13                   beq     L1299                   ; Bail if timer expired (ECU is about to shut-down...) (use 0 duty)                              
4920   DEFF C6 0C                   ldab    #$0c                    ; Load default duty cycle of b = $0c
4921   DF01 87 E6 10 0D             brset   state1, #$10, L1299     ; Bail if notRotating (use half duty...)
4922   DF05 5F                      clrb                            ; load default duty cycle of b = 0 
4923   DF06 87 D6 08 08             brset   state2, #$08, L1299     ; Bail if no pulse accumulator interrupts (use 0 duty)                               
4924   DF0A CE FF 37                ldx     #t_bGauge               ; x points to boost gauge table                              
4925   DF0D 96 E1                   ldaa    airVolT                 ; a = airVolT                                
4926   DF0F~            #ifdef batteryGauge
4927   DF0F~                        jsr     battGauge               ;
4928   DF0F             #else
4929   DF0F BD EB 4C                jsr     interp32                ; b = t_bGauge(airVolT) (max value is $18...)                                
4930   DF12             #endif
4931   DF12                         ;-------------------------------------------------
4932   DF12                         ; Update bGaugeODuty with $18-dutyCycle (min of 0)
4933   DF12                         ; bGaugeODuty is the off-duty cycle... 
4934   DF12                         ;-------------------------------------------------
4935   DF12 86 18       L1299       ldaa    #$18                    ; a = $18                              
4936   DF14 10                      sba                             ; a = $18-t_bGauge(airVolT)                              
4937   DF15 24 01                   bcc     L1300                   ; Branch if no underflow                              
4938   DF17 4F                      clra                            ; underflow, use min                             
4939   DF18 B7 01 7F    L1300       staa    bGaugeODuty             ; Update boost gauge off-duty cycle                                  
4940   DF1B             
4941   DF1B                         ;----------------------------------------------
4942   DF1B                         ; Section to update the fuel pressure solenoid
4943   DF1B                         ;----------------------------------------------
4944   DF1B                         ;-----------------------------------------------------
4945   DF1B                         ; First check if there are any reason to activate it
4946   DF1B                         ;-----------------------------------------------------
4947   DF1B D6 F9                   ldab    fpsBcsFlags              ; b = old fpsBcsFlags, used later...                         
4948   DF1D 02 F9 FB                andm    fpsBcsFlags, #$fb        ; Reset bit indicating solenoid was just deactivated will be updated below if required                          
4949   DF20 8F E6 11 1C             brclr   state1, #$11, L1302      ; branch if notRotating and startingToCrank clear   
4950   DF24 02 F9 F7                andm    fpsBcsFlags, #$f7        ; engine is either notRotating or startingToCrank                               
4951   DF27 8F E6 10 06             brclr   state1, #$10, L1301      ; Branch if notRotating clear (startingToCrank is set...)                           
4952   DF2B 87 FB 04 39             brset   obdActCmd, #$04, L1306   ; branch to activate solenoid if OBD command activated
4953   DF2F 20 3C                   bra     L1307                    ; No reason to activate it, branch to deactivate solenoid                         
4954   DF31             
4955   DF31                         ;-----------------------------------------------------------------
4956   DF31                         ; Engine is startingToCrank, check if we should set fpsBcsFlags.3 flag (vapor lock)
4957   DF31                         ; Basically set the flag when vapor lock conditions exists
4958   DF31                         ;-----------------------------------------------------------------
4959   DF31 96 D4       L1301       ldaa    iatChecked               ;                               
4960   DF33 81 9D                   cmpa    #$9d                     ;                         
4961   DF35 22 09                   bhi     L1302                    ; Branch if temperature(iatChecked) < 10degC                         
4962   DF37 96 D3                   ldaa    ectFiltered              ;                                
4963   DF39 81 27                   cmpa    #$27                     ; 72degC                         
4964   DF3B 22 03                   bhi     L1302                    ; Branch if  temperature(ectFiltered) < 72degC                           
4965   DF3D             
4966   DF3D                         ;------------------------------------------------------------------------------------------
4967   DF3D                         ; At this point engine is startingToCrank and temperature(iatChecked) >= 10degC 
4968   DF3D                         ; and temperature(ectFiltered) >= 72degC, set flag indicating vapor lock conditions exist, NOT???
4969   DF3D                         ;------------------------------------------------------------------------------------------
4970   DF3D 03 F9 08                orm     fpsBcsFlags, #$08        ; Set flag indicating vapor lock conditions exist
4971   DF40             
4972   DF40                         ;--------------------------------------------------------------------
4973   DF40                         ; Engine is running or notRotating or startingToCrank
4974   DF40                         ; Check if we should reset vapor lock flag: 3 minutes after
4975   DF40                         ; engine was started or if o2Fbk < $4d (meaning we are running rich)
4976   DF40                         ;--------------------------------------------------------------------
4977   DF40 B6 01 40    L1302       ldaa    T0p5_crank1              ;                               
4978   DF43 8B 5A                   adda    #$5a                     ;                         
4979   DF45 24 06                   bcc     L1303                    ; branch to reset flag if engine stopped "startingToCrank" more than 180s ago (engine has been running for 3 minutes)
4980   DF47 96 E9                   ldaa    o2Fbk                    ; a = o2Fbk                         
4981   DF49 81 4D                   cmpa    #$4d                     ;                         
4982   DF4B 22 03                   bhi     L1304                    ; Dont reset if o2Fbk > $4d  (running lean???)                       
4983   DF4D 02 F9 F7    L1303       andm    fpsBcsFlags, #$f7        ; Reset vappor lock flag
4984   DF50                                         
4985   DF50                         ;---------------------------------------------
4986   DF50                         ; Check whether we have vapor lock conditions
4987   DF50                         ;---------------------------------------------
4988   DF50 87 F9 08 09 L1304       brset   fpsBcsFlags, #$08, L1305 ; Branch if vapor lock flag is set
4989   DF54                                       
4990   DF54                         ;---------------------------------------------------------------------
4991   DF54                         ; Vapor lock flag is not set, at this point b = old fpsBcsFlags
4992   DF54                         ; Check if solenoid deactivation is just happening now and 
4993   DF54                         ; set flag to indicate so
4994   DF54                         ;---------------------------------------------------------------------
4995   DF54 C5 08                   bitb    #$08                     ;                         
4996   DF56 27 15                   beq     L1307                    ; Branch to reset solenoid if bit was also 0 on previous iteration                         
4997   DF58 03 F9 04                orm     fpsBcsFlags, #$04        ; Set flag indicating solenoid was just deactivated                            
4998   DF5B 20 10                   bra     L1307                    ; Branch to deactivate it                         
4999   DF5D             
5000   DF5D                         ;----------------------------------------------
5001   DF5D                         ; Vapor lock flag is set, check additional 
5002   DF5D                         ; conditions before activating solenoid 
5003   DF5D                         ;----------------------------------------------
5004   DF5D B6 01 1A    L1305       ldaa    T40_crank                  ;                              
5005   DF60 8B 50                   adda    #$50                       ;                         
5006   DF62 25 04                   bcs     L1306                      ; branch to activate solenoid if engine stopped "startingToCrank" less than 2s ago                              
5007   DF64 87 E8 01 05             brset   closedLpFlags, #$01, L1307 ; Branch to deactivate solenoid if the ECU has determined that we should be using closed loop mode (or getting close to it)                          
5008   DF68             
5009   DF68                         ;-------------------------------------
5010   DF68                         ; Activate the fuel pressure solenoid
5011   DF68                         ;-------------------------------------
5012   DF68 02 16 EF    L1306       andm    port5, #$ef             ; Activate the fuel pressure solenoid                                 
5013   DF6B 20 03                   bra     L1309                                                 
5014   DF6D             
5015   DF6D                         ;----------------------------------------
5016   DF6D                         ; Deactivate the fuel pressure solenoid
5017   DF6D                         ;----------------------------------------
5018   DF6D 03 16 10    L1307       orm     port5, #$10             ; Deactivate the fuel pressure solenoid                                 
5019   DF70 39          L1309       rts                                                          
5020   DF71             
5021   DF71             
5022   DF71             
5023   DF71             ;******************************************************************
5024   DF71             ;
5025   DF71             ;
5026   DF71             ; Second subroutine
5027   DF71             ;
5028   DF71             ;
5029   DF71             ;******************************************************************
5030   DF71                         ;--------------------------------------------------
5031   DF71                         ; Build port3Snap1 from port3Snap0 using a 
5032   DF71                         ; 
5033   DF71                         ; Set port3Snap1.2 if vssCnt1!=0, reset otherwise
5034   DF71                         ;--------------------------------------------------
5035   DF71 96 D7       subroutine2 ldaa    port3Snap0              ; start with a = port3Snap1 = port3Snap0                                  
5036   DF73 84 FB                   anda    #$fb                    ; reset 00000100                             
5037   DF75 D6 C4                   ldab    vssCnt1                 ; b = vssCnt1                                
5038   DF77 27 02                   beq     L1311                   ;                               
5039   DF79 8A 04                   oraa    #$04                    ; Set flag
5040   DF7B             
5041   DF7B                         ;---------------------------------------------------------------
5042   DF7B                         ; Reset iscFlags0.6 if key is in start and T40_noPower not expired?????? 
5043   DF7B                         ; (meaning engine is cranking and battery not KO? 
5044   DF7B                         ;---------------------------------------------------------------
5045   DF7B 85 40       L1311       bita    #$40                    ;                              
5046   DF7D 26 08                   bne     L1312                   ; Bail if key is not is start                              
5047   DF7F 7D 01 24                tst     T40_noPower             ; Key in start                               
5048   DF82 27 03                   beq     L1312                   ; Bail if timer expired                              
5049   DF84 02 4B BF                andm    iscFlags0, #$bf         ; Key in start and timer not expired, reset max calibration flag 0100 0000
5050   DF87             
5051   DF87                         ;----------------------------------------------------------
5052   DF87                         ; Re-init T40_noPower at 5 (0.125s) if ECU still has power
5053   DF87                         ;----------------------------------------------------------
5054   DF87 85 02       L1312       bita    #$02                    ;                              
5055   DF89 26 05                   bne     L1313                   ; Branch if IG1 at 0V (No more power, ECU about to turn off?)                              
5056   DF8B C6 05                   ldab    #$05                    ; ECU not about to turn off, restart timer                             
5057   DF8D F7 01 24                stab    T40_noPower             ;                              
5058   DF90             
5059   DF90                         ;-------------------------------------------
5060   DF90                         ; Move old port3Snap1 to oldP3Snap1 and 
5061   DF90                         ; update port3Snap1 with new value
5062   DF90                         ;-------------------------------------------
5063   DF90 D6 F1       L1313       ldab    port3Snap1              ; b = old port3Snap1                              
5064   DF92 97 F1                   staa    port3Snap1              ; port3Snap1 = new port3Snap1                              
5065   DF94 D7 F2                   stab    oldP3Snap1              ; oldP3Snap1 = old port3Snap1                               
5066   DF96             
5067   DF96                         ;-------------------
5068   DF96                         ; Update iscStepMax 
5069   DF96                         ;-------------------
5070   DF96 86 78                   ldaa    #$78                    ; I believe this is the max iscStepCurr value (120 decimal)                           
5071   DF98 97 F0                   staa    iscStepMax              ; iscStepMax = max possible value?                                
5072   DF9A 01                      nop                             ;                             
5073   DF9B 01                      nop                             ;                             
5074   DF9C 01                      nop                             ;
5075   DF9D                                                                                 
5076   DF9D                         ;---------------------------------------------------------------
5077   DF9D                         ; Decrement T40s_iscStable at 40Hz if iscStepCurr = iscStepTarg   
5078   DF9D                         ;---------------------------------------------------------------
5079   DF9D 96 FD                   ldaa    iscStepTarg             ;                                 
5080   DF9F 91 49                   cmpa    iscStepCurr             ;                                
5081   DFA1 26 06                   bne     L1314                   ; Branch if iscStepCurr != iscStepTarg                             
5082   DFA3 CE 01 62                ldx     #T40s_iscStable         ;                                   
5083   DFA6 BD EB FC                jsr     decX40Hz                ; Decrement T40s_iscStable at 40Hz 
5084   DFA9             
5085   DFA9                         ;-----------------------------------------------------
5086   DFA9                         ; If engine is notRotating, re-init some ISC variables
5087   DFA9                         ;-----------------------------------------------------
5088   DFA9 8F E6 10 0C L1314       brclr   state1, #$10, L1315     ; Bail if notRotating clear
5089   DFAD BD E5 18                jsr     iscYnInit               ; Init isc variables
5090   DFB0 7F 01 63                clr     iscStStall              ;                              
5091   DFB3~            #ifdef E932
5092   DFB3~                        clr     iscStBaseAcAdj          ;                              
5093   DFB3             #endif
5094   DFB3 02 F4 5F                andm    iscFlags1, #$5f         ; reset flags used when engine rotating or running, 1010 0000                                
5095   DFB6 03 F4 01                orm     iscFlags1, #$01         ; set flag (flag is only 0 when key in start and iscStTargSpec = iscStepCurr)
5096   DFB9             
5097   DFB9                         ;-----------------------------------------------------
5098   DFB9                         ; Update isc stable timer if  power 
5099   DFB9                         ; steering flag changed since last time
5100   DFB9                         ;-----------------------------------------------------
5101   DFB9 96 F1       L1315       ldaa    port3Snap1               ;                                  
5102   DFBB 98 F2                   eora    oldP3Snap1               ;                                  
5103   DFBD 85 08                   bita    #$08                     ;                            
5104   DFBF 27 05                   beq     L1316                    ; Branch if port3Snap1.3 did not change value since last time                             
5105   DFC1 C6 50                   ldab    #$50                     ;                            
5106   DFC3 BD E4 BF                jsr     updIscStableTimer        ;                                 
5107   DFC6             
5108   DFC6                         ;-----------------------------------------------------
5109   DFC6                         ; Update isc stable timer if A/C state
5110   DFC6                         ; changed since last time 
5111   DFC6                         ;-----------------------------------------------------
5112   DFC6 85 10       L1316       bita    #$10                     ;                            
5113   DFC8 27 05                   beq     L1317                    ; Branch if port3Snap1.4 did not change value since last time                             
5114   DFCA C6 50                   ldab    #$50                     ;                            
5115   DFCC BD E4 BF                jsr     updIscStableTimer        ;                                 
5116   DFCF             L1317       .equ    $                        ;
5117   DFCF             
5118   DFCF                         ;-----------------------------------------------------
5119   DFCF                         ; Update isc stable timer if park/neutral
5120   DFCF                         ; changed since last time (E932)
5121   DFCF                         ;-----------------------------------------------------
5122   DFCF~            #ifdef E932                                  
5123   DFCF~                        bita    #$20                     ;                            
5124   DFCF~                        beq     L1319                    ; Branch if port3Snap1.5 did not change value since last time                             
5125   DFCF~                        ldab    #$50                     ;                            
5126   DFCF~                        brclr   port3Snap1, #$20, L1318  ; Makes no difference, $50 used anyway...
5127   DFCF~                        ldab    #$50                     ;                            
5128   DFCF~            L1318       jsr     updIscStableTimer        ;                                 
5129   DFCF             #endif
5130   DFCF             
5131   DFCF                         ;-----------------------------------------------------
5132   DFCF                         ; Update isc stable timer if tpsDiffMax2 > $04
5133   DFCF                         ; i.e. gas pedal is moving...
5134   DFCF                         ;-----------------------------------------------------
5135   DFCF B6 01 4D    L1319       ldaa    tpsDiffMax2              ;                                   
5136   DFD2 81 04                   cmpa    #$04                     ;                            
5137   DFD4 25 05                   bcs     L1320                    ;                             
5138   DFD6 C6 28                   ldab    #$28                     ;                            
5139   DFD8 BD E4 BF                jsr     updIscStableTimer        ;                                 
5140   DFDB             
5141   DFDB                         ;----------------------------------------------------------------
5142   DFDB                         ; Update isc stable timer if idle switch is off
5143   DFDB                         ; Timer value is from table t_iscStableIdleSw
5144   DFDB                         ; Timer will only start counting when idle switch is back on...
5145   DFDB                         ;----------------------------------------------------------------
5146   DFDB 96 F1       L1320       ldaa    port3Snap1              ;                                    
5147   DFDD 2B 1E                   bmi     L1323                   ; Bail if idle switch is ON                             
5148   DFDF DC DA                   ldd     rpm4                    ;                             
5149   DFE1 04                      lsrd                            ; d = rpm4/2                             
5150   DFE2 D0 FE                   subb    idleSpdTarg             ;                              
5151   DFE4 82 00                   sbca    #$00                    ; d = rpm4/2 - idleSpdTarg                            
5152   DFE6 24 02                   bcc     L1321                   ; Branch if no overflow                              
5153   DFE8 4F                      clra                            ;                             
5154   DFE9 5F                      clrb                            ; Use min of d=0                             
5155   DFEA 04          L1321       lsrd                            ;                             
5156   DFEB 04                      lsrd                            ; d = (rpm4/2 - idleSpdTarg)/4                              
5157   DFEC 1C 00 A0                cmpd    #$00a0                  ;                               
5158   DFEF 25 02                   bcs     L1322                   ; Branch if (rpm4/2 - idleSpdTarg)/4 < $a0 (5000rpm)
5159   DFF1 C6 A0                   ldab    #$a0                    ; Use max of $a0 (5000rpm)                            
5160   DFF3 17          L1322       tba                             ; a = (rpm4/2 - idleSpdTarg)/4                             
5161   DFF4 CE FE DF                ldx     #t_iscStableIdleSw      ;                               
5162   DFF7 BD EB 49                jsr     interp16b               ; b = t_iscStableIdleSw((rpm4/2 - idleSpdTarg)/4)                                 
5163   DFFA BD E4 BF                jsr     updIscStableTimer       ;                                  
5164   DFFD             
5165   DFFD                         ;---------------------------------------------------
5166   DFFD                         ; Update isc stable timer if engine is not runnning
5167   DFFD                         ; or if min or max isc calibration is ongoing or if  
5168   DFFD                         ; we have ignition problems
5169   DFFD                         ;---------------------------------------------------
5170   DFFD 87 E6 11 08 L1323       brset   state1, #$11, L1324        ; Branch to update if notRotating or startingToCrank
5171   E001 87 4B A0 04             brset   iscFlags0, #$a0, L1324     ; Branch to update if min or max calibration requested flag is set
5172   E005 8F 85 80 05             brclr   coilChkFlags, #$80, L1325  ; Bail if no problem found on ignition signal
5173   E009 C6 78       L1324       ldab    #$78                       ; 
5174   E00B BD E4 BF                jsr     updIscStableTimer          ; 
5175   E00E             
5176   E00E                         ;-----------------------------------------------------------------
5177   E00E                         ; Update idleSpdInit = t_idleSpd(ect) or t_idleSpdDr(ect) (E932)
5178   E00E                         ;-----------------------------------------------------------------
5179   E00E             L1325       .equ    $
5180   E00E             #ifdef E931
5181   E00E CE FE C0                ldx     #t_idleSpd               ;                                   
5182   E011 BD EB 3A                jsr     interpEct                ; b = t_idleSpd(ect)                                  
5183   E014~            #else
5184   E014~                        ldx     #t_idleSpdDr             ;                                     
5185   E014~                        brclr   port3Snap1, #$20, L1326  ;                                    
5186   E014~                        ldx     #t_idleSpd               ;                                  
5187   E014~            L1326       jsr     interpEct                ;                                 
5188   E014             #endif
5189   E014 F7 01 6C                stab    idleSpdInit              ; idleSpdInit = t_idleSpd(ect) or t_idleSpdDr(ect)                                   
5190   E017             
5191   E017                         ;-----------------------------------------------------------------
5192   E017                         ; Update idleSpdMin with 0 if A/C switch is on 
5193   E017                         ; or if AT is in drive or if T0p5_crCold timer expired 
5194   E017                         ;-----------------------------------------------------------------
5195   E017 5F                      clrb                             ; preload default value of 0                            
5196   E018 96 F1                   ldaa    port3Snap1               ;                                  
5197   E01A 84 30                   anda    #$30                     ;                            
5198   E01C 81 30                   cmpa    #$30                     ;                            
5199   E01E 26 1A                   bne     L1328                    ; Branch to use default of 0 if A/C switch is on or if AT is in drive
5200   E020 B6 01 41                ldaa    T0p5_crCold              ;                              
5201   E023 27 15                   beq     L1328                    ; Branch to use default of 0 if T0p5_crCold timer expired                            
5202   E025             
5203   E025                         ;-----------------------------------------------
5204   E025                         ; A/C switch is off and AT is in not in drive 
5205   E025                         ; and  T0p5_crCold timer not expired
5206   E025                         ;
5207   E025                         ; Compute  idleSpdMin
5208   E025                         ;-----------------------------------------------
5209   E025 86 3C                   ldaa    #$3c                     ; a = $3c                            
5210   E027 97 57                   staa    temp1                    ; temp1 = $3c                            
5211   E029 86 13                   ldaa    #$13                     ; a = $13                            
5212   E02B 87 F4 20 02             brset   iscFlags1, #$20, L1327   ; Branch if engine startingToCrank and temperature(iat) < 75degC
5213   E02F             #ifdef E931
5214   E02F 86 20                   ldaa    #$20                     ; Use higher value                           
5215   E031~            #else
5216   E031~                        ldaa    #$13                     ; Use same value                            
5217   E031             #endif
5218   E031 F6 01 41    L1327       ldab    T0p5_crCold              ; b = T0p5_crCold                              
5219   E034 3D                      mul                              ; d = ($13 or $20) * T0p5_crCold                           
5220   E035 15 57                   div     temp1                    ; b = ($13 or $20) * T0p5_crCold / $3c                            
5221   E037 FB FE C0                addb    t_idleSpd                ; b = ($13 or $20) * T0p5_crCold / $3c + t_idleSpd(0)                                 
5222   E03A F7 01 6D    L1328       stab    idleSpdMin               ; idleSpdMin = 0 or (t_idleSpd(0) + (0.32 0r 0.53) * T0p5_crCold)                             
5223   E03D             
5224   E03D                         ;----------------------------------------------------------------------------------
5225   E03D                         ; Update idleSpdTarg from idleSpdInit and idleSpdMin and A/C park/neutral conditions
5226   E03D                         ;----------------------------------------------------------------------------------
5227   E03D B6 01 6C                ldaa    idleSpdInit             ; a = idleSpdInit                              
5228   E040 87 F1 10 06             brset   port3Snap1, #$10, L1331 ; Branch if A/C switch is off?                               
5229   E044~            #ifdef E932
5230   E044~                        ldab    #$53                    ; 648rpm                             
5231   E044~                        brclr   port3Snap1, #$20, L1330 ; Branch if park/neutral???                                   
5232   E044             #endif
5233   E044 C6 6D                   ldab    #$6d                    ; 852rpm                            
5234   E046 11          L1330       cba                             ;                             
5235   E047 24 01                   bcc     L1331                   ; Branch if idleSpdInit >= $6d                              
5236   E049 17                      tba                             ; Use min of a = $6d 
5237   E04A                                                      
5238   E04A B1 01 6D    L1331       cmpa    idleSpdMin              ;                              
5239   E04D 24 03                   bcc     L1332                   ; Branch if idleSpdInit >= idleSpdMin                            
5240   E04F B6 01 6D                ldaa    idleSpdMin              ; Use min of idleSpdMin                             
5241   E052 97 FE       L1332       staa    idleSpdTarg             ; idleSpdTarg = ...                             
5242   E054             
5243   E054             
5244   E054             #ifdef E931
5245   E054                         ;-------------------------------------------
5246   E054                         ; Update iscStBase for E931
5247   E054                         ; iscStBase = t_iscStEct0(ect)
5248   E054                         ;-------------------------------------------
5249   E054 CE FE C8                ldx     #t_iscStEct0            ;                                     
5250   E057 BD EB 3A                jsr     interpEct               ;                                   
5251   E05A F7 01 67                stab    iscStBase               ; iscStBase = t_iscStEct0(ect)                              
5252   E05D~            #else       
5253   E05D~                        ;------------------------------------------------------------------
5254   E05D~                        ; Update iscStBase for E932
5255   E05D~                        ; Choose a different table if transmission is engaged (e.g. drive)
5256   E05D~                        ;
5257   E05D~                        ; iscStBase = t_iscStEct1(ect) or t_iscStEct0(ect) 
5258   E05D~                        ;------------------------------------------------------------------
5259   E05D~                        ldx     #t_iscStEct1            ;                               
5260   E05D~                        brclr   port3Snap1, #$20, L1334 ; Branch if park/neutral                                    
5261   E05D~                        ldx     #t_iscStEct0            ;                                    
5262   E05D~            L1334       jsr     interpEct               ;                                  
5263   E05D~                        stab    iscStBase               ; iscStBase = t_iscStEct0(ect) or t_iscStEct1(ect)                               
5264   E05D~            
5265   E05D~                        ;-------------------------------------------------------------------
5266   E05D~                        ; For E932, decrement iscStBaseAcAdj by 1 (min of 0) at ~2.2Hz 
5267   E05D~                        ;-------------------------------------------------------------------
5268   E05D~                        ldaa    T40_21                  ; a = T40_21                              
5269   E05D~                        bne     L1336                   ; Branch if timer not expired                             
5270   E05D~                        ldaa    #$12                    ; Timer expired, re-init to 0.45sec                            
5271   E05D~                        staa    T40_21                  ; T40_21 = 0.45sec                              
5272   E05D~                        ldaa    iscStBaseAcAdj          ; a = iscStBaseAcAdj                             
5273   E05D~                        suba    #$01                    ; a = iscStBaseAcAdj - 1                            
5274   E05D~                        bcc     L1335                   ; Branch if no underflow                              
5275   E05D~                        clra                            ; Underflow, use min of 0                            
5276   E05D~            L1335       staa    iscStBaseAcAdj          ; update iscStBaseAcAdj                             
5277   E05D             #endif
5278   E05D             
5279   E05D                         ;---------------------------------------------------
5280   E05D                         ; Compute iscStBaseAc, basic iscStep corrected for 
5281   E05D                         ; additional A/C and transmission load
5282   E05D                         ;---------------------------------------------------
5283   E05D 4F          L1336       clra                            ; preload default value of offset = 0                             
5284   E05E 87 F1 10 0F             brset   port3Snap1, #$10, L1342 ; Bail to use offset of 0 if A/C switch off                                     
5285   E062 86 1C                   ldaa    #$1c                    ; A/C is on, offset = a = $1c                            
5286   E064 C6 37                   ldab    #$37                    ; minValue = b = $37                            
5287   E066~            #ifdef E932
5288   E066~                        brset   port3Snap1, #$20, L1337 ; Branch if park/neutral                                   
5289   E066~                        ldaa    #$0a                    ; AT in drive, offset = $0a                           
5290   E066~                        ldab    #$25                    ; minValue = $25                            
5291   E066             #endif
5292   E066 BB 01 67    L1337       adda    iscStBase               ; a = t_iscStEct0(ect) + offset                              
5293   E069 24 02                   bcc     L1338                   ; Branch if no overflow                             
5294   E06B 86 FF                   ldaa    #$ff                    ; Use max of $ff                            
5295   E06D 11          L1338       cba                             ;                             
5296   E06E 24 01                   bcc     L1339                   ; Branch if t_iscStEct0(ect) + offset >= minValue                              
5297   E070 17                      tba                             ; Use minValue                             
5298   E071             L1339       .equ    $
5299   E071~            #ifdef E932
5300   E071~                        brclr   port3Snap1, #$20, L1341 ; Branch if AT not in park/neutral
5301   E071~                        staa    iscStBaseAcAdj          ; AT in park, iscStBaseAcAdj = t_iscStEct0(ect) + offset                               
5302   E071~                        bra     L1342                   ;                              
5303   E071~            L1341       cmpa    iscStBaseAcAdj          ; AT in drive, update iscStBaseAc with minimum of iscStBaseAcAdj                             
5304   E071~                        bcc     L1342                   ;                              
5305   E071~                        ldaa    iscStBaseAcAdj          ;                              
5306   E071             #endif
5307   E071 B7 01 68    L1342       staa    iscStBaseAc             ; For E931, iscStBaseAc = min(t_iscStEct0(ect) + offset, minValue)
5308   E074             
5309   E074                                                           
5310   E074                         ;------------------------------------------------------------------
5311   E074                         ; Init iscStStartUsed and iscStStartMaster as long as we are 
5312   E074                         ; startingToCrank. These values are used at engine startup
5313   E074                         ;------------------------------------------------------------------
5314   E074 8F E6 01 0C             brclr   state1, #$01, L1343     ; Bail if startingToCrank clear
5315   E078 CE FE B0                ldx     #L2023                  ; Engine is startingToCrank                               
5316   E07B BD EB 3A                jsr     interpEct               ; b = L2023(ect)                                 
5317   E07E F7 01 64                stab    iscStStartUsed          ; iscStStartUsed = L2023(ect)                               
5318   E081 F7 01 8D                stab    iscStStartMaster        ; iscStStartMaster = L2023(ect)                             
5319   E084             
5320   E084                         ;----------------------------------------------------------------
5321   E084                         ; Section to update iscStStartUsed, iscStStartMaster
5322   E084                         ; and eventually iscYn after the engine is started
5323   E084                         ;
5324   E084                         ; learning variable iscYn is only updated after a certain delay 
5325   E084                         ; has passed since the engine was started. At that point we have 
5326   E084                         ; a good idea of how far we are from the ideal isc step we 
5327   E084                         ; should be using...
5328   E084                         ;----------------------------------------------------------------
5329   E084                         ;------------------------------------------
5330   E084                         ; First check if basic conditions are met 
5331   E084                         ;------------------------------------------
5332   E084 87 E6 11 37 L1343       brset   state1, #$11, L1349     ; bail if notRotating or startingToCrank 
5333   E088 B6 01 8D                ldaa    iscStStartMaster        ; a = iscStStartMaster 
5334   E08B 27 32                   beq     L1349                   ; Bail if iscStStartMaster = 0 (we already updated iscYn once)                             
5335   E08D B6 01 29                ldaa    T40_iscStart            ;                                
5336   E090 26 21                   bne     L1347                   ; Branch if T40_iscStart no yet expired                               
5337   E092             
5338   E092                         ;---------------------------------------------------------------
5339   E092                         ; Engine is running, iscStStartMaster!=0 and T40_iscStart is expired
5340   E092                         ;---------------------------------------------------------------
5341   E092                         ;--------------------------------------------------------------------------
5342   E092                         ; Decrement iscStStartMaster by 1 (min of 0) at around 6Hz (3Hz if cold)
5343   E092                         ;
5344   E092                         ; T40_iscStart is initialized with values from L2024(ect) on
5345   E092                         ; every timer expiry, if L2024(ect)=7 then freqency 
5346   E092                         ; will be around 6Hz... In colder temperature, iscStStartMaster will
5347   E092                         ; be decremented at a slower rate, e.g 3Hz
5348   E092                         ;--------------------------------------------------------------------------
5349   E092 CE FE B8                ldx     #L2024                  ; x points to L2024                              
5350   E095 BD EB 3A                jsr     interpEct               ; b = L2024(ect)                                 
5351   E098 F7 01 29                stab    T40_iscStart            ; T40_iscStart = L2024(ect)                                
5352   E09B 7A 01 8D                dec     iscStStartMaster        ; iscStStartMaster = iscStStartMaster - 1                              
5353   E09E 26 13                   bne     L1347                   ; Branch if iscStStartMaster!=0                             
5354   E0A0             
5355   E0A0                         ;------------------------------------------------------------------------
5356   E0A0                         ; iscStStartMaster reached 0, update iscYn = old iscYn + iscStStartUsed + L2023(ect)
5357   E0A0                         ; and reset iscStStartUsed since we are now finished updating iscYn
5358   E0A0                         ; i.e. both iscStStartMaster and iscStStartUsed are now 0
5359   E0A0                         ;
5360   E0A0                         ; Basically, update the isc learning variables with how much isc offset
5361   E0A0                         ; was required to get the isc step stable upon engine startup. If isc
5362   E0A0                         ; was not stable then iscStStartUsed=0 and we didn't learn anything...
5363   E0A0                         ;------------------------------------------------------------------------
5364   E0A0 BD E4 EF                jsr     iscPointers             ;                                 
5365   E0A3 B6 01 64                ldaa    iscStStartUsed          ; a = iscStStartUsed
5366   E0A6 AB 80                   adda    $00,y                   ; a = iscStStartUsed + iscYn, y = y+1                              
5367   E0A8 CD 09                   decy                            ; y = y - 1                            
5368   E0AA 24 02                   bcc     L1346                   ; Branch if no overflow                             
5369   E0AC 86 FF                   ldaa    #$ff                    ; Use max of $ff                            
5370   E0AE A7 80       L1346       staa    $00,y                   ; iscYn = old iscYn + iscStStartUsed + L2023(ect)
5371   E0B0 7F 01 64                clr     iscStStartUsed          ; iscStStartUsed = 0 since we are now finished updating iscYn
5372   E0B3                                                      
5373   E0B3                         ;-------------------------------------------------
5374   E0B3                         ; Check if we should re-init isc Yn variables???
5375   E0B3                         ;-------------------------------------------------
5376   E0B3 B6 01 62    L1347       ldaa    T40s_iscStable           ;                                  
5377   E0B6 26 04                   bne     L1348                    ; Branch to re-init if T40s_iscStable not expired, i.e. isc is not yet stable                            
5378   E0B8 87 F3 10 09             brset   iscLrnFlags, #$10, L1350 ; Branch if conditions are good to update isc learning variables
5379   E0BC             
5380   E0BC                         ;-------------------------------------------------
5381   E0BC                         ; At this point, isc is not yet stable or 
5382   E0BC                         ; conditions are not good to update isc variables
5383   E0BC                         ;
5384   E0BC                         ; Re-init isc Yn variables 
5385   E0BC                         ;-------------------------------------------------
5386   E0BC BD E5 18    L1348       jsr     iscYnInit               ;                                     
5387   E0BF             
5388   E0BF                         ;----------------------------------------------------------------------------
5389   E0BF                         ; At this point isc not yet stable or engine notRotating or startingToCrank
5390   E0BF                         ; iscStStartUsed = iscStStartMaster 
5391   E0BF                         ; 
5392   E0BF                         ; Basically synch the isc step currently in use with the master value
5393   E0BF                         ;----------------------------------------------------------------------------
5394   E0BF B6 01 8D    L1349       ldaa    iscStStartMaster        ; a = iscStStartMaster                              
5395   E0C2 B7 01 64                staa    iscStStartUsed          ; iscStStartUsed = iscStStartMaster                             
5396   E0C5             
5397   E0C5                         ;-----------------------------------------------------------------------
5398   E0C5                         ; Decrement iscStStall by 3 (min of 0) at 20Hz (T40_stall looping at 2?)???
5399   E0C5                         ;-----------------------------------------------------------------------
5400   E0C5 B6 01 63    L1350       ldaa    iscStStall              ; a = iscStStall                             
5401   E0C8 27 1B                   beq     L1355                   ; Bail if iscStStall already at 0                              
5402   E0CA F6 01 27                ldab    T40_stall                  ;                               
5403   E0CD 26 08                   bne     L1352                   ; Branch if T40_stall not expired                              
5404   E0CF 80 03                   suba    #$03                    ; a = iscStStall-3                            
5405   E0D1 24 01                   bcc     L1351                   ; Branch if no underflow                            
5406   E0D3 4F                      clra                            ; use min of 0                           
5407   E0D4 B7 01 63    L1351       staa    iscStStall              ; iscStStall = max(iscStStall-3, 0)                            
5408   E0D7 C6 02       L1352       ldab    #$02                    ; b = $02                           
5409   E0D9~            #ifdef E932
5410   E0D9~                        brset   port3Snap1, #$20, L1353 ; Branch if park/neutral                                    
5411   E0D9~                        ldab    #$02                    ; Use same value anyway...                             
5412   E0D9             #endif
5413   E0D9 B6 01 27    L1353       ldaa    T40_stall                  ; a = T40_stall                              
5414   E0DC 27 04                   beq     L1354                   ; Branch if T40_stall expired                             
5415   E0DE 11                      cba                             ;                              
5416   E0DF 24 01                   bcc     L1354                   ; Branch to use 2 if T40_stall >= 2                              
5417   E0E1 16                      tab                             ; Use b = T40_stall when T40_stall < 2                           
5418   E0E2 F7 01 27    L1354       stab    T40_stall                  ; T40_stall = min(T40_stall, 2)                              
5419   E0E5             
5420   E0E5                         ;--------------------------------------------
5421   E0E5                         ; Re-init T40_revving to 0.5sec if  
5422   E0E5                         ; tpsRaw < 86% or airVol >= $3a  ???
5423   E0E5                         ;
5424   E0E5                         ; T40_revving will start counting when tpsRaw>86%
5425   E0E5                         ; and airVol < $3a???? 
5426   E0E5                         ;--------------------------------------------
5427   E0E5 96 D2       L1355       ldaa    tpsRaw                  ; a = tpsRaw                              
5428   E0E7 81 DC                   cmpa    #$dc                    ;                             
5429   E0E9 25 06                   bcs     L1356                   ; Branch to re-init if tpsRaw < 86%                             
5430   E0EB 96 E0                   ldaa    airVol                  ; a = airVol                              
5431   E0ED 81 3A                   cmpa    #$3a                    ;                             
5432   E0EF 25 05                   bcs     L1357                   ; Branch if airVol < $3a                             
5433   E0F1 86 14       L1356       ldaa    #$14                    ; 0.5sec                            
5434   E0F3 B7 01 25                staa    T40_revving             ; Re-init T40_revving to 0.5sec                              
5435   E0F6             
5436   E0F6                         ;-------------------------------------------------
5437   E0F6                         ; Set iscFlags1.7 flag if T40_revving is expired
5438   E0F6                         ;
5439   E0F6                         ; Basically, this flag is set when tps has been 
5440   E0F6                         ; high and airVol low for more than 0.5sec 
5441   E0F6                         ;-------------------------------------------------
5442   E0F6 02 F4 7F    L1357       andm    iscFlags1, #$7f         ; Assume flag is 0                               
5443   E0F9 B6 01 25                ldaa    T40_revving             ;                               
5444   E0FC 26 03                   bne     L1358                   ; Branch if T40_revving not expired                               
5445   E0FE 03 F4 80                orm     iscFlags1, #$80         ; T40_revving expired, set flag                                
5446   E101             
5447   E101                         ;---------------------------------------------------------
5448   E101                         ; Section to update iscStStall as long as idle switch 
5449   E101                         ; is off and rpm8>=500 and iscFlags1.7 = 0 (set to 1 when 
5450   E101                         ; tps has been high and airVol low for more than 0.5sec)
5451   E101                         ;
5452   E101                         ; iscStStall will therefore be "stuck" to the value
5453   E101                         ; calculated when all these conditions were met the last 
5454   E101                         ; time. Basically says where we are coming from when 
5455   E101                         ; the throttle plate closes (likeliness of stalling the 
5456   E101                         ; engine...)??
5457   E101                         ;---------------------------------------------------------
5458   E101                         ;------------------------------
5459   E101                         ; First check those conditions
5460   E101                         ;------------------------------
5461   E101 96 F1       L1358       ldaa    port3Snap1              ;                                   
5462   E103 2B 30                   bmi     L1362                   ; Bail if idle position switch is on                             
5463   E105 96 F4                   ldaa    iscFlags1               ;                              
5464   E107 2B 2C                   bmi     L1362                   ; Bail if  tps has been high and airVol low for more than 0.5sec
5465   E109 96 DC                   ldaa    rpm8                    ;                             
5466   E10B 81 40                   cmpa    #$40                    ; 500rpm                             
5467   E10D 25 26                   bcs     L1362                   ; Bail if rpm8 < 500                             
5468   E10F             
5469   E10F                         ;------------------------------------------------
5470   E10F                         ; Set flag, not directly related to calculation
5471   E10F                         ;------------------------------------------------
5472   E10F 03 F3 20                orm     iscLrnFlags, #$20       ; 
5473   E112             
5474   E112                         ;---------------------------------------------------------------
5475   E112                         ; Compute conditionned tps and store in temp2 for 
5476   E112                         ; table interpolation below
5477   E112                         ; condTps (with range of $00 to $a0) = 
5478   E112                         ;       2* max(min(tpsRaw,$ba)-$1a,0)      if tpsRaw <= 23%
5479   E112                         ;       max(min(tpsRaw,$ba)-$1a,0) + $20   if tpsRaw >  23%
5480   E112                         ;---------------------------------------------------------------
5481   E112 D6 D2                   ldab    tpsRaw                  ;                               
5482   E114 CE BA 1A                ldx     #$ba1a                  ;                               
5483   E117 BD EB C4                jsr     clipOffset              ; b = max(min(tpsRaw,$ba)-$1a,0)-> returns b = $00 to $a0  (tpsRaw 10% to 73%)                                    
5484   E11A C1 20                   cmpb    #$20                    ;                              
5485   E11C 22 03                   bhi     L1359                   ; Branch if max(min(tpsRaw,$ba)-$1a,0) > $20 (tpsRaw>23%)                               
5486   E11E 58                      aslb                            ; b =  2* max(min(tpsRaw,$ba)-$1a,0)                              
5487   E11F 20 02                   bra     L1360                   ;                              
5488   E121 CB 20       L1359       addb    #$20                    ; b = max(min(tpsRaw,$ba)-$1a,0) + $20                             
5489   E123 D7 58       L1360       stab    temp2                   ; temp2 = condTps                             
5490   E125             
5491   E125                         ;--------------------------------------------------------------
5492   E125                         ; Update iscStStall =  max(old iscStStall, t_iscStStall(condTps)) 
5493   E125                         ;--------------------------------------------------------------
5494   E125 CE FE D0                ldx     #t_iscStStall           ; x points to t_iscStStall                               
5495   E128~            #ifdef E932
5496   E128~                        brset   port3Snap1, #$20, L1361 ; Branch if park/neutral                                    
5497   E128~                        ldx     #L2030                  ; x points to L2030 for E932                               
5498   E128             #endif
5499   E128 96 58       L1361       ldaa    temp2                   ; a = condTps                             
5500   E12A BD EB 4C                jsr     interp32                ; b = t_iscStStall(condTps)                                 
5501   E12D F1 01 63                cmpb    iscStStall              ;                              
5502   E130 25 03                   bcs     L1362                   ; Branch if t_iscStStall(condTps) < iscStStall                             
5503   E132 F7 01 63                stab    iscStStall              ; iscStStall =  max(old iscStStall, t_iscStStall(condTps))
5504   E135                                                       
5505   E135                         ;--------------------------------------------------------
5506   E135                         ; If idle switch if off, 
5507   E135                         ; subtract (iscStepTarg - iscStepCurr) from iscStStall 
5508   E135                         ;
5509   E135                         ; Basically reduce iscStStall if the current isc step is
5510   E135                         ; lower than the target. Reduce it by the same amount...
5511   E135                         ;--------------------------------------------------------
5512   E135 96 F1       L1362       ldaa    port3Snap1              ; a = port3Snap1                                  
5513   E137 2A 15                   bpl     L1365                   ; Bail if idle switch is on                              
5514   E139 98 F2                   eora    oldP3Snap1              ;                                   
5515   E13B 2A 11                   bpl     L1365                   ; Bail if it changed in that split second?????? (Am I missing something??? maybe they changed their mind...)                              
5516   E13D             
5517   E13D D6 FD                   ldab    iscStepTarg             ; b = iscStepTarg                                 
5518   E13F D0 49                   subb    iscStepCurr             ; b = iscStepTarg - iscStepCurr                                
5519   E141 24 01                   bcc     L1363                   ; Branch if result positive                             
5520   E143 5F                      clrb                            ; Use min of 0                            
5521   E144 B6 01 63    L1363       ldaa    iscStStall              ; a = iscStStall                              
5522   E147 10                      sba                             ; a = iscStStall - (iscStepTarg - iscStepCurr)                            
5523   E148 24 01                   bcc     L1364                   ; Branch if no underflow                             
5524   E14A 4F                      clra                            ; Use min of 0                            
5525   E14B B7 01 63    L1364       staa    iscStStall              ; iscStStall =  iscStStall - (iscStepTarg - iscStepCurr) 
5526   E14E                                                             
5527   E14E                         ;----------------------------------
5528   E14E                         ; Update  iscStBarOff
5529   E14E                         ;----------------------------------
5530   E14E B6 01 52    L1365       ldaa    baroCond                ; a = baroCond                                  
5531   E151 CE FE EE                ldx     #t_iscStBaro            ;                                     
5532   E154 BD EB 4C                jsr     interp32                ; b = t_iscStBaro(baroCond)                                
5533   E157 F7 01 6A                stab    iscStBarOff             ; iscStBarOff = t_iscStBaro(baroCond)
5534   E15A                                                                        
5535   E15A                         ;--------------------------------------------
5536   E15A                         ; Reset T0p5_crCold to 0 if notRotating
5537   E15A                         ; or if T0p5_crCold >= $3c (not possible???)
5538   E15A                         ;--------------------------------------------
5539   E15A 87 E6 10 07             brset   state1, #$10, L1367     ; Branch to reset T0p5_crCold if notRotating
5540   E15E 86 3C                   ldaa    #$3c                    ;                             
5541   E160 B1 01 41                cmpa    T0p5_crCold             ;                                    
5542   E163 24 03                   bcc     L1368                   ; Branch if T0p5_crCold <= $3c                              
5543   E165 7F 01 41    L1367       clr     T0p5_crCold             ; reset T0p5_crCold to 0                              
5544   E168             
5545   E168                         ;---------------------------------------
5546   E168                         ; Update T0p5_crCold to $00 or $3c 
5547   E168                         ; and iscFlags1.1 flag when startingToCrank
5548   E168                         ;---------------------------------------
5549   E168 8F E6 01 18 L1368       brclr   state1, #$01, L1370     ; Bail if startingToCrank clear
5550   E16C 5F                      clrb                            ; preload b=0                            
5551   E16D 96 D3                   ldaa    ectFiltered             ;                                    
5552   E16F 81 1B                   cmpa    #$1b                    ; 88degC                               
5553   E171 24 02                   bcc     L1369                   ; Branch if temperature(ectFiltered) <= 88degC                              
5554   E173 C6 3C                   ldab    #$3c                    ; b= $3c                             
5555   E175 F7 01 41    L1369       stab    T0p5_crCold             ; T0p5_crCold = 0 or $3c                                
5556   E178 02 F4 DF                andm    iscFlags1, #$df         ; Assume we reset bit                                
5557   E17B 96 D4                   ldaa    iatChecked              ;                                   
5558   E17D 81 29                   cmpa    #$29                    ; 75degC                             
5559   E17F 25 03                   bcs     L1370                   ; Branch if temperature(iat) > 75degC
5560   E181 03 F4 20                orm     iscFlags1, #$20         ; Set flag                                
5561   E184             
5562   E184                         ;-------------------------------------------------------------
5563   E184                         ; Update iscStBaseCSt if T0p5_crCold not expired, else use iscStBaseCSt = 0
5564   E184                         ;
5565   E184                         ;      iscStBaseCSt =  (0 or $1e or $0f) * T0p5_crCold / $3c +  t_iscStEct0
5566   E184                         ;
5567   E184                         ; iscStBaseCSt is basically the iscStep when a cold engine 
5568   E184                         ; is being started, starts with a high value and then is 
5569   E184                         ; decreased (through T0p5_crCold) towards normal  isc step 
5570   E184                         ; over a period of 120sec
5571   E184                         ;-------------------------------------------------------------
5572   E184 5F          L1370       clrb                            ; preload b = 0                            
5573   E185 B6 01 41                ldaa    T0p5_crCold             ;                                    
5574   E188 27 15                   beq     L1372                   ; Bail to store 0 if T0p5_crCold expired                              
5575   E18A 86 3C                   ldaa    #$3c                    ;                             
5576   E18C 97 57                   staa    temp1                   ; temp1 = $3c                               
5577   E18E             #ifdef E931
5578   E18E 86 1E                   ldaa    #$1e                    ; assume low iat, high value...a = $1e                            
5579   E190~            #else
5580   E190~                        ldaa    #$19                    ;                             
5581   E190             #endif
5582   E190 8F F4 20 02             brclr   iscFlags1, #$20, L1371  ; Branch if not (startingToCrank and temperature(iat) < 75degC)                               
5583   E194 86 0F                   ldaa    #$0f                    ; high iat, use lower value... a = $0f                            
5584   E196 F6 01 41    L1371       ldab    T0p5_crCold             ; b = T0p5_crCold                                   
5585   E199 3D                      mul                             ; d = $1e * T0p5_crCold                            
5586   E19A 15 57                   div     temp1                   ; d = $1e * T0p5_crCold / $3c                            
5587   E19C FB FE C8                addb    t_iscStEct0             ; b = $1e * T0p5_crCold / $3c +  t_iscStEct0                                  
5588   E19F F7 01 69    L1372       stab    iscStBaseCSt            ; iscStBaseCSt =  0 or $1e * T0p5_crCold / $3c +  t_iscStEct0                               
5589   E1A2             
5590   E1A2                         ;--------------------------------------------------
5591   E1A2                         ; Check if iscStepCurr and iscStepCom are in synch?
5592   E1A2                         ;--------------------------------------------------
5593   E1A2 0F                      sei                             ; We don't want ISC values to change during check                                           
5594   E1A3 96 49                   ldaa    iscStepCurr             ;                                                                                              
5595   E1A5 43                      coma                            ;                                                                                           
5596   E1A6 84 7F                   anda    #$7f                    ;                                                                                           
5597   E1A8 91 48                   cmpa    iscStepCom              ;                                                                                                 
5598   E1AA 0E                      cli                             ;                                                                                           
5599   E1AB 26 1C                   bne     L1373                   ; Branch if  iscStepCurr and iscStepCom are not in synch                                             
5600   E1AD             
5601   E1AD                         ;-------------------------------------------
5602   E1AD                         ; iscStepCurr and iscStepCom are in synch
5603   E1AD                         ; Check ISC variables against min/max
5604   E1AD                         ;-------------------------------------------
5605   E1AD CE B0 00                ldx     #$b000                  ; x = $b000                                
5606   E1B0 9C 44                   cpx     isc0                    ;                             
5607   E1B2 25 15                   bcs     L1373                   ; Branch to re-init if isc0 > $b000                               
5608   E1B4 9C 46                   cpx     isc1                    ;                             
5609   E1B6 25 11                   bcs     L1373                   ; Branch to re-init if isc1 > $b000                              
5610   E1B8 CE 6C 00                ldx     #$6c00                  ; x = $6c00                              
5611   E1BB 9C 44                   cpx     isc0                    ;                             
5612   E1BD 22 0A                   bhi     L1373                   ; Branch to re-init if isc0 < $6c00                             
5613   E1BF 9C 46                   cpx     isc1                    ;                             
5614   E1C1 22 06                   bhi     L1373                   ; Branch to re-init if isc1 < $6c00                             
5615   E1C3 87 4B 20 10             brset   iscFlags0, #$20, L1374  ; Branch if the ISC needs min calibration
5616   E1C7 20 3C                   bra     L1379                   ; Branch to continue processing normal flow???                              
5617   E1C9             
5618   E1C9                         ;-----------------------------------------------
5619   E1C9                         ; iscStepCurr and iscStepCom are not in synch
5620   E1C9                         ; re-initialize ISC variables 
5621   E1C9                         ; set isc flag indicating we need min calibration
5622   E1C9                         ; reset all other isc flags
5623   E1C9                         ;-----------------------------------------------
5624   E1C9 CC 8C 00    L1373       ldd     #$8c00                  ;                               
5625   E1CC DD 44                   std     isc0                    ;                             
5626   E1CE DD 46                   std     isc1                    ;                             
5627   E1D0 BD E5 18                jsr     iscYnInit               ;                                     
5628   E1D3 86 20                   ldaa    #$20                    ; Set flag indicating we need to calibrate ISC, reset all other flags
5629   E1D5 97 4B                   staa    iscFlags0               ;                              
5630   E1D7             
5631   E1D7                         ;------------------------------------------------------------------------
5632   E1D7                         ; Section for ISC min calibration, code is triggered by iscFlags0.5 being set
5633   E1D7                         ;
5634   E1D7                         ; Min calibration proceed as follows. 
5635   E1D7                         ;
5636   E1D7                         ;       1) iscFlags0.5 is set to indicate calibration is required, 
5637   E1D7                         ;          iscStepCurr init to 135, iscStepTarg init to 0
5638   E1D7                         ;       2) iscFlags0.0 is set to indicate calibration is started, 
5639   E1D7                         ;          waiting for iscStepCurr to reach iscStepTarg of 0
5640   E1D7                         ;       3) iscFlags0.1 is set to indicate calibration is finished,
5641   E1D7                         ;          iscStepCurr reached 0, we are therefore now certain that
5642   E1D7                         ;          the isc pintle is physically at position 0.iscStepTarg 
5643   E1D7                         ;          is now init to 6, waiting for iscStepCurr to reach iscStepTarg
5644   E1D7                         ;       4) iscStepCurr reached iscStepTarg = 6, iscFlags0.0.1.5 
5645   E1D7                         ;          are all reset
5646   E1D7                         ; 
5647   E1D7                         ;------------------------------------------------------------------------
5648   E1D7 87 4B 02 16 L1374       brset   iscFlags0, #$02, L1376  ; Branch if calibration is finished, we are waiting for ISC to go back to iscStepCurr=6                                
5649   E1DB 87 4B 01 0A             brset   iscFlags0, #$01, L1375  ; Branch if calibration is started, we are waiting for ISC to reach iscStepCurr=0                              
5650   E1DF 86 87                   ldaa    #$87                    ; calibration not started, use iscStepCurr = a = $87  (135, above max, maybe during calibration?)                          
5651   E1E1 0F                      sei                             ;                             
5652   E1E2 BD E4 B6                jsr     iscStepComp             ; iscStepCurr = $87, iscStepCom = (~$87 & 7F) 
5653   E1E5 0E                      cli                             ;                             
5654   E1E6 03 4B 01                orm     iscFlags0, #$01         ; Set flag indicating we just calculated iscStepCom?                              
5655   E1E9 5F          L1375       clrb                            ; use iscStepTarg = b = 0                             
5656   E1EA 96 49                   ldaa    iscStepCurr             ; a = iscStepCurr                               
5657   E1EC 26 09                   bne     L1377                   ; Branch if iscStepCurr != 0                             
5658   E1EE 03 4B 02                orm     iscFlags0, #$02         ; iscStepCurr=0, set flag                               
5659   E1F1 C6 06       L1376       ldab    #$06                    ; b = $06                            
5660   E1F3 D1 49                   cmpb    iscStepCurr             ;                                
5661   E1F5 27 05                   beq     L1378                   ; Branch if iscStepCurr=$06                             
5662   E1F7 D7 FD       L1377       stab    iscStepTarg             ; iscStepTarg = $00 or $06                                
5663   E1F9 7E E2 93                jmp     L1389                   ; Bail
5664   E1FC 4F          L1378       clra                            ; a = 0                            
5665   E1FD 0F                      sei                             ;                             
5666   E1FE BD E4 B6                jsr     iscStepComp             ; iscStepCurr = $0, iscStepCom = (~$0 & 7F)                                   
5667   E201 0E                      cli                             ;                             
5668   E202 02 4B DC                andm    iscFlags0, #$dc         ; Calibration is over, reset all flags 0010 0011                                
5669   E205             
5670   E205                         ;--------------------------------------------------------
5671   E205                         ; Normal flow continues,
5672   E205                         ; Check if  max calibration need to be performed
5673   E205                         ;--------------------------------------------------------
5674   E205 87 4B 80 09 L1379       brset   iscFlags0, #$80, L1380  ; Branch if max calibration is required?
5675   E209 7D 01 24                tst     T40_noPower             ;                                    
5676   E20C 26 1F                   bne     L1382                   ; Branch to normal flow if we are not about to loose power                              
5677   E20E 87 4B 40 1B             brset   iscFlags0, #$40, L1382  ; Branch to normal flow if max calibration already performed                              
5678   E212             
5679   E212                         ;-------------------------------------------------------------
5680   E212                         ; At this point max calibration flag is set or we are about 
5681   E212                         ; to loose power and max calibration was not performed
5682   E212                         ;
5683   E212                         ; Set iscStepTarg to 135 if iscStepCurr not already at 135
5684   E212                         ;-------------------------------------------------------------
5685   E212 03 4B 80    L1380       orm     iscFlags0, #$80         ; Set max calibration flag is case it was not set                               
5686   E215 86 87                   ldaa    #$87                    ; a = 135                            
5687   E217 91 49                   cmpa    iscStepCurr             ;                                
5688   E219 27 05                   beq     L1381                   ; Branch if iscStepCurr already at 135
5689   E21B 97 FD                   staa    iscStepTarg             ; Set target to iscStepTarg = 135                                
5690   E21D 7E E2 93                jmp     L1389                   ;                              
5691   E220             
5692   E220                         ;-------------------------------------------------------------
5693   E220                         ; At this point iscStepCurr is 135, we are therefore sure the 
5694   E220                         ; isc pintle is physically at its maximum value of 120,
5695   E220                         ; set iscStepCurr=120 and set/reset flags
5696   E220                         ;-------------------------------------------------------------
5697   E220 86 78       L1381       ldaa    #$78                    ; a = $78 (120, max usable value)                            
5698   E222 0F                      sei                             ;                             
5699   E223 BD E4 B6                jsr     iscStepComp             ; iscStepCurr = $78, iscStepCom = (~$78 & 7F)
5700   E226 0E                      cli                             ;                             
5701   E227 03 4B 40                orm     iscFlags0, #$40         ; set flag 0100 0000, calibration done?                               
5702   E22A 02 4B 7F                andm    iscFlags0, #$7f         ; reset flag indicating we need max calibration 1000 0000                               
5703   E22D             
5704   E22D                         ;-----------------------------------------------------
5705   E22D                         ; if the ECU is about to loose power then 
5706   E22D                         ;
5707   E22D                         ; set/reset flags 
5708   E22D                         ; use a fixed ISC step of $5a 
5709   E22D                         ; don't re-init updIscStableTimer since we loose power...
5710   E22D                         ;-----------------------------------------------------
5711   E22D 02 4B EF    L1382       andm    iscFlags0, #$ef         ; Assume we reset 0001 0000, updated below                               
5712   E230 B6 01 24                ldaa    T40_noPower             ;                                    
5713   E233 26 0A                   bne     L1383                   ; Branch if timer not expired                             
5714   E235 02 4B 40                andm    iscFlags0, #$40         ; reset max calibration flag? 0100 0000                               
5715   E238 03 4B 10                orm     iscFlags0, #$10         ; Set 0001 0000                               
5716   E23B C6 5A                   ldab    #$5a                    ; b = $5a                            
5717   E23D 20 4F                   bra     L1388                   ; Branch to use fix ISC step of $5a, i.e. 3/4 of full range
5718   E23F             
5719   E23F                         ;----------------------------------------------------
5720   E23F                         ; If the engine is running but we are not receiving 
5721   E23F                         ; airflow sensor interrupts then 
5722   E23F                         ;
5723   E23F                         ; set/reset flags
5724   E23F                         ; re-init iscYn variables
5725   E23F                         ; re-init updIscStableTimer
5726   E23F                         ; use a fixed ISC step of $3a
5727   E23F                         ;----------------------------------------------------
5728   E23F 02 4B F7    L1383       andm    iscFlags0, #$f7         ; Assume we reset 00001000, updated below                               
5729   E242 8F E6 02 16             brclr   state1, #$02, L1384     ; Bail if pulse accumulator interrupts are being received 
5730   E246 87 E6 11 12             brset   state1, #$11, L1384     ; Bail if notRotating or startingToCrank
5731   E24A BD E5 18                jsr     iscYnInit               ; Init variables                                     
5732   E24D 02 4B 40                andm    iscFlags0, #$40         ; reset max calibration flag? 0100 0000                               
5733   E250 03 4B 08                orm     iscFlags0, #$08         ; set 0000 1000                               
5734   E253 C6 50                   ldab    #$50                    ;                             
5735   E255 BD E4 BF                jsr     updIscStableTimer       ; re-init updIscStableTimer                                 
5736   E258 C6 3A                   ldab    #$3a                    ; b = $3a                            
5737   E25A 20 32                   bra     L1388                   ; Branch to use fix ISC step of $3a               
5738   E25C                                        
5739   E25C                         ;---------------------------------------------------
5740   E25C                         ; Section to check for idle speed adjustment mode, 
5741   E25C                         ; i.e. both ECU test mode terminal grounded and 
5742   E25C                         ; timing adjustment terminal grounded                             
5743   E25C                         ;---------------------------------------------------
5744   E25C 02 4B FB    L1384       andm    iscFlags0, #$fb         ; Reset 00000010
5745   E25F 96 D8                   ldaa    port4Snap               ; a = port4Snap                                  
5746   E261 84 18                   anda    #$18                    ; Keep only ECU test mode terminal grounded & timing adjustment terminal grounded               
5747   E263 81 18                   cmpa    #$18                    ; ECU test mode terminal grounded & timing adjustment terminal grounded                             
5748   E265 26 08                   bne     L1385                   ; Bail if not both of them grounded                             
5749   E267 87 F1 04 04             brset   port3Snap1, #$04, L1385 ; Both terminal grounded, bail if car is moving
5750   E26B~            #ifdef E932
5751   E26B~                        brclr   port3Snap1, #$20, L1385 ; Bail if not in park/neutral???                                    
5752   E26B             #endif
5753   E26B 8F E6 11 05             brclr   state1, #$11, L1386     ; branch if notRotating and startingToCrank clear
5754   E26F             
5755   E26F                         ;------------------------------------------------------------
5756   E26F                         ; Engine is either notRotating or startingToCrank
5757   E26F                         ; Reset timer (always done when both terminal not grounded)
5758   E26F                         ;------------------------------------------------------------
5759   E26F 86 08       L1385       ldaa    #$08                    ; 0.2s 
5760   E271 B7 01 2B                staa    T40_iSpAdj              ;                               
5761   E274             
5762   E274                         ;--------------------------------------------------
5763   E274                         ; If Timer T40_iSpAdj is expired (0.2 sec after
5764   E274                         ; both terminals grounded) we are in basic idle 
5765   E274                         ; speed adjustment mode. Branch accordingly...
5766   E274                         ;--------------------------------------------------
5767   E274 B6 01 2B    L1386       ldaa    T40_iSpAdj              ;                               
5768   E277 26 23                   bne     L1390                   ; Branch to next section if timer not expired
5769   E279             
5770   E279                         ;----------------------------------------------------
5771   E279                         ; Timer is expired, we are in basic idle 
5772   E279                         ; speed adjustment mode...
5773   E279                         ;
5774   E279                         ; Just compute iscStepTarg (target idle speed) as a
5775   E279                         ; function of temperature and barometric pressure,
5776   E279                         ; reset iscLrnFlags and iscStStall and exit from subroutine
5777   E279                         ;----------------------------------------------------
5778   E279 03 4B 04                orm     iscFlags0, #$04         ; Set flag                               
5779   E27C C6 50                   ldab    #$50                    ;                             
5780   E27E BD E4 BF                jsr     updIscStableTimer       ;                              
5781   E281 CE FE C8                ldx     #t_iscStEct0            ; x points to iscStepCurr(as a function of ECT) table                                
5782   E284 BD EB 3A                jsr     interpEct               ; b = t_iscStEct0(ect), basic isc value we want as a function of ECT                                 
5783   E287 FB 01 6A                addb    iscStBarOff             ; b = t_iscStEct0(ect) + iscStBarOff, Add an offset to compensate for barometric pressure
5784   E28A 24 02                   bcc     L1388                   ; Branch if no overflow                             
5785   E28C C6 FF                   ldab    #$ff                    ; Use max
5786   E28E BD E4 C8    L1388       jsr     iscStepMaxFunc          ; Apply maximum to calculated value                            
5787   E291 D7 FD                   stab    iscStepTarg             ; iscStepTarg =  t_iscStEct0(ect) + iscStBarOff 
5788   E293 4F          L1389       clra                            ;                             
5789   E294 97 F3                   staa    iscLrnFlags             ; iscLrnFlags = 0                             
5790   E296 B7 01 63                staa    iscStStall              ; iscStStall = 0                             
5791   E299 7E E4 B5                jmp     L1431                   ; Bail of subroutine
5792   E29C                                                                        
5793   E29C                         ;------------------------------------------------
5794   E29C                         ; Basic idle speed adjustment mode is not active
5795   E29C                         ; Section to update ISC stuff, long...
5796   E29C                         ;------------------------------------------------
5797   E29C 87 E6 11 08 L1390       brset   state1, #$11, L1391     ; Branch if notRotating or startingToCrank
5798   E2A0             
5799   E2A0                         ;--------------------------------------
5800   E2A0                         ; Engine is running, set /reset flags
5801   E2A0                         ;--------------------------------------
5802   E2A0 02 F3 FE                andm    iscLrnFlags, #$fe       ; Reset bit 0                               
5803   E2A3 03 F4 01                orm     iscFlags1, #$01         ; Set flag indicating "normal running mode"??                               
5804   E2A6 20 12                   bra     L1392                   ; Branch to continue                             
5805   E2A8             
5806   E2A8                         ;----------------------------------
5807   E2A8                         ; notRotating or startingToCrank
5808   E2A8                         ;----------------------------------
5809   E2A8 C6 01       L1391       ldab    #$01                    ;                             
5810   E2AA D7 F3                   stab    iscLrnFlags             ; Reset all bit to 0 and set bit 0 to 1                              
5811   E2AC             
5812   E2AC                         ;---------------------------------------------------------------
5813   E2AC                         ; Reset iscFlags1.0 if key in start and iscStTargSpec = iscStepCurr??
5814   E2AC                         ;---------------------------------------------------------------
5815   E2AC 87 F1 40 0A             brset   port3Snap1, #$40, L1392 ; Branch if key is not is start                                   
5816   E2B0 B6 01 66                ldaa    iscStTargSpec           ;                              
5817   E2B3 91 49                   cmpa    iscStepCurr             ;                                
5818   E2B5 26 03                   bne     L1392                   ; Branch if iscStTargSpec != iscStepCurr                             
5819   E2B7 02 F4 FE                andm    iscFlags1, #$fe         ;                                
5820   E2BA             
5821   E2BA                         ;------------------------------------------------------------------
5822   E2BA                         ; Init T40_acOnTrans to 0.1sec if A/C switch was just turned on?
5823   E2BA                         ;------------------------------------------------------------------
5824   E2BA 96 F1       L1392       ldaa    port3Snap1              ;                                   
5825   E2BC 98 F2                   eora    oldP3Snap1              ;                                   
5826   E2BE 85 10                   bita    #$10                    ;                             
5827   E2C0 27 04                   beq     L1393                   ; Branch if A/C switch did not change state                              
5828   E2C2 8F F1 10 02             brclr   port3Snap1, #$10, L1394 ; Branch if A/C switch is on                                   
5829   E2C6             L1393       .equ    $
5830   E2C6             #ifdef E931
5831   E2C6 20 05                   bra     L1395                   ;                               
5832   E2C8~            #else
5833   E2C8~                        bita    #$20                    ;                             
5834   E2C8~                        beq     L1395                   ;                              
5835   E2C8~                        brset   port3Snap1, #$20, L1395 ;                                    
5836   E2C8             #endif
5837   E2C8 C6 04       L1394       ldab    #$04                    ; 0.1sec                            
5838   E2CA F7 01 28                stab    T40_acOnTrans           ; T40_acOnTrans = 0.1sec
5839   E2CD                                                        
5840   E2CD                         ;--------------------------------------------------------------
5841   E2CD                         ; Update iscLrnFlags.2, flag indicating engine is running too slow? 
5842   E2CD                         ;--------------------------------------------------------------
5843   E2CD 96 F3       L1395       ldaa    iscLrnFlags              ; a = old iscLrnFlags                             
5844   E2CF 02 F3 FB                andm    iscLrnFlags, #$fb        ; Assume we reset 00000100, updated below                               
5845   E2D2 D6 D3                   ldab    ectFiltered              ;                                    
5846   E2D4 C1 3C                   cmpb    #$3c                     ; 55degC                             
5847   E2D6 24 19                   bcc     L1396                    ; Bail if temperature(ectFiltered) <= 55degC                               
5848   E2D8 D6 DC                   ldab    rpm8                     ;                             
5849   E2DA C1 40                   cmpb    #$40                     ;                             
5850   E2DC 24 13                   bcc     L1396                    ; Bail if rpm8 >=500                              
5851   E2DE 87 F3 01 0F             brset   iscLrnFlags, #$01, L1396 ; Bail if engine is notRotating or startingToCrank (and basic idle speed adjustment mode is off)                              
5852   E2E2 7D 01 28                tst     T40_acOnTrans            ;                               
5853   E2E5 26 0A                   bne     L1396                    ; Bail if timer not expired                              
5854   E2E7             
5855   E2E7                         ;----------------------------------------------------------------------------------
5856   E2E7                         ; At this point 
5857   E2E7                         ;    temperature(ectFiltered) > 55degC 
5858   E2E7                         ;    rpm8 < 500rpm 
5859   E2E7                         ;    engine is running
5860   E2E7                         ;    T40_acOnTrans is expired (A/C switch was turned on more than 0.1sec ago, or never...)
5861   E2E7                         ;
5862   E2E7                         ; Set iscLrnFlags.2 indicating the engine is running to slow 
5863   E2E7                         ; (even though A/C transcient was ignored for 0.1sec)
5864   E2E7                         ;
5865   E2E7                         ; Clear T40_checkTargRpm if this condition was just detected in order to perform
5866   E2E7                         ; current versus target rpm comparison right away and adjust isc step before 
5867   E2E7                         ; the engine stalls...
5868   E2E7                         ;----------------------------------------------------------------------------------
5869   E2E7 03 F3 04                orm     iscLrnFlags, #$04       ; set 0000 0100                               
5870   E2EA 84 04                   anda    #$04                    ; a = old iscLrnFlags & 0000 0100                            
5871   E2EC 26 03                   bne     L1396                   ; Bail if old iscLrnFlags.2 was set                              
5872   E2EE 7F 01 2A                clr     T40_checkTargRpm        ; old iscLrnFlags.2 was not set, reset timer to trigger fast rpm update... 
5873   E2F1                                                        
5874   E2F1                         ;---------------------------------
5875   E2F1                         ; Update updIscStableTimer if ???  
5876   E2F1                         ;---------------------------------
5877   E2F1 8F F3 20 05 L1396       brclr   iscLrnFlags, #$20, Ne301 ; Branch if                                
5878   E2F5 C6 50                   ldab    #$50                     ;                             
5879   E2F7 BD E4 BF                jsr     updIscStableTimer        ;                                         
5880   E2FA             Ne301        .equ    $
5881   E2FA             
5882   E2FA                         ;--------------------------------------------
5883   E2FA                         ; Update updIscStableTimer if ???  for E931 
5884   E2FA                         ;--------------------------------------------
5885   E2FA             #ifdef E931
5886   E2FA 8F E5 08 05             brclr    ftrimFlags, #$08, L1397 ; Branch if not (speed>24km/h and port3.0 is set???)                                      
5887   E2FE C6 50                   ldab    #$50                     ; speed>24km/h and port3.0 is set, update timer                            
5888   E300 BD E4 BF                jsr     updIscStableTimer        ;                                          
5889   E303             #endif
5890   E303             
5891   E303                         ;-------------------------------------------------------------------
5892   E303                         ; Section to update iscLrnFlags.4, flag indicating that conditions are
5893   E303                         ; good to update the isc learning variables???
5894   E303                         ;-------------------------------------------------------------------
5895   E303 02 F3 EF    L1397       andm    iscLrnFlags, #$ef       ; Assume we reset iscLrnFlags.4 (0001 0000)                                
5896   E306 96 F1                   ldaa    port3Snap1              ;                                   
5897   E308 2A 0F                   bpl     L1398                   ; Branch if idle position switch is off                              
5898   E30A 87 F1 04 0B             brset   port3Snap1, #$04, L1398 ; Branch if car is moving
5899   E30E B6 01 62                ldaa    T40s_iscStable          ;                                  
5900   E311 26 06                   bne     L1398                   ; Branch if isc not stable yet
5901   E313 96 DC                   ldaa    rpm8                    ;                             
5902   E315 81 2A                   cmpa    #$2a                    ;                             
5903   E317 24 08                   bcc     L1399                   ; Branch if rpm8 >= 328rpm                              
5904   E319 8F E6 01 09 L1398       brclr   state1, #$01, L1400     ; Branch if startingToCrank clear
5905   E31D 87 F4 01 05             brset   iscFlags1, #$01, L1400  ; Branch if not (key in start and iscStTargSpec = iscStepCurr)
5906   E321             
5907   E321                         ;--------------------------------------------
5908   E321                         ; At this point
5909   E321                         ;      car is not moving
5910   E321                         ; and idle switch is on 
5911   E321                         ; and isc is stable
5912   E321                         ; and rpm8 >= 328
5913   E321                         ;
5914   E321                         ; or these conditions are not met but 
5915   E321                         ;     engine is startingToCrank 
5916   E321                         ; and (key in start and iscStTargSpec = iscStepCurr)
5917   E321                         ;
5918   E321                         ; Set iscLrnFlags.4 indicating we can update the isc 
5919   E321                         ; learning variables?
5920   E321                         ;--------------------------------------------
5921   E321 03 F3 10    L1399       orm     iscLrnFlags, #$10       ;                                
5922   E324 20 05                   bra     L1401                   ;                              
5923   E326             
5924   E326                         ;-----------------------------------------------------
5925   E326                         ; At this point, 
5926   E326                         ;     car is moving
5927   E326                         ;  or idle position switch is off 
5928   E326                         ;  or isc not yet stable
5929   E326                         ;  or rpm < 328
5930   E326                         ;
5931   E326                         ; and engine is startingToCrank or key is not 
5932   E326                         ; in start or iscStTargSpec != iscStepCurr
5933   E326                         ;
5934   E326                         ; Re-init T40_iscLrn to 5sec
5935   E326                         ; Conditions are not good to update ISC learning variables?
5936   E326                         ; Flag is already reset so just reset that timer so that
5937   E326                         ; we have a 5sec delay when we can go back to being able
5938   E326                         ; to update them...
5939   E326                         ;--------------------------------------------------------------
5940   E326 C6 C8       L1400       ldab    #$c8                    ; 5sec                            
5941   E328 F7 01 26                stab    T40_iscLrn              ; T40_iscLrn = 5sec                               
5942   E32B             
5943   E32B                         ;---------------------------------------------------------------------------------------------------
5944   E32B                         ; Check whether abs(idleSpdTarg - rpm8) > (5/256 * idleSpdTarg)
5945   E32B                         ;
5946   E32B                         ; Basically chech if target and current rpm are more than 2% apart                            
5947   E32B                         ;---------------------------------------------------------------------------------------------------
5948   E32B 8F F3 10 19 L1401       brclr   iscLrnFlags, #$10, L1403 ; Bail if conditions are not good to update isc variables                               
5949   E32F B6 01 2A                ldaa    T40_checkTargRpm         ;                               
5950   E332 26 14                   bne     L1403                    ; Bail if timer not expired                             
5951   E334 96 FE                   ldaa    idleSpdTarg              ; a = idleSpdTarg                                  
5952   E336 90 DC                   suba    rpm8                     ; a = idleSpdTarg - rpm8                            
5953   E338 76 00 58                ror     temp2                    ; shift sign (carry) of result in temp2.7
5954   E33B 2A 01                   bpl     L1402                    ; Branch if (idleSpdTarg - rpm8) >= 0                             
5955   E33D 40                      nega                             ; a =  abs(idleSpdTarg - rpm8)                            
5956   E33E 36          L1402       psha                             ; st0 = abs(idleSpdTarg - rpm8)                            
5957   E33F 96 FE                   ldaa    idleSpdTarg              ; a = idleSpdTarg                                   
5958   E341 C6 0A                   ldab    #$0a                     ; b = $0a                             
5959   E343 3D                      mul                              ; d = $0a * idleSpdTarg                            
5960   E344 33                      pulb                             ; b = abs(idleSpdTarg - rpm8); a = $0a/256 * idleSpdTarg                            
5961   E345 11                      cba                              ;                             
5962   E346 25 03                   bcs     L1404                    ; Branch if ($0a/256 * idleSpdTarg) < abs(idleSpdTarg - rpm8), basically branch if difference between current rpm and desired one is too high                            
5963   E348 7E E3 A7    L1403       jmp     L1416                    ; Jump to next section
5964   E34B                                          
5965   E34B                         ;------------------------------------------------------------------
5966   E34B                         ; At this point abs(idleSpdTarg - rpm8) > (5/256 * idleSpdTarg)
5967   E34B                         ; or equivalently  abs(idleSpdTarg - rpm8)/idleSpdTarg > 2%
5968   E34B                         ; i.e. Target and current rpm are more than 2% apart
5969   E34B                         ;
5970   E34B                         ; Section to update iscYn (until L1415).
5971   E34B                         ;
5972   E34B                         ; Basically this section increases the current iscYn (iscY1, iscY2 
5973   E34B                         ; or iscY3) if the current rpm is lower than the target and vice-versa
5974   E34B                         ; iscYn is centered at $80 (100%, no correction). The isc step used 
5975   E34B                         ; is increase/decreased by iscYn-$80 later in the code
5976   E34B                         ;------------------------------------------------------------------
5977   E34B 58          L1404       aslb                            ; b = 2 * abs(idleSpdTarg - rpm8)                            
5978   E34C 25 03                   bcs     L1405                   ; branch to use max of $ff if overflow                             
5979   E34E 58                      aslb                            ; b = 4 * abs(idleSpdTarg - rpm8)                             
5980   E34F 24 02                   bcc     L1406                   ; Branch if no overflow                             
5981   E351 C6 FF       L1405       ldab    #$ff                    ; use max of $ff                            
5982   E353 D7 57       L1406       stab    temp1                   ; temp1 = 4 * abs(idleSpdTarg - rpm8)                              
5983   E355 CE FE F3                ldx     #L2035                  ; x point to L2035                               
5984   E358 96 57                   ldaa    temp1                   ; a = 4 * abs(idleSpdTarg - rpm8)                              
5985   E35A BD EB 4C                jsr     interp32                ; b = L2035(4 * abs(idleSpdTarg - rpm8))                                
5986   E35D D7 57                   stab    temp1                   ; temp1 = L2035(4 * abs(idleSpdTarg - rpm8))                              
5987   E35F BD E4 EF                jsr     iscPointers             ; have x point to isc0 or isc1 and have y point to iscY0, iscY1 or iscY2                                
5988   E362 E6 80                   ldab    $00,y                   ; b = iscYn, y = y + 1                              
5989   E364 CD 09                   decy                            ; y = y-1, points back to same value                             
5990   E366 96 58                   ldaa    temp2                   ; a.7 = sign(carry) of idleSpdTarg - rpm8 (see above L1402)
5991   E368 2A 11                   bpl     L1410                   ; Branch if  idleSpdTarg - rpm8 was positive
5992   E36A             
5993   E36A                         ;---------------------------------------------------------------------------
5994   E36A                         ; idleSpdTarg - rpm8 was negative. i.e. current rpm is too high
5995   E36A                         ; Compute b = iscYn - min (iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)))                             
5996   E36A                         ;---------------------------------------------------------------------------
5997   E36A 96 FD                   ldaa    iscStepTarg             ; a = iscStepTarg                                   
5998   E36C 27 39                   beq     L1416                   ; Branch if iscStepTarg = 0                             
5999   E36E 91 57                   cmpa    temp1                   ;                              
6000   E370 22 02                   bhi     L1408                   ; Branch if iscStepTarg > L2035(4 * abs(idleSpdTarg - rpm8))
6001   E372 97 57                   staa    temp1                   ; Use max of = iscStepTarg                             
6002   E374 D0 57       L1408       subb    temp1                   ; b = iscYn - min (iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)))                             
6003   E376 24 01                   bcc     L1409                   ; Branch if no underflow                             
6004   E378 5F                      clrb                            ; Use min of 0                            
6005   E379 20 12       L1409       bra     L1412                   ; 
6006   E37B                                          
6007   E37B                         ;-------------------------------------------------------------------------------------
6008   E37B                         ; idleSpdTarg - rpm8 was positive, i.e. current rpm is too low
6009   E37B                         ; Compute b = iscYn + min(iscStepMax - iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)) 
6010   E37B                         ;-------------------------------------------------------------------------------------
6011   E37B 96 F0       L1410       ldaa    iscStepMax              ; a = iscStepMax                                   
6012   E37D 90 FD                   suba    iscStepTarg             ; a = iscStepMax - iscStepTarg                                  
6013   E37F 27 26                   beq     L1416                   ; Branch if iscStepTarg = iscStepMax
6014   E381 91 57                   cmpa    temp1                   ;                              
6015   E383 22 02                   bhi     L1411                   ; Branch if iscStepMax - iscStepTarg > L2035(4 * abs(idleSpdTarg - rpm8))                               
6016   E385 97 57                   staa    temp1                   ; Use max of iscStepMax - iscStepTarg                             
6017   E387 DB 57       L1411       addb    temp1                   ; b = iscYn + min(iscStepMax - iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)) 
6018   E389 24 02                   bcc     L1412                   ; Branch if no overflow                              
6019   E38B C6 FF                   ldab    #$ff                    ; Use max of $ff                            
6020   E38D             
6021   E38D                         ;-------------------------------------------------------------------------------------
6022   E38D                         ; at this point 
6023   E38D                         ;        b = iscYn - min(iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)))                             
6024   E38D                         ;     or
6025   E38D                         ;        b = iscYn + min(iscStepMax - iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)) 
6026   E38D                         ;
6027   E38D                         ; Restart T40_checkTargRpm to 1 sec and decide whether to apply min/max to new iscYn=b value
6028   E38D                         ;-------------------------------------------------------------------------------------
6029   E38D 86 28       L1412       ldaa    #$28                     ; 1sec                            
6030   E38F B7 01 2A                staa    T40_checkTargRpm         ; T40_checkTargRpm = 1sec                              
6031   E392 87 F3 01 03             brset   iscLrnFlags, #$01, L1413 ; Branch to min/max checking if engine is notRotating or startingToCrank                              
6032   E396 20 0D                   bra     L1415                    ; Branch to store b in iscYn, Skip min/max checking                             
6033   E398 01                      nop                              ;                             
6034   E399             
6035   E399                         ;-------------------------------------------------
6036   E399                         ; Check b for min and max and then store in iscYn
6037   E399                         ;-------------------------------------------------
6038   E399 C1 86       L1413       cmpb    #$86                    ;                             
6039   E39B 25 02                   bcs     L1414                   ; Branch if b < $86                             
6040   E39D C6 86                   ldab    #$86                    ; Use max of $86                            
6041   E39F C1 7B       L1414       cmpb    #$7b                    ;                             
6042   E3A1 24 02                   bcc     L1415                   ; Branch if b >= $7b                             
6043   E3A3 C6 7B                   ldab    #$7b                    ; Use min of $7b                            
6044   E3A5 E7 80       L1415       stab    $00,y                   ; iscYn = b....                             
6045   E3A7             
6046   E3A7             
6047   E3A7                         ;---------------------------------------------------------------
6048   E3A7                         ; re-init iscYn variables if car is moving and rpm8>=1000rpm
6049   E3A7                         ;---------------------------------------------------------------
6050   E3A7 8F F1 04 09 L1416       brclr   port3Snap1, #$04, L1417 ; Branch if car is not moving                                    
6051   E3AB 96 DC                   ldaa    rpm8                    ;                             
6052   E3AD 81 80                   cmpa    #$80                    ;                             
6053   E3AF 25 03                   bcs     L1417                   ; Branch if rpm8 < 1000rpm                              
6054   E3B1 BD E5 18                jsr     iscYnInit               ;
6055   E3B4                                                              
6056   E3B4                         ;--------------------------------------------------------
6057   E3B4                         ; Transfer iscY0 to iscY2 if  power steering pump is off???  
6058   E3B4                         ;--------------------------------------------------------
6059   E3B4 87 F1 08 04 L1417       brset   port3Snap1, #$08, L1418 ; Bail if power steering pump is activated
6060   E3B8 96 ED                   ldaa    iscY0                   ;                              
6061   E3BA 97 EF                   staa    iscY2                   ; iscY2 = iscY0 
6062   E3BC                                                      
6063   E3BC                         ;---------------------------------------------------------
6064   E3BC                         ; Section to compute iscStepTarg from various information
6065   E3BC                         ; Ends at L1428
6066   E3BC                         ;---------------------------------------------------------
6067   E3BC                         ;-------------------------------------------------------------------------
6068   E3BC                         ; Compute workIscStep = b = max(iscStBase, iscStBaseAc, iscStBaseCSt)
6069   E3BC                         ;-------------------------------------------------------------------------
6070   E3BC F6 01 67    L1418       ldab    iscStBase               ; b = iscStBase                              
6071   E3BF F1 01 68                cmpb    iscStBaseAc             ;                              
6072   E3C2 24 03                   bcc     L1419                   ; Branch if iscStBase >= iscStBaseAc                             
6073   E3C4 F6 01 68                ldab    iscStBaseAc             ; Use min of iscStBaseAc                              
6074   E3C7 F1 01 69    L1419       cmpb    iscStBaseCSt            ;                              
6075   E3CA 24 03                   bcc     Ne3cd                   ; Branch if max(iscStBase, iscStBaseAc) >= iscStBaseCSt                             
6076   E3CC F6 01 69                ldab    iscStBaseCSt            ; Use min of iscStBaseCSt
6077   E3CF             Ne3cd       .equ    $
6078   E3CF             
6079   E3CF                         ;-----------------------------------------------------------------
6080   E3CF                         ; At this point b = workIscStep
6081   E3CF                         ;
6082   E3CF                         ; Take into port3.0 signal for E931?????
6083   E3CF                         ; Basically continue calculating the max isc step to use, 
6084   E3CF                         ; this time check A/C and port3.0
6085   E3CF                         ;-----------------------------------------------------------------
6086   E3CF             #ifdef E931
6087   E3CF 8F E5 08 0C             brclr   ftrimFlags, #$08, L1420 ; Bail if not (speed>24km/h and port3.0 set)                                   
6088   E3D3 86 53                   ldaa    #$53                    ; Use $53 
6089   E3D5 87 F1 10 02             brset   port3Snap1, #$10, Me3db ; Branch if A/C switch is off                                   
6090   E3D9 86 78                   ldaa    #$78                    ; Use higher value since A/C is on                           
6091   E3DB 11          Me3db       cba                             ;                            
6092   E3DC 25 01                   bcs     L1420                   ; Branch if we already have max value, i.e.  workIscStep > a
6093   E3DE 16                      tab                             ; Use new max value                           
6094   E3DF             #endif
6095   E3DF             
6096   E3DF                         ;---------------------------------------------
6097   E3DF                         ; At this point b = workIscStep
6098   E3DF                         ; Compensate for barometric pressure and  
6099   E3DF                         ;---------------------------------------------
6100   E3DF 4F          L1420       clra                            ; a = 0                          
6101   E3E0 FB 01 6A                addb    iscStBarOff             ; d = workIscStep + iscStBarOff
6102   E3E3 89 00                   adca    #$00                    ; propagate carry                          
6103   E3E5             
6104   E3E5                         ;------------------------------------------------
6105   E3E5                         ; At this point b = workIscStep
6106   E3E5                         ; Increase iscStep according to iscStStartUsed
6107   E3E5                         ;
6108   E3E5                         ; i.e. isc step adjustment upon engine startup
6109   E3E5                         ;------------------------------------------------
6110   E3E5 FB 01 64                addb    iscStStartUsed          ; d = workIscStep + iscStBarOff + iscStStartUsed
6111   E3E8 89 00                   adca    #$00                    ; propagate carry                          
6112   E3EA BD EB BE                jsr     ovfCheck                ; Check for overflow (force result to be in b with $ff max)                              
6113   E3ED             
6114   E3ED                         ;------------------------------------------------
6115   E3ED                         ; Check workIscStep for min value in iscStStall
6116   E3ED                         ;------------------------------------------------
6117   E3ED F1 01 63                cmpb    iscStStall              ;                            
6118   E3F0 24 05                   bcc     L1421                   ; Branch if workIscStep + iscStBarOff + iscStStartUsed  >= iscStStall
6119   E3F2 F6 01 63                ldab    iscStStall              ; Use min of iscStStall                            
6120   E3F5 20 06                   bra     L1422                   ; Branch to continue                           
6121   E3F7             
6122   E3F7                         ;-------------------------------------------------------------------
6123   E3F7                         ; At this point workIscStept + iscStBarOff + iscStStartUsed  >= iscStStall
6124   E3F7                         ;
6125   E3F7                         ; i.e. what we are using is already higher 
6126   E3F7                         ; than the minimum we therefore don't need 
6127   E3F7                         ; that minimum anymore...
6128   E3F7                         ;
6129   E3F7                         ; Reset iscStStall to 0 and reset flag
6130   E3F7                         ;-------------------------------------------------------------------
6131   E3F7 7F 01 63    L1421       clr     iscStStall              ; iscStStall = 0                           
6132   E3FA 02 F3 DF                andm    iscLrnFlags, #$df       ; Reset 00100000                              
6133   E3FD             
6134   E3FD                         ;---------------------------------------------------------------------------------
6135   E3FD                         ; At this point, b = workIscStep
6136   E3FD                         ; Add the effect of power steering pump
6137   E3FD                         ;---------------------------------------------------------------------------------
6138   E3FD 8F F1 08 06 L1422       brclr   port3Snap1, #$08, L1423 ; Branch if power steering pump is off                                 
6139   E401             #ifdef E931
6140   E401 CB 0F                   addb    #$0f                    ; b = workIscStep + $0f
6141   E403~            #else       
6142   E403~                        addb    #$11                    ;                           
6143   E403             #endif
6144   E403 24 02                   bcc     L1423                   ; Branch if no overflow                             
6145   E405 C6 FF                   ldab    #$ff                    ; Use max of $ff
6146   E407                                                     
6147   E407                         ;---------------------------------------------------------------
6148   E407                         ; increase the iscStep if the engine is running too slow 
6149   E407                         ; (stall conditions?) and  conditions are not good to update 
6150   E407                         ; isc variables (to avoid getting confused with cranking maybe?) 
6151   E407                         ;---------------------------------------------------------------
6152   E407 8F F3 04 0A L1423       brclr   iscLrnFlags, #$04, L1424 ; Branch if engine is not running too slow                              
6153   E40B 87 F3 10 06             brset   iscLrnFlags, #$10, L1424 ; Branch if conditions are good to update isc variables                             
6154   E40F CB 22                   addb    #$22                     ; b = workIscStep + $22
6155   E411 24 02                   bcc     L1424                    ; Branch if no overflow                              
6156   E413 C6 FF                   ldab    #$ff                     ; Use max of $ff                                    
6157   E415             
6158   E415                         ;-------------------------------------------------------------------
6159   E415                         ; Compute temp3 = workIscStep + (iscm/256 - $80) + (iscYn - $80)
6160   E415                         ;                 workIscStep'+ iscStBarOff + (iscm/256 - $80) + (iscYn - $80)
6161   E415                         ; This is isc step we are going to use if engine is running
6162   E415                         ;-------------------------------------------------------------------
6163   E415 BD E4 CF    L1424       jsr     iscCalc3                ; b = workIscStep + (iscm/256 - $80)
6164   E418 BD E5 07                jsr     iscCalc4                ; b = workIscStep + (iscm/256 - $80) + (iscYn - $80) 
6165   E41B D7 59                   stab    temp3                   ; temp3 =  workIscStep + (iscm/256 - $80) + (iscYn - $80)
6166   E41D             
6167   E41D                         ;---------------------------------------------------------------
6168   E41D                         ; Compute temp2 = L2031(ect) + iscStBarOff + (iscm/256 - $80)
6169   E41D                         ; This is isc step we are going to use if the engine is notRotating
6170   E41D                         ;---------------------------------------------------------------
6171   E41D CE FE D7                ldx     #L2031                  ; x points to L2031                               
6172   E420 BD EB 3A                jsr     interpEct               ; b = L2031(ect)                                   
6173   E423 FB 01 6A                addb    iscStBarOff             ; b = L2031(ect) + iscStBarOff                                    
6174   E426 24 02                   bcc     L1425                   ; Branch if no overflow                             
6175   E428 C6 FF                   ldab    #$ff                    ; overflow, use max
6176   E42A BD E4 CF    L1425       jsr     iscCalc3                ; b = L2031(ect) + iscStBarOff + (iscm/256 - $80)
6177   E42D D7 58                   stab    temp2                   ; temp2 = L2031(ect) + iscStBarOff + (iscm/256 - $80)
6178   E42F             
6179   E42F                         ;-----------------------------------------------------------------------------
6180   E42F                         ; Compute iscStTargSpec = temp2 + (iscYn - $80) 
6181   E42F                         ;                       = L2031(ect) + iscStBarOff + (iscm/256 - $80) + (iscYn - $80) 
6182   E42F                         ;
6183   E42F                         ; This is isc step we are going to use if engine is starting to crank
6184   E42F                         ;-----------------------------------------------------------------------------
6185   E42F BD E5 07                jsr     iscCalc4                ; b = L2031(ect) + iscStBarOff + (iscm/256 - $80) + (iscYn - $80) 
6186   E432 BD E4 C8                jsr     iscStepMaxFunc          ; apply max to b                                      
6187   E435 F7 01 66                stab    iscStTargSpec           ; iscStTargSpec = L2031(ect) + iscStBarOff + (iscm/256 - $80) + (iscYn - $80) 
6188   E438             
6189   E438                         ;-----------------------------------------------------------------------
6190   E438                         ; At this point,
6191   E438                         ;
6192   E438                         ;      temp3 = workIscStep' + iscStBarOff  + (iscm/256 - $80) + (iscYn - $80)
6193   E438                         ;          b = L2031(ect)   + iscStBarOff  + (iscm/256 - $80) + (iscYn - $80)
6194   E438                         ;      temp2 = L2031(ect)   + iscStBarOff  + (iscm/256 - $80)
6195   E438                         ;
6196   E438                         ; Now decide which value we are going to use 
6197   E438                         ; as working isc step  either b, temp2 or temp3
6198   E438                         ; Not sure why engine state is taken from a mix of state1 and iscLrnFlags???
6199   E438                         ;-----------------------------------------------------------------------
6200   E438 8F F3 01 08             brclr   iscLrnFlags, #$01, L1427 ; Branch to use temp3 if engine is not (notRotating or startingToCrank), runnning, normally or not...
6201   E43C 8F E6 10 06             brclr   state1, #$10, L1428      ; Branch to use iscStTargSpec (already loaded in b) if notRotating clear, only startingToCrank left??? 
6202   E440 D6 58                   ldab    temp2                    ; notRotating, use temp2
6203   E442 20 02                   bra     L1428                    ;                              
6204   E444 D6 59       L1427       ldab    temp3                    ; use temp3
6205   E446             
6206   E446                         ;-------------------------------------------------------------------------
6207   E446                         ; At this point b contains the working isc step that we have been
6208   E446                         ; updating/calculating for a while now, apply a max to it and store it 
6209   E446                         ; in iscStepTarg, this is the is isc step target...
6210   E446                         ;-------------------------------------------------------------------------
6211   E446 BD E4 C8    L1428       jsr     iscStepMaxFunc          ; apply max to b                                       
6212   E449 D7 FD                   stab    iscStepTarg             ; iscStepTarg
6213   E44B                                                            
6214   E44B                         ;--------------------------------------------
6215   E44B                         ; Section to update iscYn and iscm variables
6216   E44B                         ;--------------------------------------------
6217   E44B                         ;------------------------------------------------------------------------------
6218   E44B                         ; Check if a bunch of conditions are met to update the isc learning variables
6219   E44B                         ;------------------------------------------------------------------------------
6220   E44B 8F F3 10 66             brclr   iscLrnFlags, #$10, L1431 ; Bail if conditions are not good to update isc variables                              
6221   E44F D6 F0                   ldab    iscStepMax               ; b = iscStepMax                                  
6222   E451 96 FD                   ldaa    iscStepTarg              ; a = iscStepTarg                                   
6223   E453 27 60                   beq     L1431                    ; bail if iscStepTarg = 0
6224   E455 11                      cba                              ;                             
6225   E456 27 5D                   beq     L1431                    ; bail if iscStepTarg = iscStepMax
6226   E458 87 F1 08 59             brset   port3Snap1, #$08, L1431  ; bail if power steering pump is on                                   
6227   E45C 87 F3 01 55             brset   iscLrnFlags, #$01, L1431 ; bail if notRotating or startingToCrank                               
6228   E460 B6 01 41                ldaa    T0p5_crCold              ; a = T0p5_crCold                                    
6229   E463 26 50                   bne     L1431                    ; bail if timer not expired                              
6230   E465 96 D3                   ldaa    ectFiltered              ; a = ectFiltered                                   
6231   E467 81 1C                   cmpa    #$1c                     ; 86degC                             
6232   E469 24 4A                   bcc     L1431                    ; bail if temperature(ectFiltered) <= 86degC                             
6233   E46B 87 D8 10 46             brset   port4Snap, #$10, L1431   ; Bail if timing terminal grounded                                   
6234   E46F B6 01 64                ldaa    iscStStartUsed           ; a = iscStStartUsed                              
6235   E472 26 41                   bne     L1431                    ; Bail if iscStStartUsed != 0                             
6236   E474 8F 16 10 3D             brclr   port5, #$10, L1431       ; Bail if fuel pressure solenoid activated                               
6237   E478             
6238   E478                         ;-----------------------------------------------------------
6239   E478                         ; All the conditions are met, update iscm and iscYn at 1 Hz
6240   E478                         ;-----------------------------------------------------------
6241   E478                         ;------------------------------------------
6242   E478                         ; First check if time has come to update 
6243   E478                         ; variables and then re-init timer 
6244   E478                         ;------------------------------------------
6245   E478 B6 01 26                ldaa    T40_iscLrn              ; a = T40_iscLrn                              
6246   E47B 26 38                   bne     L1431                   ; Bail to exit subr. if timer T40_iscLrn not expired (time has not come yet...)                            
6247   E47D 86 28                   ldaa    #$28                    ; Timer is expired, a = 1sec                            
6248   E47F B7 01 26                staa    T40_iscLrn              ; re-init T40_iscLrn to 1 sec                              
6249   E482             
6250   E482                         ;-----------------------------------------
6251   E482                         ; Get current pointers and compute 
6252   E482                         ; newIscm = old iscm + 3 * (iscYn - $80)
6253   E482                         ;-----------------------------------------
6254   E482 BD E4 EF                jsr     iscPointers             ; have x point to isc0 or isc1 and have y point to iscY0, iscY1 or iscY2                                
6255   E485 CC 01 80                ldd     #$0180                  ; d = $0180                              
6256   E488 DD 58                   std     temp2                   ; temp2:temp3 = $0180                             
6257   E48A 86 03                   ldaa    #$03                    ; a = $03                             
6258   E48C E6 80                   ldab    $00,y                   ; b = iscYn, y = y + 1                              
6259   E48E CD 09                   decy                            ; y = y - 1  
6260   E490 3D                      mul                             ; d = 3 * iscYn                             
6261   E491 93 58                   subd    temp2                   ; d = 3 * (iscYn - $80)                              
6262   E493 E3 00                   addd    $00,x                   ; d = iscm + 3 * (iscYn - $80)                             
6263   E495 BD E4 DE                jsr     iscMinMax               ; Apply min and max to d                                
6264   E498 DD 57                   std     temp1                   ; temp1:temp2 = newIscm = iscm + 3 * (iscYn - $80)                             
6265   E49A             
6266   E49A                         ;---------------------------------------------------
6267   E49A                         ; Compute newIscYn = newIscm + 3 * (iscYn - $80)
6268   E49A                         ;---------------------------------------------------
6269   E49A 16                      tab                             ; b = newIscm/256                            
6270   E49B A6 80                   ldaa    $00,y                   ; a = iscYn, y = y + 1                             
6271   E49D CD 09                   decy                            ; y = y - 1                             
6272   E49F E0 00                   subb    $00,x                   ; b = newIscm/256 - iscm/256                              
6273   E4A1 24 08                   bcc     L1429                   ; Branch to continue if newIscm >= old iscm
6274   E4A3                                                  
6275   E4A3                         ;---------------------
6276   E4A3                         ; newIscm < old iscm
6277   E4A3                         ;---------------------
6278   E4A3 50                      negb                            ; b = (iscm - newIscm)/256                              
6279   E4A4 1B                      aba                             ; a = iscYn + (iscm - newIscm)/256
6280   E4A5 24 08                   bcc     L1430                   ; Branch if no overflow                             
6281   E4A7 86 FF                   ldaa    #$ff                    ; Use max of $ff                            
6282   E4A9 20 04                   bra     L1430                   ; Branch to store           
6283   E4AB                                           
6284   E4AB                         ;----------------------
6285   E4AB                         ; newIscm >= old iscm
6286   E4AB                         ;----------------------
6287   E4AB 10          L1429       sba                             ; a = iscYn - (newIscm - iscm)/256
6288   E4AC 24 01                   bcc     L1430                   ; branch if no underflow                             
6289   E4AE 4F                      clra                            ; Use min of 0                            
6290   E4AF             
6291   E4AF                         ;---------------------------------------------------------
6292   E4AF                         ; At this point 
6293   E4AF                         ;               a = newIscYn 
6294   E4AF                         ;   [temp1:temp2] = newIscm
6295   E4AF                         ;
6296   E4AF                         ; Where
6297   E4AF                         ;
6298   E4AF                         ;     newIscm = oldIscm + 3 * (oldIscYn - $80)
6299   E4AF                         ;
6300   E4AF                         ;                | oldIscYn + (oldIscm - newIscm)/256 if newIscm < oldIscm
6301   E4AF                         ;     newIscYn = |
6302   E4AF                         ;                | oldIscYn - (newIscm - oldIscm)/256 if newIscm >= oldIscm
6303   E4AF                         ;
6304   E4AF                         ;---------------------------------------------------------
6305   E4AF A7 80       L1430       staa    $00,y                   ; Update iscYn with new value
6306   E4B1 DC 57                   ldd     temp1                   ; d = newIscm
6307   E4B3 ED 00                   std     $00,x                   ; Update iscm with new value
6308   E4B5 39          L1431       rts                             ;                             
6309   E4B6             
6310   E4B6             
6311   E4B6             
6312   E4B6             ;******************************************************************
6313   E4B6             ;
6314   E4B6             ; ISC step calculation
6315   E4B6             ;
6316   E4B6             ;    input:  A = step
6317   E4B6             ;    output: A =(~step & 7F)
6318   E4B6             ;
6319   E4B6             ;            (~step & 7F) stored in iscStepCom 
6320   E4B6             ;             step stored in iscStepCurr
6321   E4B6             ;
6322   E4B6             ;
6323   E4B6             ;******************************************************************
6324   E4B6 37          iscStepComp pshb                            ; st0 = val                             
6325   E4B7 16                      tab                             ; b = step                            
6326   E4B8 43                      coma                            ; a = ~step                             
6327   E4B9 84 7F                   anda    #$7f                    ; a = ~step & $7f                             
6328   E4BB DD 48                   std     iscStepCom              ; iscStepCom = ~step & $7f, iscStepCurr = step
6329   E4BD 33                      pulb                            ; b = val                             
6330   E4BE 39                      rts                             ;                             
6331   E4BF             
6332   E4BF             
6333   E4BF             
6334   E4BF             ;******************************************************************
6335   E4BF             ;
6336   E4BF             ; Increase the value of T40s_iscStable timer if the 
6337   E4BF             ; new value is higher than the current one
6338   E4BF             ; 
6339   E4BF             ; T40s_iscStable = max(T40s_iscStable, b)
6340   E4BF             ;
6341   E4BF             ;******************************************************************
6342   E4BF             updIscStableTimer   
6343   E4BF F1 01 62                cmpb    T40s_iscStable  ;                                  
6344   E4C2 25 03                   bcs     L1434                   ; Branch if b < T40s_iscStable                             
6345   E4C4 F7 01 62                stab    T40s_iscStable          ; Use new higher value                                  
6346   E4C7 39          L1434       rts                             ;                             
6347   E4C8             
6348   E4C8             
6349   E4C8             
6350   E4C8             ;******************************************************************
6351   E4C8             ;
6352   E4C8             ;
6353   E4C8             ; b = min(b,iscStepMax)
6354   E4C8             ;
6355   E4C8             ;
6356   E4C8             ;******************************************************************
6357   E4C8 D1 F0       iscStepMaxFunc cmpb    iscStepMax                                                 
6358   E4CA 25 02                      bcs     L1436                                                 
6359   E4CC D6 F0                      ldab    iscStepMax                                                 
6360   E4CE 39          L1436          rts                                                          
6361   E4CF             
6362   E4CF             
6363   E4CF             
6364   E4CF             ;******************************************************************
6365   E4CF             ;
6366   E4CF             ; Input:
6367   E4CF             ;       b = val1
6368   E4CF             ;
6369   E4CF             ;
6370   E4CF             ;******************************************************************
6371   E4CF D7 57       iscCalc3    stab    temp1                   ; temp1 = val1                             
6372   E4D1 8D 1C                   bsr     iscPointers             ; x points to iscm; y points to iscYn                                 
6373   E4D3 EC 00                   ldd     $00,x                   ; d = iscm                             
6374   E4D5 8D 07                   bsr     iscMinMax               ; apply min and max, d = ...                                  
6375   E4D7 16                      tab                             ; b = iscm/256                             
6376   E4D8 4F                      clra                            ; a = 0                           
6377   E4D9 DB 57                   addb    temp1                   ; b = iscm/256 + val1                             
6378   E4DB 49                      rola                            ; propagate carry, d = iscm/256 + val1                             
6379   E4DC 20 30                   bra     L1445                   ; go to subtract $80 with min check and then make sure result fits in b (max of $ff)                             
6380   E4DE             
6381   E4DE             
6382   E4DE             ;******************************************************************
6383   E4DE             ;
6384   E4DE             ; ISC step related, apply min and max to D
6385   E4DE             ;
6386   E4DE             ; Input:
6387   E4DE             ;       d = val
6388   E4DE             ; Output:
6389   E4DE             ;       d = max($6c00, min($b000, val))
6390   E4DE             ;******************************************************************
6391   E4DE 1C B0 00    iscMinMax   cmpd    #$b000                   ;                              
6392   E4E1 25 03                   bcs     L1439                    ; Branch if d < $b000                             
6393   E4E3 CC B0 00                ldd     #$b000                   ; Use max of $b000                             
6394   E4E6 1C 6C 00    L1439       cmpd    #$6c00                   ;                              
6395   E4E9 24 03                   bcc     L1440                    ; Branch if d >= $6c00                            
6396   E4EB CC 6C 00                ldd     #$6c00                   ; Use min of $6c00                             
6397   E4EE 39          L1440       rts                              ;                            
6398   E4EF             
6399   E4EF             
6400   E4EF             
6401   E4EF             ;******************************************************************
6402   E4EF             ;
6403   E4EF             ; Get current pointers to ISC step learning variables 
6404   E4EF             ;
6405   E4EF             ;        input: none (port3Snap1 is used)
6406   E4EF             ;       output: X points to isc0 if A/C switch off, isc1 otherwise
6407   E4EF             ;               Y points to iscY0, iscY1 or iscY2
6408   E4EF             ;
6409   E4EF             ;           A/C switch   PS pump        x         y
6410   E4EF             ;              off         off        isc0     iscY0
6411   E4EF             ;              off         on         isc0     iscY2
6412   E4EF             ;              on          off        isc1     iscY1
6413   E4EF             ;              on          on         isc1     iscY2
6414   E4EF             ;
6415   E4EF             ;******************************************************************
6416   E4EF CE 00 44    iscPointers ldx     #isc0                    ; x points to isc0                               
6417   E4F2 CD CE 00 ED             ldy     #iscY0                   ; y points to iscY0                             
6418   E4F6 87 F1 10 04             brset   port3Snap1, #$10, L1442  ; Branch if A/C switch off                                   
6419   E4FA 08                      inx                              ;                            
6420   E4FB 08                      inx                              ; x points to isc1                           
6421   E4FC CD 08                   incy                             ; y points to iscY1                            
6422   E4FE 8F F1 08 04 L1442       brclr   port3Snap1, #$08, L1443  ; Branch if power steering pump is deactivated?                                  
6423   E502 CD CE 00 EF             ldy     #iscY2                   ; y points to iscY2                             
6424   E506 39          L1443       rts                              ;                            
6425   E507             
6426   E507             
6427   E507             
6428   E507             ;******************************************************************
6429   E507             ;
6430   E507             ; Input:
6431   E507             ;       b = val
6432   E507             ;
6433   E507             ;
6434   E507             ;******************************************************************
6435   E507 8D E6       iscCalc4    bsr     iscPointers             ; x points to iscm; y points to iscYn                                 
6436   E509 4F                      clra                            ; a = 0                             
6437   E50A EB 80                   addb    $00,y                   ; d = val + iscYn                              
6438   E50C 89 00                   adca    #$00                    ; propagate carry                            
6439   E50E 83 00 80    L1445       subd    #$0080                  ; d = val + iscYn -$80                               
6440   E511 24 02                   bcc     L1446                   ; Branch if no underflow                             
6441   E513 4F                      clra                            ;                             
6442   E514 5F                      clrb                            ; Use min of 0                            
6443   E515 7E EB BE    L1446       jmp     ovfCheck                ; Check that result fits in b ($ff max)                                 
6444   E518                         
6445   E518             
6446   E518             
6447   E518             
6448   E518             ;******************************************************************
6449   E518             ;
6450   E518             ; Initialize ISC iscYn variables
6451   E518             ;
6452   E518             ; E931:
6453   E518             ;
6454   E518             ;    iscY0 = $86
6455   E518             ;    iscY1 = $8a
6456   E518             ;    iscY2 = $86
6457   E518             ;
6458   E518             ; E932:
6459   E518             ;
6460   E518             ;    iscY0 = $86     or   iscY0 = $83 
6461   E518             ;    iscY1 = $8a          iscY1 = $83 
6462   E518             ;    iscY2 = $86          iscY2 = $83 
6463   E518             ;
6464   E518             ;******************************************************************
6465   E518             iscYnInit   .equ    $
6466   E518             #ifdef E931
6467   E518 86 86                   ldaa    #$86                                               
6468   E51A C6 8A                   ldab    #$8a                                               
6469   E51C~            #else
6470   E51C~                        ldaa    #$83                                                 
6471   E51C~                        tab                                                          
6472   E51C~                        brclr   port3Snap1, #$20, L1448                                     
6473   E51C~                        ldaa    #$86                                                 
6474   E51C~                        ldab    #$8a                                                 
6475   E51C             #endif
6476   E51C             
6477   E51C 97 ED       L1448       staa    iscY0                                                 
6478   E51E 97 EF                   staa    iscY2                                                 
6479   E520 D7 EE                   stab    iscY1                                                 
6480   E522 39                      rts                                                          
6481   E523             
6482   E523             
6483   E523             
6484   E523             ;******************************************************************
6485   E523             ;
6486   E523             ;
6487   E523             ; Sensor check related table, 
6488   E523             ; correspond one for one to table at t_snsrChk
6489   E523             ; Each entry is the bit to set/reset in the faulth:faultl 
6490   E523             ; for the corresponding sensor
6491   E523             ;
6492   E523             ;
6493   E523             ;******************************************************************
6494   E523 02 00 40 00 t_snsrChkBit  .word   $0200, $4000, $8000, $0001    
6494   E527 80 00 00 01 
6495   E52B 00 08 00 10               .word   $0008, $0010, $0040, $2000    
6495   E52F 00 40 20 00 
6496   E533 00 04 04 00               .word   $0004, $0400, $0800, $0002    
6496   E537 08 00 00 02 
6497   E53B             
6498   E53B             
6499   E53B             
6500   E53B             ;****************************************************************
6501   E53B             ;
6502   E53B             ; Used for output of error codes to test connector
6503   E53B             ;
6504   E53B             ; in order: o2   maf  iat  tps  N/A   ect  cas   tdc    (high fault, $01, $02, $04, $08, $10, $20, $40, $80)
6505   E53B             ;           vss  bar  knk  inj  fuel  egr  coil  N/A    (low fault,  $01, $02, $04, $08, $10, $20, $40, $80)
6506   E53B             ;
6507   E53B             ; Format: 
6508   E53B             ;
6509   E53B             ;       high nibble = number of "long pulse" to output (max of 7?)
6510   E53B             ;        low nibble = number of "short pulse" to output (max of 15?)
6511   E53B             ;
6512   E53B             ;****************************************************************
6513   E53B 11 12 13 14 t_snsrChkCode .byte   $11, $12, $13, $14, $15, $21, $22, $23, $24, $25, $31, $41, $42, $43, $44, $00
6513   E53F 15 21 22 23 
6513   E543 24 25 31 41 
6513   E547 42 43 44 00 
6514   E54B             
6515   E54B             
6516   E54B             
6517   E54B             ;****************************************************************
6518   E54B             ;
6519   E54B             ; Sensor check subroutine vectors
6520   E54B             ;
6521   E54B             ;****************************************************************
6522   E54B E8 FB E9 10 t_snsrChk   .word   test_maf,    test_cas,    test_tdc,    test_reed  
6522   E54F E9 1D E9 34 
6523   E553 E9 5B E9 7B             .word   test_inj,    test_fpump,  test_coil,   test_ect  
6523   E557 E9 8B E9 BA 
6524   E55B E9 9D E9 A3             .word   test_knock,  test_iat,    test_tps,    test_baro  
6524   E55F E9 A9 E9 F8 
6525   E563             
6526   E563             
6527   E563             
6528   E563             ;****************************************************************
6529   E563             ;
6530   E563             ; Actuator activate lookup table (OBD command processing)
6531   E563             ;
6532   E563             ;****************************************************************
6533   E563 20 10 08 04 t_obdActMask       .byte   $20, $10, $08, $04, $01, $02
6533   E567 01 02 
6534   E569             
6535   E569             
6536   E569             
6537   E569             ;****************************************************************
6538   E569             ;
6539   E569             ; Injector disable lookup table (OBD command processing)
6540   E569             ;
6541   E569             ;****************************************************************
6542   E569 FB FD F7 FE t_obdInjMask       .byte   $fb, $fd, $f7, $fe      
6543   E56D             
6544   E56D             
6545   E56D             
6546   E56D             ;******************************************************************
6547   E56D             ;
6548   E56D             ;
6549   E56D             ; Fourth subroutine
6550   E56D             ;
6551   E56D             ;
6552   E56D             ;******************************************************************
6553   E56D                         ;--------------------------------------------------
6554   E56D                         ; Reset a few things (most fault codes, etc)
6555   E56D                         ; if ECU power has been on for less than 0.5 sec
6556   E56D                         ;--------------------------------------------------
6557   E56D B6 01 35    subroutine4 ldaa    T2_EcuPower             ;                             
6558   E570 8B 01                   adda    #$01                    ;                             
6559   E572 24 19                   bcc     L1454                   ; Branch if its been more than 0.5sec since ECU power has been on
6560   E574 02 FC F9                andm    validFlags, #$f9        ; Reset o2 and egrt "sensor condition determined" flags
6561   E577 03 FC 01                orm     validFlags, #$01        ; set flag indicating no CAS interrupt received for a long time                               
6562   E57A 02 4E 01                andm    faultHi, #$01           ; Reset all current faults but o2 sensor bit
6563   E57D 02 4F 20                andm    faultLo, #$20           ; Reset all current faults but egrt sensor bit
6564   E580 86 08                   ldaa    #$08                    ;                             
6565   E582 B7 01 3B                staa    T2_snsrChk              ; re-init T2_snsrChk with 4 sec                             
6566   E585 86 FF                   ldaa    #$ff                    ;                             
6567   E587 B7 01 3E                staa    T2_stCrank              ; re-init T2_stCrank with max value (127.5sec)                             
6568   E58A 02 D6 EF                andm    state2, #$ef            ; Reset ECT related flag???                                
6569   E58D             
6570   E58D                         ;------------------------------------
6571   E58D                         ; Set flag if engine not rotating
6572   E58D                         ;------------------------------------
6573   E58D B6 01 20    L1454       ldaa    T40_engRot                                                 
6574   E590 26 05                   bne     L1455                   ; Branch if engine rotating                              
6575   E592 03 FC 01                orm     validFlags, #$01        ; Engine not rotating (or very slowly) set flag                                
6576   E595 20 25                   bra     L1458                   ; Branch to continue
6577   E597                                                                       
6578   E597                         ;------------------------------------------------------
6579   E597                         ; If the engine is startingToCrank or was not rotating 
6580   E597                         ; the last time we were here and is now rotating                                
6581   E597                         ;
6582   E597                         ; Update ectStCrank and related timers, the ect when
6583   E597                         ; we started cranking...
6584   E597                         ;------------------------------------------------------
6585   E597 87 FC 01 04 L1455       brset   validFlags, #$01, L1456 ; Branch if engine was not rotating the last time we checked                               
6586   E59B 8F E6 01 1D             brclr   state1, #$01, L1458     ; Bail if startingToCrank clear
6587   E59F 02 FC FE    L1456       andm    validFlags, #$fe        ;  startingToCrank or was not rotating the last time we were here and is now rotating                                
6588   E5A2 96 D3                   ldaa    ectFiltered             ;                                    
6589   E5A4 B7 01 83                staa    ectStCrank              ; ectStCrank = ectFiltered                              
6590   E5A7 C6 FF                   ldab    #$ff                    ;                             
6591   E5A9 F7 01 3E                stab    T2_stCrank              ; T2_stCrank = $ff  (127.5sec)                            
6592   E5AC F7 01 43                stab    T0p5_crank2             ; T0p5_crank2 = $ff  (510sec)                             
6593   E5AF 96 CB                   ldaa    ectRaw                  ;                               
6594   E5B1 C6 5A                   ldab    #$5a                    ; 180sec                            
6595   E5B3 81 1C                   cmpa    #$1c                    ; 86 degC                            
6596   E5B5 23 02                   bls     L1457                   ; Branch if temperature(ectRaw)>= 86degC                              
6597   E5B7 C6 B4                   ldab    #$b4                    ; 360 sec                            
6598   E5B9 F7 01 78    L1457       stab    egrtTimerThr            ; egrtTimerThr = $5a or $b4 (180sec or 360sec depending on ect)                              
6599   E5BC             
6600   E5BC                         ;-------------------------------------------------
6601   E5BC                         ; Section performing the sensor check functions..
6602   E5BC                         ;-------------------------------------------------
6603   E5BC                         ;--------------------------------------------------------------------------
6604   E5BC                         ; Loop sensrChkIdx from 0 to 7 if T2_stCrank (startingToCrank) started counting 
6605   E5BC                         ; less than 60 sec ago (only first 8 sensor tests are performed,
6606   E5BC                         ; the most important ones I suppose to start the car, except for reed 
6607   E5BC                         ; switch, safety maybe?) else loop at 12 (all tests are performed)
6608   E5BC                         ;--------------------------------------------------------------------------
6609   E5BC 86 08       L1458       ldaa    #$08                    ; a = $08                             
6610   E5BE F6 01 3E                ldab    T2_stCrank              ; b = T2_stCrank                             
6611   E5C1 CB 78                   addb    #$78                    ; b = T2_stCrank + $78   (60sec)                         
6612   E5C3 25 02                   bcs     L1459                   ; Branch if T2_stCrank started counting less than 60 sec ago
6613   E5C5 8B 04                   adda    #$04                    ; a = $0c                           
6614   E5C7 F6 01 79    L1459       ldab    sensrChkIdx             ; b = sensrChkIdx                              
6615   E5CA 11                      cba                             ;                             
6616   E5CB 22 09                   bhi     L1460                   ; Branch to start checking if sensrChkIdx < $0c or $08                             
6617   E5CD             
6618   E5CD                         ;-------------------------------------------------
6619   E5CD                         ; sensrChkIdx >= $0c or $08 
6620   E5CD                         ; re-init T2_snsrChk to 4 sec and sensrChkIdx to 0
6621   E5CD                         ;-------------------------------------------------
6622   E5CD 86 08                   ldaa    #$08                    ;                             
6623   E5CF B7 01 3B                staa    T2_snsrChk              ; T2_snsrChk = 8 (4 sec)                            
6624   E5D2 5F                      clrb                            ;                             
6625   E5D3 F7 01 79                stab    sensrChkIdx             ; sensrChkIdx = 0                             
6626   E5D6             
6627   E5D6                         ;----------------------------------------------------------
6628   E5D6                         ; Call the sensor check rountine according to sensrChkIdx 
6629   E5D6                         ;----------------------------------------------------------
6630   E5D6 58          L1460       aslb                            ; b = 2*sensrChkIdx (2 bytes per address...)                            
6631   E5D7 CE E5 4B                ldx     #t_snsrChk              ; x = t_snsrChk
6632   E5DA 3A                      abx                             ; x = t_snsrChk + 2*sensrChkIdx                            
6633   E5DB CD EE 00                ldy     $00,x                   ; y points to sensor check function                              
6634   E5DE CE E5 23                ldx     #t_snsrChkBit           ; x = t_snsrChkBit (sensor "fault bit position" table)
6635   E5E1 3A                      abx                             ; x = t_snsrChkBit + 2*sensrChkIdx                           
6636   E5E2 5F                      clrb                            ; b = 0                            
6637   E5E3 AD 80                   jsr     $00,y                   ; call sensor check subroutine                              
6638   E5E5 5D                      tstb                            ;                             
6639   E5E6 27 21                   beq     L1462                   ; Branch if no error found                              
6640   E5E8 2A 29                   bpl     L1463                   ; Branch if inconclusive                             
6641   E5EA             
6642   E5EA                         ;------------------------------------------------------
6643   E5EA                         ; Sensor check returned negative, error is detected 
6644   E5EA                         ; 
6645   E5EA                         ; Check if T2_snsrChk is expired, which would mean we have 
6646   E5EA                         ; been stuck on testing the same sensor for 4 sec and 
6647   E5EA                         ; it never worked properly...)
6648   E5EA                         ;------------------------------------------------------
6649   E5EA EC 00                   ldd     $00,x                   ; [a:b] = t_snsrChkBit(sensrChkIdx)
6650   E5EC 7D 01 3B                tst     T2_snsrChk              ;                                                                                                   
6651   E5EF 27 0A                   beq     L1461                   ; branch if T2_snsrChk is 0 (more than 4 sec elapsed since sensrChkIdx was reset to 0)
6652   E5F1             
6653   E5F1                         ;------------------------------------------------------
6654   E5F1                         ; T2_snsrChk is not expired, don't set the error flags but 
6655   E5F1                         ; if it they were already set increase sensrChkIdx
6656   E5F1                         ; (meaning this sensor was already detected as bad
6657   E5F1                         ; with a 4 sec check, don't do it again for that 
6658   E5F1                         ; sensor, go to the next one)
6659   E5F1                         ;------------------------------------------------------
6660   E5F1 94 4E                   anda    faultHi                 ; 
6661   E5F3 26 1E                   bne     L1463                   ; Branch to increase sensrChkIdx if error bit was already set (if it was located in faultHi)                                                                                               
6662   E5F5 D4 4F                   andb    faultLo                 ;                                                                                                  
6663   E5F7 26 1A                   bne     L1463                   ; Branch to increase sensrChkIdx if error bit was alrready set (if it was located in faultLo)                                                                                               
6664   E5F9 20 20                   bra     L1464                   ; Error bit was not already set, don't change sensrChkIdx (check it agaian next time)                                                                                               
6665   E5FB             
6666   E5FB                         ;-----------------------------------------------------------------------
6667   E5FB                         ; More than 4 sec elapsed since sensrChkIdx was reset to 0
6668   E5FB                         ; (this means that we have been stuck on testing the same sensor
6669   E5FB                         ; for 4 sec and it never worked properly...)
6670   E5FB                         ;
6671   E5FB                         ; Set the error flags and increase sensrChkIdx
6672   E5FB                         ;-----------------------------------------------------------------------
6673   E5FB 9A 4E       L1461       oraa    faultHi                ; Set the error bit if located in faultHi                                                                                       
6674   E5FD DA 4F                   orab    faultLo                ; Set the error bit if located in faultLo                                                                                                  
6675   E5FF DD 4E                   std     faultHi                ; Update faultHi:faultLo
6676   E601 9A 4C                   oraa    stFaultHi              ; Set the error bit if located in stFaultHi
6677   E603 DA 4D                   orab    stFaultLo              ; Set the error bit if located in stFaultLo
6678   E605 DD 4C                   std     stFaultHi              ; Update stFaultHi:stFaultLo
6679   E607 20 0A                   bra     L1463                  ; Branch to increase sensrChkIdx                                                                                               
6680   E609             
6681   E609                         ;---------------------------------------------------
6682   E609                         ; Sensor check returned zero, no error, reset bit
6683   E609                         ;---------------------------------------------------
6684   E609 EC 00       L1462       ldd     $00,x                   ; [a:b] = t_snsrChkBit(sensrChkIdx)
6685   E60B 43                      coma                            ; complement all bits                            
6686   E60C 53                      comb                            ; complement all bits                            
6687   E60D 94 4E                   anda    faultHi                 ; reset the bit if it was in faultHi 
6688   E60F D4 4F                   andb    faultLo                 ; reset the bit if it was in faultLo                               
6689   E611 DD 4E                   std     faultHi                 ; Update faultHi:faultLo                                
6690   E613             
6691   E613                         ;------------------------------------------------------
6692   E613                         ; Go to next sensor and re-init T2_snsrChk to 4 sec 
6693   E613                         ;------------------------------------------------------
6694   E613 7C 01 79    L1463       inc     sensrChkIdx             ; Increment index (go to next sensor check subroutine next time)                                    
6695   E616 86 08                   ldaa    #$08                    ; 4 sec                            
6696   E618 B7 01 3B                staa    T2_snsrChk              ; re-init timer to 4 sec                                  
6697   E61B             
6698   E61B                         ;-------------------------------------------------------------------------------
6699   E61B                         ; Section to verify the O2 sensor under specific conditions 
6700   E61B                         ;-------------------------------------------------------------------------------
6701   E61B                         ;-------------------------------------------------------------------------------
6702   E61B                         ; First check if o2Raw indicate rich or lean, set a flag in b for now
6703   E61B                         ;-------------------------------------------------------------------------------
6704   E61B 5F          L1464       clrb                            ; assume we are running lean, b = 0                            
6705   E61C 96 CE                   ldaa    o2Raw                   ; a = o2Raw                             
6706   E61E 81 1F                   cmpa    #$1f                    ;                             
6707   E620 25 02                   bcs     L1465                   ; Branch if o2Raw < 0.6V (lean)                             
6708   E622 CA 80                   orab    #$80                    ; Set flag indicating we are running rich
6709   E624                                                     
6710   E624                         ;-------------------------------------------------------------------------------
6711   E624                         ; Now check if all the conditions are met to do the verfication
6712   E624                         ;
6713   E624                         ;       engine has been running for more than 180sec
6714   E624                         ;       baro sensor value is reliable
6715   E624                         ;       no fault code on baro, coil, iat, ect, cas
6716   E624                         ;       ectRaw and iatRaw are within acceptable range
6717   E624                         ;       temperature(ectRaw) > 86degC
6718   E624                         ;       temperature(iatRaw) > 0degC
6719   E624                         ;       temperature(iatRaw) < 55degC
6720   E624                         ;       engine is running normally (no fuel cut, etc..)
6721   E624                         ;       airVolTB < $68 
6722   E624                         ;       airVolTB > $33
6723   E624                         ;       rpm31 < 4000
6724   E624                         ;       rpm31 > 2000
6725   E624                         ;       all conditions for closed loop mode are met
6726   E624                         ;
6727   E624                         ;-------------------------------------------------------------------------------
6728   E624 B6 01 43    L1465       ldaa    T0p5_crank2             ; a = T0p5_crank2                              
6729   E627 8B 5A                   adda    #$5a                    ;                             
6730   E629 25 5E                   bcs     L1467                   ; Bail if its been less than 180sec since engine started rotating                             
6731   E62B B6 01 1B                ldaa    T40_baro                ; T40_baro                                 
6732   E62E 26 59                   bne     L1467                   ; Bail if T40_baro not zero (meaning baro sensor value is not reliable)
6733   E630 87 4F 42 55             brset   faultLo, #$42, L1467    ; Bail if errors on baro or coil                                 
6734   E634 87 4E 26 51             brset   faultHi, #$26, L1467    ; Bail if errors on iat, ect or cas                                 
6735   E638 87 D6 03 4D             brset   state2, #$03, L1467     ; Bail ifectRaw or iatRaw out of acceptable range                                
6736   E63C 96 CB                   ldaa    ectRaw                  ; a = ectRaw                              
6737   E63E 81 1C                   cmpa    #$1c                    ;                             
6738   E640 24 47                   bcc     L1467                   ; Bail if temperature(ectRaw) <= 86degC                             
6739   E642 96 CC                   ldaa    iatRaw                  ; a = iatRaw                               
6740   E644 81 B3                   cmpa    #$b3                    ;                             
6741   E646 24 41                   bcc     L1467                   ; Bail if temperature(iatRaw) <= 0degC                              
6742   E648 81 41                   cmpa    #$41                    ;                             
6743   E64A 23 3D                   bls     L1467                   ; Bail if  temperature(iatRaw) >= 55degC                               
6744   E64C 87 E6 1F 39             brset   state1, #$1f, L1467     ; Bail if engine not running normally (i.e. notRotating or startingToCrank or rotatingStopInj or runningFast or no pulse accumulator interrupts received )
6745   E650 96 E2                   ldaa    airVolTB                ; a = airVolTB 
6746   E652             #ifdef E931
6747   E652 81 68                   cmpa    #$68                    ;                             
6748   E654 24 33                   bcc     L1467                   ; Bail if airVolTB >= $68 
6749   E656 81 33                   cmpa    #$33                    ;                             
6750   E658~            #else
6751   E658~                        cmpa    #$90                    ;                             
6752   E658~                        bcc     L1467                   ;                              
6753   E658~                        cmpa    #$1a                    ;                             
6754   E658             #endif
6755   E658 23 2F                   bls     L1467                   ; Bail if airVolTB <= $33 
6756   E65A 96 DD                   ldaa    rpm31                   ; a = rpm31                              
6757   E65C 81 80                   cmpa    #$80                    ;                             
6758   E65E 24 29                   bcc     L1467                   ; Bail if rpm31 >= 4000                              
6759   E660 81 40                   cmpa    #$40                    ;                             
6760   E662 23 25                   bls     L1467                   ; Bail if rpm31 <= 2000                              
6761   E664 8F E8 02 21             brclr   closedLpFlags, #$02, L1467   ; Bail if not all conditions for closed loop mode are met
6762   E668             
6763   E668                         ;---------------------------------------------------------
6764   E668                         ; All the conditions are met
6765   E668                         ; At this point, b = $80 if o2Raw is rich, $00 otherwise
6766   E668                         ;---------------------------------------------------------
6767   E668 17                      tba                             ; a = $80 if o2Raw rich else $00                               
6768   E669 9B FC                   adda    validFlags              ; a = validFlags + ($80 or $00)                              
6769   E66B 2B 16                   bmi     L1466                   ; Branch if running rich (validFlags + ($80 or $00) > $80 only if o2Raw>=0.6V above...)                             
6770   E66D             
6771   E66D                         ;-------------------------------
6772   E66D                         ; Running lean (o2Raw < 0.6V)
6773   E66D                         ;-------------------------------
6774   E66D B6 01 3C                ldaa    T2_o2Chk                ; a = T2_o2Chk                            
6775   E670 26 1C                   bne     L1468                   ; Branch if timer not expired, its been less than 30sec since all conditions were met and we are running lean                            
6776   E672 87 FC 02 18             brset   validFlags, #$02, L1468 ; Branch if o2 sensor condition already determined (no need to check further)
6777   E676             
6778   E676                         ;------------------------------------------------------
6779   E676                         ; Timer is expired and the o2 sensor condition is not 
6780   E676                         ; already determined. Since we have been running lean
6781   E676                         ; for over 30sec, we know the sensor is bad...
6782   E676                         ;
6783   E676                         ; Set the flag indicating the o2 sensor conditions was
6784   E676                         ; determined, and increment o2BadCnt (with max of 255) to
6785   E676                         ; indicate we have an error condition
6786   E676                         ; Note that o2BadCnt increase by 1 max every time 
6787   E676                         ; the ECU is turned on (which resets validFlags.1)
6788   E676                         ;------------------------------------------------------
6789   E676 03 FC 02                orm     validFlags, #$02        ; Set flag indicating o2 sensor condition was checked (bad in this case)                               
6790   E679 7C 00 50                inc     o2BadCnt                ; o2BadCnt = o2BadCnt + 1                              
6791   E67C 26 10                   bne     L1468                   ; Branch to continue if o2BadCnt != 0                              
6792   E67E 7A 00 50                dec     o2BadCnt                ; o2BadCnt equals 0, go back to 255                               
6793   E681 20 0B                   bra     L1468                   ; branch to continue                             
6794   E683             
6795   E683                         ;-----------------------------------------------------------------
6796   E683                         ; Running rich (o2Raw >= 0.6V)
6797   E683                         ; As soon as we are running rich we know the sensor 
6798   E683                         ; is good, clear fault and set flag indicating o2 sensor 
6799   E683                         ; conditions was determined (good in this case)
6800   E683                         ;-----------------------------------------------------------------
6801   E683 7F 00 50    L1466       clr     o2BadCnt                ; o2BadCnt = 0                               
6802   E686 03 FC 02                orm     validFlags, #$02             ; Set flag indicating o2 sensor condition was checked (ok in this case)                               
6803   E689             
6804   E689                         ;-------------------------------
6805   E689                         ; Re-init timer T2_o2Chk to 30sec
6806   E689                         ;-------------------------------
6807   E689 86 3C       L1467       ldaa    #$3c                    ; 30sec                             
6808   E68B B7 01 3C                staa    T2_o2Chk                ;                             
6809   E68E             
6810   E68E                         ;------------------------------------------------------------
6811   E68E                         ; Update validFlags.7 rich/lean flag with current o2 conditions
6812   E68E                         ;------------------------------------------------------------
6813   E68E 02 FC 7F    L1468       andm    validFlags, #$7f             ; Reset rich/lean flag 
6814   E691 DB FC                   addb    validFlags                   ; Add current rich/lean flag (set to 1 if rich)                            
6815   E693 D7 FC                   stab    validFlags                   ; Update validFlags                             
6816   E695             
6817   E695                         ;---------------------------------------------------------------------------
6818   E695                         ; if o2BadCnt >= 1, set o2 fault code in current and stored fault variables
6819   E695                         ;---------------------------------------------------------------------------
6820   E695 96 50                   ldaa    o2BadCnt                ;                               
6821   E697 81 01                   cmpa    #$01                    ;                             
6822   E699 25 08                   bcs     L1469                   ; Branch to no o2 fault if o2BadCnt=0                             
6823   E69B 03 4E 01                orm     faultHi, #$01           ; set oxygen sensor fault code?
6824   E69E 03 4C 01                orm     stFaultHi, #$01         ;                                    
6825   E6A1 20 03                   bra     L1470                   ;                              
6826   E6A3             
6827   E6A3                         ;------------------------------------------------------------
6828   E6A3                         ; Reset o2 fault code in only current fault variables
6829   E6A3                         ;------------------------------------------------------------
6830   E6A3 02 4E FE    L1469       andm    faultHi, #$fe           ; Clear oxygen sensor fault code
6831   E6A6             
6832   E6A6                         ;-------------------------------------------------------------------------------
6833   E6A6                         ; Check if all the conditions are met to test the egrt sensor validity
6834   E6A6                         ;
6835   E6A6                         ;       more than ($5a or $b4)/0.5 sec have elapsed since engine started rotating                             
6836   E6A6                         ;       baro sensor value is reliable
6837   E6A6                         ;       no fault code on baro, coil, iat, ect, cas
6838   E6A6                         ;       ectRaw and iatRaw are within acceptable range
6839   E6A6                         ;       temperature(ectRaw) > 86degC
6840   E6A6                         ;       temperature(iatRaw) < 55degC
6841   E6A6                         ;       baroRaw > 0.92bar
6842   E6A6                         ;       rpm31 < 3500
6843   E6A6                         ;       rpm31 > 2094
6844   E6A6                         ;       airVol < L2048(rpm)
6845   E6A6                         ;       airVol > L2047(rpm)
6846   E6A6                         ;
6847   E6A6                         ;-------------------------------------------------------------------------------
6848   E6A6 B6 01 78    L1470       ldaa    egrtTimerThr            ; a = egrtTimerThr                             
6849   E6A9 BB 01 43                adda    T0p5_crank2             ;                               
6850   E6AC 25 61                   bcs     L1474                   ; Bail if less than ($5a or $b4)/0.5 sec have elapsed since engine started rotating                             
6851   E6AE B6 01 1B                ldaa    T40_baro                ;                                 
6852   E6B1 26 5C                   bne     L1474                   ; Bail if T40_baro not zero (meaning baro sensor value is not reliable)
6853   E6B3 87 4F 42 58             brset   faultLo, #$42, L1474    ; Bail if errors on baro or coil                                      
6854   E6B7 87 4E 26 54             brset   faultHi, #$26, L1474    ; Bail if errors on iat, ect or cas                                  
6855   E6BB 87 D6 03 50             brset   state2, #$03, L1474     ; Bail ifectRaw or iatRaw out of acceptable range                                
6856   E6BF 96 CB                   ldaa    ectRaw                  ;                               
6857   E6C1 81 1C                   cmpa    #$1c                    ;                             
6858   E6C3 24 4A                   bcc     L1474                   ; Bail if temperature(ectRaw) <= 86degC                             
6859   E6C5 96 CC                   ldaa    iatRaw                  ;                               
6860   E6C7 81 42                   cmpa    #$42                    ;                             
6861   E6C9 23 44                   bls     L1474                   ; Bail if  temperature(iatRaw) >= 55degC                             
6862   E6CB 96 CD                   ldaa    baroRaw                 ;                                
6863   E6CD 81 BD                   cmpa    #$bd                    ;                             
6864   E6CF 25 3E                   bcs     L1474                   ; Bail if baroRaw < 0.92bar                               
6865   E6D1 96 DD                   ldaa    rpm31                   ;                              
6866   E6D3 81 70                   cmpa    #$70                    ;                             
6867   E6D5 24 38                   bcc     L1474                   ; Bail if rpm >=3500                              
6868   E6D7 81 43                   cmpa    #$43                    ;                             
6869   E6D9 23 34                   bls     L1474                   ; Bail if rpm <= 2094                              
6870   E6DB CE FF A1                ldx     #L2048                  ;                               
6871   E6DE BD EB 3F                jsr     interp16rpm             ; b = L2048(rpm)                                    
6872   E6E1 D1 E0                   cmpb    airVol                  ;                               
6873   E6E3 23 2A                   bls     L1474                   ; Bail if airVol >= L2048(rpm)                               
6874   E6E5 CE FF 97                ldx     #L2047                  ;                               
6875   E6E8 BD EB 3F                jsr     interp16rpm             ; b = L2047(rpm)                                   
6876   E6EB D1 E0                   cmpb    airVol                  ;                               
6877   E6ED 24 20                   bcc     L1474                   ; Bail if airVol <= L2047(rpm)                              
6878   E6EF             
6879   E6EF                         ;------------------------------------------
6880   E6EF                         ; All basic condition are met,
6881   E6EF                         ; bail if T2_egrtChk > 10
6882   E6EF                         ;------------------------------------------
6883   E6EF B6 01 3D                ldaa    T2_egrtChk              ;                             
6884   E6F2 81 0A                   cmpa    #$0a                    ;                             
6885   E6F4 22 3A                   bhi     L1478                   ; Bail if T2_egrtChk > 10 ????      
6886   E6F6                                                
6887   E6F6                         ;----------------------------------------------------
6888   E6F6                         ; All basic condition are met and  T2_egrtChk <= 10
6889   E6F6                         ; Check the temperature indicated by the egrt 
6890   E6F6                         ; sensor and branch accordingly 
6891   E6F6                         ;----------------------------------------------------
6892   E6F6 86 05                   ldaa    #$05                    ;                             
6893   E6F8 91 CF                   cmpa    egrtRaw                 ;                                
6894   E6FA 22 20                   bhi     L1477                   ; Branch if temperature(egrtRaw) > 307degCC (error, too hot)                            
6895   E6FC CE FF 90                ldx     #L2046                  ;                               
6896   E6FF BD EB 44                jsr     iatCInterp              ; b = L2046(iat)                                  
6897   E702 D1 CF                   cmpb    egrtRaw                 ;                                
6898   E704 25 16                   bcs     L1477                   ; Branch if temperature(egrtRaw) < L2046(iat) (error, too cold)                               
6899   E706             
6900   E706                         ;--------------------------------------------------------
6901   E706                         ; At this point we know the egrt sensor is good 
6902   E706                         ; clear fault and set flag indicating sensor condition
6903   E706                         ; was determined (good in this case)
6904   E706                         ;--------------------------------------------------------
6905   E706 7F 00 51                clr     egrtBadCnt              ; egrtBadCnt = 0, no fault                               
6906   E709 03 FC 04                orm     validFlags, #$04             ; Set flag indicating sensor condition was checked (ok in this case)                               
6907   E70C 4F                      clra                            ; a = 0                            
6908   E70D 20 02                   bra     L1475                   ; Branch to set timer to 5 sec such that we continously check the sensor                           
6909   E70F             
6910   E70F                         ;----------------------------------------
6911   E70F                         ; Reset T2_egrtChk timer to 20 sec and bail
6912   E70F                         ;----------------------------------------
6913   E70F 86 1E       L1474       ldaa    #$1e                    ; a = 15sec                            
6914   E711 8B 0A       L1475       adda    #$0a                    ; a = a + 5sec                            
6915   E713 24 02                   bcc     L1476                   ; Branch if no overflow                             
6916   E715 86 FF                   ldaa    #$ff                    ; Use max of $ff                            
6917   E717 B7 01 3D    L1476       staa    T2_egrtChk              ; Update T2_egrtChk                            
6918   E71A 20 14                   bra     L1478                   ; Bail                             
6919   E71C             
6920   E71C                         ;----------------------------------------------------------------------------------
6921   E71C                         ; At this point we found that the sensor temperature is out of range (bad sensor)
6922   E71C                         ;----------------------------------------------------------------------------------
6923   E71C B6 01 3D    L1477       ldaa    T2_egrtChk            ; a = T2_egrtChk                             
6924   E71F 26 0F                   bne     L1478                   ; Branch if timer not expired                             
6925   E721 87 FC 04 0B             brset   validFlags, #$04, L1478      ; Branch if egrt sensor condition already determined
6926   E725             
6927   E725                         ;--------------------------------------------------------------------------
6928   E725                         ; Sensor is bad, timer is expired and sensor condition not yet determined
6929   E725                         ;
6930   E725                         ; Set flag indicating sensor condition was determined (bad in this case)
6931   E725                         ; and increment egrtBadCnt (255 max) to indicate we have an error condition 
6932   E725                         ; Note that egrtBadCnt increase by 1 max every time the ECU is turned off/on
6933   E725                         ; (which resets validFlags.1)
6934   E725                         ;--------------------------------------------------------------------------
6935   E725 03 FC 04                orm     validFlags, #$04             ; Set flag                               
6936   E728 7C 00 51                inc     egrtBadCnt              ; egrtBadCnt = egrtBadCnt + 1                              
6937   E72B 26 03                   bne     L1478                   ; Bail if egrtBadCnt != 0                               
6938   E72D 7A 00 51                dec     egrtBadCnt              ; egrtBadCnt equals 0, go back to 255                              
6939   E730             
6940   E730                         ;---------------------------------------------------------------------------
6941   E730                         ; if egrtBadCnt >= 2, set egrt fault code in current and stored fault variables
6942   E730                         ;
6943   E730                         ; egrtBadCnt >= 2 only if the ECU is turned off and then on again 
6944   E730                         ;---------------------------------------------------------------------------
6945   E730 96 51       L1478       ldaa    egrtBadCnt              ;                               
6946   E732 81 02                   cmpa    #$02                    ;                             
6947   E734 25 08                   bcs     L1479                   ; Branch if egrtBadCnt < 2
6948   E736 03 4F 20                orm     faultLo, #$20           ; Set egrt sensor fault flag                                 
6949   E739 03 4D 20                orm     stFaultLo, #$20         ; Set egrt sensor fault flag                                   
6950   E73C 20 03                   bra     L1480                   ;                              
6951   E73E             
6952   E73E                         ;------------------------------------------------
6953   E73E                         ; Reset egrt fault code in current fault variable
6954   E73E                         ;------------------------------------------------
6955   E73E 02 4F DF    L1479       andm    faultLo, #$df           ;                                  
6956   E741             
6957   E741                         ;---------------------------------------------------------------------------
6958   E741                         ; Reset egrt errors and fault codes if vehicle is not for California 
6959   E741                         ;---------------------------------------------------------------------------
6960   E741 87 55 04 09 L1480       brset   config1, #$04, L1481    ; Bail if California car                                
6961   E745 7F 00 51                clr     egrtBadCnt              ; reset egrt error count                               
6962   E748 02 4D DF                andm    stFaultLo, #$df         ; Reset egrt stored fault code                                   
6963   E74B 02 4F DF                andm    faultLo, #$df           ; Reset egrt current fault code                                 
6964   E74E             
6965   E74E                         ;---------------------------------------------------------------------------
6966   E74E                         ; Reset N/A stored fault codes (fault codes don't correspond to anything)
6967   E74E                         ;---------------------------------------------------------------------------
6968   E74E 02 4C EF    L1481       andm    stFaultHi, #$ef         ;                                    
6969   E751 02 4D 7F                andm    stFaultLo, #$7f         ;                                    
6970   E754             
6971   E754                         ;----------------------------------------------------------------
6972   E754                         ; If ECU is not about to turn-off check if there are faults set
6973   E754                         ; and inital 5 sec "check engine light on" delay
6974   E754                         ;----------------------------------------------------------------
6975   E754 B6 01 24                ldaa    T40_noPower             ;                                    
6976   E757 27 11                   beq     L1482                   ; Branch to clear check engine light if timer expired (ECU is about to turn-off)
6977   E759 DC 4E                   ldd     faultHi                 ; d = faultHi:faultLo (current faults)                               
6978   E75B 84 EF                   anda    #$ef                    ; Reset N/A sensor fault bit                             
6979   E75D 26 10                   bne     L1483                   ; Branch to set check engine light if any errors left in faultHi
6980   E75F C4 7E                   andb    #$7e                    ; Reset vss and baro sensor in faultLo                            
6981   E761 26 0C                   bne     L1483                   ; Branch to set check engine light if any errors left in faultLo
6982   E763 B6 01 35                ldaa    T2_EcuPower             ;                                    
6983   E766 8B 0A                   adda    #$0a                    ;                             
6984   E768 25 05                   bcs     L1483                   ; Branch if its been less than 5 sec since ECU power has been on                             
6985   E76A             
6986   E76A                         ;------------------------------------------------------------------
6987   E76A                         ; Its been more than 5 sec since ECU power has been on
6988   E76A                         ; and there is no fault set in faultHi:faultLo (apart from vss)
6989   E76A                         ; and ECU in not about to turn off
6990   E76A                         ;
6991   E76A                         ; Clear check engine light                             
6992   E76A                         ;------------------------------------------------------------------
6993   E76A 03 2F 08    L1482       orm     port6, #$08             ; clear CE light                                                                            
6994   E76D 20 03                   bra     L1484                   ;                                                                                             
6995   E76F             
6996   E76F                         ;-------------------------------------------------------------
6997   E76F                         ; Its been less than 5 sec since ECU power has been on
6998   E76F                         ; or there are faults set in faultHi:faultLo (apart from vss) 
6999   E76F                         ; or ECU is about to turn off
7000   E76F                         ;
7001   E76F                         ; Activate check engine light                             
7002   E76F                         ;-------------------------------------------------------------
7003   E76F 02 2F F7    L1483       andm    port6, #$f7             ; activate CE light                                                                               
7004   E772             
7005   E772             
7006   E772                         ;-----------------------------------------------------------------
7007   E772                         ; Section to process diagnostic connector port commands/requests
7008   E772                         ;-----------------------------------------------------------------
7009   E772                         ;--------------------------------------------------------------
7010   E772                         ; Bail to "heart beat" mode section if port rx is not enabled
7011   E772                         ;--------------------------------------------------------------
7012   E772 87 11 08 03 L1484       brset   sci_scr, #$08, L1485    ; Branch if serial port rx enabled.                                                                      
7013   E776 7E E8 5A                jmp     L_heartBeat             ; rx not enabled, branch to section processing heart beat code
7014   E779             
7015   E779                         ;-----------------------------------------------------------
7016   E779                         ; rx is enabled, we are in test mode. Check if anything 
7017   E779                         ; is being transmited or if anything new was received
7018   E779                         ;-----------------------------------------------------------
7019   E779 8F 11 20 04 L1485       brclr   sci_scr, #$20, L1486    ; Branch if transmit data register is not empty (1 = empty...)                                 
7020   E77D 87 FA 40 0C             brset   obdFlags, #$40, L1487   ; tx empty, branch if anything to process (e.g. a code was received (in interupt) and stored in obdCode)?
7021   E781             
7022   E781                         ;-------------------------------------------------
7023   E781                         ; At this point rx enabled but tx not empty 
7024   E781                         ; or it is empty but there is nothing to process
7025   E781                         ;
7026   E781                         ; Reset action related registers and bail
7027   E781                         ;-------------------------------------------------
7028   E781 03 BA 3F    L1486       orm     obdInjCmd, #$3f         ; reset any injector action
7029   E784 7F 00 FB                clr     obdActCmd               ; reset any actuator action
7030   E787 7F 01 2D                clr     T40_obdCmd              ; Clear action timer                                                                         
7031   E78A 7E E8 4F                jmp     L1504                   ; Bail to rest of code                                               
7032   E78D             
7033   E78D                         ;------------------------------------------------------------
7034   E78D                         ; At this point we are in test mode, transmit register is 
7035   E78D                         ; empty and a new code was received and stored in obdCode
7036   E78D                         ; Process the new code,
7037   E78D                         ;------------------------------------------------------------
7038   E78D                         ;------------------------------------------
7039   E78D                         ; Check if code is $fd (serial link test)
7040   E78D                         ;------------------------------------------
7041   E78D             #ifdef E931
7042   E78D 86 B5       L1487       ldaa    #$b5                    ; Default value returned if code = $fd. (serial link test)
7043   E78F~            #else
7044   E78F~            L1487       ldaa    #$b7                    ; Default value returned if code = $fd. (serial link test)
7045   E78F             #endif
7046   E78F F6 01 7A                ldab    obdCode                 ; load received OBD code                       
7047   E792 C1 FD                   cmpb    #$fd                    ;                                              
7048   E794 25 11                   bcs     L1490                   ; branch if code is lower than $FD             
7049   E796 27 5D                   beq     L1496                   ; bail to send response if code is equal to $fd
7050   E798             
7051   E798                         ;--------------------------------------------------------
7052   E798                         ; obdCode equals $fe or $ff, respond with high or low
7053   E798                         ; part ($fe or $ff code) of configration data (t_strap3)
7054   E798                         ;--------------------------------------------------------
7055   E798 CE FB 32                ldx     #t_strap3               ; x = configuration data
7056   E79B 17                      tba                             ;                                              
7057   E79C BD EC 0D                jsr     cfgLookup16             ;                                              
7058   E79F 81 FE                   cmpa    #$fe                    ; compare to FE                                
7059   E7A1 1A                      xgdx                            ;
7060   E7A2 27 01                   beq     L1489                   ;
7061   E7A4 17                      tba                             ;
7062   E7A5 20 4E       L1489       bra     L1496                   ; branch to send on serial                                    
7063   E7A7             
7064   E7A7                         ;------------------------
7065   E7A7                         ; obdCode lower than $fd
7066   E7A7                         ;------------------------
7067   E7A7 C1 F1       L1490       cmpb    #$f1                    ;                                                             
7068   E7A9 24 32                   bcc     L1494                   ; branch if code is larger or equal to $f1                    
7069   E7AB C1 40                   cmpb    #$40                    ;                                                             
7070   E7AD 25 0A                   bcs     L1491                   ; branch if code is lower than $40                            
7071   E7AF             
7072   E7AF                         ;------------------------
7073   E7AF                         ; $40 <= obdCode < $f1
7074   E7AF                         ; Check if it is $ca
7075   E7AF                         ;------------------------
7076   E7AF C1 CA                   cmpb    #$ca                    ;                                                             
7077   E7B1 27 18                   beq     L1493                   ; branch if code equals $ca                                    
7078   E7B3             
7079   E7B3                         ;----------------------------------------------------------------------
7080   E7B3                         ; $40 <= obdCode < $f1 and it is not $ca
7081   E7B3                         ; just respond with whatever is stored in the corresponding memory
7082   E7B3                         ;----------------------------------------------------------------------
7083   E7B3 4F                      clra                            ; a=0
7084   E7B4 1A                      xgdx                            ; x = obdCode
7085   E7B5 A6 00                   ldaa    $00,x                   ; a = whatever is in corresponding memory
7086   E7B7 20 3C                   bra     L1496                   ; branch to send on serial                                    
7087   E7B9             
7088   E7B9                         ;----------------------------------------------------------------------
7089   E7B9                         ; obdCode lower than $40, respond with sensor value 
7090   E7B9                         ; ($3e and $3f are converted to $3d)
7091   E7B9                         ;----------------------------------------------------------------------
7092   E7B9 CE D0 00    L1491       ldx     #obdTable               ; x points to obdTable
7093   E7BC C1 3D                   cmpb    #$3d                    ;                                                             
7094   E7BE 23 02                   bls     L1492                   ; branch if obdCode <= $3d                                         
7095   E7C0 C6 3D                   ldab    #$3d                    ; Use max of $3d ($3e and $3f are converted to $3d???)                     
7096   E7C2 3A          L1492       abx                             ; x points to "sensor" address in table                                
7097   E7C3 E6 00                   ldab    $00,x                   ; b = obdTable(obdCode)
7098   E7C5 4F                      clra                            ; a = 0                                                            
7099   E7C6 1A                      xgdx                            ; x = d = obdTable(obdCode)
7100   E7C7 A6 00                   ldaa    $00,x                   ; a = sensor value
7101   E7C9 20 2A                   bra     L1496                   ; branch to send on serial                                    
7102   E7CB             
7103   E7CB                         ;----------------------------------------------------
7104   E7CB                         ; obdCode = $ca, clear error faults if engine is not 
7105   E7CB                         ; rotating and respond with $00
7106   E7CB                         ;----------------------------------------------------
7107   E7CB B6 01 20    L1493       ldaa    T40_engRot              ;                                                                                                         
7108   E7CE 26 6C                   bne     L1502                   ; Don't reset fault codes if engine is rotating, we use them to run the car...                                                                     
7109   E7D0 4F                      clra                            ;                                                                                                         
7110   E7D1 5F                      clrb                            ;                                                                                                                                      
7111   E7D2 DD 4C                   std     stFaultHi               ; Erase fault codes                                                                                                                     
7112   E7D4 DD 4E                   std     faultHi                 ; Erase fault codes                                                                                                                     
7113   E7D6 97 50                   staa    o2BadCnt                ; Erase o2 sensor error count
7114   E7D8 97 51                   staa    egrtBadCnt              ; Erase egrt sensor error count
7115   E7DA 4F                      clra                            ;                                                                                                                                      
7116   E7DB 20 18                   bra     L1496                   ; Branch to send $00 on serial
7117   E7DD                                                                                                                                                                   
7118   E7DD                         ;----------------------------------------------------
7119   E7DD                         ; obdCode >= $f1, this is a command/action code
7120   E7DD                         ; Check if any action is already ongoing
7121   E7DD                         ;----------------------------------------------------
7122   E7DD 96 BA       L1494       ldaa    obdInjCmd               ; a = obdInjCmd            
7123   E7DF 43                      coma                            ; a = ~obdInjCmd           
7124   E7E0 84 3F                   anda    #$3f                    ; a = ~obdInjCmd & 00111111                                                                                                                                        
7125   E7E2 26 04                   bne     L1495                   ; branch if any injector already turned-off
7126   E7E4 8F FB FF 10             brclr   obdActCmd, #$ff, L1497  ; branch to continue processing if no actuator previously activated
7127   E7E8                                                                                                                      
7128   E7E8                         ;----------------------------------------------------
7129   E7E8                         ; obdCode >= $f1 and an action is already ongoing
7130   E7E8                         ;----------------------------------------------------
7131   E7E8 B6 01 2D    L1495       ldaa    T40_obdCmd              ; 
7132   E7EB 26 0B                   bne     L1497                   ; Branch if timer not expired                                                                                                                                      
7133   E7ED             
7134   E7ED                         ;----------------------------------------------------
7135   E7ED                         ; Action already ongoing and timer is expired,
7136   E7ED                         ; reset all injector and actuators to normal mode and 
7137   E7ED                         ; respond with $00 (ignore new action)
7138   E7ED                         ;----------------------------------------------------
7139   E7ED 03 BA 3F                orm     obdInjCmd, #$3f         ; set all injectors to normal operation                                                                                                                 
7140   E7F0 7F 00 FB                clr     obdActCmd               ; clear current actuator commands                                                                                                                 
7141   E7F3 86 00                   ldaa    #$00                    ;                                                                                                                                      
7142   E7F5 7E E8 47    L1496       jmp     L1503                   ;                                                                                                                                       
7143   E7F8             
7144   E7F8                         ;-----------------------------------------------
7145   E7F8                         ; No action is ongoing or an action is ongoing 
7146   E7F8                         ; but not finished (timer not expired)
7147   E7F8                         ;
7148   E7F8                         ; continue processing new code
7149   E7F8                         ;-----------------------------------------------
7150   E7F8 C1 F6       L1497       cmpb    #$f6                    ;                                                                                                                                      
7151   E7FA 23 06                   bls     L1498                   ; branch if code is $f1 to $f6                                                                                                            
7152   E7FC             
7153   E7FC                         ;-----------------------------------------------------------
7154   E7FC                         ; $f7 <= obdCode <= $fc, this is a turn injector off command
7155   E7FC                         ; Bail if vehicle is moving
7156   E7FC                         ;-----------------------------------------------------------
7157   E7FC 96 C4                   ldaa    vssCnt1                 ; a = check speed                                                                                                                                      
7158   E7FE 27 07                   beq     L1499                   ; Branch if speed is close to 0                                                                                                                                      
7159   E800 20 3A                   bra     L1502                   ; speed too high, bail (safety I assume)        
7160   E802                                                                                                                                                       
7161   E802                         ;----------------------------------------------------
7162   E802                         ; $f1 <= obdCode <= f6, this is an actuator command
7163   E802                         ; Bail if engine is rotating
7164   E802                         ;----------------------------------------------------
7165   E802 B6 01 20    L1498       ldaa    T40_engRot              ; code is F1 to F6, check if "engine running"?                                                                                          
7166   E805 26 35                   bne     L1502                   ; bail if engine is rotating  (safety I assume)
7167   E807             
7168   E807                         ;------------------------------------------------------------
7169   E807                         ; $f1<= obdCode <= $f6 and it is safe to perform the action
7170   E807                         ; continue processing command/action code
7171   E807                         ;------------------------------------------------------------
7172   E807                         ;----------------------------------
7173   E807                         ; Bail if any injector is already 
7174   E807                         ; turned-off by previous command
7175   E807                         ;----------------------------------
7176   E807 96 BA       L1499       ldaa    obdInjCmd               ; a = obdInjCmd
7177   E809 43                      coma                            ; a = ~obdInjCmd
7178   E80A 84 3F                   anda    #$3f                    ; a = ~obdInjCmd & 00111111
7179   E80C 26 41                   bne     L1504                   ; bail if any injector already off                                                                                                                
7180   E80E             
7181   E80E                         ;----------------------------------
7182   E80E                         ; Bail if an actuator is already 
7183   E80E                         ; turned-on by previous command
7184   E80E                         ;----------------------------------
7185   E80E 87 FB FF 3D             brset   obdActCmd, #$ff, L1504  ; bail if a previous action is ongoing
7186   E812             
7187   E812                         ;-----------------------------------------
7188   E812                         ; Check if injector or actuator command
7189   E812                         ;-----------------------------------------
7190   E812 C0 F7                   subb    #$f7                    ; b = obdCode - $f7
7191   E814 25 0D                   bcs     L1500                   ; Branch if obdCode < $f7 (actuator command)
7192   E816             
7193   E816                         ;-------------------------------------------
7194   E816                         ; obdCode >=$f7, it is an injector command, 
7195   E816                         ; Ignore it for injectors 5 and 6
7196   E816                         ;-------------------------------------------
7197   E816 C0 02                   subb    #$02                    ; b = injIndex = obdCode - $f7 - $02 = -2 to 3 range (injector 6 to 1 respectively...)
7198   E818 25 22                   bcs     L1502                   ; branch if code is negative (injectors 5 and 6, do nothing)                                                                           
7199   E81A             
7200   E81A                         ;----------------------------------
7201   E81A                         ; obdCode >=$f7, injector command
7202   E81A                         ;----------------------------------
7203   E81A CE E5 69                ldx     #t_obdInjMask           ; x points to t_obdInjMask (table t_obdInjMask: $fb $fd $f7 $fe)                                                                                                             
7204   E81D 3A                      abx                             ; 
7205   E81E A6 00                   ldaa    $00,x                   ; a = t_obdInjMask(injIndex) ($fb $fd $f7 $fe for injector 4 3 2 1 resp.-> order in nibble -> 2 4 3 1)
7206   E820 5F                      clrb                            ; b = $00                                                                                                                                     
7207   E821 20 0A                   bra     L1501                   ;     
7208   E823                                                                                                                                                           
7209   E823                         ;--------------------------------------------
7210   E823                         ; obdCode <$f7, it is an actuator command
7211   E823                         ;--------------------------------------------
7212   E823 CB 06       L1500       addb    #$06                    ; b = actIndex = obdCode - $f7 + $06 = 0 to 5
7213   E825 CE E5 63                ldx     #t_obdActMask           ; x points to t_obdActMask: 20 10 08 04 01 02                                                                                                          
7214   E828 3A                      abx                             ;                                                                                                                                      
7215   E829 E6 00                   ldab    $00,x                   ; b = t_obdActMask(actIndex)
7216   E82B 86 FF                   ldaa    #$ff                    ; a = $ff
7217   E82D             
7218   E82D                         ;-----------------------------------------------------------
7219   E82D                         ; At this point, 
7220   E82D                         ; a contains the new injector to turn off, if any 
7221   E82D                         ; b contains the new actuator to turn on, if any 
7222   E82D                         ;
7223   E82D                         ; Update obdInjCmd and obdActCmd. Notice that only one 
7224   E82D                         ; actuator is activated at a time but multiple injectors 
7225   E82D                         ; can be turned off...
7226   E82D                         ;-----------------------------------------------------------
7227   E82D 0F          L1501       sei                             ; Disable interrupts                                                                                                                                     
7228   E82E 94 BA                   anda    obdInjCmd               ; Turn off the new injector and continue turning off the existing ones
7229   E830 97 BA                   staa    obdInjCmd               ; Update  obdInjCmd 
7230   E832 D7 FB                   stab    obdActCmd               ; Turn on the new actuator
7231   E834 0E                      cli                             ;                                                                                                                                      
7232   E835             
7233   E835                         ;--------------------------------------------
7234   E835                         ; Re-init T40_obdCmd timer to 6sec and bail
7235   E835                         ;--------------------------------------------
7236   E835 86 F0                   ldaa    #$f0                    ; 6 sec
7237   E837 B7 01 2D                staa    T40_obdCmd              ; T40_obdCmd = 6 sec                                                                                                                                      
7238   E83A 20 13                   bra     L1504                   ; jump to RTS                                                                                                                           
7239   E83C             
7240   E83C                         ;--------------------------------------------
7241   E83C                         ; Reset any ongoing actions (injector or actuator)
7242   E83C                         ;--------------------------------------------
7243   E83C 03 BA 3F    L1502       orm     obdInjCmd, #$3f         ; Set all injectors to on                                                                                                                 
7244   E83F 7F 00 FB                clr     obdActCmd               ; Set all actuators to off                                                                                                  
7245   E842 7F 01 2D                clr     T40_obdCmd              ; Clear timer
7246   E845 86 FF                   ldaa    #$ff                    ; respond with $ff                                                                                                                                     
7247   E847             
7248   E847                         ;-----------------------------------------------------------------
7249   E847                         ; At this point a contains the response to send on diagnostic port
7250   E847                         ; send it...
7251   E847                         ;-----------------------------------------------------------------
7252   E847 97 13       L1503       staa    sci_tx                  ; either FF or 00 or output value to serial port                                                                                    
7253   E849 03 FA 80                orm     obdFlags, #$80          ; set bit indicating something has been sent
7254   E84C 02 FA BF                andm    obdFlags, #$bf          ; reset bit $40 since we finished processing the request
7255   E84F             
7256   E84F                         ;---------------------------------------------
7257   E84F                         ; Jump to rest of code (skip heart beat mode)
7258   E84F                         ;---------------------------------------------
7259   E84F 7E E8 FA    L1504       jmp     L1524                   ; Jump to RTS                                                                                                                           
7260   E852                                                                                
7261   E852             
7262   E852             
7263   E852             ;****************************************************************
7264   E852             ;
7265   E852             ; Used in processing the output of error codes to test connector
7266   E852             ;
7267   E852             ; Used to Represent the number of shift we need to apply...
7268   E852             ;
7269   E852             ;****************************************************************
7270   E852 80 40 20 10 t_errCodeShift .byte   $80, $40, $20, $10, $08, $04, $02, $01
7270   E856 08 04 02 01 
7271   E85A             
7272   E85A             
7273   E85A             
7274   E85A             ;****************************************************************
7275   E85A             ;
7276   E85A             ; Output error codes to test connector (heart beat mode)
7277   E85A             ;
7278   E85A             ; a and b are used throughout this code to contain 
7279   E85A             ; the old/new values of errCodeProc and errCodeIdx
7280   E85A             ;
7281   E85A             ; Freakin difficult code to disassemble! 
7282   E85A             ;
7283   E85A             ;
7284   E85A             ;****************************************************************
7285   E85A                         ;----------------------------
7286   E85A                         ; Only execute code at 2Hz
7287   E85A                         ;----------------------------
7288   E85A 87 D9 04 03 L_heartBeat brset   Tclocks, #$04, L1507    ; Branch if 2Hz signal set
7289   E85E 7E E8 FA                jmp     L1524                   ; 2Hz signal not yet set, bail 
7290   E861             
7291   E861                         ;--------------------------------------------------
7292   E861                         ; Load basic variables and check whether 
7293   E861                         ; a code is currently being output to connector
7294   E861                         ;--------------------------------------------------
7295   E861 B6 01 7C    L1507       ldaa    errCodeProc             ; a = errCodeProc
7296   E864 F6 01 7B                ldab    errCodeIdx              ; b = errCodeIdx                                                                                         
7297   E867 4D                      tsta                            ;                             
7298   E868 26 04                   bne     L1508                   ; Branch if errCodeProc != 0 ( a code is currently being output)
7299   E86A C5 E0                   bitb    #$e0                    ; test 3 bit 2Hz timer...                            
7300   E86C 27 03                   beq     L1509                   ; Branch if timer is expired (we are really finished with previous code...)
7301   E86E 7E E8 E7    L1508       jmp     L1520                   ; Jump to continue processing the code currently being output
7302   E871                          
7303   E871                         ;---------------------------------------------------------------
7304   E871                         ; At this point we are not processing anything, continue trying
7305   E871                         ;---------------------------------------------------------------
7306   E871 4F          L1509       clra                            ; a = 0                             
7307   E872 97 57                   staa    temp1                   ; temp1 = 0                             
7308   E874 96 4C       L1510       ldaa    stFaultHi               ; preload a = stFaultHi                                   
7309   E876 D7 58                   stab    temp2                   ; temp1:temp2 = errCodeIdx, notice "stab" changes zero flag for branch below...                              
7310   E878 27 18                   beq     L1512                   ; Branch if errCodeIdx = 0
7311   E87A             
7312   E87A                         ;---------------------------------------------
7313   E87A                         ; errCodeIdx > 0
7314   E87A                         ; Check if errCodeIdx <= 8                 
7315   E87A                         ;---------------------------------------------
7316   E87A CE E8 51                ldx     #t_errCodeShift-1       ; x points to t_errCodeShift-1                              
7317   E87D C0 08                   subb    #$08                    ; b = errCodeIdx - 8                            
7318   E87F 23 0B                   bls     L1511                   ; Branch if errCodeIdx <= 8                             
7319   E881             
7320   E881                         ;----------------------------------------------
7321   E881                         ; errCodeIdx > 8, current index is in low fault                 
7322   E881                         ;----------------------------------------------
7323   E881 96 4D                   ldaa    stFaultLo               ; a = stFaultLo since thats what we should be using                                 
7324   E883 3A                      abx                             ; x points to t_errCodeShift - 1 + (errCodeIdx - 8)                            
7325   E884 E6 00                   ldab    $00,x                   ; b = t_errCodeShift(errCodeIdx)
7326   E886 3D                      mul                             ; shift whats left to process in high part of d (in a)
7327   E887 DE 57                   ldx     temp1                   ; x = 0:errCodeIdx
7328   E889 4D                      tsta                            ; test if any fault bit set
7329   E88A 20 10                   bra     L1513                   ; Branch 
7330   E88C             
7331   E88C                         ;-----------------------------------------------
7332   E88C                         ; errCodeIdx <= 8, current index is in high fault                
7333   E88C                         ;-----------------------------------------------
7334   E88C CB 08       L1511       addb    #$08                    ; b = errCodeIdx - 8 + 8 = errCodeIdx                           
7335   E88E 3A                      abx                             ; x points to t_errCodeShift-1 + errCodeIdx                           
7336   E88F E6 00                   ldab    $00,x                   ; b = t_errCodeShift(errCodeIdx)
7337   E891 3D                      mul                             ; shift whats left to process in high part of d (in a)
7338   E892             
7339   E892 DE 57       L1512       ldx     temp1                   ; x = 0:errCodeIdx
7340   E894 4D                      tsta                            ; test if any fault bit set
7341   E895 26 07                   bne     L1514                   ; Branch if any fault bit were set
7342   E897             
7343   E897                         ;-----------------------------------------------
7344   E897                         ; No fault bit set in high part, try low part now
7345   E897                         ;-----------------------------------------------
7346   E897 CE 00 08                ldx     #$0008                  ; new errCodeIdx x = 8                              
7347   E89A 96 4D                   ldaa    stFaultLo               ; a = stFaultLo                                  
7348   E89C             
7349   E89C                         ;--------------------------------------------------                 
7350   E89C                         ; At this point, a contains the error bits left (if any)
7351   E89C                         ; to process and x is the current index error 
7352   E89C                         ;--------------------------------------------------                 
7353   E89C 27 16       L1513       beq     L1515                   ; branch if no error are set in what is left to process
7354   E89E             
7355   E89E                         ;---------------------------------
7356   E89E                         ; Loop until we find the bit
7357   E89E                         ;---------------------------------                 
7358   E89E 08          L1514       inx                             ; ++x
7359   E89F 44                      lsra                            ; Shift lowest bit in carry
7360   E8A0 24 FC                   bcc     L1514                   ; Loop if bit was 0                             
7361   E8A2             
7362   E8A2                         ;----------------------------------------------------------------
7363   E8A2                         ; We found a bit set -> we found the next error code to output...
7364   E8A2                         ; update new errCodeProc value (in a for now) and new errCodeIdx
7365   E8A2                         ; (in a for now)
7366   E8A2                         ;----------------------------------------------------------------
7367   E8A2 DF 57                   stx     temp1                   ; temp1:temp2 = newBitIndex of next code????
7368   E8A4 D6 58                   ldab    temp2                   ; b = newBitIndex
7369   E8A6 CE E5 3A                ldx     #t_snsrChkCode-1        ; x points to t_snsrChkCode-1
7370   E8A9 3A                      abx                             ; x points to t_snsrChkCode-1 + newBitIndex
7371   E8AA A6 00                   ldaa    $00,x                   ; a = t_snsrChkCode(newBitIndex)                              
7372   E8AC 8A 80                   oraa    #$80                    ; a = t_snsrChkCode(newBitIndex) | $80                            
7373   E8AE C4 1F                   andb    #$1f                    ; b = newBitIndex & $1f                            
7374   E8B0 CA A0                   orab    #$a0                    ; Set newBitIndex high bits (timer) to 2.5 sec
7375   E8B2 20 3B                   bra     L1521                   ; Branch to set heart beat output and store a and b                             
7376   E8B4             
7377   E8B4                         ;------------------------------------------------------
7378   E8B4                         ; No error found in stFaultLo, this means we are 
7379   E8B4                         ; at the end of the cycle... (we checked high part 
7380   E8B4                         ; first and then low part), restart the whole 
7381   E8B4                         ; thing from errCodeIdx=0 if errCodeIdx not already at 0
7382   E8B4                         ;------------------------------------------------------
7383   E8B4 5F          L1515       clrb                            ; b = 0 = new value of errCodeIdx                             
7384   E8B5 96 58                   ldaa    temp2                   ; a = old errCodeIdx                             
7385   E8B7 26 BB                   bne     L1510                   ; Loop back if old errCodeIdx != 0                             
7386   E8B9             
7387   E8B9                         ;--------------------------------------------------------------------------
7388   E8B9                         ; errCodeIdx already at 0, there where no error during the cycle
7389   E8B9                         ; toggle heart beat sent to diagnostic port, this is the "no fault" signal
7390   E8B9                         ;--------------------------------------------------------------------------
7391   E8B9 36                      psha                            ; st0 = a, why, we know a=0 from test above???????????
7392   E8BA 0F                      sei                             ; Make sure no interrupt plays with port2 while we change it
7393   E8BB 96 03                   ldaa    port2                   ;                               
7394   E8BD 88 10                   eora    #$10                    ; Toggle heart beat sent to diagnostic port?
7395   E8BF 97 03                   staa    port2                   ; Update port                             
7396   E8C1 0E                      cli                             ;                             
7397   E8C2 32                      pula                            ; a = st0 = 0                               
7398   E8C3 20 2F                   bra     L1523                   ; Branch to exit       
7399   E8C5                                               
7400   E8C5                         ;----------------------------------------------------------------
7401   E8C5                         ; errCodeIdx upper 3 bit timer is expired (Branch from below)
7402   E8C5                         ; First check if there are more long pulse to ouptput
7403   E8C5                         ;----------------------------------------------------------------
7404   E8C5 85 70       L1516       bita    #$70                    ;                             
7405   E8C7 27 0B                   beq     L1518                   ; Branch if no more long pulse code (errCodeProc & 01110000 = 0)                             
7406   E8C9             
7407   E8C9                         ;-------------------------------------
7408   E8C9                         ; There are more long pulse to output
7409   E8C9                         ;-------------------------------------
7410   E8C9 80 10                   suba    #$10                    ; decrement the number of long pulse by 1
7411   E8CB C4 1F                   andb    #$1f                    ; reset timer to 0 (upper 3 bits)                            
7412   E8CD CA 80                   orab    #$80                    ; Set 2Hz 3 bit timer to 4 (2 sec)
7413   E8CF 02 03 EF    L1517       andm    port2, #$ef             ; Set heart beat sent to diagnostic port
7414   E8D2 20 1E                   bra     L1522                   ; Branch to update timer and exit
7415   E8D4                                                      
7416   E8D4                         ;----------------------------------------------------
7417   E8D4                         ; No more long pulse to output 
7418   E8D4                         ; Check if bit 7 is set (was set when we 
7419   E8D4                         ; started output of this code)
7420   E8D4                         ;----------------------------------------------------
7421   E8D4 85 80       L1518       bita    #$80                    ;                             
7422   E8D6 27 08                   beq     L1519                   ; Branch if bit is not set
7423   E8D8             
7424   E8D8                         ;-----------------------------------------------------------------------------
7425   E8D8                         ; bit 7 is set, we are therefore at the midpoint between long and short pulse
7426   E8D8                         ;
7427   E8D8                         ; reset the flag, set the timer to 1.5 sec, reset output and exit
7428   E8D8                         ; This is basically a 1.5 sec pause in between long and short pulse
7429   E8D8                         ;-----------------------------------------------------------------------------
7430   E8D8 84 7F                   anda    #$7f                    ; Reset bit 7 (nothing left to output flag). At this point a should be equal to $7f ???
7431   E8DA C4 1F                   andb    #$1f                    ; Reset timer to 0 (upper 3 bits)                            
7432   E8DC CA 60                   orab    #$60                    ; Set 2Hz 3 bit timer to 3 (1.5 sec)
7433   E8DE 20 0F                   bra     L1521                   ; Branch to reset hearth beat, update timer and exit                               
7434   E8E0             
7435   E8E0                         ;-----------------------------------------------------------------
7436   E8E0                         ; Flag was not set, just output whatever short pulses are left...
7437   E8E0                         ;-----------------------------------------------------------------
7438   E8E0 4A          L1519       deca                            ; decrement the number of short pulse by 1
7439   E8E1 C4 1F                   andb    #$1f                    ; reset timer to 0 (upper 3 bits)                       
7440   E8E3 CA 40                   orab    #$40                    ; Set 2Hz 3 bit timer to 2 (1 sec)                           
7441   E8E5 20 E8                   bra     L1517                   ; Branch to set hearth beat, update timer and exit                             
7442   E8E7             
7443   E8E7                         ;---------------------------------
7444   E8E7                         ; A code is currently being output...
7445   E8E7                         ; At this point we have
7446   E8E7                         ;       a = errCodeProc   
7447   E8E7                         ;       b = errCodeIdx  
7448   E8E7                         ;---------------------------------                 
7449   E8E7 C1 20       L1520       cmpb    #$20                    ;                             
7450   E8E9 25 DA                   bcs     L1516                   ; Branch if errCodeIdx < $20 (e.g. timer=0, upper 3 bit timer is expired)                            
7451   E8EB             
7452   E8EB                         ;-------------------------------------                 
7453   E8EB                         ; Timer not expired check if timer>1
7454   E8EB                         ;-------------------------------------                 
7455   E8EB C1 3F                   cmpb    #$3f                    ;                             
7456   E8ED 22 03                   bhi     L1522                   ; Branch if errCodeIdx > $3f (timer>1)
7457   E8EF             
7458   E8EF                         ;-------------------------------------------
7459   E8EF                         ; timer = 1, set heart beat mode output
7460   E8EF                         ;-------------------------------------------
7461   E8EF             
7462   E8EF                         ;-------------------------------------------
7463   E8EF                         ; Reset heart beat output on diagnostic port 
7464   E8EF                         ;-------------------------------------------
7465   E8EF 03 03 10    L1521       orm     port2, #$10             ; Reset heart beat sent to diagnostic port 
7466   E8F2             
7467   E8F2                         ;-------------------------------------------------------------
7468   E8F2                         ; Decrement errCodeIdx timer (upper 3 bits) by $20 (0.5sec)
7469   E8F2                         ;-------------------------------------------------------------
7470   E8F2 C0 20       L1522       subb    #$20                    ;                             
7471   E8F4             
7472   E8F4                         ;-----------------------------------------------------
7473   E8F4                         ; Store new errCodeProc and errCodeIdx and return
7474   E8F4                         ;-----------------------------------------------------
7475   E8F4 B7 01 7C    L1523       staa    errCodeProc             ;                              
7476   E8F7 F7 01 7B                stab    errCodeIdx              ;                              
7477   E8FA 39          L1524       rts                             ;                             
7478   E8FB             
7479   E8FB             
7480   E8FB             
7481   E8FB             ;****************************************************************
7482   E8FB             ;
7483   E8FB             ;
7484   E8FB             ; Maf sensor check:
7485   E8FB             ;
7486   E8FB             ;
7487   E8FB             ;****************************************************************
7488   E8FB 96 DD       test_maf    ldaa    rpm31                   ;                                                                  
7489   E8FD 81 10                   cmpa    #$10                    ;                                                                 
7490   E8FF 23 0D                   bls     L1528                   ;                                                                  
7491   E901 B6 01 21                ldaa    T40_mas                 ; 
7492   E904 27 06                   beq     L1526                   ; Branch if timer expired (no mas interrupt for a long time...)
7493   E906 96 9A                   ldaa    t2_diff8                ;                                                                    
7494   E908 81 31                   cmpa    #$31                    ; t2_diff8 more than 49 is an error?                                
7495   E90A 25 01                   bcs     L1527                   ;                                                                  
7496   E90C 5A          L1526       decb                            ;                                                                 
7497   E90D 39          L1527       rts                             ;                                                                 
7498   E90E 5C          L1528       incb                            ; return 1 (test not conclusive)                                                                 
7499   E90F 39                      rts                             ;                                                                 
7500   E910             
7501   E910             
7502   E910             
7503   E910             ;******************************************************************
7504   E910             ;
7505   E910             ;
7506   E910             ; Crank angle sensor
7507   E910             ;
7508   E910             ;
7509   E910             ;******************************************************************
7510   E910 B6 01 20    test_cas    ldaa    T40_engRot              ; 
7511   E913 26 05                   bne     L1530                   ; Branch if sensor is fine. T40_engRot is non-zero when CAS interrupts are being received... sensor must be fine...
7512   E915 87 D7 40 02             brset   port3Snap0, #$40, L1531 ; Branch if key is not in start
7513   E919 5A                      decb                            ; Key is in start but T40_engRot is 0, should not happen -> CAS is bad                            
7514   E91A 39          L1530       rts                             ;                             
7515   E91B 5C          L1531       incb                            ; return 1 (test not conclusive)                             
7516   E91C 39                      rts                                                          
7517   E91D             
7518   E91D             
7519   E91D             
7520   E91D             ;******************************************************************
7521   E91D             ;
7522   E91D             ;
7523   E91D             ; Top dead sensor
7524   E91D             ;
7525   E91D             ;
7526   E91D             ;******************************************************************
7527   E91D B6 01 20    test_tdc    ldaa    T40_engRot              ;                                     
7528   E920 27 10                   beq     L1535                   ; Branch if timer is 0, (engine not rotating)                             
7529   E922 96 B6                   ldaa    tdcCheck                ; Engine rotating, check if #1 TDC signal is being received
7530   E924 27 0A                   beq     L1533                   ; Branch to error if #1 TDC signal is not being received
7531   E926 96 83                   ldaa    tdcCasCount             ;                              
7532   E928 81 04                   cmpa    #$04                    ;                             
7533   E92A 24 05                   bcc     L1534                   ; Branch if tdcCasCount>=4                              
7534   E92C 8F 06 40 02             brclr   port3, #$40, L1535      ; tdcCasCount<4, branch if key is in start
7535   E930 5A          L1533       decb                            ; Set error                             
7536   E931 39          L1534       rts                             ;                             
7537   E932 5C          L1535       incb                            ; return 1 (test not conclusive)                            
7538   E933 39                      rts                             ;                             
7539   E934             
7540   E934             
7541   E934             
7542   E934             ;******************************************************************
7543   E934             ;
7544   E934             ;
7545   E934             ; Reed switch (VSS) sensor check:
7546   E934             ;
7547   E934             ;
7548   E934             ;******************************************************************
7549   E934 96 C4       test_reed   ldaa    vssCnt1                                                 
7550   E936 26 20                   bne     L1537                    ; branch if car is moving (no error since we detected that...)                             
7551   E938 87 E6 02 1D             brset   state1, #$02, L1538      ; Branch if no pulse accumulator interrupts?                                
7552   E93C 87 D7 80 19             brset   port3Snap0, #$80, L1538  ; Branch if Idle switch on (car most likely not moving...)                                   
7553   E940 96 DD                   ldaa    rpm31                    ;                             
7554   E942 81 60                   cmpa    #$60                     ;                            
7555   E944 23 13                   bls     L1538                    ;                             
7556   E946 96 E0                   ldaa    airVol                   ;                              
7557   E948 81 6D                   cmpa    #$6d                     ;                            
7558   E94A 23 0D                   bls     L1538                    ;                             
7559   E94C 87 A2 04 09             brset   state3, #$04, L1538      ; Branch if rev limiter active
7560   E950 B6 01 3E                ldaa    T2_stCrank               ;                                  
7561   E953 8B 78                   adda    #$78                     ;                            
7562   E955 25 02                   bcs     L1538                    ;                             
7563   E957 5A                      decb                             ;                            
7564   E958 39          L1537       rts                              ;                            
7565   E959 5C          L1538       incb                             ; return 1 (test not conclusive)                             
7566   E95A 39                      rts                              ;                            
7567   E95B             
7568   E95B             
7569   E95B             
7570   E95B             ;******************************************************************
7571   E95B             ;
7572   E95B             ;
7573   E95B             ; Injector circuit check
7574   E95B             ;
7575   E95B             ;
7576   E95B             ;******************************************************************
7577   E95B 96 BA       test_inj    ldaa    obdInjCmd               ; First check if we disabled an injector on purpose (OBD command)                             
7578   E95D 43                      coma                            ;                             
7579   E95E 85 3F                   bita    #$3f                    ; only keep 6 bits (6 inj.)                             
7580   E960 26 17                   bne     L1541                   ; Branch if disabled on purpose                              
7581   E962 B6 01 20                ldaa    T40_engRot              ;                               
7582   E965 27 12                   beq     L1541                   ; Branch if engine not rotating                              
7583   E967 96 DD                   ldaa    rpm31                   ;                              
7584   E969 81 20                   cmpa    #$20                    ;                             
7585   E96B 24 0C                   bcc     L1541                   ; Branch if rpm > 1000                             
7586   E96D 96 D2                   ldaa    tpsRaw                  ;                            
7587   E96F 81 24                   cmpa    #$24                    ;                             
7588   E971 24 06                   bcc     L1541                   ; Branch if tpsRaw > $24                             
7589   E973 8F B9 01 01             brclr   injBad, #$01, L1540     ; Branch if injector OK?
7590   E977 5A                      decb                            ; Error, set flag                            
7591   E978 39          L1540       rts                             ;                             
7592   E979 5C          L1541       incb                            ; return 1 (test not conclusive)                             
7593   E97A 39                      rts                                                          
7594   E97B             
7595   E97B             
7596   E97B             
7597   E97B             ;******************************************************************
7598   E97B             ;
7599   E97B             ;
7600   E97B             ; Fuel pump relay check
7601   E97B             ;
7602   E97B             ;
7603   E97B             ;******************************************************************
7604   E97B 8F D7 40 04 test_fpump  brclr   port3Snap0, #$40, L1543     ; Branch if key in start position                               
7605   E97F 87 02 10 06             brset   port1, #$10, L1545          ; Branch if fuel pump relay bit set 
7606   E983 8F D8 40 01 L1543       brclr   port4Snap, #$40, L1544      ; Fuel pump driven feedback???                                
7607   E987 5A                      decb                                                         
7608   E988 39          L1544       rts                                                          
7609   E989 5C          L1545       incb                                ; return 1 (test not conclusive)                         
7610   E98A 39                      rts                                                          
7611   E98B             
7612   E98B             
7613   E98B             
7614   E98B             ;******************************************************************
7615   E98B             ;
7616   E98B             ;
7617   E98B             ; Ignition coil check:
7618   E98B             ;
7619   E98B             ;
7620   E98B             ;******************************************************************
7621   E98B 87 E6 11 0C test_coil   brset   state1, #$11, L1548       ; Branch if notRotating or startingToCrank
7622   E98F 96 DD                   ldaa    rpm31                     ;                              
7623   E991 81 A0                   cmpa    #$a0                      ;                             
7624   E993 24 06                   bcc     L1548                     ; Branch if RPM >= 5000                              
7625   E995 8F 85 80 01             brclr   coilChkFlags, #$80, L1547 ; Branch if no error found on ignition signal
7626   E999 5A                      decb                              ; Error was found                             
7627   E99A 39          L1547       rts                               ;                             
7628   E99B 5C          L1548       incb                              ; return 1 (test not conclusive)                             
7629   E99C 39                      rts                                                          
7630   E99D             
7631   E99D             
7632   E99D             
7633   E99D             ;******************************************************************
7634   E99D             ;
7635   E99D             ;
7636   E99D             ; Knock sensor check:
7637   E99D             ;
7638   E99D             ;
7639   E99D             ;******************************************************************
7640   E99D 87 D8 20 01 test_knock  brset   port4Snap, #$20, L1550  ; Knock sensor related???
7641   E9A1 5A                      decb                                                         
7642   E9A2 39          L1550       rts                                                          
7643   E9A3             
7644   E9A3             
7645   E9A3             
7646   E9A3             ;******************************************************************
7647   E9A3             ;
7648   E9A3             ;
7649   E9A3             ; Intake air temperature sensor check:
7650   E9A3             ;
7651   E9A3             ;
7652   E9A3             ;******************************************************************
7653   E9A3 8F D6 02 01 test_iat    brclr   state2, #$02, L1552                                     
7654   E9A7 5A                      decb                                                         
7655   E9A8 39          L1552       rts                                                          
7656   E9A9             
7657   E9A9             
7658   E9A9             
7659   E9A9             ;******************************************************************
7660   E9A9             ;
7661   E9A9             ;
7662   E9A9             ; Tps sensor check:
7663   E9A9             ;
7664   E9A9             ;
7665   E9A9             ;******************************************************************
7666   E9A9 96 D2       test_tps    ldaa    tpsRaw                                                 
7667   E9AB 81 66                   cmpa    #$66                                                 
7668   E9AD 22 05                   bhi     L1554                   ; branch if tpsRaw voltage higher 40%                                   
7669   E9AF 81 0A                   cmpa    #$0a                    ;                                                                       
7670   E9B1 25 05                   bcs     L1555                   ; branch if voltage lower than 4%                                      
7671   E9B3 39                      rts                             ;                                                                       
7672   E9B4 8F D7 80 01 L1554       brclr   port3Snap0, #$80, L1556 ; branch if idle switch is off                                            
7673   E9B8 5A          L1555       decb                            ;                                                                       
7674   E9B9 39          L1556       rts                             ;                                                                       
7675   E9BA             
7676   E9BA             
7677   E9BA             
7678   E9BA             ;******************************************************************
7679   E9BA             ;
7680   E9BA             ;
7681   E9BA             ; Ect sensor check:
7682   E9BA             ;
7683   E9BA             ;
7684   E9BA             ;******************************************************************
7685   E9BA 87 D6 10 38 test_ect    brset   state2, #$10, L1563     ; Branch if flag was previously set when we were here (once in error always in error????)                                
7686   E9BE 8F D6 01 07             brclr   state2, #$01, L1558     ; Branch if no ect error flag set in main code
7687   E9C2 B6 01 3E                ldaa    T2_stCrank              ; ect error flag is set in main code, check timer                             
7688   E9C5 8B 78                   adda    #$78                    ;                             
7689   E9C7 24 25                   bcc     L1562                   ; Branch if more than 60sec have elapsed since engine startedToCrank (should have cleared by now?, sensor is in error)                              
7690   E9C9 87 E6 10 1F L1558       brset   state1, #$10, L1560     ; Branch if notRotating (not conclusive)
7691   E9CD B6 01 44                ldaa    T0p5_ect                ;                               
7692   E9D0 27 24                   beq     L1563                   ; Branch if temperature stayed at exactly 88degC for more than 5 minutes (????)
7693   E9D2 B6 01 43                ldaa    T0p5_crank2             ;                               
7694   E9D5 8B 5A                   adda    #$5a                    ;                             
7695   E9D7 25 0D                   bcs     L1559                   ; Branch if less than 180s have elapsed since ectStCrank was loaded                              
7696   E9D9             
7697   E9D9                         ;----------------------------------------------------------
7698   E9D9                         ; More than 180s have elapsed since ectStCrank was loaded
7699   E9D9                         ;----------------------------------------------------------
7700   E9D9 B6 01 83                ldaa    ectStCrank              ;                                   
7701   E9DC 81 FF                   cmpa    #$ff                    ; Not sure how we would get that value, maybe if sensor is broken??                            
7702   E9DE 25 06                   bcs     L1559                   ; Branch if ectStCrank < $ff (branch almost always???????)                              
7703   E9E0 80 0A                   suba    #$0a                    ; a=ectStCrank-$0a = $ff-$0a = $f5, am I missing someting??????????????                             
7704   E9E2 91 D3                   cmpa    ectFiltered             ;                                     
7705   E9E4 25 08                   bcs     L1562                   ; Branch if  ectFiltered > $f5 ?????? (sensor error)                             
7706   E9E6 96 D3       L1559       ldaa    ectFiltered             ;                                    
7707   E9E8 81 54                   cmpa    #$54                    ; 41degC                             
7708   E9EA 25 01                   bcs     L1561                   ; Branch if temperature(ectFiltered) > 41degC (no error)                               
7709   E9EC 5C          L1560       incb                            ; return 1 (test not conclusive)                             
7710   E9ED 39          L1561       rts                                                          
7711   E9EE B6 01 3B    L1562       ldaa    T2_snsrChk                                                 
7712   E9F1 26 03                   bne     L1563                                                 
7713   E9F3 03 D6 10                orm     state2, #$10                                             
7714   E9F6 5A          L1563       decb                                                         
7715   E9F7 39                      rts                                                          
7716   E9F8             
7717   E9F8             
7718   E9F8             
7719   E9F8             ;******************************************************************
7720   E9F8             ;
7721   E9F8             ;
7722   E9F8             ; Barometer sensor check
7723   E9F8             ;
7724   E9F8             ;
7725   E9F8             ;******************************************************************
7726   E9F8 B6 01 1B    test_baro   ldaa    T40_baro                ;                                  
7727   E9FB 26 0C                   bne     L1567                   ;                              
7728   E9FD 96 CD                   ldaa    baroRaw                 ;                                
7729   E9FF 81 E6                   cmpa    #$e6                    ;                             
7730   EA01 22 04                   bhi     L1565                   ;                              
7731   EA03 81 0A                   cmpa    #$0a                    ;                             
7732   EA05 24 01                   bcc     L1566                   ;                              
7733   EA07 5A          L1565       decb                            ;                             
7734   EA08 39          L1566       rts                             ;                             
7735   EA09 5C          L1567       incb                            ; return 1 (test not conclusive)                             
7736   EA0A 39                      rts                                                          
7737   EA0B             
7738   EA0B             
7739   EA0B             
7740   EA0B             ;******************************************************************
7741   EA0B             ;
7742   EA0B             ;
7743   EA0B             ; Serial port interrupt subroutine 
7744   EA0B             ;
7745   EA0B             ;
7746   EA0B             ;******************************************************************
7747   EA0B DC 11       serialRxInt ldd     sci_scr                 ; A=sci_cr, B=sci_read                                                                                       
7748   EA0D 85 80                   bita    #$80                    ; Check if something was received??/start of sequence to clear flag                                      
7749   EA0F 27 0F                   beq     L1570                   ;                                                                                                            
7750   EA11 87 FA 80 08             brset   obdFlags, #$80, L1569   ; Branch if the code we received is the echo of the one we just sent                                          
7751   EA15 F7 01 7A                stab    obdCode                 ;                                                                                                            
7752   EA18 03 FA 40                orm     obdFlags, #$40          ; Indicate new value available                                                                                 
7753   EA1B 20 03                   bra     L1570                   ;                                                                                                            
7754   EA1D 02 FA 7F    L1569       andm    obdFlags, #$7f          ; The code we received is the echo of what we sent, just drop it and reset flag                                
7755   EA20 3B          L1570       rti                             ;                                                                                                           
7756   EA21             
7757   EA21             
7758   EA21             
7759   EA21             ;******************************************************************
7760   EA21             ;
7761   EA21             ;
7762   EA21             ;
7763   EA21             ;
7764   EA21             ;
7765   EA21             ;******************************************************************
7766   EA21 CE FB 22    loadConfig  ldx     #t_strap1               ;                                  
7767   EA24 D6 07                   ldab    port4                   ;                              
7768   EA26 01                      nop                             ;                             
7769   EA27 C4 03                   andb    #$03                    ; Keep only config resistor bits                             
7770   EA29 58                      aslb                            ;                             
7771   EA2A 3A                      abx                             ;                             
7772   EA2B EC 00                   ldd     $00,x                   ;                              
7773   EA2D DD 55                   std     config1                 ;                              
7774   EA2F 39                      rts                             ;                             
7775   EA30             
7776   EA30             
7777   EA30             
7778   EA30             ;******************************************************************
7779   EA30             ;
7780   EA30             ;
7781   EA30             ; Initialize a few things
7782   EA30             ;
7783   EA30             ;
7784   EA30             ;******************************************************************
7785   EA30 CC 7E 16    initFunc1   ldd     #$7e16                  ;                                                                                                  
7786   EA33 DD 00                   std     p1_ddr                  ; Initialize port1 and port2 data direction registers                                              
7787   EA35 CC 00 00                ldd     #$0000                  ;                                                                                                  
7788   EA38 DD 04                   std     p3_ddr                  ; Initialize port3 and port4 data direction register (all inputs)                                  
7789   EA3A 86 FE                   ldaa    #$fe                    ;                                                                                                
7790   EA3C 97 15                   staa    p5_ddr                  ; Initialize port5 data direction register
7791   EA3E 4F                      clra                            ;                             
7792   EA3F 97 0F                   staa    L000f                   ;                              
7793   EA41 97 17                   staa    L0017                   ;                              
7794   EA43 02 02 BF                andm    port1, #$bf             ; Reset ??????                               
7795   EA46 86 00                   ldaa    #$00                    ;                             
7796   EA48 97 24                   staa    L0024                   ;                              
7797   EA4A             
7798   EA4A                         ;-------------------------------------------------------
7799   EA4A                         ; rti_freq is setting the real time interrupt frequency:
7800   EA4A                         ;    F=125000/(256-x)
7801   EA4A                         ;       x      F
7802   EA4A                         ;      0x64  1*801.28Hz
7803   EA4A                         ;      0xb2  2*801.28Hz
7804   EA4A                         ;      0xcc  3*801.28Hz
7805   EA4A                         ;      0xd9  4*801.28Hz
7806   EA4A                         ;-------------------------------------------------------
7807   EA4A CC 4D 64                ldd     #$4d64                  ; 
7808   EA4D DD 26                   std     rti_ctl                                                 
7809   EA4F 39                      rts                                                          
7810   EA50             
7811   EA50             
7812   EA50             
7813   EA50             ;******************************************************************
7814   EA50             ;
7815   EA50             ; Input: D = Tcas (period of cas interrupts in sec * 125000)
7816   EA50             ; Output: freq = $EA600/D = 960000/D
7817   EA50             ;
7818   EA50             ;        in the end, rpm = freq/8*31.25 
7819   EA50             ;
7820   EA50             ;        e.g. 1000RPM -> Tcas = 60/1000* 125000/2 = 3750
7821   EA50             ;                        freq = 960000/3750 = 256
7822   EA50             ;                        rpm = freq/8*31.25 = 1000 RPM 
7823   EA50             ;
7824   EA50             ;******************************************************************
7825   EA50 DD 5A       calcFreq    std     temp4                   ;                                                                 
7826   EA52 CC A6 00                ldd     #$a600                  ;                                                                  
7827   EA55 DD 58                   std     temp2                   ;                                     
7828   EA57 CC 00 0E                ldd     #$000e                  ; numerator = D:temp2 = 000EA600                                   
7829   EA5A 20 62                   bra     div3216                 ; D = (#$000EA600)/([$5A $5B])      
7830   EA5C             
7831   EA5C             
7832   EA5C                                                                        
7833   EA5C             ;******************************************************************
7834   EA5C             ;
7835   EA5C             ;
7836   EA5C             ;
7837   EA5C             ;
7838   EA5C             ;******************************************************************
7839   EA5C F6 01 60    mul816_baro ldab    baroFact                                                 
7840   EA5F             
7841   EA5F             ;******************************************************************
7842   EA5F             ;
7843   EA5F             ;
7844   EA5F             ;
7845   EA5F             ;
7846   EA5F             ;******************************************************************
7847   EA5F BD EB 6A    mul816_256  jsr     mul816_128              ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
7848   EA62 7E EB B9                jmp     scale2m                                                 
7849   EA65             
7850   EA65             
7851   EA65             
7852   EA65             ;******************************************************************
7853   EA65             ;
7854   EA65             ; Input 
7855   EA65             ;     x = point to table1
7856   EA65             ;     y = point to table2
7857   EA65             ;
7858   EA65             ; Output
7859   EA65             ;     d = injMasComp * table1(rpm)/128 * table2(ect)/16 * baroFact/128
7860   EA65             ;
7861   EA65             ;******************************************************************
7862   EA65 FC 01 53    L1577       ldd     injMasComp              ; d = injMasComp                                   
7863   EA68 DD 5C                   std     temp6                   ; temp6:temp7 = injMasComp                             
7864   EA6A BD EB 3F                jsr     interp16rpm             ; b = table1(rpm)                              
7865   EA6D BD EB 6A                jsr     mul816_128              ; [temp6:temp7] = injMasComp * table1(rpm)/128                                   
7866   EA70 18                      xgxy                            ; x points to table2                              
7867   EA71 BD EB 3A                jsr     interpEct               ; b = table2(ect)                                  
7868   EA74 B6 01 60                ldaa    baroFact                ; a = baroFact                                
7869   EA77 3D                      mul                             ; d =  table2(ect) * baroFact                           
7870   EA78 7E EB 86                jmp     mul1616_2K              ; d = 8* injMasComp * table1(rpm)/128 * table2(ect)/128 * baroFact/128
7871   EA7B             
7872   EA7B             
7873   EA7B             
7874   EA7B             ;******************************************************************
7875   EA7B             ;
7876   EA7B             ; 8 bit by 16 bit multiplication
7877   EA7B             ;
7878   EA7B             ; Input
7879   EA7B             ;   b: 8 bit value
7880   EA7B             ;   [temp6:temp7]: 16 bit value, optionally in X if called from mul816b
7881   EA7B             ;
7882   EA7B             ; Output: 
7883   EA7B             ;   D and [temp1:temp2] = b*[temp6:temp7]/256
7884   EA7B             ;   temp3 = Lo(b*temp7) (fractional part of result) 
7885   EA7B             ;
7886   EA7B             ;
7887   EA7B             ;
7888   EA7B             ;******************************************************************
7889   EA7B DE 5C       mul816      ldx     temp6                   ;                              
7890   EA7D DF 57       mul816b     stx     temp1                   ; temp1,temp2 = temp6,temp7                              
7891   EA7F 37                      pshb                            ; save b                            
7892   EA80 96 58                   ldaa    temp2                   ; a = temp7                             
7893   EA82 3D                      mul                             ; d = b*temp7                            
7894   EA83 DD 58                   std     temp2                   ; temp2, temp3 = b*temp7                             
7895   EA85 96 57                   ldaa    temp1                   ; a=temp6                             
7896   EA87 33                      pulb                            ;                             
7897   EA88 3D                      mul                             ; d = b*temp6                              
7898   EA89 DB 58                   addb    temp2                   ; d = b*temp6 + b*temp7/256 = b*(temp6+temp7/256) = b*[temp6:temp7]/256
7899   EA8B 89 00                   adca    #$00                    ; Propagate addition carry                            
7900   EA8D DD 57                   std     temp1                   ; temp1, temp2 = b*[temp6:temp7]/256
7901   EA8F 39                      rts                             ;                             
7902   EA90             
7903   EA90             
7904   EA90             
7905   EA90             ;******************************************************************
7906   EA90             ;
7907   EA90             ;
7908   EA90             ; 16 bit by 16 bit multiplication:
7909   EA90             ;
7910   EA90             ; Input:
7911   EA90             ;               a:b = 16 bit value  (val1:val2)
7912   EA90             ;       temp6:temp7 = 16 bit value1 (val3:val4)
7913   EA90             ;
7914   EA90             ; Output:
7915   EA90             ;               d = [a:b]*[temp6:temp7]/65536  (or equivalently, 16 upper bits of result)
7916   EA90             ;           temp2 = lower 8 bits (of 24) of results
7917   EA90             ;----------------------------------------
7918   EA90             ;
7919   EA90             ; D * temp6:temp7
7920   EA90             ; - 16 bit multiplication:
7921   EA90             ; - D * temp6:temp7 , High bytes stored in D
7922   EA90             ; -
7923   EA90             ; - (1) * (2) is equal to ( 1A + 1B ) * ( 2A + 2B )
7924   EA90             ; 
7925   EA90             ; - = 1A * 2A + 1A * 2B + 1B * 2A + 1B * 2B
7926   EA90             ; 
7927   EA90             ; - Where:
7928   EA90             ; - lets call temp6:temp7 Argument (1)
7929   EA90             ; - lets call reg D Argument (2)
7930   EA90             ; -
7931   EA90             ; - temp6 is then named (1A)
7932   EA90             ; - temp7 is then named (1B)
7933   EA90             ; - and temp6:temp7 = (1A) * #$100 + (1B)
7934   EA90             ; -
7935   EA90             ; - Reg D is reg A:reg B
7936   EA90             ; - A is then named (2A)
7937   EA90             ; - B is then named (2B)
7938   EA90             ; - temp6:temp7 = (1A) * #$100 + (1B)
7939   EA90             ; 
7940   EA90             ; - D consists of (2A) * #$100 + (2B)
7941   EA90             ; 
7942   EA90             ; -Result (R) will be 32 bit, (R3)-(R0) where
7943   EA90             ; -temp3 = (R0) low
7944   EA90             ; -temp2 = (R1)
7945   EA90             ; -temp1 = (R2) --\ Stored and returned in D
7946   EA90             ;
7947   EA90             ;******************************************************************
7948   EA90 CE 00 5C    mul1616     ldx     #temp6                  ; x points to temp6
7949   EA93 36                      psha                            ; st0 = val1                            
7950   EA94 37                      pshb                            ; st1 = val2                            
7951   EA95 A6 01                   ldaa    $01,x                   ; a = val4                             
7952   EA97 3D                      mul                             ; d = val4*val2                            
7953   EA98 DD 58                   std     temp2                   ; temp2:temp3=val4*val2                             
7954   EA9A 33                      pulb                            ; b = val2                            
7955   EA9B A6 00                   ldaa    $00,x                   ; a = val3                             
7956   EA9D 3D                      mul                             ; d = val2*val3                            
7957   EA9E DB 58                   addb    temp2                   ; d = val2*val3 + val4*val2/256
7958   EAA0 89 00                   adca    #$00                    ; propagate carry                            
7959   EAA2 DD 57                   std     temp1                   ; temp1:temp2 = val2*val3 + val4*val2/256
7960   EAA4 32                      pula                            ; a = val1                            
7961   EAA5 36                      psha                            ; st0 = val1                            
7962   EAA6 E6 01                   ldab    $01,x                   ; b = val4                             
7963   EAA8 3D                      mul                             ; d = val1*val4                            
7964   EAA9 D3 57                   addd    temp1                   ; d = val1*val4 + val2*val3 + val4*val2/256
7965   EAAB DD 57                   std     temp1                   ; temp1:temp2 = val1*val4 + val2*val3 + val4*val2/256
7966   EAAD 32                      pula                            ; a = val1                            
7967   EAAE 56                      rorb                            ; shift in carry bit                            
7968   EAAF C4 80                   andb    #$80                    ; keep only carry bit                             
7969   EAB1 37                      pshb                            ; st0 = carry bit in position $80                            
7970   EAB2 E6 00                   ldab    $00,x                   ; b=val3                             
7971   EAB4 3D                      mul                             ; d=val1*val3                            
7972   EAB5 1A                      xgdx                            ; x=val1*val3, d points to temp6
7973   EAB6 33                      pulb                            ; b=carry bit in position $80                            
7974   EAB7 3A                      abx                             ; add 2 x carry bit (since shifted right previously)                            
7975   EAB8 3A                      abx                             ; x=val1*val3 + carry                               
7976   EAB9 D6 57                   ldab    temp1                   ; b = (val1*val4 + val2*val3 + val4*val2/256)/256
7977   EABB 3A                      abx                             ; x = val1*val3 + carry + (val1*val4 + val2*val3 + val4*val2/256)/256
7978   EABC 1A                      xgdx                            ; x points to temp6, d = val1*val3 + carry + (val1*val4 + val2*val3 + val4*val2/256)/256
7979   EABD 39                      rts                             ;                             
7980   EABE                                                         
7981   EABE             
7982   EABE             
7983   EABE             ;******************************************************************
7984   EABE             ;
7985   EABE             ;
7986   EABE             ; fractional 32 bit by 16 bit division:
7987   EABE             ; input: D:temp2:temp3 = 32 bit numerator; 
7988   EABE             ;        temp4:temp5 = 16 bit denominator
7989   EABE             ;
7990   EABE             ; output: D = quotient
7991   EABE             ;         X = remainder
7992   EABE             ;
7993   EABE             ;******************************************************************
7994   EABE 1D 5A       div3216     cmpd1   temp4                   ;                                                                                    
7995   EAC0 25 05                   bcs     L1582                   ; Branch if denominator > numerator (results<1)                                      
7996   EAC2 CC FF FF                ldd     #$ffff                  ; denominator<=numerator, return .99998....                                           
7997   EAC5 20 19                   bra     L1586                   ;                                                                                    
7998   EAC7                                                                                                                
7999   EAC7 CD CE 00 10 L1582       ldy     #$0010                  ; Loop 16 times                                                                       
8000   EACB DE 58                   ldx     temp2                                                 
8001   EACD 1A          L1583       xgdx                                                         
8002   EACE 05                      asld                                                         
8003   EACF 1A                      xgdx                                                         
8004   EAD0 59                      rolb                                                         
8005   EAD1 49                      rola                                                         
8006   EAD2 25 04                   bcs     L1584                                                 
8007   EAD4 1D 5A                   cmpd1   temp4                                                 
8008   EAD6 25 03                   bcs     L1585                                                 
8009   EAD8 93 5A       L1584       subd    temp4                                                 
8010   EADA 08                      inx                                                          
8011   EADB CD 09       L1585       decy                                                         
8012   EADD 26 EE                   bne     L1583                                                 
8013   EADF 1A                      xgdx                                                         
8014   EAE0 39          L1586       rts                                                          
8015   EAE1                         
8016   EAE1             
8017   EAE1             
8018   EAE1             ;******************************************************************
8019   EAE1             ;
8020   EAE1             ;
8021   EAE1             ; 2D table lookup/interpolation
8022   EAE1             ;
8023   EAE1             ; Input:
8024   EAE1             ;       temp6 = in1 (column index*16) (optionally in a if using 2Dlookup2)
8025   EAE1             ;       temp7 = in2 (row index*16)    (optionally in b if using 2Dlookup2)
8026   EAE1             ;       hi(Y) = scale, number of elements per row in the table 
8027   EAE1             ;       lo(Y) = offset, added to value loaded from table before interpolation
8028   EAE1             ;           X = 2Dtable address
8029   EAE1             ;
8030   EAE1             ; Output: A and B contain the same 2D interpolated value from the table 
8031   EAE1             ;         
8032   EAE1             ;
8033   EAE1             ;
8034   EAE1             ;******************************************************************
8035   EAE1 DC 5C       lookup2D    ldd     temp6                   ; a=in1, b=in2                              
8036   EAE3 CD DF 59    lookup2D2   sty     temp3                   ; temp3 = scale temp4=offset                              
8037   EAE6 97 5B                   staa    temp5                   ; temp5 = in1                              
8038   EAE8 4F                      clra                            ; a=0, b=in2
8039   EAE9 05                      asld                            ;                             
8040   EAEA 05                      asld                            ;                             
8041   EAEB 05                      asld                            ;                             
8042   EAEC 05                      asld                            ; d = in2*16                             
8043   EAED 37                      pshb                            ; st0 = LO(in2*16)                            
8044   EAEE D6 59                   ldab    temp3                   ; b=scale                             
8045   EAF0 3D                      mul                             ; d = in2*16/256*scale                             
8046   EAF1 DF 57                   stx     temp1                   ; temp1:temp2 = 2Dtable
8047   EAF3 D3 57                   addd    temp1                   ; d = 2Dtable + in2*16/256*scale
8048   EAF5 DD 57                   std     temp1                   ; temp1:temp2 = 2Dtable + in2*16/256*scale
8049   EAF7 DE 57                   ldx     temp1                   ; X =  2Dtable + in2*16/256*scale, first row of interpolation
8050   EAF9 3C                      pshx                            ; st1:st2 = 2Dtable + in2*16/256*scale
8051   EAFA D6 59                   ldab    temp3                   ; b=scale                              
8052   EAFC 3A                      abx                             ; X = 2Dtable + in2*16/256*scale + scale, go to next row of interpolation...
8053   EAFD 8D 0D                   bsr     L1589                   ; Calculate interpolated value on second row, result in b                              
8054   EAFF D7 59                   stab    temp3                   ; temp3 = interpolated value on second row                             
8055   EB01 38                      pulx                            ; x = 2Dtable + in2*16/256*scale (first row)
8056   EB02 8D 08                   bsr     L1589                   ; Calculate interpolated value on first row, result in b                               
8057   EB04 D7 58                   stab    temp2                   ; temp3 = interpolated value on first row                               
8058   EB06 32                      pula                            ; a = LO(in2*16)                              
8059   EB07 CE 00 58                ldx     #temp2                  ;                                
8060   EB0A 20 4A                   bra     interpSpec              ; Interpolate temp variables temp2 and temp3 using fractional part a=LO(in2*16) with no scaling on a and return to calling sub, result in b
8061   EB0C             
8062   EB0C             
8063   EB0C             
8064   EB0C             ;******************************************************************
8065   EB0C             ;
8066   EB0C             ;
8067   EB0C             ; Used by lookup2D, interpolate on one row between two columns
8068   EB0C             ;
8069   EB0C             ;
8070   EB0C             ;******************************************************************
8071   EB0C 96 5B       L1589       ldaa    temp5                   ; a = in1                              
8072   EB0E 5F                      clrb                            ; b=0                             
8073   EB0F 04                      lsrd                            ;                             
8074   EB10 04                      lsrd                            ;                             
8075   EB11 04                      lsrd                            ;                             
8076   EB12 04                      lsrd                            ; d = in1*256/16 = in1*16                             
8077   EB13 37                      pshb                            ; st3 = LO(in1*16)
8078   EB14 16                      tab                             ; b=in1*16/256=in1/16
8079   EB15 32                      pula                            ; a=LO(in1*16)
8080   EB16 3A                      abx                             ; X = startOfRow + in1/16
8081   EB17 E6 00                   ldab    $00,x                   ; b = val1, table lookup, get value in row                             
8082   EB19 DB 5A                   addb    temp4                   ; b = val1 + offset                             
8083   EB1B D7 57                   stab    temp1                   ; temp1 = val1 + offset                             
8084   EB1D E6 01                   ldab    $01,x                   ; b = val2, next value in table on same row                             
8085   EB1F DB 5A                   addb    temp4                   ; b = val2 + offset                            
8086   EB21 D7 58                   stab    temp2                   ; temp2 = val2 + offset                             
8087   EB23 CE 00 57                ldx     #temp1                  ; X points to temp variables
8088   EB26 20 2E                   bra     interpSpec              ; Interpolate temp variables temp1 and temp2 using fractional part a=LO(in1*16) with no scaling on a and return to calling sub, result in b
8089   EB28             
8090   EB28             
8091   EB28             
8092   EB28             ;******************************************************************
8093   EB28             ;
8094   EB28             ; Interpolate a table using ectCond, (ectCond is inv. proportional to temp)
8095   EB28             ; This one compensate for non constant distance between the table points
8096   EB28             ;
8097   EB28             ; Used in the calculation of injPwStart
8098   EB28             ; Input X = table
8099   EB28             ;
8100   EB28             ;
8101   EB28             ;
8102   EB28             ;******************************************************************
8103   EB28 F6 01 4E    interpEct2  ldab    ectCond                 ; b = ectCond (ect conditionned for table interp..)                            
8104   EB2B C1 C0                   cmpb    #$c0                    ; -7degC                            
8105   EB2D 25 08                   bcs     L1591                   ; Branch if ectCond < $c0
8106   EB2F 4F                      clra                            ; a = 0, d = ectCond 
8107   EB30 05                      asld                            ; d = 2*ectCond                            
8108   EB31 83 00 C0                subd    #$00c0                  ; d = 2*ectCond -$c0                              
8109   EB34 BD EB BE                jsr     ovfCheck                ;                              
8110   EB37 17          L1591       tba                             ; a = 2*ectCond -$c0                              
8111   EB38 20 12                   bra     interp32                ;                                 
8112   EB3A             
8113   EB3A             
8114   EB3A             
8115   EB3A             ;******************************************************************
8116   EB3A             ;
8117   EB3A             ;
8118   EB3A             ; Interpolate a table using ECT (ectCond is inv. proportional to temp)
8119   EB3A             ; Input X = table
8120   EB3A             ;
8121   EB3A             ;
8122   EB3A             ;******************************************************************
8123   EB3A B6 01 4E    interpEct   ldaa    ectCond                                                 
8124   EB3D 20 0D                   bra     interp32                                                 
8125   EB3F             
8126   EB3F             
8127   EB3F             
8128   EB3F             ;******************************************************************
8129   EB3F             ;
8130   EB3F             ;
8131   EB3F             ;
8132   EB3F             ;
8133   EB3F             ;
8134   EB3F             ;******************************************************************
8135   EB3F B6 01 51    interp16rpm ldaa    rpmIndex1                                                 
8136   EB42 20 05                   bra     interp16b                                                 
8137   EB44             
8138   EB44             
8139   EB44             
8140   EB44             ;******************************************************************
8141   EB44             ;
8142   EB44             ;
8143   EB44             ; Interpolate table using Conditionned IAT (iatCond)
8144   EB44             ;
8145   EB44             ;
8146   EB44             ;******************************************************************
8147   EB44 B6 01 4F    iatCInterp  ldaa    iatCond                                                 
8148   EB47 20 03                   bra     interp32                                                 
8149   EB49             
8150   EB49             
8151   EB49             
8152   EB49             ;******************************************************************
8153   EB49             ;
8154   EB49             ;
8155   EB49             ;
8156   EB49             ;
8157   EB49             ;
8158   EB49             ;******************************************************************
8159   EB49 5F          interp16b   clrb                                                         
8160   EB4A 20 02                   bra     interp16                                                 
8161   EB4C             
8162   EB4C             
8163   EB4C             
8164   EB4C             ;******************************************************************
8165   EB4C             ;
8166   EB4C             ; Table lookup with fractional interpolation
8167   EB4C             ; input value = A
8168   EB4C             ; input table = X
8169   EB4C             ; output value in a and b is (interpolated table) = X(A/32)
8170   EB4C             ;
8171   EB4C             ;
8172   EB4C             ;******************************************************************
8173   EB4C 5F          interp32    clrb                            ;                             
8174   EB4D 04                      lsrd                            ; 
8175   EB4E 04          interp16    lsrd                            ;                             
8176   EB4F 04                      lsrd                            ;                             
8177   EB50 04                      lsrd                            ;                             
8178   EB51 04                      lsrd                            ; A=A/32, B = 5 LSB of A in upper part 
8179   EB52 37          interp1     pshb                            ; \                                                                                                
8180   EB53 16                      tab                             ;  >transfer A to B, only 3 bits left                                                              
8181   EB54 32                      pula                            ; / At this point, B=integer part of input/32, A=fractional part                                   
8182   EB55 3A                      abx                             ; ADD B TO X:  B = 0 to 7 (3 bits) (integer table lookup), X=V(0)     
8183   EB56                                                                                                                                                        
8184   EB56 4D          interpSpec  tsta                            ; 
8185   EB57 27 0B                   beq     L1601                   ; Branch if a = 0 (no fractional interp)                                                       
8186   EB59 E6 01                   ldab    $01,x                   ; B=V(1)                                                                                            
8187   EB5B E0 00                   subb    $00,x                   ; B=V(1)-V(0)                                                                                       
8188   EB5D 24 03                   bcc     L1600                   ; banch if V(1)-V(0) > 0                                                                             
8189   EB5F 08                      inx                             ; negative->X=V(1)                                                                                 
8190   EB60 50                      negb                            ;                                                                                                  
8191   EB61 40                      nega                            ;                                                                                                  
8192   EB62 3D          L1600       mul                             ; D=A*B (                                                                                          
8193   EB63 58                      aslb                            ; shift left B (... carry)                                                                         
8194   EB64 A9 00       L1601       adca    $00,x                   ; add to a with carry                                                                               
8195   EB66 16                      tab                                                          
8196   EB67 39                      rts                                                          
8197   EB68             
8198   EB68             
8199   EB68             
8200   EB68             ;******************************************************************
8201   EB68             ;
8202   EB68             ; Interpolate table an multiply result by [temp6:temp7]
8203   EB68             ; 
8204   EB68             ;
8205   EB68             ;
8206   EB68             ;******************************************************************
8207   EB68 8D E2       interp32mul   bsr     interp32                                                 
8208   EB6A                         ; continued below...
8209   EB6A             
8210   EB6A             
8211   EB6A             
8212   EB6A             ;******************************************************************
8213   EB6A             ;
8214   EB6A             ;  Multiply 8 bit by 16 bits, final result is scaled by 128, 
8215   EB6A             ;  rounded and checked for overflow
8216   EB6A             ;
8217   EB6A             ; input:
8218   EB6A             ;   b: 8 bit value
8219   EB6A             ;   [temp6:temp7]: 16 bit value
8220   EB6A             ;
8221   EB6A             ; output:      
8222   EB6A             ;   D and [temp6:temp7]: rounded 2*b*[temp6:temp7]/256 = b*[temp6:temp7]/128
8223   EB6A             ;
8224   EB6A             ;
8225   EB6A             ;******************************************************************
8226   EB6A BD EA 7B    mul816_128  jsr     mul816                  ; D = b*[temp6:temp7]/256                              
8227   EB6D 78 00 59                asl     temp3                   ; Get lowest bit from fractional part                              
8228   EB70 59                      rolb                            ; Shift it in                            
8229   EB71 49                      rola                            ; shift it in, D = 2*b*[temp6:temp7]/256 
8230   EB72 25 09                   bcs     L1604                   ; Branch if overflow                             
8231   EB74 78 00 59                asl     temp3                   ; No overflow, Get second lowest bit from fractional part
8232   EB77 C9 00                   adcb    #$00                    ; Add it to result (round-up result)                            
8233   EB79 89 00                   adca    #$00                    ; propagate                            
8234   EB7B 24 02                   bcc     L1605                   ; Branch if no overflow                             
8235   EB7D 86 FF       L1604       ldaa    #$ff                    ; Overflow, return max value                            
8236   EB7F DD 5C       L1605       std     temp6                   ; Store result                             
8237   EB81 39                      rts                             ;                             
8238   EB82                                                         
8239   EB82             
8240   EB82             
8241   EB82             ;******************************************************************
8242   EB82             ;
8243   EB82             ; Input:
8244   EB82             ;               D = 16 bit value1 (should be only 11 or 12 bits???)
8245   EB82             ;     temp6:temp7 = 16 bit value2
8246   EB82             ;
8247   EB82             ; Output:
8248   EB82             ;       D and [temp6:temp7] = rounded value1*value2/128 (a=$ff in case of overflow)
8249   EB82             ;       Optionally, divided by and additional 4 if mul1616_512 is used or 16 if mul1616_2K is used
8250   EB82             ;
8251   EB82             ;******************************************************************
8252   EB82 05          mul1616_128 asld                            ;                              
8253   EB83 05                      asld                            ;                             
8254   EB84 05          mul1616_512 asld                            ;                             
8255   EB85 05                      asld                            ; D = value1 * 16                            
8256   EB86 BD EA 90    mul1616_2K  jsr     mul1616                 ; D = (value1 * 16 * value2)/65536 (upper 16 bits of mul1616)                              
8257   EB89 DE 58                   ldx     temp2                   ; X = lower 16 bits of (value1 * 16 * value2)                             
8258   EB8B 1A                      xgdx                            ; D = lower 16 bits of (value1 * 16 * value2), X = (value1 * 16 * value2)/65536                           
8259   EB8C C6 03                   ldab    #$03                    ; a = 3rd part of mul1616, b=3=number of loop to execute                            
8260   EB8E             
8261   EB8E                         ;--------------------------------------------
8262   EB8E                         ; Loop 3 times to divide 24 bit result by 8 
8263   EB8E                         ;--------------------------------------------
8264   EB8E 1A          L1609       xgdx                            ; Xhi = 3rd part of mul1616, Xlo = 3, D = (value1 * 16 * value2)/65536
8265   EB8F 04                      lsrd                            ; D = (value1 * 16 * value2)/65536/2^n, carry = lower bit
8266   EB90 1A                      xgdx                            ; X = (value1 * 16 * value2)/65536/2^n, a = 3rd part of mul1616/2^(n-1), b=3 on first loop                             
8267   EB91 46                      rora                            ; shift in carry, a = (3rd part of mul1616)/2^n, b=3 on first loop
8268   EB92 5A                      decb                            ; b=b-1                           
8269   EB93 26 F9                   bne     L1609                   ; loop
8270   EB95             
8271   EB95                         ;------------------------------------------------------------
8272   EB95                         ; Round-up and check for overflow in A
8273   EB95                         ; At this point, 24 bit result should have been
8274   EB95                         ; shifted down to fit only in 16 bits, upper 8 bit
8275   EB95                         ; should be 0, if not, b will be loaded with $ff in scale1m
8276   EB95                         ;------------------------------------------------------------
8277   EB95 89 00                   adca    #$00                    ; Round-up result 3rd part of result                            
8278   EB97 36                      psha                            ; st0 = lower 8 bit of result                            
8279   EB98 1A                      xgdx                            ; D = (value1 * 16 * value2)/65536/8                             
8280   EB99 8D 1F                   bsr     scale1m                 ; Propagate carry from 3rd part of result to D and check for overflow 
8281   EB9B             
8282   EB9B                         ;-----------------------------------------------------------------------
8283   EB9B                         ; At this point, we assume upper 8 bits=0 and only keep lower 16 bits
8284   EB9B                         ;-----------------------------------------------------------------------
8285   EB9B 17                      tba                             ; a =  2nd part of 24 bit result                            
8286   EB9C 33                      pulb                            ; b =  lower 8 bit of 24 bit result, in short, D=(value1 * 16 * value2)/256/8 = value1*value2/128
8287   EB9D DD 5C                   std     temp6                   ; temp6:temp7 = value1*value2/128
8288   EB9F 39                      rts                             ;                             
8289   EBA0                         
8290   EBA0             
8291   EBA0             
8292   EBA0             ;******************************************************************
8293   EBA0             ;
8294   EBA0             ; Scaling function with rounding
8295   EBA0             ; Divide d by 128 or 64, etc.
8296   EBA0             ;
8297   EBA0             ;
8298   EBA0             ;
8299   EBA0             ;******************************************************************
8300   EBA0 04          scale128    lsrd                              ;                           
8301   EBA1 04          scale64     lsrd                              ;                           
8302   EBA2 04                      lsrd                              ;                           
8303   EBA3 04          scale16     lsrd                              ;                           
8304   EBA4 04          scale8      lsrd                              ;                           
8305   EBA5 04                      lsrd                              ;                           
8306   EBA6 04                      lsrd                              ;                           
8307   EBA7 C9 00                   adcb    #$00                      ; Round-up by adding carry bit                          
8308   EBA9 89 00                   adca    #$00                      ; propagate addition                          
8309   EBAB 39                      rts                               ;                            
8310   EBAC                                                          
8311   EBAC             
8312   EBAC             
8313   EBAC             ;******************************************************************
8314   EBAC             ;
8315   EBAC             ; Input:
8316   EBAC             ;       d = v1:v0
8317   EBAC             ;
8318   EBAC             ; Output:
8319   EBAC             ;       a = v1 rounded up depending on v0, up to max of $ff
8320   EBAC             ;
8321   EBAC             ;
8322   EBAC             ;******************************************************************
8323   EBAC 58          round256    aslb                            ; Shift high bit of b in carry
8324   EBAD 89 00                   adca    #$00                    ; roundup a                            
8325   EBAF 24 01                   bcc     L1615                   ; branch if no overflow                             
8326   EBB1 4A                      deca                            ; Overflow, use max of $ff                            
8327   EBB2 39          L1615       rts                             ;                             
8328   EBB3             
8329   EBB3             
8330   EBB3             
8331   EBB3             ;******************************************************************
8332   EBB3             ;
8333   EBB3             ;
8334   EBB3             ; Divide D by 128 or 64 or 32... in order for the value to fit
8335   EBB3             ; only in b (with a=0). If it does not fit (a<>0), b is loaded with 
8336   EBB3             ; max value of $ff
8337   EBB3             ;
8338   EBB3             ;
8339   EBB3             ;
8340   EBB3             ;******************************************************************
8341   EBB3 04          scale128m   lsrd                                                         
8342   EBB4 04          scale64m    lsrd                                                         
8343   EBB5 04                      lsrd                                                         
8344   EBB6 04          scale16m    lsrd                                                         
8345   EBB7 04          scale8m     lsrd                                                         
8346   EBB8 04          scale4m     lsrd                                                         
8347   EBB9 04          scale2m     lsrd                            ; D = D/128, carry contains last bit shifted out                                        
8348   EBBA C9 00       scale1m     adcb    #$00                    ; Add last bit shifted out (round-up number)                                            
8349   EBBC 89 00                   adca    #$00                    ; propagate addition of last bit                                                        
8350   EBBE 4D          ovfCheck    tsta                                                         
8351   EBBF 27 02                   beq     L1624                   ; branch if A=0                                                                                            
8352   EBC1 C6 FF                   ldab    #$ff                    ; A is not 0, set fractional part to FF (the only one returned...)                              
8353   EBC3 39          L1624       rts                                                          
8354   EBC4             
8355   EBC4             
8356   EBC4             
8357   EBC4             ;******************************************************************
8358   EBC4             ;
8359   EBC4             ;
8360   EBC4             ; Apply an offset and clip input, the result is usually used to 
8361   EBC4             ; interpolate a table with a value of known range...
8362   EBC4             ;
8363   EBC4             ;        in Xhi = max value
8364   EBC4             ;        in Xlo = offset
8365   EBC4             ;        in   b = input value
8366   EBC4             ;
8367   EBC4             ;        out b = max(min(b,Xhi)-Xlo,0)
8368   EBC4             ;
8369   EBC4             ;
8370   EBC4             ;******************************************************************
8371   EBC4 DF 57       clipOffset  stx     temp1                                                 
8372   EBC6 D1 57                   cmpb    temp1                                                 
8373   EBC8 25 02                   bcs     L1626                                                 
8374   EBCA D6 57                   ldab    temp1                                                 
8375   EBCC D0 58       L1626       subb    temp2                                                 
8376   EBCE 24 01                   bcc     L1627                                                 
8377   EBD0 5F                      clrb                                                         
8378   EBD1 39          L1627       rts                                                          
8379   EBD2             
8380   EBD2             
8381   EBD2             
8382   EBD2             ;******************************************************************
8383   EBD2             ;
8384   EBD2             ; This function is used to apply a piecewise linear transformation
8385   EBD2             ; to the input value, see L2052, L2053 and L2054. This can be seen
8386   EBD2             ; as calculating the index into a table where the spacing between
8387   EBD2             ; table entries is not constant (first three entries spaced by x,
8388   EBD2             ; next three spaced by 2x, etc...)
8389   EBD2             ;
8390   EBD2             ; Input:
8391   EBD2             ;       a = val
8392   EBD2             ;       b = 0 (ignored or cleared)
8393   EBD2             ;       y = points to table with first two values being a max 
8394   EBD2             ;           and offset and the rest being triplets (addVal, nshift, compVal)
8395   EBD2             ;           where compVal is monotonicaly increasing... 
8396   EBD2             ;
8397   EBD2             ; Output:
8398   EBD2             ;       a = (min(val,max) - offset + addVal)/2^(nshift-1)
8399   EBD2             ;       
8400   EBD2             ;       where max and offset are the first two values of the table
8401   EBD2             ;       and where addVal and nShift are taken from the table according to val-offset
8402   EBD2             ;
8403   EBD2             ;******************************************************************
8404   EBD2                         ;------------------------------------------------------
8405   EBD2                         ; Apply max value of table, a = min(val,table[0])
8406   EBD2                         ;------------------------------------------------------
8407   EBD2 A1 80       pwiseLin    cmpa    $00,y                   ; Operation does ++y...I assume                             
8408   EBD4 25 05                   bcs     L1629                   ; Branch if a < table[0]                             
8409   EBD6 CD 09                   decy                            ; --y, go back to 0                           
8410   EBD8 A6 80                   ldaa    $00,y                   ; a=table[y++]                             
8411   EBDA 5F                      clrb                            ; b=0
8412   EBDB                               
8413   EBDB                         ;----------------------------------------------------------                      
8414   EBDB                         ; Subtract offset of table, a = val-table[1] = val-offset
8415   EBDB                         ;----------------------------------------------------------                      
8416   EBDB A0 80       L1629       suba    $00,y                   ; a = val-table[y++] = val-offset                             
8417   EBDD 24 02                   bcc     L1630                   ; Branch if result positive                             
8418   EBDF 4F                      clra                            ; Result negative, d=0                            
8419   EBE0 5F                      clrb                            ; d=0
8420   EBE1                                                     
8421   EBE1                         ;----------------------------------------------
8422   EBE1                         ; Loop until we find compVal > a 
8423   EBE1                         ;----------------------------------------------
8424   EBE1 EE 80       L1630       ldx     $00,y                   ; x = table[y]:table[y+1]; y = y + 2                               
8425   EBE3 A1 80                   cmpa    $00,y                   ; Operation does ++y...I assume                             
8426   EBE5 24 FA                   bcc     L1630                   ; Loop if  a >= table[y]                              
8427   EBE7             
8428   EBE7                         ;-------------------------------------------------------------- 
8429   EBE7                         ; Store the corresponding addVal and nshift in temp1 and temp2
8430   EBE7                         ;-------------------------------------------------------------- 
8431   EBE7 DF 57                   stx     temp1                   ; temp1 = addVal;, temp2 = nshift
8432   EBE9             
8433   EBE9                         ;--------------------------------------------
8434   EBE9                         ; Add addVal to a, a = val - offset + addVal
8435   EBE9                         ;--------------------------------------------
8436   EBE9 9B 57                   adda    temp1                   ; a = a-offset+addVal 
8437   EBEB                         
8438   EBEB                         ;----------------------------------------------------------------
8439   EBEB                         ; Apply nshift to a, a =  (val - offset + addVal)/2^(nshift-1)
8440   EBEB                         ;----------------------------------------------------------------
8441   EBEB 7A 00 58    L1631       dec     temp2                   ; temp2=table[y+1]-1
8442   EBEE 27 03                   beq     L1632                   ; Btanch if table[y+1]-1 =0
8443   EBF0 04                      lsrd                            ; d = d/2                            
8444   EBF1 20 F8                   bra     L1631                   ; Loop                             
8445   EBF3 39          L1632       rts                             ;                             
8446   EBF4             
8447   EBF4             
8448   EBF4             
8449   EBF4             ;******************************************************************
8450   EBF4             ;
8451   EBF4             ; Input: 
8452   EBF4             ;       y: point to piecewise linear transformation table
8453   EBF4             ;
8454   EBF4             ; Apply piecewise linear transformation to rpm4 and scale
8455   EBF4             ;
8456   EBF4             ;
8457   EBF4             ;******************************************************************
8458   EBF4 DC DA       rpmPwise    ldd     rpm4                    ;                              
8459   EBF6 05                      asld                            ;                             
8460   EBF7 05                      asld                            ; d = rpm4*4                            
8461   EBF8 8D D8                   bsr     pwiseLin                ;                              
8462   EBFA 20 BA                   bra     scale16m                ;                                 
8463   EBFC             
8464   EBFC             
8465   EBFC             
8466   EBFC             ;******************************************************************
8467   EBFC             ;
8468   EBFC             ;
8469   EBFC             ; Decrement value at X by 1 (min of 0) if Tclocks.0 (40Hz signal) is set
8470   EBFC             ;
8471   EBFC             ;
8472   EBFC             ;******************************************************************
8473   EBFC C6 01       decX40Hz    ldab    #$01                                                 
8474   EBFE 8F D9 01 0A             brclr   Tclocks, #$01, L1637                                     
8475   EC02             
8476   EC02             
8477   EC02             
8478   EC02             ;******************************************************************
8479   EC02             ;
8480   EC02             ;
8481   EC02             ; Decrement all values in a given table by 1, stop at min value 0
8482   EC02             ; X points to table, b is number of elements
8483   EC02             ;
8484   EC02             ;
8485   EC02             ;******************************************************************
8486   EC02 CF 00 FF 02 decTable    brclr   $0000,x,#$ff,L1636  
8487   EC06 6A 00                   dec     $0000,x                                                 
8488   EC08 08          L1636       inx                                                          
8489   EC09 5A                      decb                                                         
8490   EC0A 26 F6                   bne     decTable                                                 
8491   EC0C 39          L1637       rts                                                          
8492   EC0D             
8493   EC0D             
8494   EC0D             
8495   EC0D             ;******************************************************************
8496   EC0D             ;
8497   EC0D             ; Lookup the given table using config2 
8498   EC0D             ; lowest 2 bits as index to 16 bits values
8499   EC0D             ;
8500   EC0D             ; Input:
8501   EC0D             ;     x: points to table
8502   EC0D             ;
8503   EC0D             ; Output:
8504   EC0D             ;
8505   EC0D             ;     x(16 bits): table(2*(config2 & $03))
8506   EC0D             ;
8507   EC0D             ;******************************************************************
8508   EC0D D6 56       cfgLookup16 ldab    config2                 ; b = config2                               
8509   EC0F C4 03                   andb    #$03                    ;                             
8510   EC11 58                      aslb                            ; b = 2*(config2 & $03)                            
8511   EC12 3A                      abx                             ; x points to table(2*(config2 & $03))                            
8512   EC13 EE 00                   ldx     $00,x                   ; x =  table(2*(config2 & $03))                             
8513   EC15 39                      rts                             ;                             
8514   EC16             
8515   EC16             
8516   EC16             
8517   EC16             ;******************************************************************
8518   EC16             ;
8519   EC16             ; Read value from IO port (ADC) using a and b (d) as the values
8520   EC16             ; to write to adc_ctl and adc_data respectively. a should be set
8521   EC16             ; to the port number (0 to 7 as indicated below) with the start bit
8522   EC16             ; set to 1 ($08) 
8523   EC16             ;
8524   EC16             ;     Port $00: ECT (engine coolant temp)
8525   EC16             ;     Port $01: IAT
8526   EC16             ;     Port $02: BARO
8527   EC16             ;     Port $03: O2
8528   EC16             ;     Port $04: EGRT
8529   EC16             ;     Port $05: BATT
8530   EC16             ;     Port $06: KNOCK count
8531   EC16             ;     Port $07: TPS
8532   EC16             ;
8533   EC16             ;
8534   EC16             ;******************************************************************
8535   EC16 0F          readAdc1    sei                            ; set interrupt mask             
8536   EC17 DD 1F       readAdc2    std     adc_ctl                ; set port #                     
8537   EC19 21 00                   brn     L1641                  ; time delay                     
8538   EC1B 15 FF       L1641       div     airCntDef              ; time delay                     
8539   EC1D 3D                      mul                            ; time delay                     
8540   EC1E 3D                      mul                            ; time delay                     
8541   EC1F 3D                      mul                            ; time delay                     
8542   EC20 3D                      mul                            ; time delay                     
8543   EC21 3D                      mul                            ; time delay                     
8544   EC22 3D                      mul                            ; time delay                     
8545   EC23 3D                      mul                            ; time delay                     
8546   EC24 DC 1F                   ldd     adc_ctl                ; get port value                 
8547   EC26 39                      rts                                                          
8548   EC27             
8549   EC27             
8550   EC27             
8551   EC27             ;******************************************************************
8552   EC27             ;
8553   EC27             ;
8554   EC27             ; input: rpm in b, maxRpm in a 
8555   EC27             ;        (note that airVol is also used instead of rpm in 
8556   EC27             ;         calling this function)
8557   EC27             ;
8558   EC27             ; output:   b = min(max(rpm-$10,0), maxRpm)      $10->500rpm
8559   EC27             ;
8560   EC27             ;******************************************************************
8561   EC27 C0 10       rpmRange    subb    #$10                    ;                                              
8562   EC29 24 01                   bcc     abmin                   ; Branch if result positive
8563   EC2B 5F                      clrb                            ; Use min of 0
8564   EC2C             
8565   EC2C                         ;--------------------------------------------
8566   EC2C                         ; Code below also called as a function
8567   EC2C                         ; abmin -> b = minimum of a and b (can also 
8568   EC2C                         ; be seen as applying a max...)
8569   EC2C                         ;--------------------------------------------
8570   EC2C 11          abmin       cba                             ; compare (A-B)                                
8571   EC2D 24 01                   bcc     L1644                   ; Branch if b<=maxRpm
8572   EC2F 16                      tab                             ; b = maxRpm
8573   EC30 39          L1644       rts                             ; return                                  
8574   EC31             
8575   EC31             
8576   EC31             
8577   EC31             ;******************************************************************
8578   EC31             ;
8579   EC31             ; Input:
8580   EC31             ;     None (a=airVol if called from L1647)
8581   EC31             ;
8582   EC31             ; Output: in b (same result in a):
8583   EC31             ; 
8584   EC31             ;     airVol[T]B  < 60: airVol[T]B - $20
8585   EC31             ;     airVol[T]B >= 60: 0.668 * airVol[T]B
8586   EC31             ;
8587   EC31             ; The maximum of airVolTB or airVolB is used, see comments below
8588   EC31             ;
8589   EC31             ;----------------------------------------
8590   EC31             ;
8591   EC31             ; the ecu makes a temp value for the table lookup..
8592   EC31             ; so if 0xe3 <= 96, value = 0xe3 - 32,
8593   EC31             ; if 0xe3 > 96, value = 0xe3 * 2/3
8594   EC31             ;
8595   EC31             ;******************************************************************
8596   EC31             getLoadForMaps
8597   EC31~            #ifdef extLoadRange
8598   EC31~            #ifdef extLoadRange2
8599   EC31~                        ldaa    L0054                   ; a = airVol16/4
8600   EC31~                        ldab    baroFact                ; b = baroFact
8601   EC31~                        mul                             ; d = airVol16/4 * baroFact
8602   EC31~                        jsr     scale128m               ; b = airVol16/4 * baroFact/128
8603   EC31~                        ldaa    iatCompFact             ; a = iatCompFact 
8604   EC31~                        bpl     test123                 ; Branch if iatCompFact < $80
8605   EC31~                        mul                             ; d = airVol16/4 * baroFact/128  * iatCompFact
8606   EC31~                        jsr     scale128m               ; b = airVol16/4 * baroFact/128  * iatCompFact/128
8607   EC31~            test123     tba                             ; a = airVol16/4 * baroFact/128 [* iatCompFact/128]
8608   EC31~            #else
8609   EC31~                        ldaa    L0054                   ; a = airVol16/4
8610   EC31~                        bra     L1647
8611   EC31~                        nop
8612   EC31~                        nop
8613   EC31~                        nop
8614   EC31~                        nop
8615   EC31~                        nop
8616   EC31~                        nop
8617   EC31~                        nop
8618   EC31~            #endif
8619   EC31             #else
8620   EC31                         ;-----------------------------------------------------
8621   EC31                         ; Decide on which value to use, airVolTB or airVolB
8622   EC31                         ;
8623   EC31                         ; Done this way, it correspond to taking the 
8624   EC31                         ; highest of the two since:
8625   EC31                         ;
8626   EC31                         ;       airVolTB = airVolB * iatCompFact/128
8627   EC31                         ;
8628   EC31                         ;       if iatCompFact<128  -> max is airVolB 
8629   EC31                         ;       if iatCompFact>=128 -> max is airVolTB 
8630   EC31                         ;
8631   EC31                         ; Since the load is used to interpolate the fuel map,
8632   EC31                         ; it is probably safer to use the maximum of the two 
8633   EC31                         ; value, i.e. assume there is more air than less and 
8634   EC31                         ; therefore risk of running too rich. The risk of using 
8635   EC31                         ; only airVolTB is that if the temperature sensor is 
8636   EC31                         ; heat soaked then it will report a higher temperature 
8637   EC31                         ; than the actual temperature of the air getting in.
8638   EC31                         ; This means that airVolTB will report less air than
8639   EC31                         ; is actually getting in and there won't be enough 
8640   EC31                         ; fuel injected -> we will run too lean... 
8641   EC31                         ;-----------------------------------------------------
8642   EC31 B6 01 5F                ldaa    iatCompFact             ; a=iatCompFact ($80=100%)                                   
8643   EC34 2A 04                   bpl     L1646                   ; Branch if iatCompFact<100%                              
8644   EC36 96 E2                   ldaa    airVolTB                ; iatCompFact>=100%, a = airVolTB                                 
8645   EC38 20 02                   bra     L1647                   ;                              
8646   EC3A 96 E3       L1646       ldaa    airVolB                 ; iatCompFact<100%, a = airVolB                               
8647   EC3C             #endif
8648   EC3C             
8649   EC3C                         ;-------------------------------------
8650   EC3C                         ; Compute load index from air volume
8651   EC3C                         ;-------------------------------------
8652   EC3C 16          L1647       tab                             ; a = b = airVol[T]B
8653   EC3D C0 60                   subb    #$60                    ; b = airVol[T]B - $60
8654   EC3F 25 08                   bcs     L1648                   ; branch if underflow (airVol[T]B <$60)
8655   EC41 86 AB                   ldaa    #$ab                    ; a = $ab                            
8656   EC43 3D                      mul                             ; d = $ab * (airVol[T]B - $60)
8657   EC44 58                      aslb                            ; Shift higher bit of b in carry
8658   EC45 89 00                   adca    #$00                    ; Round-up a                            
8659   EC47 8B 60                   adda    #$60                    ; a = rounded $ab * (airVol[T]B - $60)/256 + $60
8660   EC49 80 20       L1648       suba    #$20                    ; a = a-20                             
8661   EC4B 24 01                   bcc     L1649                   ; branch if no overflow                             
8662   EC4D 4F                      clra                            ; use min value                            
8663   EC4E 16          L1649       tab                             ; a = b = result                            
8664   EC4F 39                      rts                             ;                             
8665   EC50             
8666   EC50             
8667   EC50             
8668   EC50             ;******************************************************************
8669   EC50             ;
8670   EC50             ; Input: temp22:temp23 = v1:v0 (set to Tcas)
8671   EC50             ;
8672   EC50             ; Output 
8673   EC50             ;       d = abs([temp22:temp23] - TcasLast0) - [temp22:temp23] * $30//256
8674   EC50             ;
8675   EC50             ;******************************************************************
8676   EC50 96 80       L1650       ldaa    temp22                  ; a = v1
8677   EC52 C6 30                   ldab    #$30                    ; b = $30                             
8678   EC54 3D                      mul                             ; d = $30 * v1                             
8679   EC55 1A                      xgdx                            ; x = $30 * v1                            
8680   EC56 96 81                   ldaa    temp23                  ; a = v0                             
8681   EC58 C6 30                   ldab    #$30                    ; b = $30                            
8682   EC5A 3D                      mul                             ; d = $30 * v0                            
8683   EC5B 16                      tab                             ; b = $30 * v0 /256                            
8684   EC5C 3A                      abx                             ; x = $30 * v1 + $30 * v0 /256 = $30*(v1+v0/256) = [temp22:temp23] * $30//256                           
8685   EC5D DF 7E                   stx     temp20                  ; temp20 = [temp22:temp23] * $30//256                           
8686   EC5F             
8687   EC5F                         ;---------------------------------------
8688   EC5F                         ; Compute abs(temp22:temp23 - TcasLast0)
8689   EC5F                         ;---------------------------------------
8690   EC5F DC 80                   ldd     temp22                  ; d = temp22:temp23                             
8691   EC61 93 64                   subd    TcasLast0                ; d = temp22:temp23 - TcasLast0                              
8692   EC63 24 05                   bcc     L1651                   ; Branch if result positive
8693   EC65 43                      coma                            ; Result negative, make it positive                            
8694   EC66 53                      comb                            ;                             
8695   EC67 C3 00 01                addd    #$0001                  ; two's complement...                              
8696   EC6A             
8697   EC6A                         ;----------------
8698   EC6A                         ; Compute result
8699   EC6A                         ;----------------
8700   EC6A 93 7E       L1651       subd    temp20                  ; d = abs(temp22:temp23 - TcasLast0) - [temp22:temp23] * $30//256                                    
8701   EC6C 39                      rts                             ;                             
8702   EC6D             
8703   EC6D             
8704   EC6D             
8705   EC6D             ;******************************************************************
8706   EC6D             ;
8707   EC6D             ;
8708   EC6D             ; Input capture interrupt 1
8709   EC6D             ;
8710   EC6D             ; Main CAS interrupt routine, triggered on both the rising
8711   EC6D             ; and falling edge of the CAS signal (edge detection polarity 
8712   EC6D             ; is toggled in the code upon each interrupt)
8713   EC6D             ;
8714   EC6D             ;
8715   EC6D             ;******************************************************************
8716   EC6D                         ;------------------------------------------------
8717   EC6D                         ; Read t3_clock1 for later use and then 
8718   EC6D                         ; read t1_csr (not used so I assume it ackowledges 
8719   EC6D                         ; the interrupt ?) 
8720   EC6D                         ;------------------------------------------------
8721   EC6D DE 29       inCaptInt1  ldx     t3_clock1               ; Get current coil clock value when the cas edge changed?
8722   EC6F D6 08                   ldab    t1_csr                  ; Acknowledge cas input capture interrupt?                                                                                                                              
8723   EC71             
8724   EC71                         ;--------------------------------------------------------
8725   EC71                         ; Update t1_lastCas for eventual aiflow calculation
8726   EC71                         ;--------------------------------------------------------
8727   EC71 DC 0D                   ldd     t1_inCapt               ; Get cas input timer capture high/low                                                                                            
8728   EC73 DD 96                   std     t1_lastCas              ; store it here                                                                                                               
8729   EC75             
8730   EC75                         ;------------------------------------------------
8731   EC75                         ; Update temp20 assuming interrupt is from t2
8732   EC75                         ; will be changed later if assumption was wrong
8733   EC75                         ;------------------------------------------------
8734   EC75 DC 2D                   ldd     t3_clock2               ; Get current counter value
8735   EC77 DD 7E                   std     temp20                  ; temp20 = t3_clock2                                                                                                                            
8736   EC79             
8737   EC79                         ;-------------------------------------------
8738   EC79                         ; Branch to rising or falling edge section 
8739   EC79                         ; depending on the interrupt source
8740   EC79                         ;-------------------------------------------
8741   EC79 8F 08 02 03             brclr   t1_csr, #$02, casRiseProc ; Branch if this is the cas rising edge
8742   EC7D 7E F0 AF                jmp     casFallProc               ; Branch to cas failling edge section
8743   EC80             
8744   EC80             
8745   EC80             
8746   EC80             ;******************************************************************
8747   EC80             ;
8748   EC80             ;
8749   EC80             ; Section processing the CAS interrupt on the rising edge
8750   EC80             ;   
8751   EC80             ;;
8752   EC80             ;
8753   EC80             ;******************************************************************
8754   EC80                         ;-------------------------------------------------------------------------
8755   EC80                         ; Check which of t3_clock1 or t3_clock2 should be used?
8756   EC80                         ; Not sure what that bit means???????????
8757   EC80                         ;-------------------------------------------------------------------------
8758   EC80 8F 19 10 03 casRiseProc brclr   t3_csr0, #$10, L1654    ; Branch if we should use t3_clock2, nothing to do, that's what we assumed above
8759   EC84             
8760   EC84                         ;-------------------------------------------------------------------------
8761   EC84                         ; t3_clock1 should be used, our assumption that it was
8762   EC84                         ; t3_clock2 was wrong, update d and  temp20 with the correct values
8763   EC84                         ;-------------------------------------------------------------------------
8764   EC84 1A                      xgdx                            ; d = t3_clock1
8765   EC85 DD 7E                   std     temp20                  ; temp20 = t3_clock1
8766   EC87             
8767   EC87                         ;-------------------------------------------------------------
8768   EC87                         ; Branch to rest of code if the time between CAS
8769   EC87                         ; interrupts makes sense (rpm is not too high...)
8770   EC87                         ;
8771   EC87                         ; The time measured here is the time in-between cas
8772   EC87                         ; pulses since it is measured from the falling edge to the 
8773   EC87                         ; rising edge. Since this time correspond to 110deg
8774   EC87                         ; then the 1ms below correspond to 360/110*1ms = 3.27ms 
8775   EC87                         ; per rotation which correspond to 18333rpm. The threshold of
8776   EC87                         ; 1ms or 0.5 ms (18333 or 23333rpm) on the cas rising and falling 
8777   EC87                         ; edge section is not the same and it might be due to the fact
8778   EC87                         ; that on the cas falling edge, we measure a smaller interval 
8779   EC87                         ; (70deg instead of 110deg) and therefore the uncertainty is 
8780   EC87                         ; higher???
8781   EC87                         ;-------------------------------------------------------------
8782   EC87 93 6A       L1654       subd    casFallTime0            ; d = t3_clock1 - casFallTime0
8783   EC89 1C 00 FA                cmpd    #$00fa                  ; 1ms at 250KHz                                                                                                                             
8784   EC8C 24 07                   bcc     L1655                   ; Branch if (t3_clock1 or  t3_clock2 - casFallTime0) >= $00fa
8785   EC8E             
8786   EC8E                         ;------------------------------------------------
8787   EC8E                         ; RPM seems too high to make sense, check if it is
8788   EC8E                         ; not instead because RPM is so low that the 16 bit 
8789   EC8E                         ; counter subtraction above rolled-over.
8790   EC8E                         ;
8791   EC8E                         ; Branch to rest of code if the T200_casFall timer shows
8792   EC8E                         ; that rpm is very low... 
8793   EC8E                         ;------------------------------------------------
8794   EC8E 96 C0                   ldaa    T200_casFall            ;                                                                                                                             
8795   EC90 81 0E                   cmpa    #$0e                    ; 70ms at 200Hz                                                                                                                             
8796   EC92 25 01                   bcs     L1655                   ; branch if T200_casFall<70ms, T200_casFall is init with 265ms, the time between interrupt is very high                                                                                                                            
8797   EC94             
8798   EC94                         ;-------------------------------------------------------------
8799   EC94                         ; Time between interrupts doesn't make sense, just ignore it
8800   EC94                         ; Return from interrupt
8801   EC94                         ;-------------------------------------------------------------
8802   EC94 3B                      rti                             ;                                                                                                                            
8803   EC95             
8804   EC95                         ;---------------------------------------------------------------
8805   EC95                         ; Update temp22:temp23 = Tcas measured on the cas rising edge
8806   EC95                         ;---------------------------------------------------------------
8807   EC95 DC 7E       L1655       ldd     temp20                  ; D = temp20
8808   EC97 93 68                   subd    casRiseTime0            ; D = temp20-casRiseTime0(old counter) = Tcas = 250000/2/(rpm/60)                                      
8809   EC99 DD 80                   std     temp22                  ; temp22:temp23 = Tcas (temp22 is not dedicated for that purpose...)                                 
8810   EC9B             
8811   EC9B                         ;--------------------------------
8812   EC9B                         ; Validate temp22:temp23 = Tcas
8813   EC9B                         ;--------------------------------
8814   EC9B D6 BF                   ldab    T200_casRise            ;                                
8815   EC9D 27 07                   beq     L1656                   ; Branch if timer expired (very long Tcas...)                            
8816   EC9F 4D                      tsta                            ;                             
8817   ECA0 2B 09                   bmi     L1657                   ; Branch if Tcas/256 >= 128 (rpm<229)                             
8818   ECA2 C1 0E                   cmpb    #$0e                    ;                             
8819   ECA4 22 05                   bhi     L1657                   ; Branch if T200_casRise > $0e (70ms)                             
8820   ECA6 CC FF FF    L1656       ldd     #$ffff                  ; Use max Tcas                              
8821   ECA9 DD 80                   std     temp22                  ; store Tcas
8822   ECAB             
8823   ECAB                         ;----------------------------------------------
8824   ECAB                         ; Section to calculate new casFlags0 value but do 
8825   ECAB                         ; not store it now. It will be stored once the 
8826   ECAB                         ; interrupt is validated
8827   ECAB                         ;----------------------------------------------
8828   ECAB                         ;----------------------------------------------
8829   ECAB                         ; First transfer some bits to "old" positions 
8830   ECAB                         ; and assume some bits will be set...
8831   ECAB                         ;----------------------------------------------
8832   ECAB 96 61       L1657       ldaa    casFlags0               ; a = casFlags0                              
8833   ECAD 84 05                   anda    #$05                    ; a = casFlags0 & 00000101 (keep some old bits)                            
8834   ECAF 48                      asla                            ; Move the old bits to the "old" positions                            
8835   ECB0 8A 35                   oraa    #$35                    ; preload some bits (00110101)
8836   ECB2             
8837   ECB2                         ;--------------------------------------------------
8838   ECB2                         ; Set flag if timing adjustement mode is active
8839   ECB2                         ;--------------------------------------------------
8840   ECB2 8F 87 80 02             brclr   timAdjFlags, #$80, L1658 ; Branch if we are not in timing adjustement mode                               
8841   ECB6 8A 40                   oraa    #$40                     ; a = (casFlags0 & 00001001)*2 | 01110101                            
8842   ECB8             
8843   ECB8                         ;-------------------------------------------------
8844   ECB8                         ; Reset some new casFlags0 bits depending on rpm
8845   ECB8                         ;-------------------------------------------------
8846   ECB8 DE 80       L1658       ldx     temp22                   ; x = temp22:temp23 = Tcas                             
8847   ECBA 8C 06 1A                cpx     #$061a                  ; 4801rpm                                   
8848   ECBD 25 1E                   bcs     L1662                   ; Branch if rpm(Tcas) >  4801rpm                                        
8849   ECBF 84 DF                   anda    #$df                    ; Reset 00100000                                        
8850   ECC1 8C 10 81                cpx     #$1081                  ; 1775rpm                                    
8851   ECC4 25 02                   bcs     L1659                   ; Branch if rpm(Tcas) >  1775rpm
8852   ECC6 84 FB                   anda    #$fb                    ; Reset 00000100                                        
8853   ECC8 8C 13 06    L1659       cpx     #$1306                  ; 1540rpm                                    
8854   ECCB 25 02                   bcs     L1660                   ; Branch if rpm(Tcas) >  1540rpm                                           
8855   ECCD 84 EF                   anda    #$ef                    ; reset 00010000                                        
8856   ECCF             
8857   ECCF                         ;---------------------------------------
8858   ECCF                         ; At this point rpm(Tcas) <= 4801rpm
8859   ECCF                         ; Choose rpm threshold with hysteresis
8860   ECCF                         ;---------------------------------------
8861   ECCF C6 49       L1660       ldab    #$49                    ; b = $49 (401rpm)                            
8862   ECD1 85 02                   bita    #$02                    ;                              
8863   ECD3 26 02                   bne     L1661                   ; Branch if bit was already set                             
8864   ECD5 C6 3A                   ldab    #$3a                    ; use lower threshold if bit alread set b = $3a (505rpm)                             
8865   ECD7             
8866   ECD7                         ;---------------------------------------------------------------------
8867   ECD7                         ; Reset flag bit if we are above/below threshold, with hysteresis
8868   ECD7                         ;---------------------------------------------------------------------
8869   ECD7 D1 80       L1661       cmpb    temp22                  ;                              
8870   ECD9 22 02                   bhi     L1662                   ; Branch if rpm(Tcas) < b (401rpm or 505rpm)                             
8871   ECDB 84 FE                   anda    #$fe                    ; Reset 00000001                      
8872   ECDD                               
8873   ECDD                         ;-----------------------------------------------------------
8874   ECDD                         ; Store new value of casFlags0 in temp location for now
8875   ECDD                         ;-----------------------------------------------------------
8876   ECDD 97 82       L1662       staa    temp24                  ; Store new casFlags0 in temp memory for now
8877   ECDF                         
8878   ECDF                         ;--------------------------------------------------------------------
8879   ECDF                         ; At this point, we will check the CAS signal to make sure it stays
8880   ECDF                         ; set until 56us after the start of the interrupt. I guess this might
8881   ECDF                         ; be to filter eventual glitches in the CAS signal
8882   ECDF                         ;--------------------------------------------------------------------
8883   ECDF DC 7E                   ldd     temp20                  ;                                   
8884   ECE1 C3 00 0E                addd    #$000e                  ; d = StartInterruptTime + $0e (56us)                              
8885   ECE4 8F 16 01 01 L1663       brclr   port5, #$01, L1664      ; Branch as long as CAS bit is clear (CAS signal is set)
8886   ECE8 3B                      rti                             ; CAS bit was set, Bail of interrupt
8887   ECE9 1D 29       L1664       cmpd1   t3_clock1               ; Compare current time to time stored when we started the interrupt processing                                 
8888   ECEB 2A F7                   bpl     L1663                   ; Loop if t3_clock1 < (temp20 + $0e (56us)), i.e. if its been less than 56us since interrupt was called
8889   ECED             
8890   ECED             
8891   ECED             
8892   ECED             ;******************************************************************
8893   ECED             ;
8894   ECED             ; Interrupt was valid
8895   ECED             ; Proceed with processing stuff on the CAS rising edge
8896   ECED             ;
8897   ECED             ;
8898   ECED             ;******************************************************************
8899   ECED                         ;------------------------------------------
8900   ECED                         ; Update p4Latched
8901   ECED                         ; (get our own copy of port4, we don't want 
8902   ECED                         ; changes during processing) 
8903   ECED                         ;------------------------------------------
8904   ECED 96 07                   ldaa    port4                   ;                              
8905   ECEF 97 86                   staa    p4Latched               ;                                  
8906   ECF1             
8907   ECF1                         ;-----------------------
8908   ECF1                         ; Update casRiseTime0 
8909   ECF1                         ;-----------------------
8910   ECF1 DC 7E                   ldd     temp20                  ; d = temp20                                   
8911   ECF3 DD 68                   std     casRiseTime0            ; casRiseTime0 = time at interrupt start 
8912   ECF5             
8913   ECF5                         ;--------------------------------------
8914   ECF5                         ; Finally store the new casFlags0 value  
8915   ECF5                         ; (we now know interrupt was valid...)
8916   ECF5                         ;--------------------------------------
8917   ECF5 96 82                   ldaa    temp24                  ;                              
8918   ECF7 97 61                   staa    casFlags0               ;                              
8919   ECF9             
8920   ECF9                         ;---------------------------------------------------------
8921   ECF9                         ; Reset flag ignFallFlags.0
8922   ECF9                         ;---------------------------------------------------------
8923   ECF9 02 62 FE                andm    ignFallFlags, #$fe             ;                                
8924   ECFC             
8925   ECFC                         ;---------------------------------------------------------
8926   ECFC                         ; restart T200_casRise timer to 175ms
8927   ECFC                         ;---------------------------------------------------------
8928   ECFC 86 35                   ldaa    #$35                    ; 175ms                             
8929   ECFE 97 BF                   staa    T200_casRise            ;                              
8930   ED00             
8931   ED00                         ;------------------------------------
8932   ED00                         ; Store current TDC state in temp24
8933   ED00                         ;------------------------------------
8934   ED00 96 06                   ldaa    port3                   ;                             
8935   ED02 84 04                   anda    #$04                    ; Keep only TDC bit                           
8936   ED04 97 82                   staa    temp24                  ; temp24.2 = TDC bit
8937   ED06             
8938   ED06                         ;-----------------------------------------------
8939   ED06                         ; Toggle tdcMask0:tdcMask1 (between $0402 and $0204)
8940   ED06                         ;-----------------------------------------------
8941   ED06 CC 04 02                ldd     #$0402                  ;                              
8942   ED09 87 7B 02 03             brset   tdcMask0, #$02, L1665   ; Branch if old tdcMask0.1 is set
8943   ED0D CC 02 04                ldd     #$0204                  ;                               
8944   ED10 DD 7B       L1665       std     tdcMask0                ; Store new value
8945   ED12                                
8946   ED12                         ;-----------------------------------------------------
8947   ED12                         ; Only execute the following section if the TDC signal 
8948   ED12                         ; did not change. Why? we just stored it 
8949   ED12                         ; a few lines earlier????? and if we really are on the
8950   ED12                         ; CAS rising edge then TDC cannot change at this time...
8951   ED12                         ;
8952   ED12                         ; Maybe this is some kind of safety/glitch/noise 
8953   ED12                         ; safety precaution. TDC signal could get corrupted
8954   ED12                         ; when the engine is cranking, low battery...? 
8955   ED12                         ;-----------------------------------------------------
8956   ED12 96 82                   ldaa    temp24                  ; a.2 = TDC bit, we just stored this value a few lines earlier, probability of it changing must be very low? I guess we MUST ensure temp24 is in synch with port3.2?????
8957   ED14 98 06                   eora    port3                   ; a.2 = oldTdcbit eor newTdcBit                             
8958   ED16 84 04                   anda    #$04                    ; Keep only TDC bit
8959   ED18 26 35                   bne     L1671                   ; branch if TDC bit changed, very low probability or even impossible if we really are on the CAS rising edge????
8960   ED1A             
8961   ED1A                         ;--------------------------------------------------------------
8962   ED1A                         ; TDC bit did not change (normal case), execute the section
8963   ED1A                         ;--------------------------------------------------------------
8964   ED1A                         ;-----------------------
8965   ED1A                         ; First check start key
8966   ED1A                         ;-----------------------
8967   ED1A 8F 06 40 22             brclr   port3, #$40, L1668      ; Branch if key is in start position                                
8968   ED1E             
8969   ED1E                         ;----------------------------------------------------
8970   ED1E                         ; Key is not in start
8971   ED1E                         ; Increment tdcCasCount up to a max of 6 
8972   ED1E                         ;----------------------------------------------------
8973   ED1E 96 83                   ldaa    tdcCasCount             ; a = old tdcCasCount                             
8974   ED20 7C 00 83                inc     tdcCasCount             ; tdcCasCount += 1
8975   ED23 81 05                   cmpa    #$05                    ;                             
8976   ED25 23 04                   bls     L1666                   ; branch if old tdcCasCount <=5 (new one is then <=6, no need to check max)                            
8977   ED27 86 06                   ldaa    #$06                    ; use max of 6                            
8978   ED29 97 83                   staa    tdcCasCount             ; store new value                             
8979   ED2B             
8980   ED2B                         ;----------------------------------------------------
8981   ED2B                         ; Load b=$02 or $04 depending on TDC current value
8982   ED2B                         ;----------------------------------------------------
8983   ED2B C6 02       L1666       ldab    #$02                    ; b = $02                            
8984   ED2D 8F 82 FF 02             brclr   temp24, #$ff, L1667     ; Branch if TDC bit is 0 (TDC signal active)                              
8985   ED31 C6 04                   ldab    #$04                    ; b = $04                            
8986   ED33             
8987   ED33                         ;------------------------------------------------------------
8988   ED33                         ; At this point b=$02 if TDC signal is active, $04 otherwise
8989   ED33                         ;------------------------------------------------------------
8990   ED33 D1 7B       L1667       cmpb    tdcMask0                ;                              
8991   ED35 27 18                   beq     L1671                   ; Branch if b = tdcMask0 (tdcMask0 is in synch with TDC???)                             
8992   ED37             
8993   ED37                         ;----------------------------------------------------
8994   ED37                         ; b != tdcMask0, we are out of synch, reinstate old 
8995   ED37                         ; tdcCasCount and branch to re-init tdcMask0
8996   ED37                         ;----------------------------------------------------
8997   ED37 4A                      deca                            ;                            
8998   ED38 97 83                   staa    tdcCasCount             ; tdcCasCount -= 1                                   
8999   ED3A 81 03                   cmpa    #$03                    ;                            
9000   ED3C 27 05                   beq     L1669                   ; Branch if tdcCasCount=3                            
9001   ED3E 2A 0F                   bpl     L1671                   ; Branch if tdcCasCount>3                           
9002   ED40             
9003   ED40                         ;-----------------------------------------------
9004   ED40                         ; Key in start or tdcCasCount<3, restart synch 
9005   ED40                         ; from scratch, i.e. tdcCasCount=0
9006   ED40                         ;-----------------------------------------------
9007   ED40 4F          L1668       clra                            ;                             
9008   ED41 97 83                   staa    tdcCasCount             ; tdcCasCount = 0                                   
9009   ED43             
9010   ED43                         ;------------------------------------------------------------------
9011   ED43                         ; Init tdcMask0 with $0204 if TDC is active $0402 otherwise
9012   ED43                         ;------------------------------------------------------------------
9013   ED43 CC 04 02    L1669       ldd     #$0402                  ;                               
9014   ED46 87 82 FF 03             brset   temp24, #$ff, L1670     ; Branch if TDC bit is 1 (TDC signal inactive)                               
9015   ED4A CC 02 04                ldd     #$0204                  ;                               
9016   ED4D DD 7B       L1670       std     tdcMask0                ;                              
9017   ED4F             
9018   ED4F                         ;---------------------------------------------
9019   ED4F                         ; Decide if we are going to calculate timing 
9020   ED4F                         ; or use fix timing of 5deg BTDC 
9021   ED4F                         ;---------------------------------------------
9022   ED4F CE 00 2A    L1671       ldx     #$002a                   ; x = $002a in case we have to bail to L1679                               
9023   ED52 8F 83 FE 04             brclr   tdcCasCount, #$fe, L1672 ; Branch if tdcCasCount = 0 or 1
9024   ED56 8F 61 40 04             brclr   casFlags0, #$40, L1673   ; Branch if timing adjustment mode is not active
9025   ED5A                                                      
9026   ED5A                         ;-----------------------------------------------------------------------
9027   ED5A                         ; tdcCasCount = 0 or 1 or timing adjustment mode is active
9028   ED5A                         ; Use default timing of 5 deg BTDC (or 4.75deg? close enough)
9029   ED5A                         ;-----------------------------------------------------------------------
9030   ED5A C6 A0       L1672       ldab    #$a0                     ; Use default value of tim61 = $a0 = 160 = 4.75deg BTDC (tech manual says 5deg BTDC)                             
9031   ED5C 20 35                   bra     L1679                    ;                             
9032   ED5E             
9033   ED5E                         ;------------------------------------
9034   ED5E                         ; tdcCasCount >= 2 and casFlags0.6 = 0 
9035   ED5E                         ; Reset knockSum if knockSum>43 ???
9036   ED5E                         ;------------------------------------
9037   ED5E D6 8B       L1673       ldab    knockSum                 ;                                
9038   ED60 C1 2B                   cmpb    #$2b                     ;                            
9039   ED62 23 03                   bls     L1674                    ; Branch if knockSum<= $2b (43)                            
9040   ED64 5F                      clrb                             ;                            
9041   ED65 D7 8B                   stab    knockSum                 ;
9042   ED67                                                         
9043   ED67                         ;---------------------------------------------------------------
9044   ED67                         ; Compute the new target timing tim61Tot1 
9045   ED67                         ;
9046   ED67                         ;      tim61Tot1 = temp24 = min(knockSum+tim61Tot0, $bc)
9047   ED67                         ;
9048   ED67                         ; tim61Tot1 is therefore tim61Tot0 which is further retarded
9049   ED67                         ; by a number of degrees equal to knockSum. Maximum value is
9050   ED67                         ;
9051   ED67                         ;       max = $bc = 188 =  256 * 66deg / 90
9052   ED67                         ;
9053   ED67                         ; which is +5deg ATDC since it is referenced to 61degBTDC
9054   ED67                         ;---------------------------------------------------------------
9055   ED67 DB 88       L1674       addb    tim61Tot0                ; b = knockSum + tim61Tot0                            
9056   ED69 25 04                   bcs     L1675                    ; Branch if overflow                            
9057   ED6B C1 BC                   cmpb    #$bc                     ; Check for max                           
9058   ED6D 25 02                   bcs     L1676                    ; Branch if knockSum+tim61Tot0 < $bc                            
9059   ED6F C6 BC       L1675       ldab    #$bc                     ; Use max              
9060   ED71 D7 82       L1676       stab    temp24                   ; temp24 = tim61Tot1 = min(knockSum+tim61Tot0, $bc)
9061   ED73             
9062   ED73                         ;-------------------------------------------------------------
9063   ED73                         ; Compute the new timing newTim61 we are going to apply 
9064   ED73                         ;
9065   ED73                         ; We start with tim61Tot1 computed above but the code below 
9066   ED73                         ; seem to limit the rate of change of the timing by 22.5 
9067   ED73                         ; deg per iteration ($40). 
9068   ED73                         ;-------------------------------------------------------------
9069   ED73 DC 6C                   ldd     timCas0                 ; d = timCas0:timCas1                            
9070   ED75 83 00 2A                subd    #$002a                  ; d = timCas0:timCas1 - $002a                              
9071   ED78 D1 82                   cmpb    temp24                  ;                              
9072   ED7A 24 0A                   bcc     L1677                   ; Branch if timCas0:timCas1 - $002a >= tim61Tot1
9073   ED7C             
9074   ED7C                         ;----------------------------------------------------
9075   ED7C                         ; low(timCas0:timCas1 - $002a) < tim61Tot1
9076   ED7C                         ;----------------------------------------------------
9077   ED7C CB 40                   addb    #$40                    ; b = timCas0:timCas1 - $002a + $40                            
9078   ED7E 25 0E                   bcs     L1678                   ; Branch if overflow                            
9079   ED80 D1 82                   cmpb    temp24                  ;                               
9080   ED82 25 0F                   bcs     L1679                   ; Branch if  timCas0:timCas1 - $002a + $40 < tim61Tot1
9081   ED84 20 08                   bra     L1678                   ; Use tim61Tot1                            
9082   ED86             
9083   ED86                         ;----------------------------------------------------
9084   ED86                         ; low(timCas0:timCas1 - $002a) >= min(knockSum+tim61Tot0, $bc)
9085   ED86                         ;----------------------------------------------------
9086   ED86 C0 40       L1677       subb    #$40                    ; b = timCas0:timCas1 - $002a - $40                           
9087   ED88 25 04                   bcs     L1678                   ; Branch if  timCas0:timCas1 - $002a - $40 < 0                            
9088   ED8A D1 82                   cmpb    temp24                  ;                              
9089   ED8C 24 05                   bcc     L1679                   ; Branch if timCas0:timCas1 - $002a - $40 >= tim61Tot1
9090   ED8E             
9091   ED8E                         ;-------------------
9092   ED8E                         ; Use tim61Tot1 
9093   ED8E                         ;-------------------
9094   ED8E D6 82       L1678       ldab    temp24                  ; Use tim61Tot1                             
9095   ED90 CE 00 2A                ldx     #$002a                  ; reload x = $002a (why, did not change)                             
9096   ED93             
9097   ED93                         ;-----------------------------------------------------------------------------------------------
9098   ED93                         ;
9099   ED93                         ; At this point x = $002a, b = newTim61
9100   ED93                         ;
9101   ED93                         ; Where newTim61 is tim61Tot1 with a limit on its 
9102   ED93                         ; rate of change (21.5deg/iteration max):
9103   ED93                         ;
9104   ED93                         ;    if oldtim61 >= tim61Tot1                    if old timing is more retarded
9105   ED93                         ;           if oldtim61 - $40 < 0                    if oldtim61< 22.5deg (minimum allowed)
9106   ED93                         ;                tim61Tot1                               Use new value
9107   ED93                         ;           else if oldtim61 - $40 >= 0               else if oldtim61 >= 22.5deg (minimum allowed)
9108   ED93                         ;                max(oldtim61 - $40, tim61Tot1)          Use the one with the least amount of change... 
9109   ED93                         ;
9110   ED93                         ;   else if oldtim61 < tim61Tot1                  else if old timing is less retarded
9111   ED93                         ;            if oldtim61 + $40 > 256                 if oldtim61 > 67.5deg (max allowed)  
9112   ED93                         ;                tim61Tot1                               Use new value
9113   ED93                         ;            else if oldtim61 + $40 < 256            else if oldtim61 < 67.5deg (max allowed)
9114   ED93                         ;                min(oldtim61 + $40, tim61Tot1)          Use the one withe the least amount of change...
9115   ED93                         ;
9116   ED93                         ; where tim61Tot1 = min(knockSum+tim61Tot0, $bc)
9117   ED93                         ;       oldtim61 = [timCas0:timCas1] - $002a
9118   ED93                         ;
9119   ED93                         ;-----------------------------------------------------------------------------------------------
9120   ED93                         ;----------------------------------------------------
9121   ED93                         ;
9122   ED93                         ; Update tim61 and [timCas0:timCas1]
9123   ED93                         ;     timCas0:timCas1 = tim61 + $002a
9124   ED93                         ;                 = 256 * (61 - degAdv) / 90 + 42
9125   ED93                         ;                 = 256 * ((61 - degAdv) + 14.77) / 90
9126   ED93                         ;                 = 256 * (75.77 - degAdv) / 90
9127   ED93                         ;
9128   ED93                         ; Since each CAS pulse rising edge is at 75deg BTDC,  
9129   ED93                         ; [timCas0:timCas1] is the timing referenced to  
9130   ED93                         ; the CAS pulse rising edge
9131   ED93                         ;----------------------------------------------------
9132   ED93 3A          L1679       abx                            ; x = tim61 + $002a                            
9133   ED94 DF 6C                   stx     timCas0                ; [timCas0:timCas1] = tim61 + $002a
9134   ED96 D7 7D                   stab    tim61                  ;                              
9135   ED98             
9136   ED98                         ;----------------------------------------------------------------------
9137   ED98                         ; Branch to re-init timing stuff if rpm<505 or key in start position
9138   ED98                         ;----------------------------------------------------------------------
9139   ED98 8F 61 01 14             brclr   casFlags0, #$01, L1680  ; Branch to re-init timing stuff if rpm<505, with hysteresis                              
9140   ED9C 8F 06 40 10             brclr   port3, #$40, L1680      ; Branch to re-init timing stuff if key in start position                               
9141   EDA0             
9142   EDA0                         ;---------------------------------------------------
9143   EDA0                         ; At this point rpm>505 and key is not is start
9144   EDA0                         ;
9145   EDA0                         ; branch to normal code if rpm>505rpm the previous time
9146   EDA0                         ; else update TcasLast0 and re-init timing stuff 
9147   EDA0                         ;---------------------------------------------------
9148   EDA0 87 61 02 0F             brset   casFlags0, #$02, L1681  ; Branch to normal code if rpm>=505rpm the previous time                               
9149   EDA4 BD EC 50                jsr     L1650                   ; d = abs(Tcas - TcasLast0) - Tcas * $30/256
9150   EDA7 24 07                   bcc     L1680                   ; Branch to re-init timing stuff if abs(Tcas - TcasLast0) >= Tcas * $30//256, i.e. abs(Tcas - TcasLast0)/Tcas >= 18.75%
9151   EDA9 DE 80                   ldx     temp22                  ; abs(Tcas - TcasLast0)/Tcas < 18.75%
9152   EDAB DF 64                   stx     TcasLast0               ; Update TcasLast0
9153   EDAD 7E EF 60                jmp     L1710                   ; Jump to re-init timing stuff
9154   EDB0             
9155   EDB0                         ;------------------------------
9156   EDB0                         ; Jump to re-init timing stuff
9157   EDB0                         ;------------------------------
9158   EDB0 7E EF 59    L1680       jmp     L1709                                                 
9159   EDB3             
9160   EDB3                         ;--------------------------------------------
9161   EDB3                         ; Section to perform some additional Tcas 
9162   EDB3                         ; validation when  rpm(Tcas) <= 4801rpm
9163   EDB3                         ;--------------------------------------------
9164   EDB3 8F 61 20 03 L1681       brclr   casFlags0, #$20, L1682  ; Branch if rpm(Tcas) <= 4801rpm
9165   EDB7 7E EE 21                jmp     L1685                   ; Bail to next section
9166   EDBA             
9167   EDBA                         ;---------------------------
9168   EDBA                         ; rpm(Tcas) <= 4801rpm
9169   EDBA                         ;---------------------------
9170   EDBA                         ;---------------------------
9171   EDBA                         ; Check rpm
9172   EDBA                         ;---------------------------
9173   EDBA 96 80       L1682       ldaa    temp22                  ; a = Tcas/256                             
9174   EDBC 81 14                   cmpa    #$14                    ; 1464rpm                            
9175   EDBE 23 0F                   bls     L1683                   ; Branch if rpm(Tcas) >= 1464rpm
9176   EDC0                                                      
9177   EDC0                         ;----------------------------------------------------
9178   EDC0                         ; rpm(Tcas) < 1464
9179   EDC0                         ;----------------------------------------------------
9180   EDC0 DE 6C                   ldx     timCas0                 ; x = timCas0                              
9181   EDC2 8C 00 CA                cpx     #$00ca                  ;                               
9182   EDC5 22 08                   bhi     L1683                   ; branch if timCas0 > $ca (4deg BTDC)                               
9183   EDC7 BD EC 50                jsr     L1650                   ; d = abs(Tcas - TcasLast0) - Tcas * $30/256                             
9184   EDCA 25 03                   bcs     L1683                   ; Branch if result was negative                             
9185   EDCC 7E EF 59                jmp     L1709                   ;                              
9186   EDCF             
9187   EDCF                         ;----------------------------------------------------
9188   EDCF                         ;    timCas0 > $ca (4deg BTDC)
9189   EDCF                         ; or abs(Tcas - TcasLast0) - Tcas * $30/256 < 0
9190   EDCF                         ; or rpm(Tcas) >= 1464
9191   EDCF                         ;----------------------------------------------------
9192   EDCF DC 80       L1683       ldd     temp22                  ; d = Tcas                             
9193   EDD1 81 19                   cmpa    #$19                    ; 1171rpm                       
9194   EDD3 24 4C                   bcc     L1685                   ; Branch if rpm(Tcas) >= 1171rpm
9195   EDD5 04                      lsrd                            ;                             
9196   EDD6 04                      lsrd                            ;                             
9197   EDD7 04                      lsrd                            ;                             
9198   EDD8 04                      lsrd                            ;                             
9199   EDD9 04                      lsrd                            ;                             
9200   EDDA 04                      lsrd                            ; d = Tcas/64                            
9201   EDDB DD 7E                   std     temp20                  ; temp20 = Tcas/64                                   
9202   EDDD             
9203   EDDD DC 64                   ldd     TcasLast0               ; d = TcasLast0                             
9204   EDDF 93 80                   subd    temp22                  ; d = TcasLast0 - Tcas                              
9205   EDE1 24 1F                   bcc     L1684                   ; Branch if result positive (rpm is increasing????)                            
9206   EDE3             
9207   EDE3 DC 80                   ldd     temp22                  ;                              
9208   EDE5 93 64                   subd    TcasLast0               ; d =                              
9209   EDE7 93 7E                   subd    temp20                  ; d = Tcas - TcasLast0 - Tcas/64                                    
9210   EDE9 25 36                   bcs     L1685                   ; Branch if result negative                              
9211   EDEB             
9212   EDEB                         ;------------------------------------------------------------
9213   EDEB                         ; d = Tcas - TcasLast0 - Tcas/64 >= 0
9214   EDEB                         ; Multiply result d = v1:v0 by $80/$80 = 1.0
9215   EDEB                         ;
9216   EDEB                         ; Maybe I miss something but this is useless. My guess
9217   EDEB                         ; is that the multiplicative factor (1.0 in this case) was 
9218   EDEB                         ; configurable but in the end they chose 1.0 which renders this
9219   EDEB                         ; code useless???
9220   EDEB                         ;
9221   EDEB                         ;------------------------------------------------------------
9222   EDEB D7 82                   stab    temp24                  ; save b                              
9223   EDED C6 80                   ldab    #$80                    ; b = $80                             
9224   EDEF 3D                      mul                             ; d = v1*$80                            
9225   EDF0 1A                      xgdx                            ; x = v1*$80                            
9226   EDF1 96 82                   ldaa    temp24                  ; a = v0                              
9227   EDF3 C6 80                   ldab    #$80                    ; b = $80                            
9228   EDF5 3D                      mul                             ; d = v0 * $80                            
9229   EDF6 16                      tab                             ; b = v0 * $80/256                            
9230   EDF7 3A                      abx                             ; x = v1*$80 +  v0 * $80/256 = [v1:v0] * $80/256
9231   EDF8 1A                      xgdx                            ; d = $80/256 * (Tcas - TcasLast0 - Tcas/64)                              
9232   EDF9 05                      asld                            ; d = $80/128 * (Tcas - TcasLast0 - Tcas/64) = Tcas - TcasLast0 - Tcas/64                            
9233   EDFA             
9234   EDFA                         ;---------------------------------------------------------------------------
9235   EDFA                         ; Branch to re-init if Tcas + (Tcas - TcasLast0 - Tcas/64)  > 32767
9236   EDFA                         ;                              (TcasLast0 - Tcas - Tcas/64) > Tcas
9237   EDFA                         ;                                       (TcasLast0 - Tcas ) > Tcas(1+1/64)
9238   EDFA                         ;                                  (TcasLast0 - Tcas )/Tcas > 101.6%
9239   EDFA                         ;
9240   EDFA                         ; We are basically checking if Tcas increased by more than 101.6%
9241   EDFA                         ;---------------------------------------------------------------------------
9242   EDFA 25 30                   bcs     L1687                   ; Branch to re-init if overflow                              
9243   EDFC D3 80                   addd    temp22                  ; d = Tcas + (Tcas - TcasLast0 - Tcas/64) = Tcas(2-1/64) - TcasLast0                             
9244   EDFE 25 2C                   bcs     L1687                   ; Branch to re-init if overflow                             
9245   EE00 20 21                   bra     L1686                   ; Branch to code continuation
9246   EE02                                                       
9247   EE02                         ;----------------------------------------------------
9248   EE02                         ; (TcasLast0 - Tcas) > 0 (rpm is increasing),
9249   EE02                         ;
9250   EE02                         ; Check if  
9251   EE02                         ;               TcasLast0 - Tcas < Tcas/64
9252   EE02                         ;        (TcasLast0 - Tcas)/Tcas < 1/64
9253   EE02                         ;        (TcasLast0 - Tcas)/Tcas < 1.6%
9254   EE02                         ; 
9255   EE02                         ; We are basically checking if Tcas changed by less than 1.6%
9256   EE02                         ; This also correspond to a change of rpm of 1.6%
9257   EE02                         ;----------------------------------------------------
9258   EE02 93 7E       L1684       subd    temp20                  ; d = TcasLast0 - Tcas - Tcas/64                                    
9259   EE04 25 1B                   bcs     L1685                   ; Branch if result negative, i.e. change in Tcas is less than 1/64                            
9260   EE06             
9261   EE06                         ;------------------------------------------------------------
9262   EE06                         ; At this point, rpm increased by more than 1.6%
9263   EE06                         ; and d = TcasLast0 - Tcas - Tcas/64 >= 0
9264   EE06                         ; Multiply result d = v1:v0 by $80/$80 = 1.0
9265   EE06                         ;
9266   EE06                         ; Maybe I miss something but this is useless. My guess
9267   EE06                         ; is that the multiplicative factor (1.0 in this case) was 
9268   EE06                         ; configurable but in the end they chose 1.0 which renders this
9269   EE06                         ; code useless???
9270   EE06                         ;------------------------------------------------------------
9271   EE06 D7 82                   stab    temp24                  ; temp24 = v0
9272   EE08 C6 80                   ldab    #$80                    ; b = $80                           
9273   EE0A 3D                      mul                             ; d = $80 * v1                            
9274   EE0B 1A                      xgdx                            ; x = $80 * v1                           
9275   EE0C 96 82                   ldaa    temp24                  ; a = v0
9276   EE0E C6 80                   ldab    #$80                    ; b = $80                             
9277   EE10 3D                      mul                             ; d = $80 * v0                            
9278   EE11 16                      tab                             ; b = $80/256 * v0                             
9279   EE12 3A                      abx                             ; x = $80 * v1 + $80/256 * v0 = $80/256 * [v1:v0]
9280   EE13 1A                      xgdx                            ; d = $80/256 * (TcasLast0 - Tcas - Tcas/64)
9281   EE14 05                      asld                            ; d = $80/128 * (TcasLast0 - Tcas - Tcas/64) = (TcasLast0 - Tcas - Tcas/64)
9282   EE15                                                      
9283   EE15                         ;-----------------------------------------------------------------------------
9284   EE15                         ; Branch to re-init if  Tcas - (TcasLast0 - Tcas - Tcas/64) < 0???
9285   EE15                         ;                              (TcasLast0 - Tcas - Tcas/64) > Tcas
9286   EE15                         ;                                       (TcasLast0 - Tcas ) > Tcas(1+1/64)
9287   EE15                         ;                                  (TcasLast0 - Tcas )/Tcas > 101.6%
9288   EE15                         ;
9289   EE15                         ; We are basically checking if Tcas increased by more than 101.6%
9290   EE15                         ;-----------------------------------------------------------------------------
9291   EE15 25 15                   bcs     L1687                   ; Branch to re-init if overflow
9292   EE17 DD 7E                   std     temp20                  ; temp20 = TcasLast0 - Tcas - Tcas/64                                   
9293   EE19 DC 80                   ldd     temp22                  ; d = Tcas                             
9294   EE1B 93 7E                   subd    temp20                  ; d = Tcas - (TcasLast0 - Tcas - Tcas/64) =  Tcas(2+1/64) - TcasLast0 
9295   EE1D 25 0D                   bcs     L1687                   ; Branch to re-init if Tcas increased by more than 101.6%
9296   EE1F 20 02                   bra     L1686                   ; Branch to code continuation
9297   EE21             
9298   EE21                         ;----------------------------------------
9299   EE21                         ; Update TcasNew0:TcasNew1
9300   EE21                         ; Check if Tcas is within normal range
9301   EE21                         ; Branch to re-init if not
9302   EE21                         ;----------------------------------------
9303   EE21 DC 80       L1685       ldd     temp22                  ; d = Tcas                              
9304   EE23 DD 66       L1686       std     TcasNew0                ; [TcasNew0:TcasNew1] = Tcas                             
9305   EE25 2B 05                   bmi     L1687                   ; Branch if sign bit set, Tcas at max value, jump to re-init???                             
9306   EE27 1C 01 46                cmpd    #$0146                  ; Compare to min (max of 23006rpm??)                               
9307   EE2A 24 03                   bcc     L1688                   ; Branch if d >= min (rpm < 23006rpm)                              
9308   EE2C 7E EF 59    L1687       jmp     L1709                   ; rpm >= 23006rpm, jump to re-init
9309   EE2F             
9310   EE2F                         ;-------------------------------
9311   EE2F                         ; Tcas is within normal range
9312   EE2F                         ; Update TcasLast0
9313   EE2F                         ;-------------------------------
9314   EE2F DC 80       L1688       ldd     temp22                   ;                              
9315   EE31 DD 64                   std     TcasLast0                ;
9316   EE33                                                                         
9317   EE33                         ;--------------------------------------------------------
9318   EE33                         ; Compute d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256
9319   EE33                         ; We assume timCas0 can only be 0 or 1 
9320   EE33                         ; (Higher values are impossible, huge timing retard...)
9321   EE33                         ;--------------------------------------------------------
9322   EE33 D6 6D                   ldab    timCas1                 ;                              
9323   EE35 96 67                   ldaa    TcasNew1                ;                              
9324   EE37 3D                      mul                             ; d = timCas1 * TcasNew1                            
9325   EE38 97 7E                   staa    temp20                  ;                                    
9326   EE3A 96 6D                   ldaa    timCas1                 ;                              
9327   EE3C D6 66                   ldab    TcasNew0                ;                              
9328   EE3E 3D                      mul                             ; d = timCas1 * TcasNew0                             
9329   EE3F DB 7E                   addb    temp20                  ;                                    
9330   EE41 89 00                   adca    #$00                    ; d = [TcasNew0:TcasNew1] * timCas1/256
9331   EE43 8F 6C FF 02             brclr   timCas0, #$ff, L1689    ; Branch if timCas0=0
9332   EE47 D3 66                   addd    TcasNew0                ; d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256
9333   EE49             
9334   EE49                         ;--------------------------------------------------------------------------------------
9335   EE49                         ; At this point d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256
9336   EE49                         ; Update ignRelTime0:ignRelTime1 (ignition timing measured in time instead of degrees)
9337   EE49                         ;
9338   EE49                         ;       ignRelTime0:ignRelTime1 = [TcasNew0:TcasNew1]/2 * [timCas0:timCas1]/256 - $0012
9339   EE49                         ;
9340   EE49                         ; timCas0/256 is a ratio from 0 to 1 corresponding to 0 to 90deg, since Tcas 
9341   EE49                         ; correspond to 180 deg, Tcas/2 * timsCas0/256 is equal to the "timing time" referenced
9342   EE49                         ; to 75 BTDC
9343   EE49                         ;
9344   EE49                         ; ignRelTime0:ignRelTime1 is therefore the ignition timing (in timer time) 
9345   EE49                         ; referenced to 75BTDC and minus 72us
9346   EE49                         ;--------------------------------------------------------------------------------------
9347   EE49 04          L1689       lsrd                            ; d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256/2
9348   EE4A 83 00 12                subd    #$0012                  ; d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256/2 - $0012
9349   EE4D 24 02                   bcc     L1690                   ; Branch if no underflow                              
9350   EE4F 4F                      clra                            ; use min of 0                            
9351   EE50 5F                      clrb                            ; use min of 0                            
9352   EE51 DD 6E       L1690       std     ignRelTime0             ; [ignRelTime0:ignRelTime1] = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256/2 - $0012
9353   EE53             
9354   EE53                         ;----------------------------------------------------
9355   EE53                         ; Check if the current coil is already energized
9356   EE53                         ;----------------------------------------------------
9357   EE53 96 16                   ldaa    port5                   ;                              
9358   EE55 94 7B                   anda    tdcMask0                ; $02 or $04                              
9359   EE57 27 78                   beq     L1698                   ; Branch if coil is already energized
9360   EE59             
9361   EE59                         ;----------------------------------------------------------------------
9362   EE59                         ; Coil is not yet energized, section to calculate energization time
9363   EE59                         ; and schedule the energization...
9364   EE59                         ;----------------------------------------------------------------------
9365   EE59                         ;-----------------------------------------
9366   EE59                         ; Init enerFlags to $02 since we know we 
9367   EE59                         ; are going to schedule energization
9368   EE59                         ;-----------------------------------------
9369   EE59 86 02                   ldaa    #$02                    ; a = $02                             
9370   EE5B 97 63                   staa    enerFlags               ; enerFlags = $02 
9371   EE5D                                                     
9372   EE5D                         ;-----------------------------------------------------------------------------
9373   EE5D                         ; If rpm(Tcas) > 1775rpm and previously rpm(Tcas) >  1775rpm
9374   EE5D                         ; The we can  use enerLenX0 (already calculated in previous iteration?)
9375   EE5D                         ;-----------------------------------------------------------------------------
9376   EE5D 8F 61 04 06             brclr   casFlags0, #$04, L1691  ; Branch to compute energization time if rpm(Tcas) <=  1775rpm
9377   EE61 DC 72                   ldd     enerLenX0               ; d = [enerLenX0:enerLenX1]
9378   EE63 87 61 08 37             brset   casFlags0, #$08, L1695  ; Branch to use enerLenX0 if rpm(Tcas) >  1775rpm the previous time
9379   EE67             
9380   EE67                         ;--------------------------------------------------------------------------
9381   EE67                         ;    rpm(Tcas) <=  1775rpm
9382   EE67                         ; or rpm(Tcas) >  1775rpm  but  previously rpm(Tcas) <=  1775rpm
9383   EE67                         ; We need to compute the energization time
9384   EE67                         ;
9385   EE67                         ; Check if we can use a short or long energization time??? not sure
9386   EE67                         ; why 
9387   EE67                         ;--------------------------------------------------------------------------
9388   EE67 DC 66       L1691       ldd     TcasNew0                ; d = TcasNew0
9389   EE69 83 11 30                subd    #$1130                  ; d = TcasNew0 - $1130  (18ms????) (check for rollover???)
9390   EE6C 24 09                   bcc     L1692                   ; Branch if no underflow                             
9391   EE6E             
9392   EE6E                         ;------------------------------------------------------------------
9393   EE6E                         ; Underflow, use a shorter fixed value of d = 16*enerLen
9394   EE6E                         ;------------------------------------------------------------------
9395   EE6E 96 89                   ldaa    enerLen                 ; a = enerLen
9396   EE70 5F                      clrb                            ; d = enerLen*256                             
9397   EE71 04                      lsrd                            ;                              
9398   EE72 04                      lsrd                            ;                              
9399   EE73 04                      lsrd                            ;                              
9400   EE74 04                      lsrd                            ; d = enerLen*256/16 = 16*enerLen                              
9401   EE75 20 27                   bra     L1695                   ; Bail                              
9402   EE77             
9403   EE77                         ;----------------------------------------------------------------------------------------------
9404   EE77                         ; TcasNew0 >= $1130, i.e. rpm <= 1704rpm,
9405   EE77                         ;
9406   EE77                         ; Compute  a longer energization time????
9407   EE77                         ;
9408   EE77                         ;   d = 16*enerLen + TcasNew0/2 * (timCas0 - $00ca + $04)/256/2    + (TcasNew0 - $1130)/16
9409   EE77                         ;     = 16*enerLen + TcasNew0/2 * (timCas0 - 71deg + 1.4deg)/256/2 + (TcasNew0 - $1130)/16
9410   EE77                         ;
9411   EE77                         ;----------------------------------------------------------------------------------------------
9412   EE77 04          L1692       lsrd                            ;                              
9413   EE78 04                      lsrd                            ;                              
9414   EE79 04                      lsrd                            ;                              
9415   EE7A 04                      lsrd                            ; d = (TcasNew0 - $1130)/16
9416   EE7B DD 80                   std     temp22                  ; temp22 = (TcasNew0 - $1130)/16
9417   EE7D DC 6C                   ldd     timCas0                 ; d = timCas0                              
9418   EE7F 83 00 CA                subd    #$00ca                  ; d = timCas0 - $00ca (71deg)                              
9419   EE82 23 11                   bls     L1694                   ; Branch if timCas0 <= $00ca (71deg)                             
9420   EE84 CB 04                   addb    #$04                    ; b = timCas0 - $00ca + $04                            
9421   EE86 96 66                   ldaa    TcasNew0                ; a = TcasNew0/256                             
9422   EE88 3D                      mul                             ; d = TcasNew0/256 * (timCas0 - $00ca + $04)                             
9423   EE89 04                      lsrd                            ;                             
9424   EE8A 04                      lsrd                            ; d = TcasNew0/256/4 * (timCas0 - $00ca + $04)                            
9425   EE8B 4D                      tsta                            ;                             
9426   EE8C 27 03                   beq     L1693                   ; Branch if a=0 (result <= $ff)                             
9427   EE8E CC 01 00                ldd     #$0100                  ; Use max of $0100                              
9428   EE91 D3 80       L1693       addd    temp22                  ; d = TcasNew0/256/4 * (timCas0 - $00ca + $04) + (TcasNew0 - $1130)/16
9429   EE93 DD 80                   std     temp22                  ; temp22 = TcasNew0/256/4 * (timCas0 - $00ca + $04) + (TcasNew0 - $1130)/16
9430   EE95 96 89       L1694       ldaa    enerLen                 ; a = enerLen                             
9431   EE97 5F                      clrb                            ; d = enerLen*256                            
9432   EE98 04                      lsrd                            ;                             
9433   EE99 04                      lsrd                            ;                             
9434   EE9A 04                      lsrd                            ;                             
9435   EE9B 04                      lsrd                            ; d = enerLen*256/16                             
9436   EE9C D3 80                   addd    temp22                  ; d = enerLen*16 + (TcasNew0 - $1130)/16 + [TcasNew0/2 * (timCas0 - $00ca + $04)/256/2]
9437   EE9E DD 80       L1695       std     temp22                  ; temp22 = enerLen*16 + (TcasNew0 - $1130)/16 + [TcasNew0/2 * (timCas0 - $00ca + $04)/256/2]
9438   EEA0             
9439   EEA0             
9440   EEA0                         ;---------------------------------------------------------------------------------------
9441   EEA0                         ; At this point temp22 = energizationDuration contains the energization time, 3 cases:
9442   EEA0                         ; 
9443   EEA0                         ;       temp22 = 16*enerLen 
9444   EEA0                         ;    or temp22 = 16*enerLen + (TcasNew0 - $1130)/16 + [if timing >71deg, TcasNew0/2 * (timCas0 - $00ca + $04)/256/2]
9445   EEA0                         ;    or temp22 = enerLenX0:enerLenX1
9446   EEA0                         ;
9447   EEA0                         ;
9448   EEA0                         ; Compute temp22 = the absolute time (timer clock) at 
9449   EEA0                         ; which the coil needs to start being energized
9450   EEA0                         ;---------------------------------------------------------------------------------------
9451   EEA0 DC 6E                   ldd     ignRelTime0             ;                              
9452   EEA2 93 80                   subd    temp22                  ; d = ignRelTime0 - energizationDuration
9453   EEA4 D3 68                   addd    casRiseTime0            ; d = casRiseTime0 + ignRelTime0 - energizationDuration
9454   EEA6 DD 80                   std     temp22                  ; temp22 = casRiseTime0 + ignRelTime0 - energizationDuration
9455   EEA8             
9456   EEA8                         ;---------------------------------------------------------------------
9457   EEA8                         ; Check if the energization time of next coil is sufficientlty far
9458   EEA8                         ; away from the preceeding coil ignition time. If not then use
9459   EEA8                         ; an energization time as close as possible to that ignition time???
9460   EEA8                         ;---------------------------------------------------------------------
9461   EEA8 DC 76                   ldd     ignTime0                ; d = ignTime0:ignTime1                            
9462   EEAA C3 00 FA                addd    #$00fa                  ; d = ignTime0 + $fa (1ms)                            
9463   EEAD 1D 80                   cmpd1   temp22                  ;                             
9464   EEAF 2B 02                   bmi     L1696                   ; Branch if ignTime0 + $fa < energization time, i.e. energization is sufficiently far away from the ignition of the preceeding cylinder, less than 1ms
9465   EEB1 DD 80                   std     temp22                  ; Replace energization time with ignTime0 + $fa 
9466   EEB3             
9467   EEB3                         ;-----------------------------------------
9468   EEB3                         ; Check that coil energization is 
9469   EEB3                         ; sufficiently in the future to be valid
9470   EEB3                         ;-----------------------------------------
9471   EEB3 DC 29       L1696       ldd     t3_clock1               ; d = t3_clock1                                   
9472   EEB5 C3 00 0A                addd    #$000a                  ; d = t3_clock1 + $0a (40usec)                             
9473   EEB8 1A                      xgdx                            ; x = t3_clock1 + $0a                            
9474   EEB9 9C 80                   cpx     temp22                  ;                              
9475   EEBB 2A 02                   bpl     L1697                   ; Branch to use t3_clock1 + $0a if energization is "in the past"
9476   EEBD DE 80                   ldx     temp22                  ; Energization time is valid, use it
9477   EEBF             
9478   EEBF                         ;---------------------------------------------------------------------------
9479   EEBF                         ; Schedule coil energization interrupt time and update enerAbsTime0 with it
9480   EEBF                         ;---------------------------------------------------------------------------
9481   EEBF DF 2B       L1697       stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register
9482   EEC1 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                    
9483   EEC3 DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register
9484   EEC5 DF 74                   stx     enerAbsTime0            ; Save energization interrupt time in memory
9485   EEC7                                                      
9486   EEC7                         ;-------------------------------------------------------------------------
9487   EEC7                         ; Reset the bit for the corresponding cylinder in control register
9488   EEC7                         ; in order to energize the proper coil at the scheduled time
9489   EEC7                         ;
9490   EEC7                         ; Bits in t3_csr0 are offset by 1 bit compared to tdcMask0, so shift 
9491   EEC7                         ; tdcMask0 by 1 bit and then reset that bit in t3_csr0...  
9492   EEC7                         ;-------------------------------------------------------------------------
9493   EEC7 96 7B                   ldaa    tdcMask0                ; a = $02 or $04                             
9494   EEC9 48                      asla                            ; a = $04 or $08 (shift tdcMask0 bit by 1 to have the corresponding bit in t3_csr0)                             
9495   EECA 43                      coma                            ; a = ~($04 or $08)                            
9496   EECB 94 19                   anda    t3_csr0                 ; reset that bit in t3_csr0 (energize coil at scheduled time)                            
9497   EECD 97 19                   staa    t3_csr0                 ; Update t3_csr0 
9498   EECF 20 09                   bra     L1699                   ; Bail to  ignition section                             
9499   EED1             
9500   EED1                         ;---------------------------------------------------------
9501   EED1                         ; Coil is already energized
9502   EED1                         ;
9503   EED1                         ; Flush the first output compare register (write the 
9504   EED1                         ; fartest possible time) since we don't need an interrupt
9505   EED1                         ; to energize it???. Also make sure enerFlags = 1 to indicate 
9506   EED1                         ; coil is energized?
9507   EED1                         ;---------------------------------------------------------
9508   EED1 DE 29       L1698       ldx     t3_clock1               ; x = t3_clock1                                   
9509   EED3 09                      dex                             ; x = t3_clock1-1                            
9510   EED4 DF 2B                   stx     t3_outCmpWr             ; Re-init first output compare register with t3_clock1-1, the fartest time possible
9511   EED6 86 01                   ldaa    #$01                    ; a = 1                            
9512   EED8 97 63                   staa    enerFlags               ; enerFlags = 1                             
9513   EEDA             
9514   EEDA                         ;------------------
9515   EEDA                         ; Ignition section
9516   EEDA                         ;------------------
9517   EEDA                         ;-------------------------------------------------------------------
9518   EEDA                         ; Compute ignTime0 = absolute ignition time (referenced to timer clock)
9519   EEDA                         ;-------------------------------------------------------------------
9520   EEDA DC 6E       L1699       ldd     ignRelTime0             ; d = ignRelTime0:ignRelTime1                              
9521   EEDC D3 68                   addd    casRiseTime0            ; d = ignRelTime0 + casRiseTime0                                       
9522   EEDE DD 76                   std     ignTime0                ; ignTime0:ignTime1 = ignRelTime0:ignRelTime1 + casRiseTime0                             
9523   EEE0             
9524   EEE0                         ;-----------------------------------------------------------
9525   EEE0                         ; Based on ignition timing, check if we are going to schedule
9526   EEE0                         ; ignition at this time or wait for the cas falling edge???
9527   EEE0                         ;-----------------------------------------------------------
9528   EEE0 DE 6C                   ldx     timCas0                 ; x = timCas0:timCas1                             
9529   EEE2 8C 00 CA                cpx     #$00ca                  ; (71deg, 4deg BTDC)                              
9530   EEE5 25 0D                   bcs     L1701                   ; Branch if timCas0:timCas1 < $00ca (71deg, 4deg BTDC)                            
9531   EEE7 87 61 40 04             brset   casFlags0, #$40, L1700  ; Branch if timing adjustment mode is active                                
9532   EEEB 87 61 10 05             brset   casFlags0, #$10, L1701  ; Branch if rpm(Tcas) >  1540rpm
9533   EEEF             
9534   EEEF                         ;--------------------------------------------------------------
9535   EEEF                         ; timCas0:timCas1 >= $00ca (71deg, 4deg BTDC)  
9536   EEEF                         ; and  timing adjustement mode is active or rpm(Tcas)<=1540rpm
9537   EEEF                         ;
9538   EEEF                         ; Set flag and wait for the cas falling edge
9539   EEEF                         ;--------------------------------------------------------------
9540   EEEF 03 62 01    L1700       orm     ignFallFlags, #$01      ; Set flag indicating we need to schedule ignition on the cas falling edge                               
9541   EEF2 20 1D                   bra     L1703                   ; Branch to continue                             
9542   EEF4             
9543   EEF4                         ;---------------------------------------------------------------------
9544   EEF4                         ; At this point, enerFlags=1 if coil is energized or enerFlags=2
9545   EEF4                         ; if energization has been scheduled. In the case where enerFlags=2
9546   EEF4                         ; ignition will be scheduled in the output compare subroutine, i.e.
9547   EEF4                         ; coilFunc, we therefore don't need to schedule it here. In the case
9548   EEF4                         ; where enerFlags=1, we will now schedule ignition...
9549   EEF4                         ;---------------------------------------------------------------------
9550   EEF4 96 63       L1701       ldaa    enerFlags               ; a = enerFlags                             
9551   EEF6 81 02                   cmpa    #$02                    ;                             
9552   EEF8 27 17                   beq     L1703                   ; Branch if enerFlags=2
9553   EEFA             
9554   EEFA                         ;------------------------------------------------------------
9555   EEFA                         ; enerFlags=1, we will now schedule ignition
9556   EEFA                         ; Make sure ignition time is sufficiently in 
9557   EEFA                         ; the future to be valid. If not, use ignition time of "now"
9558   EEFA                         ;------------------------------------------------------------
9559   EEFA DC 29                   ldd     t3_clock1               ; d = t3_clock1                                    
9560   EEFC C3 00 06                addd    #$0006                  ; d = t3_clock1 + $0006 (24usec)                             
9561   EEFF 1A                      xgdx                            ; x = t3_clock1 + $0006                            
9562   EF00 9C 76                   cpx     ignTime0                ;                              
9563   EF02 2A 02                   bpl     L1702                   ; Branch to use t3_clock1 + $0006 if ignTime0 is "in the past"
9564   EF04 DE 76                   ldx     ignTime0                ; ignTime0 is valid, use it
9565   EF06             
9566   EF06                         ;--------------------------------------------------------
9567   EF06                         ; Schedule coil ignition time, set the proper coil bits
9568   EF06                         ; and update ignTime0 with the interrupt time used
9569   EF06                         ;--------------------------------------------------------
9570   EF06 DF 2B       L1702       stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register  
9571   EF08 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                           
9572   EF0A DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register                                    
9573   EF0C 03 19 0C                orm     t3_csr0, #$0c           ; Set both coil bits in t3_csr0, i.e. provoke ignition at scheduled time
9574   EF0F DF 76                   stx     ignTime0                ; Store actual value used                             
9575   EF11             
9576   EF11                         ;---------------------------------------------------------------------------------------
9577   EF11                         ; Common branching point for all code above (except re-init)
9578   EF11                         ;
9579   EF11                         ; Update enerAbsTimeNext0, The absolute coil energization time for the next cylinder???
9580   EF11                         ;---------------------------------------------------------------------------------------
9581   EF11 DC 66       L1703       ldd     TcasNew0                ; d = TcasNew0:TcasNew1                              
9582   EF13 93 72                   subd    enerLenX0               ; d = TcasNew0 - enerLenX0                             
9583   EF15 D3 6E                   addd    ignRelTime0             ; d = TcasNew0 - enerLenX0 + ignRelTime0                            
9584   EF17 D3 68                   addd    casRiseTime0            ; d = TcasNew0 - enerLenX0 + ignRelTime0 + casRiseTime0                                        
9585   EF19 DD 78                   std     enerAbsTimeNext0        ; enerAbsTimeNext0 = casRiseTime0 + TcasNew0 - enerLenX0 + ignRelTime0
9586   EF1B             
9587   EF1B                         ;------------------------------------------------------------------
9588   EF1B                         ; Check enerAbsTimeNext0 to make sure it is not too close
9589   EF1B                         ; to the current cylinder ignition time (1ms min between the two)
9590   EF1B                         ;------------------------------------------------------------------
9591   EF1B DC 76                   ldd     ignTime0                 ; d = ignTime0                             
9592   EF1D C3 00 FA                addd    #$00fa                   ; d = ignTime0 + $fa (1ms)                              
9593   EF20 1D 78                   cmpd1   enerAbsTimeNext0         ;                              
9594   EF22 2B 02                   bmi     L1704                    ; Branch if ignTime0 + $fa < enerAbsTimeNext0, energization time of next cylinder is far enough                              
9595   EF24 DD 78                   std     enerAbsTimeNext0         ; Energization of next cylinder is to close to ignition of current cylinder, use closest possible value, enerAbsTimeNext0 = ignTime0 + $fa                              
9596   EF26             
9597   EF26                         ;----------------------------------------------------------------------------
9598   EF26                         ; Section to update ignFallRelTime0, the ignition time relative to the cas falling edge
9599   EF26                         ; It will be non zero only if it makes sense to schedule ignition on the falling edge
9600   EF26                         ; i.e. timing >= 5degBTDC or timing adjustment mode is active, etc...
9601   EF26                         ;----------------------------------------------------------------------------
9602   EF26 4F          L1704       clra                            ; a = 0                            
9603   EF27 5F                      clrb                            ; b = 0                            
9604   EF28 DD 70                   std     ignFallRelTime0         ; ignFallRelTime0 = 0, in case we don't update it below                              
9605   EF2A DC 6C                   ldd     timCas0                 ; d = timCas0                              
9606   EF2C 83 00 C7                subd    #$00c7                  ; d = timCas0 - $00c7                              
9607   EF2F 23 26                   bls     L1708                   ; Branch to use  ignFallRelTime0=0 if timCas0 <= $00c7 (70deg, 5deg BTDC)
9608   EF31 8F 61 40 05             brclr   casFlags0, #$40, L1705  ; Branch to compute ignFallRelTime0 if timing adjustment mode is not active                               
9609   EF35 CC 00 32                ldd     #$0032                  ; timing adjustment mode is active, use default of d = $0032 (ignFallRelTime0 = 200us, almost on the CAS falling edge, i.e. 5degBTDC)                              
9610   EF38 20 1B                   bra     L1707                   ; Branch to update ignFallRelTime0 
9611   EF3A                                                      
9612   EF3A                         ;---------------------------------------------------------------------------------------------
9613   EF3A                         ; Compute 
9614   EF3A                         ;     [ignFallRelTime0:ignFallRelTime1] = [TcasNew0:TcasNew1]/2 * (timCas0 - $00c7)/256 - $12 
9615   EF3A                         ;                                       = [TcasNew0:TcasNew1]/2 * (timCas0 - 70deg)/256 - $12 
9616   EF3A                         ;
9617   EF3A                         ; [ignFallRelTime0:ignFallRelTime1] is the ignition time (timer clock) 
9618   EF3A                         ; relative to the CAS falling edge (-5 deg BTDC) minus 72us 
9619   EF3A                         ;
9620   EF3A                         ; Imposed minimum value is 1 since ignFallRelTime0=0 indicate we should not use it...
9621   EF3A                         ;---------------------------------------------------------------------------------------------
9622   EF3A D7 82       L1705       stab    temp24                  ; temp24 =  timCas0 - $00c7                              
9623   EF3C 96 67                   ldaa    TcasNew1                ; a = TcasNew1                              
9624   EF3E 3D                      mul                             ; d = TcasNew1 * (timCas0 - $00c7)                            
9625   EF3F D6 82                   ldab    temp24                  ; b = timCas0 - $00c7                              
9626   EF41 97 82                   staa    temp24                  ; temp24 = TcasNew1/256 * (timCas0 - $00c7)                              
9627   EF43 96 66                   ldaa    TcasNew0                ; a = TcasNew0                             
9628   EF45 3D                      mul                             ; d = TcasNew0 * (timCas0 - $00c7)                            
9629   EF46 DB 82                   addb    temp24                  ; d = TcasNew0 * (timCas0 - $00c7) + TcasNew1/256 * (timCas0 - $00c7) =  (timCas0 - $00c7) * (TcasNew0 + TcasNew1/256) = (timCas0 - $00c7)/256 * [TcasNew0:TcasNew1]                              
9630   EF48 89 00                   adca    #$00                    ; propagate carry                            
9631   EF4A 04                      lsrd                            ; d = (timCas0 - $00c7)/256/2 * [TcasNew0:TcasNew1]                             
9632   EF4B 83 00 12                subd    #$0012                  ; d = (timCas0 - $00c7)/256/2 * [TcasNew0:TcasNew1] - $12                              
9633   EF4E 25 02                   bcs     L1706                   ; Branch if underflow                             
9634   EF50 26 03                   bne     L1707                   ; Branch if not null                             
9635   EF52 CC 00 01    L1706       ldd     #$0001                  ; Null or underflow, use min of $0001                              
9636   EF55 DD 70       L1707       std     ignFallRelTime0         ; ignFallRelTime0 = [TcasNew0:TcasNew1]/2 * (timCas0 - $00c7)/256 - $12
9637   EF57 20 3C       L1708       bra     L1713                   ; Branch to normal code continuation
9638   EF59                                            
9639   EF59                         ;--------------------------------------------------------------
9640   EF59                         ; Section to re-init timing stuff in case of detected problems
9641   EF59                         ; 2 different entry points, L1709 and L1710
9642   EF59                         ;--------------------------------------------------------------
9643   EF59                         ;----------------
9644   EF59                         ; Update TcasLast0
9645   EF59                         ;----------------
9646   EF59 DE 80       L1709       ldx     temp22                  ; get Tcas                                           
9647   EF5B DF 64                   stx     TcasLast0               ; store Tcas in TcasLast0                                
9648   EF5D             
9649   EF5D                         ;---------------------------------------------------------
9650   EF5D                         ; Init casFlags0 to 0 or 1 depending where we came from
9651   EF5D                         ;---------------------------------------------------------
9652   EF5D 4F                      clra                            ; a = 1, rpm(Tcas)<505, no timing adjustment mode, etc                             
9653   EF5E 20 02                   bra     L1711                   ;                              
9654   EF60 86 01       L1710       ldaa    #$01                    ; a = 1, rpm(Tcas)>=505, no timing adjustment mode, etc.                            
9655   EF62 97 61       L1711       staa    casFlags0               ; casFlags0 = 0 or 1                              
9656   EF64             
9657   EF64                         ;-------------------------------------------
9658   EF64                         ; Flush both coil output compare registers,
9659   EF64                         ; i.e. write the fartest possible time
9660   EF64                         ;-------------------------------------------
9661   EF64 DE 29                   ldx     t3_clock1               ;                                    
9662   EF66 09                      dex                             ; x = t3_clock1-1, the fartest possible time                             
9663   EF67 DF 2B                   stx     t3_outCmpWr             ; Flush first output compare register                                       
9664   EF69 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                             
9665   EF6B DF 2B                   stx     t3_outCmpWr             ; Flush second output compare register                                      
9666   EF6D             
9667   EF6D                         ;----------------------------------
9668   EF6D                         ; Reset the current coil bit to 0?
9669   EF6D                         ;----------------------------------
9670   EF6D 96 7B                   ldaa    tdcMask0                ; a = $02 or $04
9671   EF6F 48                      asla                            ; a = $04 or $08                                          
9672   EF70 43                      coma                            ; complement, a=~($04 or $08)
9673   EF71 94 19                   anda    t3_csr0                 ; Reset the coil bit to 0, energize coil at next interrupt
9674   EF73 97 19                   staa    t3_csr0                 ; Update t3_csr0                              
9675   EF75             
9676   EF75                         ;--------------------------------------------
9677   EF75                         ; Re-init control register/flush them??? 
9678   EF75                         ; Not sure what this means???
9679   EF75                         ;--------------------------------------------
9680   EF75 86 09                   ldaa    #$09                    ; a = $09                            
9681   EF77 87 7B 02 02             brset   tdcMask0, #$02, L1712   ; branch if tdcMask0 is $02 (current TDC is for cylinder 1 or 4)                              
9682   EF7B 86 06                   ldaa    #$06                    ; a = $06, current TDC is for 2 or 3                           
9683   EF7D 97 1A       L1712       staa    t3_csr1                 ; t3_csr1 = $06 or $09 (00000110 or 00001001)                                   
9684   EF7F 4F                      clra                            ; a = 0                            
9685   EF80 97 1A                   staa    t3_csr1                 ; t3_csr1 = 0                                   
9686   EF82             
9687   EF82                         ;--------------------------
9688   EF82                         ; Re-init timing variables
9689   EF82                         ;--------------------------
9690   EF82 DC 64                   ldd     TcasLast0               ; d = TcasLast0                                
9691   EF84 DD 66                   std     TcasNew0                ; TcasNew0:TcasNew1 = TcasLast0                                 
9692   EF86 4F                      clra                            ;                             
9693   EF87 5F                      clrb                            ; d = 0                             
9694   EF88 DD 70                   std     ignFallRelTime0         ; ignFallRelTime0 = 0                             
9695   EF8A CE 00 CA                ldx     #$00ca                  ; 4deg BTDC                              
9696   EF8D DF 6C                   stx     timCas0                 ; timCas0 = 4deg BTDC                                
9697   EF8F 97 63                   staa    enerFlags               ; enerFlags = 0
9698   EF91 86 A0                   ldaa    #$a0                    ; 4.75deg BTDC                             
9699   EF93 97 7D                   staa    tim61                   ; tim61 = 4.75deg BTDC     
9700   EF95                                                  
9701   EF95                         ;-----------------------
9702   EF95                         ; Normal flow continues
9703   EF95                         ;-----------------------
9704   EF95                         ;--------------------------------------------
9705   EF95                         ; Update TcasLast128 = TcasLast0/128
9706   EF95                         ;--------------------------------------------
9707   EF95 DC 64       L1713       ldd     TcasLast0               ; d = TcasLast0                                
9708   EF97 05                      asld                            ; d = 2 * TcasLast0                            
9709   EF98 24 02                   bcc     L1714                   ; Branch if no overflow                              
9710   EF9A 86 FF                   ldaa    #$ff                    ; use max of $ff                            
9711   EF9C 97 7A       L1714       staa    TcasLast128             ; TcasLast128 =  2 * TcasLast0/256 = TcasLast0/128
9712   EF9E                                          
9713   EF9E                         ;---------------------------------------
9714   EF9E                         ; Re-init t3_csr0 and t1_csr mode bits
9715   EF9E                         ; This also changes the cas edge detection 
9716   EF9E                         ; polarity for the next interrupt
9717   EF9E                         ;---------------------------------------
9718   EF9E 96 19                   ldaa    t3_csr0                 ; a = t3_csr0                             
9719   EFA0 84 0C                   anda    #$0c                    ; Reset 1111 0011, reset all except bits corresponding to coil output
9720   EFA2 8A 52                   oraa    #$52                    ; Set 0101 0010, set normal control bits...                            
9721   EFA4 D6 08                   ldab    t1_csr                  ; b = t1_csr                               
9722   EFA6 C4 19                   andb    #$19                    ; reset 1110 0110                            
9723   EFA8 CA 02                   orab    #$02                    ; set 0000 0010, cas edge detection polarity                            
9724   EFAA DE 0D                   ldx     t1_inCapt               ; x = t1_inCapt (clear input capture flag?)                               
9725   EFAC 97 19                   staa    t3_csr0                 ; t3_csr0  = t3_csr0  & 0000 1100 | 0101 0010                             
9726   EFAE D7 08                   stab    t1_csr                  ; t1_csr = t1_csr & 0001 1001 | 0000 0010                                
9727   EFB0             
9728   EFB0                         ;--------------------------------------
9729   EFB0                         ; Re-init timer T40s_casInt to 1.275sec
9730   EFB0                         ;--------------------------------------
9731   EFB0 86 33                   ldaa    #$33                    ; 1.275sec 
9732   EFB2 97 84                   staa    T40s_casInt             ; T40s_casInt = 1.275sec                                  
9733   EFB4             
9734   EFB4                         ;----------------------
9735   EFB4                         ; Update TcasOld
9736   EFB4                         ;----------------------
9737   EFB4 FC 01 45                ldd     Tcas                    ; d = Tcas                            
9738   EFB7 FD 01 47                std     TcasOld                 ; TcasOld = Tcas                               
9739   EFBA             
9740   EFBA                         ;---------------------------------------------------
9741   EFBA                         ; Compute new Tcas = 1/2 * [TcasLast0:TcasLast1]
9742   EFBA                         ; and limit max value to $7fff (min rpm of 229rpm)
9743   EFBA                         ;---------------------------------------------------
9744   EFBA DC 64                   ldd     TcasLast0               ; d = TcasLast0
9745   EFBC 04                      lsrd                            ; d = TcasLast0/2                            
9746   EFBD 81 80                   cmpa    #$80                    ;                             
9747   EFBF 25 03                   bcs     L1715                   ; Branch if TcasLast0/2/256 < $80, i.e. TcasLast0/2 < $7fff?
9748   EFC1 CC 7F FF                ldd     #$7fff                  ; Use max of $7fff (229rpm)                              
9749   EFC4 FD 01 45    L1715       std     Tcas                    ; store new Tcas for rpm calculation
9750   EFC7             
9751   EFC7                         ;----------------------------------------------------------
9752   EFC7                         ; Update coilHist with input from the coil sensing circuit
9753   EFC7                         ; coilHist basically contains the sensing circuit value 
9754   EFC7                         ; (0 or 1) for the last 8 interrupts, bit 7 being the 
9755   EFC7                         ; oldest and  bit 0 the newest
9756   EFC7                         ;----------------------------------------------------------
9757   EFC7 B6 01 75                ldaa    coilHist                ; a = coilHist                             
9758   EFCA 48                      asla                            ; a = 2*coilHist (shift existing bits left)                            
9759   EFCB 8F 86 04 01             brclr   p4Latched, #$04, L1716  ; Branch if CAS "clock" is clear?
9760   EFCF 4C                      inca                            ; a = 2*coilHist + 1 (set lower bit)
9761   EFD0 B7 01 75    L1716       staa    coilHist                ; coilHist = updated CAS clock history
9762   EFD3             
9763   EFD3                         ;-------------------------------------------------------------
9764   EFD3                         ; If "engine is running and rpm<5000 and 8V<=battRaw<=18V"
9765   EFD3                         ; then check if coilHist lower 4 bits make sense, i.e. should
9766   EFD3                         ; have changed on every CAS interrupt since we have ignition
9767   EFD3                         ; just as often...
9768   EFD3                         ;-------------------------------------------------------------
9769   EFD3 C6 20                   ldab    #$20                      ; preload b = $20 for eventual storage in coilChkCnt
9770   EFD5 8F 85 20 3E             brclr   coilChkFlags, #$20, L1722 ; Bail if not "engine is running and rpm<5000 and 8V<=battRaw<=18V" (we don't perform the test, so reset timer as if no problem...)
9771   EFD9 84 0F                   anda    #$0f                      ; a = coilHist & $0f                              
9772   EFDB 81 05                   cmpa    #$05                      ;                             
9773   EFDD 27 04                   beq     L1717                     ; Branch if coilHist & $0f = $05  (0000 0101)                            
9774   EFDF 81 0A                   cmpa    #$0a                      ;                              
9775   EFE1 26 08                   bne     L1718                     ; Branch if coilHist & $0f != $0a  (0000 1010)                            
9776   EFE3             
9777   EFE3                         ;------------------------------------------------------------------
9778   EFE3                         ; coilHist & $0f = $05 or $0a (0101 or 1010), this is the normal
9779   EFE3                         ; alternating pattern of the check circuit, everything is therefore OK, 
9780   EFE3                         ; reset error bit and allow all 4 injectors to be used
9781   EFE3                         ;------------------------------------------------------------------
9782   EFE3 02 85 7F    L1717       andm    coilChkFlags, #$7f      ; Reset error flag                                
9783   EFE6 03 85 0F                orm     coilChkFlags, #$0f      ; Set all 4 lower bits to 1, meaning all 4 injectors can be used
9784   EFE9 20 2C                   bra     L1722                   ; Bail                              
9785   EFEB             
9786   EFEB                         ;---------------------------------------------------------------
9787   EFEB                         ; coilHist & $0f != $05 or $0a
9788   EFEB                         ; That means some ignition signal were not properly generated.
9789   EFEB                         ;
9790   EFEB                         ; Investigate a little more the bit pattern and then decide
9791   EFEB                         ; if we need to deactivate some injectors.
9792   EFEB                         ; Did not attempt to understand this yet???
9793   EFEB                         ;---------------------------------------------------------------
9794   EFEB 44          L1718       lsra                            ; 
9795   EFEC 44                      lsra                            ; a = (coilHist & $0f)/4                             
9796   EFED B8 01 75                eora    coilHist                ; a = (coilHist & $0f)/4 eor coilHist                            
9797   EFF0 44                      lsra                            ; shift lower bit in carry                             
9798   EFF1 24 24                   bcc     L1722                   ; Branch if lower bit 0, no error to flag yet??                           
9799   EFF3 B6 01 75                ldaa    coilHist                ; a = coilHist                             
9800   EFF6 44                      lsra                            ; a = coilHist/2                            
9801   EFF7 B8 01 75                eora    coilHist                ; a = coilHist/2 eor coilHist                             
9802   EFFA 44                      lsra                            ; shift lower bit in carry                            
9803   EFFB 25 0F                   bcs     L1720                   ; Branch if lower bit 1, flag an error but dont deactivate injectors                             
9804   EFFD             
9805   EFFD                         ;--------------------------------------------------------------------------------
9806   EFFD                         ; Select injectors that are OK to use depending on whether TDC is active or not
9807   EFFD                         ;--------------------------------------------------------------------------------
9808   EFFD C6 05                   ldab    #$05                   ; Set bits corresponding to injectors 1 and 4                              
9809   EFFF 8F 06 04 02             brclr   port3, #$04, L1719     ; Branch if TDC signal is active
9810   F003 C6 0A                   ldab    #$0a                   ; Set bits corresponding to injectors 3 and 2                              
9811   F005             
9812   F005                         ;------------------------------------------------------------
9813   F005                         ; Update coilChkFlags with injectors that are ok to use
9814   F005                         ;------------------------------------------------------------
9815   F005 96 85       L1719       ldaa    coilChkFlags            ; a = coilChkFlags                              
9816   F007 84 F0                   anda    #$f0                    ; reset 4 lower bits
9817   F009 1B                      aba                             ; Set the injectors that are OK to use in lower 4 bits
9818   F00A 97 85                   staa    coilChkFlags            ; Update coilChkFlags    
9819   F00C                                                  
9820   F00C                         ;---------------------------------------------------------
9821   F00C                         ; We have a missing ignition signal, decrement coilChkCnt 
9822   F00C                         ; (min of 0) and set coilChkFlags.7 error flag if it reached 0
9823   F00C                         ; That would mean we missed $20 ignition signals...
9824   F00C                         ;---------------------------------------------------------
9825   F00C F6 01 74    L1720       ldab    coilChkCnt              ; b = coilChkCnt                              
9826   F00F 27 03                   beq     L1721                   ; Branch if coilChkCnt=0                             
9827   F011 5A                      decb                            ;                             
9828   F012 20 03                   bra     L1722                   ;
9829   F014 03 85 80    L1721       orm     coilChkFlags, #$80      ; Set error flag
9830   F017             
9831   F017                         ;---------------------------------------------------
9832   F017                         ; Store new coilChkCnt value, $20 loaded way above 
9833   F017                         ; or decremented value just calculated
9834   F017                         ;---------------------------------------------------
9835   F017 F7 01 74    L1722       stab    coilChkCnt              ;                                                                                                     
9836   F01A             
9837   F01A                         ;----------------------------------------------------
9838   F01A                         ; Section to update knockSum from the knock sensor
9839   F01A                         ;----------------------------------------------------
9840   F01A                         ;-----------------------------------------------
9841   F01A                         ; Skip section (use knockSum = 0 ) if car has been 
9842   F01A                         ; running less than 1 sec
9843   F01A                         ;-----------------------------------------------
9844   F01A 8F 53 40 4D             brclr   knockFlags, #$40, L1731 ; Branch to use knockSum = 0 if engine has been running less than 1 sec?
9845   F01E             
9846   F01E                         ;---------------------------------------
9847   F01E                         ; b = rawKnock value from the ADC port
9848   F01E                         ;---------------------------------------
9849   F01E 86 0E                   ldaa    #$0e                    ; A = knock port number 6 with start bit set = $06 | $08                                                                                
9850   F020 BD EC 17                jsr     readAdc2                ; b = rawKnock from adc port
9851   F023             
9852   F023                         ;-----------------------------------------
9853   F023                         ; Increment knockTimer up to max of 255
9854   F023                         ;-----------------------------------------
9855   F023 B6 01 77                ldaa    knockTimer              ; Read current counter value                                                                          
9856   F026 4C                      inca                            ; increment some knock related counter                                                               
9857   F027 26 02                   bne     L1723                   ; Branch if no overflow
9858   F029 86 FF                   ldaa    #$ff                    ; overflow, use max
9859   F02B B7 01 77    L1723       staa    knockTimer              ; store new counter value                                                              
9860   F02E             
9861   F02E                         ;--------------------------------------------------
9862   F02E                         ; Decide if we are going to use rawKnock directly
9863   F02E                         ;--------------------------------------------------
9864   F02E C1 0C                   cmpb    #$0c                    ; 
9865   F030 25 0C                   bcs     L1725                   ; branch to use it if rawKnock < $0c                                                                                     
9866   F032 C1 24                   cmpb    #$24                    ; 
9867   F034 22 08                   bhi     L1725                   ; branch to use it if rawKnock > $24
9868   F036             
9869   F036                         ;----------------------------------------------------------------
9870   F036                         ; $0c <= rawKnock <= $24, this is a zone where we don't count
9871   F036                         ; rawKnock except if  knockTimer > $78. knockTimer is however 
9872   F036                         ; reset to 0 which means it only applies to the first time 
9873   F036                         ; that happens. Basically, we ignore rawKnock when it is 
9874   F036                         ; between $0c and $24???
9875   F036                         ;----------------------------------------------------------------
9876   F036 81 78                   cmpa    #$78                    ;                                                                                     
9877   F038 22 01                   bhi     L1724                   ; Branch if knockTimer > $78 
9878   F03A             
9879   F03A                         ;--------------------------------------------
9880   F03A                         ; $0c <= rawKnock <= $24 and knockTimer<78
9881   F03A                         ;
9882   F03A                         ; Use rawKnock=0 and reset knockTimer
9883   F03A                         ;--------------------------------------------
9884   F03A 5F                      clrb                            ; b = 0                                                                                    
9885   F03B 7F 01 77    L1724       clr     knockTimer              ; reset knockTimer                                                                                     
9886   F03E             
9887   F03E                         ;----------------------------------
9888   F03E                         ; Update knockSensor from rawKnock
9889   F03E                         ;----------------------------------
9890   F03E D7 D1       L1725       stab    knockSensor             ; knockSensor = rawKnock (processed port value)                                                      
9891   F040             
9892   F040                         ;----------------------------------
9893   F040                         ; Compute a = (rawKnock-4)/8
9894   F040                         ;----------------------------------
9895   F040 96 D1                   ldaa    knockSensor             ; a = rawKnock
9896   F042 80 04                   suba    #$04                    ; rawKnock -= 4                                                         
9897   F044 24 01                   bcc     L1726                   ; Branch rawKnock-4 >= 0
9898   F046 4F                      clra                            ; Use min of 0    
9899   F047 44          L1726       lsra                            ;                                                                                     
9900   F048 44                      lsra                            ;                                                                                     
9901   F049 44                      lsra                            ; a = (rawKnock-4)/8                                                           
9902   F04A             
9903   F04A                         ;------------------------------------------------- 
9904   F04A                         ; Compute a = (rawKnock-4)/8/2 if under low load
9905   F04A                         ;------------------------------------------------- 
9906   F04A 87 53 80 03             brset   knockFlags, #$80, L1727 ; branch if airVol>$49  (high load)
9907   F04E 44                      lsra                            ; knock = knock/2 under low load                                                      
9908   F04F 20 06                   bra     L1728                   ;                                                                                      
9909   F051             
9910   F051                         ;------------------------------------------------- 
9911   F051                         ; Check for max value of 7 under high load?
9912   F051                         ;------------------------------------------------- 
9913   F051 81 07       L1727       cmpa    #$07                    ;                                                                                                 
9914   F053 25 02                   bcs     L1728                   ; branch if (rawKnock-4)/8 < 7                                                                              
9915   F055 86 07                   ldaa    #$07                    ; Use max of 7                                                                         
9916   F057             
9917   F057                         ;-----------------------------------------------------------
9918   F057                         ; Add min((rawKnock-4)/8,7) or (rawKnock-4)/8/2 to knockSum
9919   F057                         ; and check for max of 43
9920   F057                         ;-----------------------------------------------------------
9921   F057 9B 8B       L1728       adda    knockSum                ; a = knockSum + min((rawKnock-4)/8,7) or (rawKnock-4)/8/2
9922   F059 25 04                   bcs     L1729                   ; Branch if overflow                                                                                                 
9923   F05B 81 2B                   cmpa    #$2b                    ; No overflow, check for max of 43
9924   F05D 23 02                   bls     L1730                   ; Branch if new knockSum <=43                                                                         
9925   F05F 86 2B       L1729       ldaa    #$2b                    ; Use max of 43 
9926   F061                                                                                                            
9927   F061                         ;-------------------------------------------------------
9928   F061                         ; If knock sensor not working, use knockSum=$09 under 
9929   F061                         ; high load and knockSum=$00 under low load
9930   F061                         ;-------------------------------------------------------
9931   F061 8F D6 20 07 L1730       brclr   state2, #$20, L1732     ; Branch if knock sensor working properly?                                                                                                   
9932   F065 86 09                   ldaa    #$09                    ; a = $09                                                                                                
9933   F067 87 53 80 01             brset   knockFlags, #$80, L1732 ; Branch if airVol>$49                                                                                                  
9934   F06B 4F          L1731       clra                            ;                                                                                                 
9935   F06C             
9936   F06C                         ;-------------------------------------------------------------
9937   F06C                         ; Store new knockSum and reset knock sensor physical filter
9938   F06C                         ;-------------------------------------------------------------
9939   F06C 97 8B       L1732       staa    knockSum                ; Store new knock sum                                                                                 
9940   F06E 03 2F 01                orm     port6, #$01             ; Reset knock sensor physical filter?
9941   F071             
9942   F071             
9943   F071                         ;----------------------------------------------
9944   F071                         ; Update maxAdv for E931 in order to slowly
9945   F071                         ; remove its effect with time
9946   F071                         ;----------------------------------------------
9947   F071             #ifdef E931
9948   F071 96 F5                   ldaa    T_maxAdv                ;                               
9949   F073 27 03                   beq     Mf078                   ; Branch if timer T_maxAdv expired                              
9950   F075 4A                      deca                            ; Decrement timer                             
9951   F076 26 09                   bne     Mf081                   ; Bail if not expired                              
9952   F078             
9953   F078                         ;---------------------------------------------------------
9954   F078                         ; Timer expired increase maxAdv by 1 (increase 
9955   F078                         ; timing advance limit up to $80) and restart timer to 1
9956   F078                         ;---------------------------------------------------------
9957   F078 D6 F6       Mf078       ldab    maxAdv                  ;                               
9958   F07A 2B 05                   bmi     Mf081                   ; Branch if maxAdv>=$80 (no limit to advance)                                
9959   F07C 7C 00 F6                inc     maxAdv                  ;                               
9960   F07F 86 01                   ldaa    #$01                    ; re-init timer t0 1 (we do it every loop)                              
9961   F081 97 F5       Mf081       staa    T_maxAdv                ;                               
9962   F083             #endif
9963   F083             
9964   F083                         ;------------------------------------------
9965   F083                         ; Set flag masCasFlags.1 indicating to the 
9966   F083                         ; main loop that it can update rpmX4Filt
9967   F083                         ;------------------------------------------
9968   F083 03 9E 01                orm     masCasFlags, #$01       ;                                
9969   F086             
9970   F086                         ;---------------------------------------------------------------------
9971   F086                         ; Section to update o2Fbk from o2 sensor during closed loop operation
9972   F086                         ;---------------------------------------------------------------------
9973   F086 8F E6 80 24             brclr   state1, #$80, L1735     ; Bail  if open loop mode                                
9974   F08A 4F                      clra                            ; a = 0                            
9975   F08B D6 CE                   ldab    o2Raw                   ; b = o2Raw
9976   F08D C1 1A                   cmpb    #$1a                    ;                                                     
9977   F08F 24 0D                   bcc     L1733                   ; branch if o2Raw >= 0.507V                                 
9978   F091             
9979   F091                         ;-----------------------------------------
9980   F091                         ; o2Raw < 0.507V (lean) 
9981   F091                         ; increase o2Fbk = o2Fbk + 8 * o2Fbk_inc
9982   F091                         ;-----------------------------------------
9983   F091 D6 EC                   ldab    o2Fbk_inc               ; d = o2Fbk_inc (a cleared earlier)                             
9984   F093 05                      asld                            ;                             
9985   F094 05                      asld                            ; d = 8 * o2Fbk_inc                             
9986   F095 D3 E9                   addd    o2Fbk                   ; d = 8 * o2Fbk_inc + o2Fbk
9987   F097 24 13                   bcc     L1734                   ; Branch if no overflow                             
9988   F099 CC FF FF                ldd     #$ffff                  ; Use max of $ffff                              
9989   F09C 20 0E                   bra     L1734                   ; Branch to store
9990   F09E             
9991   F09E                         ;-------------------------------------
9992   F09E                         ; o2Raw >= 0.507V (rich) 
9993   F09E                         ; decrease o2Fbk = o2Fbk - 4 * o2Fbk_dec
9994   F09E                         ;-------------------------------------
9995   F09E D6 EB       L1733       ldab    o2Fbk_dec               ; d = o2Fbk_dec (a cleared earlier)                              
9996   F0A0 05                      asld                            ;                             
9997   F0A1 05                      asld                            ; d = 4 * o2Fbk_inc                            
9998   F0A2 DD 5E                   std     temp8                   ;                               
9999   F0A4 DC E9                   ldd     o2Fbk                   ;                              
10000  F0A6 93 5E                   subd    temp8                   ; d = o2Fbk - 4 * o2Fbk_dec                               
10001  F0A8 24 02                   bcc     L1734                   ; Branch if no underflow                             
10002  F0AA 4F                      clra                            ;                             
10003  F0AB 5F                      clrb                            ; Underflow, use min of $0000                            
10004  F0AC             
10005  F0AC                         ;--------------
10006  F0AC                         ; Update o2Fbk 
10007  F0AC                         ;--------------
10008  F0AC DD E9       L1734       std     o2Fbk                   ; Store new o2Fbk
10009  F0AE             
10010  F0AE                         ;-------------------------------------
10011  F0AE                         ; Return from interrupt
10012  F0AE                         ;-------------------------------------
10013  F0AE 3B          L1735       rti                             ;                             
10014  F0AF             
10015  F0AF             
10016  F0AF             
10017  F0AF             ;******************************************************************
10018  F0AF             ;
10019  F0AF             ;
10020  F0AF             ; Section processing the CAS interrupt on the falling edge
10021  F0AF             ;
10022  F0AF             ;
10023  F0AF             ;******************************************************************
10024  F0AF                         ;------------------------------------------------------------
10025  F0AF                         ; Check which of t3_clock1 or t3_clock2 should be used?
10026  F0AF                         ; Not sure what that bit means???????????
10027  F0AF                         ;------------------------------------------------------------
10028  F0AF 87 19 10 03 casFallProc brset   t3_csr0, #$10, L1737    ; Branch if we should use t3_clock2, nothing to do, that's what we assumed above (from where we jumped to casFallProc...)
10029  F0B3             
10030  F0B3                         ;-------------------------------------------------------------------------
10031  F0B3                         ; t3_clock1 should be used, our assumption that it was
10032  F0B3                         ; t3_clock2 was wrong, update d and  temp20 with the correct values
10033  F0B3                         ;-------------------------------------------------------------------------
10034  F0B3 1A                      xgdx                            ; d = t3_clock1
10035  F0B4 DD 7E                   std     temp20                  ; temp20 = t3_clock1
10036  F0B6                                                                       
10037  F0B6                         ;------------------------------------------------
10038  F0B6                         ; Branch to rest of code if the time between CAS
10039  F0B6                         ; interrupts makes sense (rpm is not too high...)
10040  F0B6                         ;
10041  F0B6                         ; The time measured here is the cas pulse width 
10042  F0B6                         ; since it is measured from rising to falling edge
10043  F0B6                         ; Since the cas pulse is 70deg then the 0.5ms below
10044  F0B6                         ; correspond to 360/70*0.5ms = 2.57ms per rotation which
10045  F0B6                         ; correspond to 23333rpm???
10046  F0B6                         ;------------------------------------------------
10047  F0B6 93 68       L1737       subd    casRiseTime0            ; d = (t3_clock1 or t3_clock2) - casRiseTime0
10048  F0B8 1C 00 7D                cmpd    #$007d                  ; 0.5ms at 250KHz                               
10049  F0BB 24 07                   bcc     L1738                   ; Branch if (t3_clock1 or  t3_clock2 - casRiseTime0) >= $007d
10050  F0BD             
10051  F0BD                         ;------------------------------------------------
10052  F0BD                         ; RPM seems too high to make sense, check if it is
10053  F0BD                         ; not instead because RPM is so low that the 16 bit 
10054  F0BD                         ; counter subtraction above rolled-over.
10055  F0BD                         ;
10056  F0BD                         ; Branch to rest of code if the T200_casRise timer shows
10057  F0BD                         ; that rpm is very low... 
10058  F0BD                         ;------------------------------------------------
10059  F0BD 96 BF                   ldaa    T200_casRise                                                 
10060  F0BF 81 0E                   cmpa    #$0e                    ; 70ms at 200Hz                             
10061  F0C1 25 01                   bcs     L1738                   ; branch if T200_casRise<70ms, T200_casRise is init with 265ms, the time between interrupt is very high                                                                                                                            
10062  F0C3             
10063  F0C3                         ;-------------------------------------------------------------
10064  F0C3                         ; Time between interrupts doesn't make sense, just ignore it
10065  F0C3                         ; return from interrupt
10066  F0C3                         ;-------------------------------------------------------------
10067  F0C3 3B                      rti                                                          
10068  F0C4             
10069  F0C4                         ;---------------------------------------------------------------
10070  F0C4                         ; Update temp22:temp23 = Tcas measured on the cas falling edge
10071  F0C4                         ;---------------------------------------------------------------
10072  F0C4 DC 7E       L1738       ldd     temp20                  ; d = temp20
10073  F0C6 93 6A                   subd    casFallTime0            ; d = temp20-casFallTime0(old counter) = Tcas = 250000/2/(rpm/60)                                      
10074  F0C8 DD 80                   std     temp22                  ; temp22:temp23 = Tcas (temp22 is not dedicated for that purpose...)                                 
10075  F0CA             
10076  F0CA                         ;---------------------------------
10077  F0CA                         ; Validate temp22:temp23 = Tcas
10078  F0CA                         ;---------------------------------
10079  F0CA D6 C0                   ldab    T200_casFall            ;                               
10080  F0CC 27 07                   beq     L1739                   ; Branch if timer expired (very long Tcas...)                             
10081  F0CE 4D                      tsta                            ;                             
10082  F0CF 2B 09                   bmi     L1740                   ; Bail if Tcas/256 >= 128 (rpm<229)                              
10083  F0D1 C1 0E                   cmpb    #$0e                    ;                             
10084  F0D3 22 05                   bhi     L1740                   ; Branch if T200_casRise > $0e (70ms)                             
10085  F0D5 CC FF FF    L1739       ldd     #$ffff                  ; Use max Tcas                               
10086  F0D8 DD 80                   std     temp22                  ; store Tcas
10087  F0DA                                           
10088  F0DA                         ;--------------------------------------------------------------------
10089  F0DA                         ; At this point, we will check the CAS signal to make sure it stays
10090  F0DA                         ; reset until 56us after the start of the interrupt. I guess this might
10091  F0DA                         ; be to filter eventual glitches in the CAS signal
10092  F0DA                         ;--------------------------------------------------------------------
10093  F0DA DC 7E       L1740       ldd     temp20                  ;                                    
10094  F0DC C3 00 0E                addd    #$000e                  ; d = StartInterruptTime + $0e (56us)                               
10095  F0DF 87 16 01 01 L1741       brset   port5, #$01, L1742      ; Branch as long as CAS bit is set (CAS signal is reset)
10096  F0E3 3B                      rti                             ; CAS bit was reset, Bail of interrupt
10097  F0E4 1D 29       L1742       cmpd1   t3_clock1               ; Compare current time to time stored when we started the interrupt processing                                 
10098  F0E6 2A F7                   bpl     L1741                   ; Loop if t3_clock1 < (temp20 + $0e (56us)), i.e. if its been less than 56us since interrupt was called
10099  F0E8             
10100  F0E8             
10101  F0E8             
10102  F0E8             
10103  F0E8             ;******************************************************************
10104  F0E8             ;
10105  F0E8             ;
10106  F0E8             ; Interrupt was valid
10107  F0E8             ; Proceed with processing stuff on the CAS falling edge
10108  F0E8             ;
10109  F0E8             ;
10110  F0E8             ;******************************************************************
10111  F0E8                         ;---------------------------------------------------------
10112  F0E8                         ; restart T200_casRise timer to 175ms
10113  F0E8                         ;---------------------------------------------------------
10114  F0E8 86 35                   ldaa    #$35                    ; 265ms                             
10115  F0EA 97 C0                   staa    T200_casFall            ; T200_casFall = 265ms                               
10116  F0EC             
10117  F0EC                         ;-----------------------
10118  F0EC                         ; Update casFallTime0 
10119  F0EC                         ;-----------------------
10120  F0EC DC 7E                   ldd     temp20                  ;                                     
10121  F0EE DD 6A                   std     casFallTime0            ; casFallTime0 = temp20                             
10122  F0F0             
10123  F0F0                         ;---------------------------------------------------------------------
10124  F0F0                         ; Branch to re-init if T40s_casInt expired or if Tcas/256 >= $80
10125  F0F0                         ;
10126  F0F0                         ; i.e. no cas rising edge interrupt received 
10127  F0F0                         ; in the last 1.275sec or rpm is very low
10128  F0F0                         ;---------------------------------------------------------------------
10129  F0F0 8F 84 FF 04             brclr   T40s_casInt, #$ff, L1743 ; Branch if T40s_casInt expired                                    
10130  F0F4 96 80                   ldaa    temp22                   ; a = Tcas/256                             
10131  F0F6 2A 11                   bpl     L1744                    ; Branch if a < $80                             
10132  F0F8             
10133  F0F8                         ;---------------------------------------------------------
10134  F0F8                         ; T40s_casInt expired or Tcas/256 >= $80 (too big)
10135  F0F8                         ; Re-init casFlags0, enerFlags and control registers 
10136  F0F8                         ; and jump over the entire ignition section
10137  F0F8                         ;---------------------------------------------------------
10138  F0F8 4F          L1743       clra                            ; a = 0                            
10139  F0F9 97 61                   staa    casFlags0               ; casFlags0 = 0                             
10140  F0FB 97 63                   staa    enerFlags               ; enerFlags = 0                              
10141  F0FD 03 19 0C                orm     t3_csr0, #$0c           ; set 0000 1100, disable both coils                               
10142  F100 03 1A 0A                orm     t3_csr1, #$0a           ; set 0000 1010, ???                                     
10143  F103 02 1A F0                andm    t3_csr1, #$f0           ; reset 0000 1111 (reset the bit we just set...)                                     
10144  F106 7E F2 56                jmp     L1765                   ; Bail, jump over ignition section                             
10145  F109                                                         
10146  F109                         ;---------------------------------------------------------
10147  F109                         ; Section to process ignFallRelTime0 when it is non-null
10148  F109                         ; Firs check just that...
10149  F109                         ;---------------------------------------------------------
10150  F109 DC 70       L1744       ldd     ignFallRelTime0         ; d = ignFallRelTime0:ignFallRelTime1                              
10151  F10B 26 03                   bne     L1745                   ; Branch if ignFallRelTime0:ignFallRelTime1 != 0                             
10152  F10D 7E F1 AA                jmp     L1754                   ; Bail since ignFallRelTime0=0
10153  F110             
10154  F110                         ;----------------------------------------------------------
10155  F110                         ; At this point ignFallRelTime0 != 0
10156  F110                         ; When ignFallRelTime0:ignFallRelTime1 is not  0, it 
10157  F110                         ; means we determined on the cas rising edge that ignition
10158  F110                         ; would be scheduled on the cas falling edge, which we are in
10159  F110                         ; now... But coil need to be energized first...
10160  F110                         ;
10161  F110                         ; Check if current coil is already energized
10162  F110                         ;----------------------------------------------------------
10163  F110 96 16       L1745       ldaa    port5                   ; a = port5                             
10164  F112 94 7B                   anda    tdcMask0                ; a = port5 & tdcMask0  ($02 or $04)                            
10165  F114 27 57                   beq     L1750                   ; Branch if coil is energized
10166  F116             
10167  F116                         ;---------------------------------------------
10168  F116                         ; Currrent coil is not yet energized
10169  F116                         ;---------------------------------------------
10170  F116                         ;----------------------------------------------------------------------------
10171  F116                         ; Check if energization has been scheduled?, this would mean energization
10172  F116                         ; will occur soon, or should have occured by now
10173  F116                         ;----------------------------------------------------------------------------
10174  F116 87 63 02 03             brset   enerFlags, #$02, L1746  ; Branch if enerFlags=2, energization was scheduled
10175  F11A 7E F1 AA                jmp     L1754                   ; Bail, not sure what this would mean, probably that ignition already occured and there is nothing left to do??????
10176  F11D             
10177  F11D                         ;--------------------------------------------------------------
10178  F11D                         ; At this point 
10179  F11D                         ; -Coil is not yet energized 
10180  F11D                         ; -We determined on the cas rising edge that ignition would be
10181  F11D                         ;  schedule on the cas falling edge (thats now...)
10182  F11D                         ; -enerFlags indicates energization was scheduled from 
10183  F11D                         ;  the cas rising edge and should already have occured 
10184  F11D                         ;  or will occur very soon??? Just reschedule energization...
10185  F11D                         ;--------------------------------------------------------------
10186  F11D                         ;----------------------------------------------------------------------------------
10187  F11D                         ; Compute enerAbsTime0:
10188  F11D                         ;
10189  F11D                         ;    enerAbsTime0 = casFallTime0 + ignFallRelTime0 - enerLenX0 - TcasLast128
10190  F11D                         ;
10191  F11D                         ; enerAbsTime0 is the coil energization absolute time (timer clock) 
10192  F11D                         ; (calculated from the CAS falling edge in this case)
10193  F11D                         ;----------------------------------------------------------------------------------
10194  F11D DC 70       L1746       ldd     ignFallRelTime0       ; d = ignFallRelTime0                             
10195  F11F 93 72                   subd    enerLenX0             ; d = ignFallRelTime0 - enerLenX0                             
10196  F121 D0 7A                   subb    TcasLast128           ; d = ignFallRelTime0 - enerLenX0 - TcasLast128                             
10197  F123 82 00                   sbca    #$00                  ; propagate carry                             
10198  F125 D3 6A                   addd    casFallTime0          ; d = ignFallRelTime0 - enerLenX0 - TcasLast128 + casFallTime0                              
10199  F127 DD 74                   std     enerAbsTime0          ; enerAbsTime0 = casFallTime0 + ignFallRelTime0 - enerLenX0 - TcasLast128
10200  F129             
10201  F129                         ;---------------------------------------------------------------------------
10202  F129                         ; Reset the proper coil bit in t3_csr0, i.e. energize coil at next interrupt
10203  F129                         ;---------------------------------------------------------------------------
10204  F129 96 7B                   ldaa    tdcMask0                ; a = $02 or $04                             
10205  F12B 48                      asla                            ; a = $04 or $08
10206  F12C 43                      coma                            ; a = ~($04 or $08)                            
10207  F12D 94 19                   anda    t3_csr0                 ; Reset that coil bit, i.e. have the coil energized the next time
10208  F12F 97 19                   staa    t3_csr0                 ; Update t3_csr0                              
10209  F131             
10210  F131                         ;------------------------------------------------------------------------------
10211  F131                         ; Check if enerAbsTime0 that we just calculated is sufficiently in the future
10212  F131                         ;------------------------------------------------------------------------------
10213  F131 DC 29                   ldd     t3_clock1               ; d = t3_clock1                                   
10214  F133 C3 00 06                addd    #$0006                  ; d = t3_clock1 + $06 (24us)                             
10215  F136 1A                      xgdx                            ; x = t3_clock1 + $06                            
10216  F137 9C 74                   cpx     enerAbsTime0            ;                              
10217  F139 2B 0A                   bmi     L1747                   ; Branch to use enerAbsTime0 if it is sufficiently "in the future", i.e. t3_clock1 + $06 < enerAbsTime0
10218  F13B             
10219  F13B                         ;------------------------------------------------------------------------
10220  F13B                         ; enerAbsTime0 is not sufficiently in the future, 
10221  F13B                         ;
10222  F13B                         ; schedule energization for "now", i.e. t3_clock1 + $06 
10223  F13B                         ; this is 24usec (a few cycles) I assume the output compare will
10224  F13B                         ; therefore happen before we schedule the ignition later in the code 
10225  F13B                         ; below... Note that only the first output compare register is updated.
10226  F13B                         ; Also update enerAbsTime0
10227  F13B                         ;
10228  F13B                         ; Update enerFlags = 1 to reflect the fact that coil is now energized.
10229  F13B                         ; It is not really but it will be in 24usec....
10230  F13B                         ;------------------------------------------------------------------------
10231  F13B DF 74                   stx     enerAbsTime0            ; enerAbsTime0 = t3_clock1 + $06
10232  F13D DF 2B                   stx     t3_outCmpWr             ; Schedule energization interrupt time on first output compare register                                   
10233  F13F 86 01                   ldaa    #$01                    ;                             
10234  F141 97 63                   staa    enerFlags               ; Make sure flag reflects the fact that coil is energized or will be very soon???                             
10235  F143 20 44                   bra     L1752                   ; Branch to compute ignition time                             
10236  F145             
10237  F145                         ;-----------------------------------------------------
10238  F145                         ; enerAbsTime0 is sufficiently in the future
10239  F145                         ; Schedule regular coil energization interrupt time 
10240  F145                         ; and update enerAbsTime0 with it.
10241  F145                         ;
10242  F145                         ; Note that Ignition will be calculated below but scheduled 
10243  F145                         ; only  when the output compare interrupt to energize the 
10244  F145                         ; coil actually happens (i.e. in coilFunc)
10245  F145                         ;-----------------------------------------------------
10246  F145 DE 74       L1747       ldx     enerAbsTime0            ; x = enerAbsTime0                             
10247  F147 DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register                                     
10248  F149 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                           
10249  F14B DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register 
10250  F14D                                                             
10251  F14D                         ;---------------------------------------------------------------------------
10252  F14D                         ; Branch to compute ignTime0
10253  F14D                         ; if we predicted we would schedule ignition on the CAS falling edge???
10254  F14D                         ;---------------------------------------------------------------------------
10255  F14D 87 62 01 14             brset   ignFallFlags, #$01, L1749 ; Branch if ignFallFlags = 1
10256  F151             
10257  F151                         ;-------------------------------------------------------------------
10258  F151                         ; Flag is not set, do it anyway if 
10259  F151                         ;
10260  F151                         ;     abs(ignTime0 - casFallTime0 - ignFallRelTime0) >= TcasLast128
10261  F151                         ;           abs(compIgnFallRelTime - ignFallRelTime0) >= TcasLast128
10262  F151                         ;
10263  F151                         ; where compIgnFallRelTime = ignTime0 - casFallTime0 is the ignition
10264  F151                         ; time relative to the cas falling edge but calculated from ignTime0...
10265  F151                         ;
10266  F151                         ; i.e. Do it anyway if they are more than 1.4deg apart??? Why not
10267  F151                         ; just recompute it anyway instead of doing this lenghty 
10268  F151                         ; computation to check it, there must be a reason??? I guess
10269  F151                         ; in most cases, it might be more acurate to use ignFallRelTime0
10270  F151                         ; but in case it is too far apart from what makes sense at this time
10271  F151                         ; then just use whatever makes sense at this time...
10272  F151                         ;-------------------------------------------------------------------
10273  F151 DC 76                   ldd     ignTime0                ; d = ignTime0                             
10274  F153 93 6A                   subd    casFallTime0            ; d = ignTime0 - casFallTime0                             
10275  F155 93 70                   subd    ignFallRelTime0         ; d = ignTime0 - casFallTime0 - ignFallRelTime0                            
10276  F157 24 05                   bcc     L1748                   ; Branch if no overflow                             
10277  F159 43                      coma                            ; overflow, compute 2s complement                            
10278  F15A 53                      comb                            ;                             
10279  F15B C3 00 01                addd    #$0001                  ; d = abs(ignTime0 - casFallTime0 - ignFallRelTime0)                             
10280  F15E 4D          L1748       tsta                            ;                             
10281  F15F 26 04                   bne     L1749                   ; Branch if abs(compIgnFallRelTime - ignFallRelTime0)/256 != 0                             
10282  F161 D1 7A                   cmpb    TcasLast128             ; high part is null, check low part                              
10283  F163 25 45                   bcs     L1754                   ; Bail if difference is small, i.e. abs(compIgnFallRelTime - ignFallRelTime0) <  TcasLast128
10284  F165                                                      
10285  F165                         ;------------------------------------------------------------------
10286  F165                         ; Compute ignTime0 = ignFallRelTime0 + casFallTime0
10287  F165                         ; The ignition time computed from the cas falling edge
10288  F165                         ;------------------------------------------------------------------
10289  F165 DC 70       L1749       ldd     ignFallRelTime0         ; d = ignFallRelTime0                               
10290  F167 D3 6A                   addd    casFallTime0            ; d = ignFallRelTime0 + casFallTime0                             
10291  F169 DD 76                   std     ignTime0                ; ignTime0 = ignFallRelTime0 + casFallTime0                              
10292  F16B 20 3D                   bra     L1754                   ; Bail                             
10293  F16D             
10294  F16D                         ;----------------------------------------------------------------
10295  F16D                         ; At this point we detected that coil is already energized...
10296  F16D                         ; Section of code similar to above one...
10297  F16D                         ;----------------------------------------------------------------
10298  F16D                         ;--------------------------------------------------
10299  F16D                         ; Check if flag indicate ignition makes sense???
10300  F16D                         ;--------------------------------------------------
10301  F16D 8F 63 03 39 L1750       brclr   enerFlags, #$03, L1754    ; Bail if flag indicates coil is not energized and energization is not scheduled???
10302  F171             
10303  F171                         ;---------------------------------------------------------------------------
10304  F171                         ; Branch to compute ignTime0
10305  F171                         ; if we predicted we would schedule ignition on the CAS falling edge???
10306  F171                         ;---------------------------------------------------------------------------
10307  F171 87 62 01 14             brset   ignFallFlags, #$01, L1752 ; Branch if ??? TDC related                              
10308  F175             
10309  F175                         ;-------------------------------------------------------------------
10310  F175                         ; Flag is not set, do it anyway if 
10311  F175                         ;
10312  F175                         ;     abs(ignTime0 - casFallTime0 - ignFallRelTime0) >= TcasLast128
10313  F175                         ;           abs(compIgnFallRelTime - ignFallRelTime0) >= TcasLast128
10314  F175                         ;
10315  F175                         ; where compIgnFallRelTime = ignTime0 - casFallTime0 is the ignition
10316  F175                         ; time relative to the cas falling edge but calculated from ignTime0...
10317  F175                         ;
10318  F175                         ; i.e. Do it anyway if they are more than 1.4deg apart??? Why not
10319  F175                         ; just recompute it anyway instead of doing this lenghty 
10320  F175                         ; computation to check it, there must be a reason??? I guess
10321  F175                         ; in most cases, it might be more acurate to use ignFallRelTime0
10322  F175                         ; but in case it is too far apart from what makes sense at this time
10323  F175                         ; then just use whatever makes sense at this time...
10324  F175                         ;-------------------------------------------------------------------
10325  F175 DC 76                   ldd     ignTime0                  ; d = ignTime0                              
10326  F177 93 6A                   subd    casFallTime0              ; d = ignTime0 - casFallTime0                             
10327  F179 93 70                   subd    ignFallRelTime0           ; d = ignTime0 - casFallTime0 - ignFallRelTime0                              
10328  F17B 24 05                   bcc     L1751                     ; Branch if no overflow                             
10329  F17D 43                      coma                              ; overflow, compute 2s complement                            
10330  F17E 53                      comb                              ;                             
10331  F17F C3 00 01                addd    #$0001                    ; d = abs(ignTime0 - casFallTime0 - ignFallRelTime0)                              
10332  F182 4D          L1751       tsta                              ;                             
10333  F183 26 04                   bne     L1752                     ; Branch if abs(ignTime0 - casFallTime0 - ignFallRelTime0)/256 > 0                             
10334  F185 D1 7A                   cmpb    TcasLast128               ; high part is zero (a = 0), check low part for minimum                              
10335  F187 25 21                   bcs     L1754                     ; Branch if difference is small, i.e. abs(ignTime0 - casFallTime0 - ignFallRelTime0) <  TcasLast128
10336  F189             
10337  F189                         ;----------------------------------------------------
10338  F189                         ; Compute ignTime0 = ignFallRelTime0 + casFallTime0
10339  F189                         ; The ignition time computed from the cas falling edge
10340  F189                         ;----------------------------------------------------
10341  F189 DC 70       L1752       ldd     ignFallRelTime0         ; d = ignFallRelTime0                                              
10342  F18B D3 6A                   addd    casFallTime0            ; d = ignFallRelTime0 + casFallTime0                                     
10343  F18D DD 76                   std     ignTime0                ; ignTime0 = ignFallRelTime0 + casFallTime0 
10344  F18F                                                         
10345  F18F                         ;-------------------------------------------
10346  F18F                         ; Update enerFlags = 1 since at this 
10347  F18F                         ; point we know the coil is energized???
10348  F18F                         ;-------------------------------------------
10349  F18F 86 01                   ldaa    #$01                    ; a = $01                            
10350  F191 97 63                   staa    enerFlags               ; enerFlags = $01                             
10351  F193             
10352  F193                         ;------------------------------------------
10353  F193                         ; Make sure ignition time is in the future
10354  F193                         ;------------------------------------------
10355  F193 DC 29                   ldd     t3_clock1               ; d = t3_clock1                                   
10356  F195 C3 00 09                addd    #$0009                  ; d = t3_clock1 + $09 (36usec)                             
10357  F198 1A                      xgdx                            ; x = t3_clock1 + $09                             
10358  F199 9C 76                   cpx     ignTime0                ;                              
10359  F19B 2A 02                   bpl     L1753                   ; Branch to use t3_clock1 + $09 if ignTime0 is "in the past"                             
10360  F19D DE 76                   ldx     ignTime0                ; ignTime0 is valid, use it                             
10361  F19F             
10362  F19F                         ;-----------------------------------------------------------
10363  F19F                         ; Schedule ignition time on both output compare registers
10364  F19F                         ; Update the coil bits and save time in ignTime0
10365  F19F                         ;-----------------------------------------------------------
10366  F19F DF 2B       L1753       stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register
10367  F1A1 03 19 0C                orm     t3_csr0, #$0c           ; Set both coil bits for ignition
10368  F1A4 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                            
10369  F1A6 DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register                                     
10370  F1A8 DF 76                   stx     ignTime0                ; ignTime0 = next interrupt time                             
10371  F1AA             
10372  F1AA                         ;-----------------------------------------------
10373  F1AA                         ; Common branching place for most code above...
10374  F1AA                         ;-----------------------------------------------
10375  F1AA                         ;---------------------------------------------------------
10376  F1AA                         ; Section to check if ignition should have occured by 
10377  F1AA                         ; now and schedule it "now" if needed
10378  F1AA                         ;---------------------------------------------------------
10379  F1AA 8F 61 02 15 L1754       brclr   casFlags0, #$02, L1755    ; Branch if rpm(Tcas) < 505 previously
10380  F1AE 87 61 40 1F             brset   casFlags0, #$40, L1756    ; Branch to continue if timing adjustement mode active                             
10381  F1B2 DC 6C                   ldd     timCas0                   ; d = timCas0:timCas1                               
10382  F1B4 1C 00 C8                cmpd    #$00c8                    ;                               
10383  F1B7 24 18                   bcc     L1756                     ; Branch if timCas0 >= $c8 (4.7 BTDC)                             
10384  F1B9 96 16                   ldaa    port5                     ; a = port5                               
10385  F1BB 94 7B                   anda    tdcMask0                  ; a = port5 & $02 or $04                              
10386  F1BD 26 12                   bne     L1756                     ; Branch if current coil bit is 1, i.e. coil is not energized
10387  F1BF 8F 63 03 0E             brclr   enerFlags, #$03, L1756    ; Branch to continue if flag indicate coil is not energized and energization is not scheduled
10388  F1C3                                                       
10389  F1C3                         ;-----------------------------------------------------------------------------------
10390  F1C3                         ; At this point, 
10391  F1C3                         ;     rpm(Tcas) < 505 
10392  F1C3                         ; or
10393  F1C3                         ;     current coil is energized
10394  F1C3                         ;     and timCas0 < $c8 (4.7 BTDC)
10395  F1C3                         ;     and enerFlags =  1 or 2, coil is energized or energization is scheduled
10396  F1C3                         ;
10397  F1C3                         ; In all those cases, ignition should have occured by now???
10398  F1C3                         ;
10399  F1C3                         ; Schedule interrupt on first output compare register to provoke 
10400  F1C3                         ; ignition now, save time in ignTime0 and clear enerFlags
10401  F1C3                         ;-----------------------------------------------------------------------------------
10402  F1C3 03 19 0C    L1755       orm     t3_csr0, #$0c           ; Set both coil bits for ignition
10403  F1C6 DE 29                   ldx     t3_clock1               ; x = t3_clock1                                   
10404  F1C8 08                      inx                             ;                             
10405  F1C9 08                      inx                             ; x = t3_clock1 + $02                             
10406  F1CA DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register
10407  F1CC DF 76                   stx     ignTime0                ; Update ignTime0 with the ignition time we just used                              
10408  F1CE 4F                      clra                            ;                             
10409  F1CF 97 63                   staa    enerFlags               ; enerFlags = 0                             
10410  F1D1             
10411  F1D1                         ;--------------------------------------------------------------
10412  F1D1                         ; Section to update ignition stuff when rpm(Tcas) < 505???
10413  F1D1                         ; Probably a dedicated section when engine is cranking???
10414  F1D1                         ; First check rpm flag...
10415  F1D1                         ;--------------------------------------------------------------
10416  F1D1 87 61 02 03 L1756       brset   casFlags0, #$02, L1757  ; Branch if rpm(Tcas) >= 505 previously
10417  F1D5 7E F2 56                jmp     L1765                   ; Bail                         
10418  F1D8                             
10419  F1D8                         ;---------------------
10420  F1D8                         ; rpm(Tcas) < 505rpm
10421  F1D8                         ;---------------------
10422  F1D8                         ;---------------------------------------------------------
10423  F1D8                         ; Compute enerLenX0 = min($60/128 * Tcas, 16*enerLen)
10424  F1D8                         ;                   = min(   0.75 * Tcas, 16*enerLen)
10425  F1D8                         ;---------------------------------------------------------
10426  F1D8 96 89       L1757       ldaa    enerLen                 ; a = enerLen                              
10427  F1DA 5F                      clrb                            ; d = enerLen*256                             
10428  F1DB 04                      lsrd                            ;                             
10429  F1DC 04                      lsrd                            ;                             
10430  F1DD 04                      lsrd                            ;                             
10431  F1DE 04                      lsrd                            ; d = enerLen*256/16 = 16*enerLen                            
10432  F1DF DD 7E                   std     temp20                  ; temp20 = 16*enerLen                                   
10433  F1E1 96 81       L1758       ldaa    temp23                  ; a = temp23  (low part of Tcas)                            
10434  F1E3 C6 60                   ldab    #$60                    ; b = $60                             
10435  F1E5 3D                      mul                             ; d = $60 * temp23                            
10436  F1E6 97 72                   staa    enerLenX0               ; enerLenX0 = $60/256 * temp23                             
10437  F1E8 96 80                   ldaa    temp22                  ; a = temp22                             
10438  F1EA C6 60                   ldab    #$60                    ; b = $60                            
10439  F1EC 3D                      mul                             ; d = $60 * temp22                            
10440  F1ED DB 72                   addb    enerLenX0               ; d = $60 * temp22 + $60/256 * temp23 = $60/256 * [temp22:temp23]                             
10441  F1EF 89 00                   adca    #$00                    ; propagate carry                            
10442  F1F1 05                      asld                            ; d = $60/128 * [temp22:temp23] = $60/128 * Tcas                            
10443  F1F2 25 04                   bcs     L1759                   ; Branch if overflow
10444  F1F4 1D 7E                   cmpd1   temp20                  ;                                     
10445  F1F6 25 02                   bcs     L1760                   ; Branch if $60/128 * Tcas < 16*enerLen                            
10446  F1F8 DC 7E       L1759       ldd     temp20                  ; Use max of 16*enerLen                                     
10447  F1FA DD 72       L1760       std     enerLenX0               ; enerLenX0 = min($60/128 * Tcas, 16*enerLen)                    
10448  F1FC                      
10449  F1FC                         ;-------------------------------------------------------------------------------------
10450  F1FC                         ; Compute  temp20 = casFallTime0 + $9c/256 * Tcas + ignRelTime0  - enerLenX0 
10451  F1FC                         ;                 = casFallTime0 + 110deg + ignRelTime0  - enerLenX0 
10452  F1FC                         ;
10453  F1FC                         ; 110deg is the number of degrees between the CAS falling edge and the next
10454  F1FC                         ; CAS rising edge since CAS starts at -75deg and ends at -5deg, CAS width = 70deg
10455  F1FC                         ; and then distance from falling edge to next rising edge = 180deg - 70deg = 110deg
10456  F1FC                         ;
10457  F1FC                         ; we are therefore calculating the coil energization absolute time for the next
10458  F1FC                         ; CAS/cylinder from the CAS falling edge of the current CAS/cylinder... 
10459  F1FC                         ;-------------------------------------------------------------------------------------
10460  F1FC 8F 83 FE 56             brclr   tdcCasCount, #$fe, L1765 ; Bail if tdcCasCount = 0 or 1                                    
10461  F200 D6 81                   ldab    temp23                   ; b = temp23 (low part of Tcas)                            
10462  F202 86 9C                   ldaa    #$9c                     ; a = $9c                            
10463  F204 3D                      mul                              ; d = $9c * temp23                             
10464  F205 97 7F                   staa    temp21                   ; temp21 = $9c * temp23/256                               
10465  F207 96 80                   ldaa    temp22                   ; a = temp22                             
10466  F209 C6 9C                   ldab    #$9c                     ; b = $9c                             
10467  F20B 3D                      mul                              ; d =  $9c * temp22                            
10468  F20C DB 7F                   addb    temp21                   ; d = $9c * temp22 + $9c * temp23/256  = $9c/256 * [temp22:temp23]                            
10469  F20E 89 00                   adca    #$00                     ; propagate carry                            
10470  F210 D3 6E                   addd    ignRelTime0              ; d = $9c/256 * Tcas + ignRelTime0                             
10471  F212 93 72                   subd    enerLenX0                ; d = $9c/256 * Tcas + ignRelTime0  - enerLenX0                             
10472  F214 D3 6A                   addd    casFallTime0             ; d = $9c/256 * Tcas + ignRelTime0  - enerLenX0 + casFallTime0                             
10473  F216 DD 7E                   std     temp20                   ; temp20 = $9c/256 * Tcas + ignRelTime0  - enerLenX0 + casFallTime0                                      
10474  F218             
10475  F218                         ;----------------------------------------------------------------------
10476  F218                         ; Verify that energization time does not occur too close to ignition
10477  F218                         ; of current cylinder, i.e. energization should not occur sooner than 
10478  F218                         ; 1ms after ignition of preceeding cylinder
10479  F218                         ;----------------------------------------------------------------------
10480  F218 DC 76                   ldd     ignTime0                 ; d = ignTime0                              
10481  F21A C3 00 FA                addd    #$00fa                   ; d = ignTime0 + $fa (1ms)                              
10482  F21D 1D 7E                   cmpd1   temp20                   ;                                    
10483  F21F 2B 02                   bmi     L1761                    ; Branch if ignTime0 + $fa < casFallTime0 + $9c/256 * Tcas + ignRelTime0  - enerLenX0
10484  F221 DD 7E                   std     temp20                   ; Use closest possible energization time of ignTime0 + $fa (1ms)
10485  F223             
10486  F223                         ;-------------------------------------
10487  F223                         ; Check if current coil is energized
10488  F223                         ;-------------------------------------
10489  F223 96 16       L1761       ldaa    port5                   ; a = port5                              
10490  F225 94 7B                   anda    tdcMask0                ; a = port5 & tdcMask0 ($02 or $04)                             
10491  F227 27 25                   beq     L1763                   ; Branch if coil bit is 0, i.e. coil is energized                              
10492  F229             
10493  F229                         ;--------------------------------------------------
10494  F229                         ; Current coil is not yet energized,
10495  F229                         ;
10496  F229                         ; Check that energization time computed above and 
10497  F229                         ; stored in temp20 is sufficiently in the future
10498  F229                         ;--------------------------------------------------
10499  F229 87 63 02 25             brset   enerFlags, #$02, L1764  ; Bail if flag indicates coil is energized or energization is scheduled
10500  F22D DC 29                   ldd     t3_clock1               ; d = t3_clock1                                   
10501  F22F C3 00 0A                addd    #$000a                  ; d = t3_clock1 + $0a  (40usec)                            
10502  F232 1A                      xgdx                            ; x = t3_clock1 + $0a                             
10503  F233 9C 7E                   cpx     temp20                  ; Compare to energization time                                    
10504  F235 2A 02                   bpl     L1762                   ; Branch to use t3_clock1 + $0a if energization time is "in the past"                             
10505  F237 DE 7E                   ldx     temp20                  ; Energization time is valid, use it
10506  F239             
10507  F239                         ;----------------------------------------------------
10508  F239                         ; Schedule the coil energization 
10509  F239                         ; time and store time in enerAbsTimeNext0
10510  F239                         ;----------------------------------------------------
10511  F239 DF 2B       L1762       stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register  
10512  F23B 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                                                               
10513  F23D DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register 
10514  F23F DF 78                   stx     enerAbsTimeNext0        ; Store actual time used                             
10515  F241             
10516  F241                         ;--------------------------------------------------
10517  F241                         ; Reset the corresponding coil bit to 
10518  F241                         ; energize the coil at the specified time
10519  F241                         ;--------------------------------------------------
10520  F241 96 7C                   ldaa    tdcMask1                ; a = $02 or $04
10521  F243 48                      asla                            ; a = $04 or $08
10522  F244 43                      coma                            ; a = ~($04 or $08)                            
10523  F245 94 19                   anda    t3_csr0                 ; reset that coil bit, i.e. energize that coil at the specified time                             
10524  F247 97 19                   staa    t3_csr0                 ; update t3_csr0                             
10525  F249             
10526  F249                         ;-----------------------------------------------
10527  F249                         ; Set enerFlags = 0
10528  F249                         ; Although coil is energized, it seems we use 
10529  F249                         ; this value when rpm is low...
10530  F249                         ;-----------------------------------------------
10531  F249 4F                      clra                            ;                             
10532  F24A 97 63                   staa    enerFlags               ;                              
10533  F24C 20 08                   bra     L1765                   ;                              
10534  F24E             
10535  F24E                         ;------------------------------------------------------------------------------
10536  F24E                         ; Update enerAbsTimeNext0 with its latest value if flag indicates 
10537  F24E                         ; coil is energized or energization has been scheduled
10538  F24E                         ; Makes sense to update the variable if energization time was actually used...
10539  F24E                         ;------------------------------------------------------------------------------
10540  F24E 8F 63 03 04 L1763       brclr   enerFlags, #$03, L1765  ; Branch if flag indicates coil is not energized and energization is not scheduled
10541  F252 DC 7E       L1764       ldd     temp20                  ; d = temp20                                   
10542  F254 DD 78                   std     enerAbsTimeNext0        ; enerAbsTimeNext0 = temp20                               
10543  F256             
10544  F256                         ;-------------------------------------------
10545  F256                         ; Common branching place for all code above
10546  F256                         ;-------------------------------------------
10547  F256                         ;-------------------------------------------------------
10548  F256                         ; Update ignFallFlags, t3_csr0 and t1_csr
10549  F256                         ; Change cas edge detection polarity among others... 
10550  F256                         ;-------------------------------------------------------
10551  F256 02 62 FE    L1765       andm    ignFallFlags, #$fe      ; Reset 0000 0001                               
10552  F259 96 19                   ldaa    t3_csr0                 ; a = t3_csr0                              
10553  F25B 84 0C                   anda    #$0c                    ; reset both coil bits, i.e. energize both coil at the specified time
10554  F25D 8A 42                   oraa    #$42                    ; set   0100 0010 ???                                                                                                  
10555  F25F D6 08                   ldab    t1_csr                  ; b = t1_csr                                                                                                       
10556  F261 C4 19                   andb    #$19                    ; reset 1110 0110, change cas detection polarity, enable injectors 5/6 bits???, reset injector and cas interrupt pending flags
10557  F263 DE 0D                   ldx     t1_inCapt               ; Clear input capture flag?
10558  F265 97 19                   staa    t3_csr0                 ; Update t3_csr0                                                                                                     
10559  F267 D7 08                   stab    t1_csr                  ; Update t1_csr   
10560  F269                                                                                                                           
10561  F269                         ;-----------------------------------
10562  F269                         ; Reset instant knock sum???
10563  F269                         ;-----------------------------------
10564  F269 02 2F FE                andm    port6, #$fe             ; Reset instant knock sum???                                                                                             
10565  F26C             
10566  F26C                         ;---------------------------------------------------------------------
10567  F26C                         ; Reset engine rotating timer to 0.6sec or 1.2sec depending on 
10568  F26C                         ; whether key is in start. If key is in start it means we are 
10569  F26C                         ; cranking, rpm is therefore low and we need a longer timeout value...
10570  F26C                         ;---------------------------------------------------------------------
10571  F26C 86 18                   ldaa    #$18                    ; a = 0.6sec                                                                                                   
10572  F26E 87 06 40 01             brset   port3, #$40, L1766      ; Branch if key is not in start???                                                                                                      
10573  F272 48                      asla                            ; key in start, use a = 1.2sec                                                                                                    
10574  F273 B7 01 20    L1766       staa    T40_engRot              ; T40_engRot = #$18 (0.6sec) or #$30 (1.2sec)
10575  F276             
10576  F276                         ;----------------------------
10577  F276                         ; Update rev limiter flag
10578  F276                         ;----------------------------
10579  F276 FE 01 45                ldx     Tcas                    ; Tcas = Time(s) per engine revolution * 125000, rpm = (125000*60)/(2*Tcas)                               
10580  F279 8C 01 F4                cpx     #$01f4                  ; Rev limiter (limit rpm = (125000*60)/(2*$01F4) = 7500)                                                     
10581  F27C 24 05                   bcc     L1767                   ; branch if RPM lower than threshold (Tcas higher than threshold)
10582  F27E 03 A2 04                orm     state3, #$04            ; RPM exceeds threshold, set bit                                
10583  F281 20 03                   bra     L1768                   ;                              
10584  F283 02 A2 FB    L1767       andm    state3, #$fb            ; RPM below threshold, reset bit                                
10585  F286             
10586  F286                         ;-----------------------------
10587  F286                         ; Update cylinder1 TDC state
10588  F286                         ;-----------------------------
10589  F286 02 B3 7F    L1768       andm    tdcCasFlags, #$7f         ; Assume flag is 0                                 
10590  F289 8F B3 08 0A             brclr   tdcCasFlags, #$08, L1769  ; branch if TDC was 0 last time
10591  F28D             
10592  F28D                         ;------------------------------------------------
10593  F28D                         ; TDC bit was 1 last time, check if it changed
10594  F28D                         ;------------------------------------------------
10595  F28D 87 06 04 06             brset   port3, #$04, L1769      ; branch if current TDC bit is 1                               
10596  F291             
10597  F291                         ;-------------------------------------------------------------------------------
10598  F291                         ; TDC bit was 1 last time and is now 0, update flag and reset counter (lower three bits)
10599  F291                         ;
10600  F291                         ; -> since we are executing this code on every falling edge of CAS pulses,
10601  F291                         ; we necessarily are on the cylinder #1 TDC
10602  F291                         ;-------------------------------------------------------------------------------
10603  F291 03 B3 80                orm     tdcCasFlags, #$80       ; 
10604  F294 02 B3 F8                andm    tdcCasFlags, #$f8       ; Reset lower 3 bits of tdcCasFlags
10605  F297             
10606  F297                         ;------------------------
10607  F297                         ; Update stored TDC bit
10608  F297                         ;------------------------
10609  F297 02 B3 F7    L1769       andm    tdcCasFlags, #$f7       ; Reset old TDC bit to 0
10610  F29A 8F 06 04 03             brclr   port3, #$04, L1770      ; branch if current TDC bit is not set                               
10611  F29E 03 B3 08                orm     tdcCasFlags, #$08       ; Current TDC bit set, update the flag with current value
10612  F2A1             
10613  F2A1                         ;---------------------------------------------------------
10614  F2A1                         ; Decrement tdcCasFlags lower 3 bits if not already at 0
10615  F2A1                         ;---------------------------------------------------------
10616  F2A1 8F B3 07 03 L1770       brclr   tdcCasFlags, #$07, L1771  ; Branch if lower 3 bits have reached 0                                
10617  F2A5 7A 00 B3                dec     tdcCasFlags               ; Decrement lower 3 bits
10618  F2A8             
10619  F2A8                         ;--------------------------------------------------------------------------------------------------
10620  F2A8                         ; Increment casCylIndex (loop from 0 to 3) and reset it to 0 if TDC detected on #1 cyl (tdcCasFlags.7 set)
10621  F2A8                         ;--------------------------------------------------------------------------------------------------
10622  F2A8 96 B4       L1771       ldaa    casCylIndex               ;                              
10623  F2AA 4C                      inca                              ;                             
10624  F2AB 81 04                   cmpa    #$04                      ;                             
10625  F2AD 24 04                   bcc     L1772                     ; Branch if new value >= 4                             
10626  F2AF 8F B3 80 01             brclr   tdcCasFlags, #$80, L1773  ; New value < 4, branch if no TDC detected                              
10627  F2B3 4F          L1772       clra                              ; TDC detected, restart counter at 0                            
10628  F2B4 97 B4       L1773       staa    casCylIndex               ;                              
10629  F2B6             
10630  F2B6             
10631  F2B6                         ;------------------------------------------------
10632  F2B6                         ; Update tdcCheck
10633  F2B6                         ; Decrement on every cas falling edge and 
10634  F2B6                         ; re-init to 8 on cylinder #1 TDC, tdcCheck
10635  F2B6                         ; should never reach 0 if TDC sensor is working
10636  F2B6                         ;------------------------------------------------
10637  F2B6 96 B6                   ldaa    tdcCheck                  ;                              
10638  F2B8 27 01                   beq     L1774                     ; Branch if tdcCheck already 0                            
10639  F2BA 4A                      deca                              ; a = tdcCheck                          
10640  F2BB 8F B3 80 02 L1774       brclr   tdcCasFlags, #$80, L1775  ; branch to store if not cylinder #1 TDC                                  
10641  F2BF 86 08                   ldaa    #$08                      ; We are at cylinder #1 TDC, restart tdcCheck with 8                          
10642  F2C1 97 B6       L1775       staa    tdcCheck                  ; Store new value                              
10643  F2C3             
10644  F2C3                         ;---------------------
10645  F2C3                         ; Update oldAirCnt0
10646  F2C3                         ;---------------------
10647  F2C3 DC 8D                   ldd     airCnt0                                                 
10648  F2C5 DD 92                   std     oldAirCnt0                                                 
10649  F2C7             
10650  F2C7                         ;---------------------------------------------------------------
10651  F2C7                         ; Compute d = t1_t2_diff/8, 
10652  F2C7                         ; the time between the last time we received a airflow
10653  F2C7                         ; sensor pulse and the time when the current cas edge was 
10654  F2C7                         ; detected (t1_lastCas stored at the beginning of the interrupt) 
10655  F2C7                         ;
10656  F2C7                         ; If airCntNew0 is null (we did not count any air since the 
10657  F2C7                         ; last time we were here) then use d = Tcas??? 
10658  F2C7                         ;---------------------------------------------------------------
10659  F2C7 DC 90                   ldd     airCntNew0              ;                                 
10660  F2C9 26 05                   bne     L1776                   ; Branch if airCntNew0 != 0                            
10661  F2CB FC 01 45                ldd     Tcas                    ; airCntNew0=0, use d = Tcas??                           
10662  F2CE 20 0A                   bra     L1777                   ;          
10663  F2D0 DC 96       L1776       ldd     t1_lastCas              ; Get cas edge time value
10664  F2D2 93 98                   subd    t2_lastMas              ; Subtract last time mas interrupt was called, d = t1_lastCas - t2_lastMas = t1_t2_diff                                                        
10665  F2D4 CE 00 C1                ldx     #T200_mas               ;                                                                    
10666  F2D7 BD F8 1F                jsr     masFunc1                ; D = ~t1_t2_diff/8                                                       
10667  F2DA             
10668  F2DA                         ;---------------------------------------------------------------
10669  F2DA                         ; Loop to scale D=t1_t2_diff (and X=t2_diff8 at the same time) 
10670  F2DA                         ; to fit in lower nibble only
10671  F2DA                         ;---------------------------------------------------------------
10672  F2DA DE 9A       L1777       ldx     t2_diff8                ; X = t2_diff8                                                         
10673  F2DC 4D          L1778       tsta                            ;                                                                                       
10674  F2DD 27 06                   beq     L1779                   ; Branch if high nibble=0                                                                
10675  F2DF 04                      lsrd                            ; high nibble<>0, divide by 2                                                           
10676  F2E0 1A                      xgdx                            ; X<->D                                                                                 
10677  F2E1 04                      lsrd                            ; divide t2_diff8 by 2                                                                   
10678  F2E2 1A                      xgdx                            ; X<->D                                                                                 
10679  F2E3 20 F7                   bra     L1778                   ; At this point, X=t2_diff8/2, D=t1_t2_diff/2, loop back     
10680  F2E5                                                                 
10681  F2E5                         ;---------------------------------------------------------------------------
10682  F2E5                         ; At this point, D=scaledt1_t2_diff fits in lower nibble and X=scaledt2_diff8
10683  F2E5                         ;----------------------------------------------------------------------------
10684  F2E5 86 9C       L1779       ldaa    #$9c                    ; A=$9C, B=scaledt1_t2_diff                                         
10685  F2E7 3D                      mul                             ; D = scaledt1_t2_diff * $9C                                        
10686  F2E8 1A                      xgdx                            ; X = scaledt1_t2_diff * $9C, D=scaledt2_diff8
10687  F2E9             
10688  F2E9                         ;----------------------------------------------------------------
10689  F2E9                         ; Loop to scale X=scaledt1_t2_diff*$9C to fit in lower nibble
10690  F2E9                         ; scales D = scaledt2_diff8 by the same amount
10691  F2E9                         ;----------------------------------------------------------------
10692  F2E9 4D          L1780       tsta                            ;                                
10693  F2EA 27 06                   beq     L1781                   ;                                 
10694  F2EC 04                      lsrd                            ;                                
10695  F2ED 1A                      xgdx                            ;                                
10696  F2EE 04                      lsrd                            ;                                
10697  F2EF 1A                      xgdx                            ;                                
10698  F2F0 20 F7                   bra     L1780                   ;                                 
10699  F2F2             
10700  F2F2                         ;---------------------------------------------------------------
10701  F2F2                         ; At this point, D=scaledt2_diff8 and X=scaledt1_t2_diff * $9C
10702  F2F2                         ; Compute airQuantumRemainder = scaledt1_t2_diff/scaledt2_diff8 * $9C
10703  F2F2                         ;---------------------------------------------------------------
10704  F2F2 D7 5E       L1781       stab    temp8                   ; temp8 = scaledt2_diff8                                                       
10705  F2F4 1A                      xgdx                            ; D=scaledt1_t2_diff * $9C, X=scaledt2_diff8                                   
10706  F2F5 15 5E                   div     temp8                   ; D=D/temp8 = scaledt1_t2_diff * $9C / scaledt2_diff8?                                                                   
10707  F2F7 25 0A                   bcs     L1782                   ; Branch if overflow                                                                               
10708  F2F9 74 00 5E                lsr     temp8                   ; Check for ???                                                                              
10709  F2FC 91 5E                   cmpa    temp8                   ;                                                                               
10710  F2FE 25 05                   bcs     L1783                   ; 
10711  F300 5C                      incb                            ; 
10712  F301 26 02                   bne     L1783                   ;                                                                              
10713  F303 C6 FF       L1782       ldab    #$ff                    ; overflow, use max  
10714  F305                                        
10715  F305                         ;------------------------------------------------------------------------
10716  F305                         ; At this point, b = airQuantumRemainder = scaledt1_t2_diff/scaledt2_diff8 * $9C             
10717  F305                         ; Check if we should use it
10718  F305                         ;------------------------------------------------------------------------
10719  F305 D1 9C       L1783       cmpb    airQuantum              ;                              
10720  F307 25 07                   bcs     L1784                   ; Branch if airQuantumRemainder  < airQuantum, which means we can use it
10721  F309 D6 9C                   ldab    airQuantum              ; airQuantumRemainder >= airQuantum (in theory, I suppose at most it should only be equal to it...) use b=airQuantum                             
10722  F30B 7F 00 9C                clr     airQuantum              ; airQuantum=0 (since we "transfered" all of it to b)                             
10723  F30E 20 05                   bra     L1785                   ;                              
10724  F310             
10725  F310                         ;------------------------------------------------------------------------
10726  F310                         ; At this point airQuantumRemainder < airQuantum
10727  F310                         ; and b = airQuantumRemainder = scaledt1_t2_diff/scaledt2_diff8 * $9C
10728  F310                         ; 
10729  F310                         ; We are going to use airQuantumRemainder in this calculation cycle. 
10730  F310                         ; Subtract it from airQuantum. What is left in airQuantum 
10731  F310                         ; is going to be used as the startup value for the next airflow
10732  F310                         ; calculation cycle. Basically we don't want to loose any air in
10733  F310                         ; the calculations... 
10734  F310                         ;------------------------------------------------------------------------
10735  F310 96 9C       L1784       ldaa    airQuantum              ; a = airQuantum
10736  F312 10                      sba                             ; a = airQuantum -  airQuantumRemainder
10737  F313 97 9C                   staa    airQuantum              ; airQuantum = old airQuantum - airQuantumRemainder, basically we subtract what we are going to use
10738  F315             
10739  F315                         ;------------------------------------------------------- 
10740  F315                         ; Finish calc and scale airQuantumRemainder if required
10741  F315                         ;------------------------------------------------------- 
10742  F315 4F          L1785       clra                              ; d = airQuantumRemainder (high part=0)                            
10743  F316 8F 9E 80 01             brclr   masCasFlags, #$80, L1786  ; Branch if no scaling                                       
10744  F31A 05                      asld                              ; scale d = airQuantumRemainder * 2                                            
10745  F31B             
10746  F31B                         ;-----------------------------------------------------------------------
10747  F31B                         ; At this point, d = airQuantumRemainder, 
10748  F31B                         ; add it for a final time to airCntNew0, also check for minimum value
10749  F31B                         ;-----------------------------------------------------------------------
10750  F31B D3 90       L1786       addd    airCntNew0              ; d = airQuantumRemainder + airCntNew0                                                           
10751  F31D 1F 01 87                cmpd    airCntMin0              ;                                                           
10752  F320 24 03                   bcc     L1787                   ; Branch if airCntNew0 + airQuantumRemainder > airCntMin0                                                          
10753  F322 FC 01 87                ldd     airCntMin0              ; Use airCntMin0                                                          
10754  F325 DD 90       L1787       std     airCntNew0              ; airCntNew0 =   max(airQuantumRemainder+airCntNew0, airCntMin0)
10755  F327             
10756  F327                         ;---------------------------------------------------------------------------------
10757  F327                         ; Adjust airCntNew0 when mafRaw below 50Hz:
10758  F327                         ; If mafRaw below 50Hz and (airCnt0-airCntNew0) >= $004e then airCntNew0 = (airCnt0-$0010)
10759  F327                         ; Limits the downward rate of change of airCntNew0 under rapidly decreasing air flow conditions???
10760  F327                         ;---------------------------------------------------------------------------------
10761  F327 96 E4                   ldaa    mafRaw                  ; a = mafRaw                                                
10762  F329~            #ifdef masLog2X                              
10763  F329~                        cmpa    #$04                     
10764  F329             #else                                        
10765  F329 81 08                   cmpa    #$08                                                  
10766  F32B             #endif                                       
10767  F32B 24 12                   bcc     L1788                   ; Branch if mafRaw > 50Hz (no adjustment)
10768  F32D DC 8D                   ldd     airCnt0                 ; mafRaw<50Hz, d = airCnt0
10769  F32F 93 90                   subd    airCntNew0              ; d = airCnt0-airCntNew0 
10770  F331 25 0C                   bcs     L1788                   ; Branch if airCnt0 < airCntNew0 (no adjustment)
10771  F333 1C 00 4E                cmpd    #$004e                  ; airCnt0 >= airCntNew0, check difference
10772  F336 25 07                   bcs     L1788                   ; Branch if (airCnt0-airCntNew0)<$004e (no adjustment)
10773  F338 DC 8D                   ldd     airCnt0                 ; (airCnt0-airCntNew0)>=$004e, subtract $10
10774  F33A 83 00 10                subd    #$0010                  ;                               
10775  F33D DD 90                   std     airCntNew0              ; airCntNew0 = (airCnt0-$0010)                              
10776  F33F             
10777  F33F                         ;--------------------------------------------------------
10778  F33F                         ; Section below is to update airCnt0:airCnt1:airCnt2 
10779  F33F                         ; (filtered air count) from airCntNew0:airCntNew1 (latest 
10780  F33F                         ; air count received from aiflow sensor)
10781  F33F                         ;--------------------------------------------------------
10782  F33F                         ;------------------------------------------------------------
10783  F33F                         ; Multiply airCnt0:airCnt1:airCnt2 by 8 * airFiltFact/256
10784  F33F                         ;------------------------------------------------------------
10785  F33F 96 9F       L1788       ldaa    airFiltFact             ;                                    
10786  F341 97 5E                   staa    temp8                   ; temp8=airFiltFact                               
10787  F343 DC 8E                   ldd     airCnt1                 ; d = airCnt1:airCnt2                                 
10788  F345 05                      asld                            ;                              
10789  F346 79 00 8D                rol     airCnt0                 ;                                
10790  F349 05                      asld                            ;                             
10791  F34A 79 00 8D                rol     airCnt0                 ;                                
10792  F34D 05                      asld                            ; d = 8*[airCnt1:airCnt2]
10793  F34E 79 00 8D                rol     airCnt0                 ; airCnt0 = 8*airCnt0                                 
10794  F351 D6 5E                   ldab    temp8                   ; b = airFiltFact                               
10795  F353 3D                      mul                             ; d = airFiltFact * (8*[airCnt1:airCnt2])/256
10796  F354 DD 8E                   std     airCnt1                 ; airCnt1:airCnt2 =  airFiltFact * (8*[airCnt1:airCnt2])/256
10797  F356 96 8D                   ldaa    airCnt0                 ;                                 
10798  F358 D6 5E                   ldab    temp8                   ;                               
10799  F35A 3D                      mul                             ; d = airCnt0 * airFiltFact                             
10800  F35B DB 8E                   addb    airCnt1                 ; Add lower part                                 
10801  F35D 89 00                   adca    #$00                    ; Propagate carry
10802  F35F DD 8D                   std     airCnt0                 ; Store final result, 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256
10803  F361             
10804  F361                         ;------------------------------------------------------------------
10805  F361                         ; Multiply airCntNew0:airCntNew1 by 4 with overflow check
10806  F361                         ;------------------------------------------------------------------
10807  F361 DC 90                   ldd     airCntNew0              ;                              
10808  F363 05                      asld                            ;                             
10809  F364 25 03                   bcs     L1789                   ;                              
10810  F366 05                      asld                            ;                             
10811  F367 24 02                   bcc     L1790                   ;                              
10812  F369 86 FF       L1789       ldaa    #$ff                    ; Use max
10813  F36B DD 90       L1790       std     airCntNew0              ;                              
10814  F36D             
10815  F36D                         ;-----------------------------------------------------------------------------------------------------------
10816  F36D                         ; Add 2*(256-airFiltFact)*4*[airCntNew0:airCntNew1] to 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256
10817  F36D                         ; with overflow check
10818  F36D                         ;-----------------------------------------------------------------------------------------------------------
10819  F36D 96 5E                   ldaa    temp8                   ; Still contains airFiltFact ($d1 or $e4 from code)?                               
10820  F36F 40                      nega                            ;                               
10821  F370 48                      asla                            ; a = 2*(256-airFiltFact) -> $d1->$5e   $e4->$38    209->94   228->56 
10822  F371 3D                      mul                             ; d = 2*(256-airFiltFact) * airCntNew1
10823  F372 D3 8E                   addd    airCnt1                 ;                                        
10824  F374 DD 8E                   std     airCnt1                 ;                                 
10825  F376 96 8D                   ldaa    airCnt0                 ;                                 
10826  F378 89 00                   adca    #$00                    ;                             
10827  F37A 24 02                   bcc     L1791                   ; Branch if no overflow                             
10828  F37C 86 FF                   ldaa    #$ff                    ; Use max if overflow                            
10829  F37E 97 8D       L1791       staa    airCnt0                 ;                    
10830  F380             
10831  F380 96 5E                   ldaa    temp8                  ; Still contains airFiltFact                              
10832  F382 40                      nega                            ;                             
10833  F383 48                      asla                            ;                             
10834  F384 D6 90                   ldab    airCntNew0              ;                              
10835  F386 3D                      mul                             ;                             
10836  F387 D3 8D                   addd    airCnt0                 ;                                 
10837  F389 24 03                   bcc     L1792                   ; Branch if no overflow                                 
10838  F38B CC FF FF                ldd     #$ffff                  ; Use max if overflow                                    
10839  F38E             
10840  F38E                         ;-------------------------------------------------------------------------------------------------------------------
10841  F38E                         ; At this point, D:airCnt2 contains result from above: 
10842  F38E                         ; D:airCnt2 = 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256 + 2*4*(256-airFiltFact)*[airCntNew0:airCntNew1] 
10843  F38E                         ; Divide it by 8 and store it. 
10844  F38E                         ; If no  pulse accumulator interrupts were receive, use airCntDef
10845  F38E                         ;-------------------------------------------------------------------------------------------------------------------
10846  F38E 04          L1792       lsrd                            ;                              
10847  F38F 76 00 8F                ror     airCnt2                 ;                                 
10848  F392 04                      lsrd                            ;                             
10849  F393 76 00 8F                ror     airCnt2                 ;                                 
10850  F396 04                      lsrd                            ;                             
10851  F397 76 00 8F                ror     airCnt2                 ; Divide D:airCnt2 by 8
10852  F39A 8F A2 02 06             brclr   state3, #$02, L1793     ; Branch if pulse accumulator interrupts received
10853  F39E D6 FF                   ldab    airCntDef               ; No pulse accumulator interrupts                              
10854  F3A0 4F                      clra                            ;                             
10855  F3A1 05                      asld                            ;                             
10856  F3A2 05                      asld                            ;                             
10857  F3A3 05                      asld                            ;                             
10858  F3A4 DD 8D       L1793       std     airCnt0                 ; Store airCnt0:airCnt1, airCnt2 was stored earlier                                 
10859  F3A6             
10860  F3A6                         ;-------------------------------------------------------------------------------------------------------------------------------------------
10861  F3A6                         ; At this point: 
10862  F3A6                         ;
10863  F3A6                         ; [airCnt0:airCnt1:airCnt2]    = 1/8 * ( 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256 + 2*4*(256-airFiltFact)*[airCntNew0:airCntNew1] )
10864  F3A6                         ;                              = 1/8 * ( 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256 + 256/256*2*4*(256-airFiltFact)*[airCntNew0:airCntNew1] )
10865  F3A6                         ;                              = 1/8 * ( 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256 + 8*(256-airFiltFact)/256 * 256*[airCntNew0:airCntNew1] )
10866  F3A6                         ;                              = [airCnt0:airCnt1:airCnt2] * airFiltFact/256 + (256-airFiltFact)/256 * 256*[airCntNew0:airCntNew1]
10867  F3A6                         ;                              = [airCnt0:airCnt1:airCnt2] * alpha + (1-alpha) * 256*[airCntNew0:airCntNew1]
10868  F3A6                         ;
10869  F3A6                         ;                              = alpha * oldAirCnt24bits + (1-alpha) * scaledNewAirCnt16bits
10870  F3A6                         ;
10871  F3A6                         ;                                        where alpha = airFiltFact/256, 0<=alpha<=1, 
10872  F3A6                         ;
10873  F3A6                         ; This is exponential averaging of [airCnt0:airCnt1:airCnt2] with [airCntNew0:airCntNew1]*256 as input 
10874  F3A6                         ;
10875  F3A6                         ;-------------------------------------------------------------------------------------------------------------------------------------------
10876  F3A6             
10877  F3A6                         ;-----------------------------------------------------------------
10878  F3A6                         ; If engine is notRotating or startingToCrank then ignore 
10879  F3A6                         ; airCnt0 we just calculated and use airCntMax*8 instead 
10880  F3A6                         ;-----------------------------------------------------------------
10881  F3A6 D6 A0                   ldab    airCntMax               ; d = airCntMax                                   
10882  F3A8 4F                      clra                            ;                             
10883  F3A9 05                      asld                            ;                             
10884  F3AA 05                      asld                            ;                             
10885  F3AB 05                      asld                            ; d = 8*airCntMax                             
10886  F3AC 87 A2 11 04             brset   state3, #$11, L1794     ; Branch if notRotating or startingToCrank -> Always use airCntMax*8 in that case?                              
10887  F3B0             
10888  F3B0             
10889  F3B0                         ;-------------------------------------------------
10890  F3B0                         ; Engine is running, cap airCnt0 with airCntMax*8
10891  F3B0                         ;-------------------------------------------------
10892  F3B0 1D 8D                   cmpd1   airCnt0                 ;                                 
10893  F3B2 24 02                   bcc     L1795                   ; Branch if airCntMax*8 >= airCnt0                               
10894  F3B4 DD 8D       L1794       std     airCnt0                 ; Store airCntMax in airCnt0 
10895  F3B6             
10896  F3B6                         ;----------------------------------------------------------------------
10897  F3B6                         ; Update oldAirCnt0 if no pulse accumulator interrupts were received????
10898  F3B6                         ;----------------------------------------------------------------------
10899  F3B6 8F A2 02 04 L1795       brclr   state3, #$02, L1796     ; Branch if pulse accumulator interrupts are being received                               
10900  F3BA DC 8D                   ldd     airCnt0                 ; No pulse accumulator interrupts received, store airCnt0 in oldAirCnt0???                                 
10901  F3BC DD 92                   std     oldAirCnt0              ;                                    
10902  F3BE             
10903  F3BE                         ;-----------------------------------------
10904  F3BE                         ; Re-init airCntNew0, start a new cycle
10905  F3BE                         ;-----------------------------------------
10906  F3BE 4F          L1796       clra                                                         
10907  F3BF 5F                      clrb                                                         
10908  F3C0 DD 90                   std     airCntNew0     
10909  F3C2                          
10910  F3C2                         ;---------------------------------------------------------------------------------                  
10911  F3C2                         ; Execute the coil interrupt routine if an output capture interrupt is pending                       
10912  F3C2                         ;                                                                                                    
10913  F3C2                         ; Might be called from here because we are about to spend 
10914  F3C2                         ; a lot of time to calculate airflow and injectors???? I assume here
10915  F3C2                         ; that by doing so, the pending interrupt will be cleared?
10916  F3C2                         ;---------------------------------------------------------------------------------                                                              
10917  F3C2 8F 1A 40 03             brclr   t3_csr1, #$40, L1797   ; Branch if no interrupt pending                                   
10918  F3C6 BD FA 95                jsr     coilFunc                   ;                              
10919  F3C9             
10920  F3C9                         ;-------------------------------------------------------------------------------------
10921  F3C9                         ; Execute the pulse accumulator routine if an interrupt is pending
10922  F3C9                         ;
10923  F3C9                         ; At this point, airQuantum contains whatever air remains to be counted
10924  F3C9                         ; from the time the current CAS interrupt occured up to the time the next
10925  F3C9                         ; mas interrupt will happen (the next airflow sensor pulse). If the mas interrupt
10926  F3C9                         ; is pending then this air should already have been added. Do it now. I assume
10927  F3C9                         ; that by doing so, the pending interrupt will be cleared?
10928  F3C9                         ;
10929  F3C9                         ; If no interrupt is pending then the remaining air will be added when the
10930  F3C9                         ; next mas interrupt will occur, which is the normal way.
10931  F3C9                         ;
10932  F3C9                         ; In both cases airQuantum is re-initialized to its maximum value when masProc 
10933  F3C9                         ; is executed
10934  F3C9                         ;-------------------------------------------------------------------------------------
10935  F3C9 8F 18 80 03 L1797       brclr   t2_csr, #$80, L1798     ; Branch if no interrupt pending                                 
10936  F3CD BD F7 BE                jsr     masProc                 ;                              
10937  F3D0             
10938  F3D0                         ;------------------------------------------------------------------------------------
10939  F3D0                         ; Compute a kind of airCnt0 derivative (acceleration and decceleration)
10940  F3D0                         ; Update airDiffPos or airDiffNeg with airFlowDifference = abs(airCnt0-oldAirCnt0)
10941  F3D0                         ; airDiffPos is updated when airCnt0-oldAirCnt0 >= 0
10942  F3D0                         ; airDiffNeg is updated when airCnt0-oldAirCnt0 < 0
10943  F3D0                         ;------------------------------------------------------------------------------------
10944  F3D0 CE 00 94    L1798       ldx     #airDiffPos             ;                               
10945  F3D3 DC 8D                   ldd     airCnt0                 ; d = airCnt0                                
10946  F3D5 93 92                   subd    oldAirCnt0              ; d = airCnt0-oldAirCnt0                             
10947  F3D7 24 06                   bcc     L1799                   ; Branch if result positive
10948  F3D9 43                      coma                            ; Result negative, change sign                           
10949  F3DA 53                      comb                            ;                            
10950  F3DB C3 00 01                addd    #$0001                  ; d = oldAirCnt0-airCnt0
10951  F3DE 08                      inx                             ; x =  x + 1                           
10952  F3DF 4D          L1799       tsta                            ; Check for overflow in a (we want result in b only)                           
10953  F3E0 27 02                   beq     L1800                   ; Branch if a=0 (b contains difference)                             
10954  F3E2 C6 FF                   ldab    #$ff                    ; a not null->overflow, use b = maximum
10955  F3E4 E1 00       L1800       cmpb    $00,x                   ; 
10956  F3E6 23 02                   bls     L1801                   ; Branch if abs(airCnt0-oldAirCnt0) <= airDiffPos or airDiffNeg
10957  F3E8 E7 00                   stab    $00,x                   ; Store new value of airDiffPos or airDiffNeg
10958  F3EA                                                     
10959  F3EA                         ;---------------------------------------------------------------------------
10960  F3EA                         ; Decide what value we are going to use for injPw (0, injPwStart or normal)
10961  F3EA                         ;---------------------------------------------------------------------------
10962  F3EA 8F A2 01 05 L1801       brclr   state3, #$01, L1802     ; Branch if startingToCrank clear                                
10963  F3EE FC 01 00                ldd     injPwStart              ; Engine startingToCrank, use injPwStart                              
10964  F3F1 20 06                   bra     L1803                   ; Do not compute injPw from airflow                              
10965  F3F3 8F A2 3C 06 L1802       brclr   state3, #$3c, L1804     ; startingToCrank clear, branch to compute normal injPw from airflow if all clear: "rotatingStopInj but not runningFast" and "notRotating" and "rotatingStopInj" and "rev limiter active"
10966  F3F7 4F                      clra                            ; Use injPw=0 if rev limiter is active or if engine is notRotating, rotatingStopInj or "rotatingStopInj and not runningFast" 
10967  F3F8 5F                      clrb                            ;                             
10968  F3F9 DD A7       L1803       std     injPw                   ;                              
10969  F3FB 20 2E                   bra     L1807                   ;                              
10970  F3FD             
10971  F3FD             
10972  F3FD                         ;----------------------------------------------------------------
10973  F3FD                         ; Compute injector pulsewidth for normal engine conditions
10974  F3FD                         ;
10975  F3FD                         ; injPw =  [airCnt0:airCnt1] * injFactor/256, 16 bit multiply
10976  F3FD                         ;----------------------------------------------------------------
10977  F3FD 96 8E       L1804       ldaa    airCnt1                 ; a = airCnt1                                 
10978  F3FF D6 A4                   ldab    injFactor+1             ; b = injFactor1                                    
10979  F401 3D                      mul                             ; d = airCnt1*injFactor1                             
10980  F402 16                      tab                             ; b = airCnt1*injFactor1/256                             
10981  F403 4F                      clra                            ; d = airCnt1*injFactor1/256                            
10982  F404 DD A7                   std     injPw                   ; injPw = airCnt1*injFactor1/256                              
10983  F406 96 8E                   ldaa    airCnt1                 ;                                 
10984  F408 D6 A3                   ldab    injFactor               ;                                  
10985  F40A 3D                      mul                             ;                             
10986  F40B D3 A7                   addd    injPw                   ;                              
10987  F40D 25 18                   bcs     L1805                   ;                              
10988  F40F DD A7                   std     injPw                   ;                              
10989  F411 96 8D                   ldaa    airCnt0                 ;                                 
10990  F413 D6 A4                   ldab    injFactor+1             ;                                    
10991  F415 3D                      mul                             ;                             
10992  F416 D3 A7                   addd    injPw                   ;                              
10993  F418 25 0D                   bcs     L1805                   ;                              
10994  F41A DD A7                   std     injPw                   ;                              
10995  F41C 96 8D                   ldaa    airCnt0                 ;                                 
10996  F41E D6 A3                   ldab    injFactor               ;                                  
10997  F420 3D                      mul                             ;                             
10998  F421 DB A7                   addb    injPw                   ;                              
10999  F423 89 00                   adca    #$00                    ; Propagate carry                            
11000  F425 27 02                   beq     L1806                   ; Branch if no overflow                             
11001  F427 C6 F0       L1805       ldab    #$f0                    ; Overflow, use max of ~$f000 (61ms) in case of overflow                             
11002  F429 D7 A7       L1806       stab    injPw                   ;                              
11003  F42B             
11004  F42B                         ;----------------------
11005  F42B                         ; Compute accEnrDiffT
11006  F42B                         ;----------------------
11007  F42B CE FF 1C    L1807       ldx     #L2040                   ; x points to L2040                              
11008  F42E D6 92                   ldab    oldAirCnt0               ; b = oldAirCnt0/256 (high part only...)                                  
11009  F430 C1 05                   cmpb    #$05                     ;                            
11010  F432 25 02                   bcs     L1808                    ; Branch if below max                            
11011  F434 C6 05                   ldab    #$05                     ; Use max                           
11012  F436 3A          L1808       abx                              ; x = L2040 + min(oldAirCnt0, 5)                            
11013  F437 E6 00                   ldab    $00,x                    ; b = L2040(oldAirCnt0/256)                            
11014  F439 F7 01 0C                stab    accEnrDiffT              ; accEnrDiffT = L2040(oldAirCnt0/256)                             
11015  F43C             
11016  F43C                         ;------------------------------------------------------------------------
11017  F43C                         ; Update accEnr
11018  F43C                         ;
11019  F43C                         ; At first accEnr is decreased by a fixed factor (exponentially)
11020  F43C                         ; on each iteration. When it reaches a certain level, it this 
11021  F43C                         ; then held constant for the duration of a timer and then 
11022  F43C                         ; decremented by 1 to 0. First do the exponential part...
11023  F43C                         ;------------------------------------------------------------------------
11024  F43C D6 A1                   ldab    accEnr                  ; b = accEnr                             
11025  F43E 27 17                   beq     L1811                   ; Branch if accEnr = 0                            
11026  F440 B6 01 03                ldaa    accEnrDecay             ; a = accEnrDecay                            
11027  F443 3D                      mul                             ; d = accEnrDecay * accEnr                           
11028  F444 16                      tab                             ; b = accEnr * accEnrDecay/256                            
11029  F445 96 A1                   ldaa    accEnr                  ; a = accEnr                             
11030  F447 10                      sba                             ; a = accEnrNew = accEnr - accEnr * accEnrDecay/256 = accEnr * (1-accEnrDecay/256)                             
11031  F448 81 02                   cmpa    #$02                    ;                            
11032  F44A 24 0B                   bcc     L1811                   ; Branch if accEnrNew >= 2                            
11033  F44C             
11034  F44C                         ;-------------------------------------------------------------------
11035  F44C                         ; accEnr - accEnr * accEnrDecay/256 < 2 (which means accEnr much bigger than 2)
11036  F44C                         ; Just decrement accEnr by 1 if  accEnrTmr2=0 else don't change it
11037  F44C                         ;
11038  F44C                         ; Basically hold the accEnr to current value for 4 or 5 iterations 
11039  F44C                         ; and then start decrease it by 1 to 0
11040  F44C                         ;-------------------------------------------------------------------
11041  F44C B6 01 0D                ldaa    accEnrTmr2              ; 
11042  F44F 27 03                   beq     L1810                   ;                             
11043  F451 4A                      deca                            ;                            
11044  F452 26 0F                   bne     L1812                   ;                             
11045  F454 D6 A1       L1810       ldab    accEnr                  ;                              
11046  F456 5A                      decb                            ;                            
11047  F457 D7 A1       L1811       stab    accEnr                  ;                              
11048  F459             
11049  F459                         ;----------------------------------
11050  F459                         ; Update accEnrTmr2 from ect
11051  F459                         ;----------------------------------
11052  F459 86 04                   ldaa    #$04                    ; a = 4                           
11053  F45B D6 D3                   ldab    ectFiltered             ; b = ectFiltered                                  
11054  F45D C1 80                   cmpb    #$80                    ; 21degC                             
11055  F45F 25 02                   bcs     L1812                   ; Branch if temperature(ectFiltered) >= 21degC
11056  F461 86 05                   ldaa    #$05                    ; temperature <21degC                           
11057  F463 B7 01 0D    L1812       staa    accEnrTmr2              ; re-init accEnrTmr2 with 5                            
11058  F466             
11059  F466                         ;--------------------------------------
11060  F466                         ; Decrement accEnrTimer if not yet 0
11061  F466                         ;--------------------------------------
11062  F466 B6 01 04                ldaa    accEnrTimer             ; 
11063  F469 27 04                   beq     L1813                   ; Branch if accEnrTimer = 0                             
11064  F46B 4A                      deca                            ;                             
11065  F46C B7 01 04                staa    accEnrTimer             ;                              
11066  F46F             
11067  F46F                         ;---------------------------------------------------
11068  F46F                         ; Re-init accEnrTimer to 4 if airCnt0>=accEnrMinAf 
11069  F46F                         ;---------------------------------------------------
11070  F46F DC 8D       L1813       ldd     airCnt0                 ;                                 
11071  F471 1F 01 05                cmpd    accEnrMinAf             ;                                     
11072  F474 24 05                   bcc     L1814                   ; Branch if airCnt0>=accEnrMinAf 
11073  F476 86 04                   ldaa    #$04                    ;                              
11074  F478 B7 01 04                staa    accEnrTimer             ; re-init accEnrTimer = 4                              
11075  F47B             
11076  F47B                         ;----------------------------
11077  F47B                         ; Bail if engine not running 
11078  F47B                         ;----------------------------
11079  F47B 8F A2 13 06 L1814       brclr   state3, #$13, L1815     ; Branch if notRotating and startingToCrank and "no pulse accumulator interrupts" clear                               
11080  F47F 7F 00 A1                clr     accEnr                  ; One of them set, no accEnr should be applied
11081  F482 7E F5 0A                jmp     L1825                   ; Bail                              
11082  F485             
11083  F485                         ;---------------------------------------------------
11084  F485                         ; Skip section if injPw==0
11085  F485                         ;---------------------------------------------------
11086  F485 DC A7       L1815       ldd     injPw                   ;                              
11087  F487 26 03                   bne     L1816                   ; Branch if injPw !=0                             
11088  F489 7E F5 0A                jmp     L1825                   ; Bail                              
11089  F48C             
11090  F48C                         ;---------------------------------------------------
11091  F48C                         ; Section to factor acceleration/deceleration enrichment
11092  F48C                         ; to injPw (when injPw!=0)
11093  F48C                         ;---------------------------------------------------
11094  F48C                         ;---------------------------------------------------
11095  F48C                         ; Compute diff = airCnt0-oldAirCnt0
11096  F48C                         ; Check if positive or negative
11097  F48C                         ;---------------------------------------------------
11098  F48C 7F 01 07    L1816       clr     decEnr                  ; Assume decEnr = 0
11099  F48F DC 8D                   ldd     airCnt0                 ; d = airCnt0                                 
11100  F491 93 92                   subd    oldAirCnt0              ; d = airCnt0-oldAirCnt0                                   
11101  F493 25 1F                   bcs     L1820                   ; Branch if result negative                             
11102  F495             
11103  F495                         ;---------------------------------------------------
11104  F495                         ; diff>=0 (airCnt0 increased or is unchanged)
11105  F495                         ; Check if conditions are met to apply acceleration enrichment
11106  F495                         ;---------------------------------------------------
11107  F495 7D 01 04                tst     accEnrTimer             ; Check if timer expired
11108  F498 27 18                   beq     L1819                   ; Bail if accEnrTimer expired (airflow has been below absolute threshold for more than 4 iterations)                             
11109  F49A 87 06 80 14             brset   port3, #$80, L1819      ; Bail if idle switch is on                              
11110  F49E             
11111  F49E                         ;----------------------------------
11112  F49E                         ; Check diff against max of $48
11113  F49E                         ;----------------------------------
11114  F49E 4D                      tsta                            ; test hi part of diff                            
11115  F49F 26 04                   bne     L1817                   ; Branch if diff >=256 (hi(diff)!=0) -> use $48                             
11116  F4A1 C1 48                   cmpb    #$48                    ; diff <256 check low part against $48                           
11117  F4A3 25 02                   bcs     L1818                   ; Branch if diff <$48                                
11118  F4A5 C6 48       L1817       ldab    #$48                    ; use $48                             
11119  F4A7             
11120  F4A7                         ;---------------------------------------------------------------------------
11121  F4A7                         ; At this point b contains diff=min(airCnt0-oldAirCnt0,$48)
11122  F4A7                         ;
11123  F4A7                         ; Update accEnr with diff if diff is big enough (big increase in airflow)
11124  F4A7                         ; and higher than old accEnr
11125  F4A7                         ;---------------------------------------------------------------------------
11126  F4A7 F1 01 0C    L1818       cmpb    accEnrDiffT             ;                              
11127  F4AA 23 06                   bls     L1819                   ; Branch if diff<=accEnrDiffT                             
11128  F4AC D1 A1                   cmpb    accEnr                  ; diff>accEnrDiffT store new value if higher than old one                             
11129  F4AE 23 02                   bls     L1819                   ;                              
11130  F4B0 D7 A1                   stab    accEnr                  ; accEnr = min(airCnt0-oldAirCnt0,$48)
11131  F4B2 20 1B       L1819       bra     L1822                   ;                              
11132  F4B4             
11133  F4B4                         ;---------------------------------------------------------
11134  F4B4                         ;
11135  F4B4                         ;
11136  F4B4                         ; airCnt0 decreased check if below absolute threshold
11137  F4B4                         ;
11138  F4B4                         ;
11139  F4B4                         ;---------------------------------------------------------
11140  F4B4 DC 8D       L1820       ldd     airCnt0                 ; d = airCnt0                               
11141  F4B6 1F 01 05                cmpd    accEnrMinAf             ;                              
11142  F4B9 24 14                   bcc     L1822                   ; Bail if airCnt0 >= accEnrMinAf                            
11143  F4BB             
11144  F4BB                         ;---------------------------------------------------------
11145  F4BB                         ; airCnt0 decreased and is below absolute threshold
11146  F4BB                         ; compute diff = min(airCnt0-oldAirCnt0,$ff)
11147  F4BB                         ;---------------------------------------------------------
11148  F4BB DC 92                   ldd     oldAirCnt0              ;                                    
11149  F4BD 93 8D                   subd    airCnt0                 ; d = oldAirCnt0-airCnt0                                
11150  F4BF 4D                      tsta                            ; test hi part (diff>=256?)                            
11151  F4C0 27 02                   beq     L1821                   ; Branch if below max
11152  F4C2 C6 FF                   ldab    #$ff                    ; Use max of $ff                            
11153  F4C4             
11154  F4C4                         ;---------------------------------------------------------------------------
11155  F4C4                         ; Clear accEnr if diff is big enough (big decrease in airflow)
11156  F4C4                         ; At this point b contsains diff=min(airCnt0-oldAirCnt0,$ff)
11157  F4C4                         ;---------------------------------------------------------------------------
11158  F4C4 F1 01 0C    L1821       cmpb    accEnrDiffT             ;                              
11159  F4C7 23 06                   bls     L1822                   ;                              
11160  F4C9 F7 01 07                stab    decEnr                  ; decEnr = min(airCnt0-oldAirCnt0,$ff)
11161  F4CC 7F 00 A1                clr     accEnr                  ; accEnr = 0                              
11162  F4CF             
11163  F4CF                         ;---------------------------------------------------
11164  F4CF                         ; Section to add acceleration enrichment to injPw or
11165  F4CF                         ; reduce it in case of deceleration
11166  F4CF                         ;
11167  F4CF                         ; Check if min(airCnt0-oldAirCnt0,$ff) >0
11168  F4CF                         ;---------------------------------------------------
11169  F4CF F6 01 07    L1822       ldab    decEnr                  ; 
11170  F4D2 26 18                   bne     L1823                   ; Branch if decEnr > 0 (reduce injPw)                            
11171  F4D4             
11172  F4D4                         ;---------------------------------------------------------------
11173  F4D4                         ; decEnr = 0, increase or do not change injPw
11174  F4D4                         ;
11175  F4D4                         ; Apply enrichment: 
11176  F4D4                         ;     injPw = injPw + accEnr*accEnrFact/256
11177  F4D4                         ;           = injPw + 8 * min(airCnt0-oldAirCnt0,$48) * injMasComp/256 * t_accEnr1(rpm)/128 * [t_accEnr2a(ect) or t_accEnr2b(ect)]/128 * baroFact/128
11178  F4D4                         ;---------------------------------------------------------------
11179  F4D4 96 A1                   ldaa    accEnr                  ; a = accEnr                               
11180  F4D6 F6 01 08                ldab    accEnrFact              ; b = accEnrFact                            
11181  F4D9 3D                      mul                             ; d = accEnr * accEnrFact                             
11182  F4DA 1A                      xgdx                            ; x = accEnr * accEnrFact                           
11183  F4DB 96 A1                   ldaa    accEnr                  ;                               
11184  F4DD F6 01 09                ldab    accEnrFact+1            ;                              
11185  F4E0 3D                      mul                             ; d = accEnr * L0109                            
11186  F4E1 16                      tab                             ; b = accEnr * L0109/256                            
11187  F4E2 3A                      abx                             ; x = accEnr * accEnrFact +  accEnr * L0109/256 = accEnr*(accEnrFact + L0109/256)                            
11188  F4E3 1A                      xgdx                            ; d = accEnr*(accEnrFact + L0109/256)
11189  F4E4 D3 A7                   addd    injPw                   ; d = injPw + accEnr*accEnrFact/256
11190  F4E6 24 20                   bcc     L1824                   ; Bail if no overflow                             
11191  F4E8 86 F0                   ldaa    #$f0                    ; Overflow, use max of $f000                            
11192  F4EA 20 1C                   bra     L1824                   ; Bail
11193  F4EC                                                       
11194  F4EC                         ;---------------------------------------------------
11195  F4EC                         ; decEnr > 0. decrease injPw
11196  F4EC                         ;
11197  F4EC                         ; Apply reduction 
11198  F4EC                         ;      injPw = injPw - decEnr*decEnrFact/256
11199  F4EC                         ;            = injPw +  8 * min(airCnt0-oldAirCnt0,$ff) * injMasComp/256 * t_decEnr1(rpm)/128 * t_decEnr2(ect)/128 * baroFact/128
11200  F4EC                         ;---------------------------------------------------
11201  F4EC B6 01 07    L1823       ldaa    decEnr                  ; a = decEnr                             
11202  F4EF F6 01 0A                ldab    decEnrFact              ; b = decEnrFact                             
11203  F4F2 3D                      mul                             ; d = decEnr * decEnrFact                               
11204  F4F3 1A                      xgdx                            ; x = decEnr * decEnrFact                            
11205  F4F4 B6 01 07                ldaa    decEnr                  ;                              
11206  F4F7 F6 01 0B                ldab    decEnrFact+1            ;                              
11207  F4FA 3D                      mul                             ; d = decEnr * L010b                            
11208  F4FB 16                      tab                             ; b = decEnr * L010b/256                            
11209  F4FC 3A                      abx                             ; x = decEnr * decEnrFact + decEnr * L010b/256                            
11210  F4FD DF 5E                   stx     temp8                   ; temp8:dTemp2 = decEnr * decEnrFact + decEnr * L010b/256  = decEnr*(decEnrFact+L010b/256)                             
11211  F4FF DC A7                   ldd     injPw                   ; d = injPw                             
11212  F501 93 5E                   subd    temp8                   ; d = injPw - decEnr*decEnrFact/256                               
11213  F503 22 03                   bhi     L1824                   ; Bail if positive                             
11214  F505 4F                      clra                            ;                             
11215  F506 C6 01                   ldab    #$01                    ; Use min of $0001                            
11216  F508 DD A7       L1824       std     injPw                   ; Update injPw                             
11217  F50A             
11218  F50A                         ;---------------------------------------------------
11219  F50A                         ; Skip section if injPw==0
11220  F50A                         ;---------------------------------------------------
11221  F50A DC A7       L1825       ldd     injPw                   ;                              
11222  F50C 26 03                   bne     L1826                   ; Branch to do section when injPw!=0                            
11223  F50E 7E F5 E4                jmp     L1845                   ; bail to next section                            
11224  F511             
11225  F511                         ;--------------------------------------------------------
11226  F511                         ; injPw != 0, increment injCount if not already at max(255)
11227  F511                         ;--------------------------------------------------------
11228  F511 7C 01 86    L1826       inc     injCount                ;                                 
11229  F514 26 03                   bne     L1827                   ; Branch if injCount!=0                               
11230  F516 7A 01 86                dec     injCount                ; injCount was 255 and is now 0, go back to max of 255                                
11231  F519             
11232  F519                         ;-------------------------------------------------
11233  F519                         ; Load injPw in d and divide by 4 if necessary???
11234  F519                         ;-------------------------------------------------
11235  F519 7F 00 B5    L1827       clr     newInjToAct               ; newInjToAct = 0                               
11236  F51C DC A7                   ldd     injPw                     ;                              
11237  F51E 87 A2 80 06             brset   state3, #$80, L1828       ; Branch if startingToCrankColdEngine                                
11238  F522 8F B3 07 05             brclr   tdcCasFlags, #$07, L1829  ; Branch if down counter = 0 (first TDC on cyl. #1 was already encoutered)                               
11239  F526             
11240  F526                         ;-------------------------------------------------------------------------------
11241  F526                         ; Seems we are startingToCrank (TDC #1 not yet encountered) but engine is 
11242  F526                         ; not cold so divide injPw by 4 since the value it constains(injPwStart) 
11243  F526                         ; was multiplied by 4 in injPwStart culculations, why???
11244  F526                         ;-------------------------------------------------------------------------------
11245  F526 04                      lsrd                            ; 
11246  F527 04                      lsrd                            ; d = injPw/4 = injPwStart                              
11247  F528 03 B5 80    L1828       orm     newInjToAct, #$80       ; Set flag indicating we should be doing simultaneous injection
11248  F52B             
11249  F52B                         ;-------------------------------------------------------
11250  F52B                         ; Add injector deadtime and check for max and min value
11251  F52B                         ;-------------------------------------------------------
11252  F52B BD F7 AB    L1829       jsr     addDeadtime             ; Add deadtime to d
11253  F52E 81 EA                   cmpa    #$ea                    ;                             
11254  F530 25 03                   bcs     L1830                   ; Branch if d < $ea00
11255  F532 86 EA                   ldaa    #$ea                    ;                             
11256  F534 5F                      clrb                            ; Too big, use max of d=$ea00 (60ms)                            
11257  F535 1C 05 14    L1830       cmpd    #$0514                  ;                               
11258  F538 24 03                   bcc     L1831                   ; Branch if above minimum                              
11259  F53A CC 05 14                ldd     #$0514                  ; Too small, use minimum of d=$0514 (1.3ms)                               
11260  F53D DD A7       L1831       std     injPw                   ; Store new value
11261  F53F             
11262  F53F                         ;--------------------------------------------------------------------------------
11263  F53F                         ; Schedule all 4 injector interrupts and bail if in simultaneous injection mode
11264  F53F                         ;--------------------------------------------------------------------------------
11265  F53F 8F B5 80 09             brclr   newInjToAct, #$80, L1832 ; Branch if sequential injection                                
11266  F543 03 B5 0F                orm     newInjToAct, #$0f        ; Simultaneous injection, set mask corresponding to all 4 injectors
11267  F546 BD F7 63                jsr     schedInjSim              ; Schedule simultaneous injection interrupts                             
11268  F549 7E F5 E4                jmp     L1845                    ; Bail to exit routine
11269  F54C             
11270  F54C                         ;---------------------------------------------------
11271  F54C                         ; At this point we are in sequential injection mode
11272  F54C                         ;---------------------------------------------------
11273  F54C                         ;------------------------------------------------------------------------------------
11274  F54C                         ; Get the injector mask of the injector to activate for this particular CAS interrupt
11275  F54C                         ; Injector for cylinder #1 starts injecting on the CAS falling edge of cylinder #3, 
11276  F54C                         ; i.e. at the end on #1 combustion cycle/start of #1 exhaust cycle
11277  F54C                         ;
11278  F54C                         ;   casCylIndex   Cylinder number   Injector number       mask
11279  F54C                         ;                 having its TDC    to activate on
11280  F54C                         ;                 closest to CAS    CAS falling edge
11281  F54C                         ;                 falling edge       
11282  F54C                         ;        0             1                  2                $08
11283  F54C                         ;        1             3                  1                $01
11284  F54C                         ;        2             4                  3                $02
11285  F54C                         ;        3             2                  4                $04
11286  F54C                         ;
11287  F54C                         ;------------------------------------------------------------------------------------
11288  F54C CE F6 0F    L1832       ldx     #t_cylMask              ; table content: [$08 $01 $02 $04] -> injector numbers: 2 1 3 4                            
11289  F54F D6 B4                   ldab    casCylIndex             ; b = casCylIndex                             
11290  F551 3A                      abx                             ; x = t_cylMask + casCylIndex                            
11291  F552 A6 00                   ldaa    $00,x                   ; a has one bit set to indicate which injector to use (one of $08 $01 $02 $04)                            
11292  F554             
11293  F554                         ;-------------------------------------------------------
11294  F554                         ; Reset the mask if engine not running or if
11295  F554                         ; disabled by an obd command or if ignition is not happening
11296  F554                         ;-------------------------------------------------------
11297  F554 87 A2 11 06             brset   state3, #$11, L1833        ; Branch if notRotating or startingToCrank                                
11298  F558 8F 85 80 02             brclr   coilChkFlags, #$80, L1833  ; Branch if no ignition error found
11299  F55C 94 85                   anda    coilChkFlags               ; Reset the injectors corresponding to missing ignition signal
11300  F55E 94 BA       L1833       anda    obdInjCmd                  ; Reset injector if disabled by OBD command                            
11301  F560             
11302  F560                         ;-------------------------------------------------------
11303  F560                         ; Update newInjToAct, injToAct and last_t1t2_clk
11304  F560                         ;-------------------------------------------------------
11305  F560 97 B5                   staa    newInjToAct             ; newInjToAct = injector to activate                               
11306  F562 9A B2                   oraa    injToAct                ;                                
11307  F564 97 B2                   staa    injToAct                ; injToAct = injToAct | newInjToAct
11308  F566 96 09                   ldaa    t1t2_clk                ;                                 
11309  F568 97 B1                   staa    last_t1t2_clk           ; last_t1t2_clk = t1t2_clk/256 (current timer 1 clock?)                              
11310  F56A             
11311  F56A                         ;----------------------------------------------------------------
11312  F56A                         ; Branch to section depending on new injector to activate
11313  F56A                         ;----------------------------------------------------------------
11314  F56A 87 B5 0A 3E             brset   newInjToAct, #$0a, L1839   ; Branch if injector to activate is #2 or #3                                 
11315  F56E 8F B5 05 72             brclr   newInjToAct, #$05, L1845   ; Bail if remaining injector #1 and #4 don't need activation either                                
11316  F572             
11317  F572                         ;----------------------------------------------------------------
11318  F572                         ; Injector to activate is #1 or #4, check if already activated
11319  F572                         ;----------------------------------------------------------------
11320  F572 8F 03 02 04 L1833b      brclr   port2, #$02, L1834      ; Branch if injector #1 activated (reverse logic)                               
11321  F576 87 02 08 24             brset   port1, #$08, L1838      ; Branch if injector #4 deactivated (reverse logic)
11322  F57A             
11323  F57A                         ;------------------------------------------------------------------------------
11324  F57A                         ; Injector #1 or #4 already activated
11325  F57A                         ;
11326  F57A                         ; Check how much time remains before next interrupt occurs
11327  F57A                         ;------------------------------------------------------------------------------
11328  F57A DC 0B       L1834       ldd     t1_outCmpWr             ; d = nextInterruptTime                                   
11329  F57C 93 09                   subd    t1t2_clk                ; remainingTime  = d = nextInterruptTime - t1t2_clk                                  
11330  F57E 1C 00 32                cmpd    #$0032                  ;                               
11331  F581 25 09                   bcs     L1835                   ; Branch if remainingTime < $0032 (50us)                            
11332  F583 1C 00 C8                cmpd    #$00c8                  ;                               
11333  F586 24 08                   bcc     L1836                   ; Branch if remainingTime >= $00c8 (200us)                             
11334  F588             
11335  F588                         ;--------------------------------------------------------
11336  F588                         ; 50us <= remainingTime < 200us, remaining time before the
11337  F588                         ; next interrupt is long enough to allow us to do something 
11338  F588                         ; but is not so long that activation will be too late...
11339  F588                         ;
11340  F588                         ; Enable injector activation bit and compute deactivation 
11341  F588                         ; time as  nextInterruptTime + injPw Since the injector 
11342  F588                         ; will be enabled when the interrupt occur, very shortly.
11343  F588                         ; Then exit this interrupt.
11344  F588                         ;--------------------------------------------------------
11345  F588 8D 5B                   bsr     actDeact14             ; Enable injector activation bit and compute deactivation time                                   
11346  F58A 20 58                   bra     L1845                  ; Bail of interrupt                            
11347  F58C             
11348  F58C                         ;--------------------------------------------------------
11349  F58C                         ; remainingTime < $0032 (50us). remaining time before the
11350  F58C                         ; next interrupt is too short to do what we need to do... 
11351  F58C                         ; just wait for the interrupt to occur using an infinite 
11352  F58C                         ; loop (5000 cycles max assuming 1Mcycles/sec)
11353  F58C                         ;--------------------------------------------------------
11354  F58C 8F 08 40 FC L1835       brclr   t1_csr, #$40, L1835     ;                                
11355  F590                         ;--------------------------------------------------------------------------------
11356  F590                         ; Interrupt has been triggered we can now proceed with activation
11357  F590                         ;--------------------------------------------------------------------------------
11358  F590             
11359  F590                         ;------------------------------------------------------------------------------------
11360  F590                         ; At this point the remainingTime before the next interrupt is larger than 200us
11361  F590                         ; or it was smaller than 50us but we waited for the interrupt to occur. In both
11362  F590                         ; cases, we are certain an interrupt will no happen right away, just do what needs 
11363  F590                         ; doing...
11364  F590                         ;------------------------------------------------------------------------------------
11365  F590                         ;---------------------------------------------------------------------------
11366  F590                         ; First check if an injector is already activated and if so, just reflect 
11367  F590                         ; that fact in the activation bits (such that we don't change that injector
11368  F590                         ; state when we activate a new injector...)???
11369  F590                         ;---------------------------------------------------------------------------
11370  F590 87 03 02 03 L1836       brset   port2, #$02, L1837      ; Branch if injector #1 is deactivated                                
11371  F594 02 08 FE                andm    t1_csr, #$fe            ; injector #1 is activated, enable activation bit for it
11372  F597 87 02 08 03 L1837       brset   port1, #$08, L1838      ; Branch if injector #4 is deactivated                              
11373  F59B 02 18 DF                andm    t2_csr, #$df            ; injector #4 is activated, enable activation bit for it
11374  F59E             
11375  F59E                         ;-----------------------------------------------------------------
11376  F59E                         ; Enable the activation bit for the new injector #1 or #4.
11377  F59E                         ; Schedule an interrupt for "now + 22us" to activate them.
11378  F59E                         ; Compute its deactivation time and schedule an interrupt for it
11379  F59E                         ;
11380  F59E                         ; I assume here that the 22us delay is small enough that it ensures
11381  F59E                         ; the injector activation will occur before the deactivation is scheduled???
11382  F59E                         ; not sure if interrupt subroutine is called in that case since we are 
11383  F59E                         ; already in interrupt??????????? 
11384  F59E                         ;-----------------------------------------------------------------
11385  F59E DC 09       L1838       ldd     t1t2_clk                ; d = t1t2_clk (current time)                                  
11386  F5A0 C3 00 16                addd    #$0016                  ; activationTime   d = t1t2_clk + $16 (22us)
11387  F5A3 DD 0B                   std     t1_outCmpWr             ; Schedule interrupt at t1_outCmpWr = t1t2_clk + $16, i.e. activationTime = now + 22us                                  
11388  F5A5 8D 3E                   bsr     actDeact14              ; Enable new injector activation bit and compute deactivation time                                   
11389  F5A7 BD F6 2B                jsr     schedDeact14            ; Schedule deactivation time                            
11390  F5AA 20 38                   bra     L1845                   ; Bail
11391  F5AC                                                                     
11392  F5AC                         ;-----------------------------------------------------
11393  F5AC                         ; Injector to activate is #2 or #3 
11394  F5AC                         ; Logic is identical to #1 #4 injectors 
11395  F5AC                         ; above starting at L1833b ......
11396  F5AC                         ;-----------------------------------------------------
11397  F5AC 8F 02 02 04 L1839       brclr   port1, #$02, L1840      ; Injector 3                               
11398  F5B0 87 02 04 24             brset   port1, #$04, L1844      ; Injector 2                               
11399  F5B4 DC 1B       L1840       ldd     t2_outCmpWr             ;                                    
11400  F5B6 93 09                   subd    t1t2_clk                ;                                 
11401  F5B8 1C 00 32                cmpd    #$0032                  ;                               
11402  F5BB 25 09                   bcs     L1841                   ;                              
11403  F5BD 1C 00 C8                cmpd    #$00c8                  ;                               
11404  F5C0 24 08                   bcc     L1842                   ;                              
11405  F5C2 8D 36                   bsr     actDeact23              ;                                   
11406  F5C4 20 1E                   bra     L1845                   ; 
11407  F5C6 8F 18 40 FC L1841       brclr   t2_csr, #$40, L1841     ; Infinite loop waiting for interrupt to be triggered                               
11408  F5CA 87 02 02 03 L1842       brset   port1, #$02, L1843      ; 
11409  F5CE 02 18 FE                andm    t2_csr, #$fe            ; 
11410  F5D1 87 02 04 03 L1843       brset   port1, #$04, L1844      ; 
11411  F5D5 02 18 FB                andm    t2_csr, #$fb            ; 
11412  F5D8 DC 09       L1844       ldd     t1t2_clk                ;                                 
11413  F5DA C3 00 16                addd    #$0016                  ;                               
11414  F5DD DD 1B                   std     t2_outCmpWr             ;                                    
11415  F5DF 8D 19                   bsr     actDeact23              ;                                   
11416  F5E1 BD F6 88                jsr     schedDeact23            ;                                     
11417  F5E4             
11418  F5E4                         ;-------
11419  F5E4                         ; Exit
11420  F5E4                         ;-------
11421  F5E4 3B          L1845       rti                             ;                             
11422  F5E5                                                                                ; 
11423  F5E5             
11424  F5E5             ;******************************************************************
11425  F5E5             ;
11426  F5E5             ; Enable injector activation bit for injector #1 or #4
11427  F5E5             ; and calculate the corresponding injector deactivation time
11428  F5E5             ;
11429  F5E5             ;
11430  F5E5             ;
11431  F5E5             ;******************************************************************
11432  F5E5 DC 0B       actDeact14  ldd     t1_outCmpWr              ; 
11433  F5E7 D3 A7                   addd    injPw                    ; d = t1_outCmpWr + injPw                             
11434  F5E9 87 B5 04 07             brset   newInjToAct, #$04, L1847 ; Branch if inj #4 needs activation
11435  F5ED             
11436  F5ED                         ;--------------------------------
11437  F5ED                         ; Injector #1 needs activation
11438  F5ED                         ;--------------------------------
11439  F5ED 02 08 FE                andm    t1_csr, #$fe            ; Reset injector #1 bit                                 
11440  F5F0 DD A9                   std     inj1_offT               ; inj1_offT = t1_outCmpWr + injPw                             
11441  F5F2 20 05                   bra     L1848                   ; Bail                             
11442  F5F4             
11443  F5F4                         ;--------------------------------
11444  F5F4                         ; Injector #4 needs activation
11445  F5F4                         ;--------------------------------
11446  F5F4 02 18 DF    L1847       andm    t2_csr, #$df            ; Reset injector #4 bit                                 
11447  F5F7 DD AD                   std     inj4_offT               ; inj4_offT = t1_outCmpWr + injPw                             
11448  F5F9 39          L1848       rts                             ;                             
11449  F5FA             
11450  F5FA             
11451  F5FA             
11452  F5FA             ;******************************************************************
11453  F5FA             ;
11454  F5FA             ; Enable injector activation bit for injector #1 or #4
11455  F5FA             ; and calculate the corresponding injector deactivation time
11456  F5FA             ;
11457  F5FA             ;
11458  F5FA             ;
11459  F5FA             ;******************************************************************
11460  F5FA DC 1B       actDeact23  ldd     t2_outCmpWr              ;                                                        
11461  F5FC D3 A7                   addd    injPw                     ; d = t1_outCmpWr + injPw                                                        
11462  F5FE 87 B5 08 07             brset   newInjToAct, #$08, L1850  ;                                                        
11463  F602             
11464  F602                         ;--------------------------------
11465  F602                         ; Injector #3 needs activation
11466  F602                         ;--------------------------------
11467  F602 02 18 FE                andm    t2_csr, #$fe            ; Reset injector #3 bit (enable output compare interrupt???)                                   
11468  F605 DD AB                   std     inj3_offT               ;                                                       
11469  F607 20 05                   bra     L1851                   ;                                                       
11470  F609             
11471  F609                         ;--------------------------------
11472  F609                         ; Injector #2 needs activation
11473  F609                         ;--------------------------------
11474  F609 02 18 FB    L1850       andm    t2_csr, #$fb            ; Reset injector #2 bit                                    
11475  F60C DD AF                   std     inj2_offT               ;                                                       
11476  F60E 39          L1851       rts                             ;                                                      
11477  F60F             
11478  F60F             
11479  F60F             
11480  F60F             ;******************************************************************
11481  F60F             ;
11482  F60F             ; Table used to determine which cylinder/injector the current 
11483  F60F             ; CAS interrupt corresponds to. The table contains injector bit masks 
11484  F60F             ;
11485  F60F             ;
11486  F60F             ; t_cylMask[casCylIndex] -> cylinder numbers: 2 1 3 4                            
11487  F60F             ;
11488  F60F             ;
11489  F60F             ;******************************************************************
11490  F60F 08 01 02 04 t_cylMask       .byte   $08, $01, $02, $04
11491  F613             
11492  F613             
11493  F613             
11494  F613             ;******************************************************************
11495  F613             ;
11496  F613             ; Output compare interrupt1 
11497  F613             ;
11498  F613             ; Triggered by injector #1 and #4 activation/deactivation
11499  F613             ;
11500  F613             ;
11501  F613             ;******************************************************************
11502  F613 96 08       outCompInt1 ldaa    t1_csr                  ; Ack interrupt?                              
11503  F615 DC 0B                   ldd     t1_outCmpWr             ; 
11504  F617 DD 0B                   std     t1_outCmpWr             ; Flush the output compare value that triggered the current interrupt??? 
11505  F619 BD F6 2B                jsr     schedDeact14            ; Schedule deactivation time
11506  F61C             
11507  F61C                         ;------------------------------------------
11508  F61C                         ; Branch to execute rest of subroutine...
11509  F61C                         ;------------------------------------------
11510  F61C 20 09                   bra     L1855                                                 
11511  F61E             
11512  F61E             
11513  F61E             
11514  F61E             ;******************************************************************
11515  F61E             ;
11516  F61E             ; Output compare interrupt2
11517  F61E             ;
11518  F61E             ; Triggered by injector #2 and #3 activation/deactivation
11519  F61E             ;
11520  F61E             ;
11521  F61E             ;******************************************************************
11522  F61E 96 18       outCompInt2 ldaa    t2_csr                  ; Ack interrupt?                              
11523  F620 DC 1B                   ldd     t2_outCmpWr             ; 
11524  F622 DD 1B                   std     t2_outCmpWr             ; Flush the output compare value that triggered the current interrupt???                       
11525  F624 BD F6 88                jsr     schedDeact23            ; Schedule deactivation time                                                           
11526  F627             
11527  F627                         ;------------------------------------------
11528  F627                         ; Perform injector testing and update 
11529  F627                         ; simultaneous injection mode if required
11530  F627                         ;------------------------------------------
11531  F627 BD F7 09    L1855       jsr     injUpdate0              ;                              
11532  F62A 3B                      rti                             ;                             
11533  F62B             
11534  F62B             
11535  F62B             
11536  F62B             ;******************************************************************
11537  F62B             ;
11538  F62B             ; Schedule injector #1 and #4 deactivation 
11539  F62B             ; time interrupt if necessary
11540  F62B             ;
11541  F62B             ;
11542  F62B             ;******************************************************************
11543  F62B                         ;-----------------------------------
11544  F62B                         ; Update oldInjToAct and injToAct
11545  F62B                         ;-----------------------------------
11546  F62B 96 B2       schedDeact14 ldaa   injToAct                ; a = injToAct                             
11547  F62D 97 B7                   staa    oldInjToAct             ; oldInjToAct = old injToAct
11548  F62F 8F 03 02 02             brclr   port2, #$02, L1857      ; Branch if injector #1 is activated                              
11549  F633 84 FE                   anda    #$fe                    ; Reset injector #1 bit                            
11550  F635 8F 02 08 02 L1857       brclr   port1, #$08, L1858      ; Branch if injector #4 is activated                              
11551  F639 84 FB                   anda    #$fb                    ; Reset injector #4 bit                             
11552  F63B 97 B2       L1858       staa    injToAct                ; Update injToAct
11553  F63D                                            
11554  F63D                         ;--------------------------------------------------------------------------
11555  F63D                         ; Clear sInjPw if injectors from both banks are activated (1 or 4 and 2 or 3)
11556  F63D                         ;--------------------------------------------------------------------------
11557  F63D 8F B7 05 0E             brclr   oldInjToAct, #$05, L1860 ; Branch if both inj #1 and #4 are not activated
11558  F641 8F 02 04 04             brclr   port1, #$04, L1859       ; inj #1 or #4 activated, branch if #2 activated (sim injection on)                               
11559  F645 87 02 02 06             brset   port1, #$02, L1860       ; Branch if #3 not activated (sim injection off                                
11560  F649 7F 01 14    L1859       clr     sInjPw                   ; clear sInjPw and sInjPw+1                             
11561  F64C 7F 01 15                clr     sInjPw+1                 ;                              
11562  F64F             
11563  F64F                         ;----------------------------------
11564  F64F                         ; Find which of #1 or #4 is active
11565  F64F                         ;----------------------------------
11566  F64F 8F 03 02 06 L1860       brclr   port2, #$02, L1861      ; Branch if inj #1 activated                                
11567  F653 87 02 08 30             brset   port1, #$08, L1866      ; Bail if inj #4 is also deactivated (none activated)                               
11568  F657 20 14                   bra     L1862                   ; Only inj #4 activated, branch to deactivate it                            
11569  F659             
11570  F659                         ;------------------------------
11571  F659                         ; Inj #1 activated, check #4
11572  F659                         ;------------------------------
11573  F659 87 02 08 1F L1861       brset   port1, #$08, L1864      ; Branch if #4 deactivated                              
11574  F65D             
11575  F65D                         ;--------------------------
11576  F65D                         ; Inj #1 and #4 activated
11577  F65D                         ;--------------------------
11578  F65D CE 00 A9                ldx     #inj1_offT              ; x points to injectors deactivation time table                              
11579  F660 BD F6 F6                jsr     injRemTime              ; Compute injection remaining time for #1 and #4, a = remTime1, b = remTime4                              
11580  F663 10                      sba                             ; a = remTime1 - remTime4                            
11581  F664 25 0E                   bcs     L1863                   ; Branch if remTime1 < remTime4                        
11582  F666                              
11583  F666                         ;---------------------------------------------------------------------------------
11584  F666                         ; Inj #1 and #4 are activated and remTime1 >= remTime4
11585  F666                         ;
11586  F666                         ; This would mean we are in #1 combustion cycle. In that case, we would 
11587  F666                         ; deactivate inj #4 first (since it has been injecting for a long time by now) 
11588  F666                         ; and eventually inj #1 (which has just started injecting)
11589  F666                         ;
11590  F666                         ; Branch to disable only inj #4 if remTime1 - remTime4 > 1.024ms
11591  F666                         ;---------------------------------------------------------------------------------
11592  F666 81 04                   cmpa    #$04                    ;                              
11593  F668 22 03                   bhi     L1862                   ; Branch if remTime1-remTime4 > 4 (1.024ms)
11594  F66A             
11595  F66A                         ;--------------------------------------------------------------------
11596  F66A                         ; remTime1-remTime4 <= 4 (1.024ms). This means both injectors will 
11597  F66A                         ; be disabled at about the same time, just deactivate both
11598  F66A                         ; of them at that time...
11599  F66A                         ;
11600  F66A                         ; Disable the activation bit for inj. #1 and #4 (two lines below)
11601  F66A                         ; and use inj. #4 deactivation time
11602  F66A                         ;--------------------------------------------------------------------
11603  F66A 03 08 01                orm     t1_csr, #$01            ; Disable the activation bit for inj. #1
11604  F66D             
11605  F66D                         ;-----------------------------------------
11606  F66D                         ; Disable the activation bit for inj. #4 
11607  F66D                         ; and load deactivation time in d
11608  F66D                         ;-----------------------------------------
11609  F66D 03 18 20    L1862       orm     t2_csr, #$20            ; Disable the activation bit for inj. #4
11610  F670 DC AD                   ldd     inj4_offT               ; d = inj4_offT, injector #4 deactivation time                                   
11611  F672 20 0D                   bra     L1865                   ; Branch to schedule deactivation interrupt                             
11612  F674             
11613  F674                         ;--------------------------------------------------------------------------------------
11614  F674                         ; Inj #1 and #4 are activated and remTime1 < remTime4
11615  F674                         ; This would mean we are in #4 combustion cycle. In that case,
11616  F674                         ;--------------------------------------------------------------------------------------
11617  F674 40          L1863       nega                            ; make result positive, a = remTime4 - remTime1
11618  F675 81 04                   cmpa    #$04                    ;                             
11619  F677 22 03                   bhi     L1864                   ; Branch if remTime4 - remTime1 > 4 (1.024ms)                             
11620  F679             
11621  F679                         ;--------------------------------------------------------------------
11622  F679                         ; remTime4-remTime1 <= 4 (1.024ms). This means both injectors will 
11623  F679                         ; be disabled at about the same time, just deactivate both
11624  F679                         ; of them at that time???
11625  F679                         ;
11626  F679                         ; Disable the activation bit for inj. #4 and #1 (two lines below)
11627  F679                         ; and use inj. #1 deactivation time
11628  F679                         ;--------------------------------------------------------------------
11629  F679 03 18 20                orm     t2_csr, #$20            ; Disable the activation bit for inj. #4
11630  F67C             
11631  F67C                         ;-----------------------------------------
11632  F67C                         ; Disable the activation bit for inj. #1
11633  F67C                         ; and load deactivation time in d
11634  F67C                         ;-----------------------------------------
11635  F67C 03 08 01    L1864       orm     t1_csr, #$01            ; Disable the activation bit for inj. #1
11636  F67F DC A9                   ldd     inj1_offT               ; d = inj1_offT, i.e. inj #1 deactivation time  
11637  F681                                                         
11638  F681                         ;--------------------------------------------------------------------------
11639  F681                         ; Validate deactivation time and write to timer 1 output compare register
11640  F681                         ;--------------------------------------------------------------------------
11641  F681 8D 5F       L1865       bsr     validDeactT             ; Validate deactivation time                              
11642  F683 DE 08                   ldx     t1_csr                  ; Read t1_csr and  t1t2_clk??? sequence to follow I assume but it is different from schedDeact23???
11643  F685 DD 0B                   std     t1_outCmpWr             ; Write next interrupt time                                    
11644  F687 39          L1866       rts                             ;                             
11645  F688             
11646  F688             
11647  F688             
11648  F688             ;******************************************************************
11649  F688             ;
11650  F688             ; Schedule injector #2 and #3 deactivation time interrupt
11651  F688             ;
11652  F688             ; Logic is identical to the actDeact14 subroutine
11653  F688             ;
11654  F688             ;
11655  F688             ;******************************************************************
11656  F688 96 B2       schedDeact23 ldaa    injToAct               ;                               
11657  F68A 97 B7                   staa    oldInjToAct             ;                              
11658  F68C 8F 02 04 02             brclr   port1, #$04, L1868      ; 
11659  F690 84 F7                   anda    #$f7                    ; 
11660  F692 8F 02 02 02 L1868       brclr   port1, #$02, L1869      ; 
11661  F696 84 FD                   anda    #$fd                    ; 
11662  F698 97 B2       L1869       staa    injToAct                ; 
11663  F69A 8F B7 0A 0E             brclr   oldInjToAct, #$0a, L1871 ;
11664  F69E 8F 02 08 04             brclr   port1, #$08, L1870      ; 
11665  F6A2 87 03 02 06             brset   port2, #$02, L1871      ; 
11666  F6A6 7F 01 14    L1870       clr     sInjPw                  ; 
11667  F6A9 7F 01 15                clr     sInjPw+1                ; 
11668  F6AC 8F 02 04 06 L1871       brclr   port1, #$04, L1872      ; 
11669  F6B0 87 02 02 2D             brset   port1, #$02, L1877      ; 
11670  F6B4 20 22                   bra     L1875                   ;  
11671  F6B6 87 02 02 0F L1872       brset   port1, #$02, L1873      ; 
11672  F6BA CE 00 AB                ldx     #$00ab                  ;  
11673  F6BD 8D 37                   bsr     injRemTime              ;  
11674  F6BF 10                      sba                             ;  
11675  F6C0 25 0E                   bcs     L1874                   ;  
11676  F6C2 81 04                   cmpa    #$04                    ;  
11677  F6C4 22 03                   bhi     L1873                   ;  
11678  F6C6 03 18 01                orm     t2_csr, #$01            ; 
11679  F6C9 03 18 04    L1873       orm     t2_csr, #$04            ; 
11680  F6CC DC AF                   ldd     inj2_offT               ;  
11681  F6CE 20 0D                   bra     L1876                   ;  
11682  F6D0 40          L1874       nega                            ;  
11683  F6D1 81 04                   cmpa    #$04                    ;  
11684  F6D3 22 03                   bhi     L1875                   ;  
11685  F6D5 03 18 04                orm     t2_csr, #$04            ; 
11686  F6D8 03 18 01    L1875       orm     t2_csr, #$01            ; 
11687  F6DB DC AB                   ldd     inj3_offT               ;  
11688  F6DD             
11689  F6DD                         ;--------------------------------------------------------------------------
11690  F6DD                         ; Validate deactivation time and write to timer 2 output compare register
11691  F6DD                         ; sequence is different compared to schedDeact14?????? (and the t1 and t2
11692  F6DD                         ; control registers are also different????)
11693  F6DD                         ;--------------------------------------------------------------------------
11694  F6DD 8D 03       L1876       bsr     validDeactT                                                 
11695  F6DF DD 1B                   std     t2_outCmpWr                                                 
11696  F6E1 39          L1877       rts                                                          
11697  F6E2             
11698  F6E2             
11699  F6E2             
11700  F6E2             ;******************************************************************
11701  F6E2             ;
11702  F6E2             ; Check injector deactivation time for validity
11703  F6E2             ;
11704  F6E2             ; Input: 
11705  F6E2             ;       d = deactTime = injector deactivation time 
11706  F6E2             ;
11707  F6E2             ;
11708  F6E2             ; Output:
11709  F6E2             ;       d = deactTime or current time + 20us if deactTime>61ms
11710  F6E2             ;
11711  F6E2             ;******************************************************************
11712  F6E2 DD 5E       validDeactT std     temp8                   ; temp8 = deactTime                               
11713  F6E4 83 00 14                subd    #$0014                  ; d = deactTime - $14   (20us)                              
11714  F6E7 93 09                   subd    t1t2_clk                ; remTime = d = deactTime - $14 - t1t2_clk (remaining time until deactivation - 20us)                                
11715  F6E9 1C EE 00                cmpd    #$ee00                  ;                               
11716  F6EC DC 5E                   ldd     temp8                   ; d = deactTime                              
11717  F6EE 25 05                   bcs     L1879                   ; Branch if remTime < $ee00 (61ms)                             
11718  F6F0             
11719  F6F0                         ;--------------------------------------------- 
11720  F6F0                         ; Remaining time too high, deactivate in 20us
11721  F6F0                         ;--------------------------------------------- 
11722  F6F0 DC 09                   ldd     t1t2_clk                ; d = t1t2_clk                                 
11723  F6F2 C3 00 14                addd    #$0014                  ; d = t1t2_clk + 20us                              
11724  F6F5 39          L1879       rts                             ;                             
11725  F6F6             
11726  F6F6             
11727  F6F6             
11728  F6F6             ;******************************************************************
11729  F6F6             ;
11730  F6F6             ;  Compute the remainingInjectionTime/256 for injectors #1 and #4 (or #2 and #3)
11731  F6F6             ;  remaining time might be measured from the most recent CAS falling edge since
11732  F6F6             ;  that is what last_t1t2_clk contains... However the function might also be called 
11733  F6F6             ;  just after last_t1t2_clk has been updated... but not always??? In any case, the 
11734  F6F6             ;  difference between the two remaining times is the most important...
11735  F6F6             ;
11736  F6F6             ; Input: 
11737  F6F6             ;       x: points to inj1_offT or inj3_offT (injector deactivation time table)
11738  F6F6             ;
11739  F6F6             ; Output:
11740  F6F6             ;       a = 0 if inj #1 (or #2) remaining injection time > 61ms  else  remaining injection time/256
11741  F6F6             ;       b = 0 if inj #4 (or #3) remaining injection time > 61ms  else  remaining injection time/256
11742  F6F6             ;
11743  F6F6             ; Basically a and b are the remainingActivationTime/256
11744  F6F6             ; or 0 if it doesn't make sense (i.e. > 61ms)
11745  F6F6             ;
11746  F6F6             ;******************************************************************
11747  F6F6 A6 00       injRemTime  ldaa    $00,x                   ; a = inj1_offT/256
11748  F6F8 90 B1                   suba    last_t1t2_clk           ; a = inj1_offT - last_t1t2_clk
11749  F6FA 81 EE                   cmpa    #$ee                    ;                             
11750  F6FC 25 01                   bcs     L1881                   ; Branch if inj1_offT - last_t1t2_clk <$ee (61ms)
11751  F6FE 4F                      clra                            ; a = 0                            
11752  F6FF             
11753  F6FF E6 04       L1881       ldab    $04,x                   ; b = inj4_offT/256
11754  F701 D0 B1                   subb    last_t1t2_clk           ; b = inj4_offT/256 - last_t1t2_clk
11755  F703 C1 EE                   cmpb    #$ee                    ;                            
11756  F705 25 01                   bcs     L1882                   ; Branch if inj1_offT - last_t1t2_clk <$ee (61ms)
11757  F707 5F                      clrb                            ; b = 0                            
11758  F708 39          L1882       rts                             ;                             
11759  F709             
11760  F709             
11761  F709             
11762  F709             ;******************************************************************
11763  F709             ;
11764  F709             ; Called on every injector activation/deactivation (output compare)
11765  F709             ;
11766  F709             ; Tests injector feedback bit if time has come and 
11767  F709             ; perform simultaneous injection activation/deactivation if
11768  F709             ; required
11769  F709             ;
11770  F709             ;
11771  F709             ;******************************************************************
11772  F709                         ;------------------------------------------------------------------
11773  F709                         ; Check whether we should test the injectors for proper operation
11774  F709                         ;------------------------------------------------------------------
11775  F709 96 B8       injUpdate0  ldaa    injToTest               ; a = injToTest                               
11776  F70B 91 B7                   cmpa    oldInjToAct             ;                                    
11777  F70D 26 11                   bne     L1885                   ; Bail if injToTest != oldInjToAct, i.e. the injector to test was not the one and only one activated
11778  F70F 87 B2 0F 0D             brset   injToAct, #$0f, L1885   ; Bail if any injector currently activated          
11779  F713                                                
11780  F713                         ;--------------------------------------------------------------------------------
11781  F713                         ; At this point, we know that the current injector to test was
11782  F713                         ; active in the past (oldInjToAct) and that it is not active anymore
11783  F713                         ; (injToAct). Basically, we know that the injector to test was just 
11784  F713                         ; deactivated and no other injector is currently active. 
11785  F713                         ;
11786  F713                         ; port4.7 might be loaded on the falling edge of the injector driving current???
11787  F713                         ;--------------------------------------------------------------------------------
11788  F713                         ;------------------------------------------------------------------
11789  F713                         ; Check feedback flag to know if injector is working correctly???
11790  F713                         ;------------------------------------------------------------------
11791  F713 8F 07 80 05             brclr   port4, #$80, L1884      ; Branch if injector flag shows it is OK?                                
11792  F717 03 B9 01                orm     injBad, #$01            ; Set bit indicating injectors is bad?                                   
11793  F71A 20 04                   bra     L1885                   ; Branch to rest of code, we will continue testing the same injector.                             
11794  F71C             
11795  F71C                         ;--------------------------------------------------------------
11796  F71C                         ; Injector is OK, reset injBad flag and go to next injToTest
11797  F71C                         ;--------------------------------------------------------------
11798  F71C 48          L1884       asla                            ; a = injToTest<<1, go to next injector to test
11799  F71D 02 B9 FE                andm    injBad, #$fe            ; Reset bit indicating injectors is bad?                                
11800  F720             
11801  F720                         ;-------------------
11802  F720                         ; Update injToTest
11803  F720                         ;-------------------
11804  F720 84 0F       L1885       anda    #$0f                    ; Keep only 4 bits, 4 injectors to test
11805  F722 26 02                   bne     L1886                   ; Branch if any injector bit left                             
11806  F724 86 01                   ldaa    #$01                    ; Nothing left, restart testing with injector at bit 0                             
11807  F726 97 B8       L1886       staa    injToTest               ; Update injToTest
11808  F728                         ;-----------------------------------
11809  F728                         ; Code continues in function below......
11810  F728                         ;-----------------------------------
11811  F728                         ;;;;; bra  simInject
11812  F728             
11813  F728             
11814  F728             
11815  F728             
11816  F728             
11817  F728             ;******************************************************************
11818  F728             ;
11819  F728             ; Simultaneous injection code called every 10ms from real time
11820  F728             ; interrupt or from above code continuation. sInjPw is cleared
11821  F728             ; if sim. injection is actually scheduled such that even if it 
11822  F728             ; is called from multiple places, sim. injection will only happen
11823  F728             ; once every time sInjPw is re-loaded...
11824  F728             ;
11825  F728             ;
11826  F728             ;******************************************************************
11827  F728                         ;----------------------------------------------------------------------------
11828  F728                         ; Bail out of function if any injectors are set in injToAct 
11829  F728                         ; (rest of function is for simultaneous injection and all bit should be 0?)
11830  F728                         ;----------------------------------------------------------------------------
11831  F728 87 B2 0F 7E simInject   brset   injToAct, #$0f, L1897   ; branch if any injector bit set
11832  F72C                                              
11833  F72C                         ;-------------------------------------------------------
11834  F72C                         ; All injectors are currently off, we can therefore
11835  F72C                         ; proceed with simultaneous injection if sInjPw >256us
11836  F72C                         ;
11837  F72C                         ; Update injPw from sInjPw if larger than 256us
11838  F72C                         ;-------------------------------------------------------
11839  F72C FC 01 14                ldd     sInjPw                  ; d = sInjPw
11840  F72F 4D                      tsta                            ;                             
11841  F730 27 78                   beq     L1897                   ; Bail of subroutine if sInjPw/256 = 0 (sInjPw<256us), too small....
11842  F732 7F 01 14                clr     sInjPw                  ;                              
11843  F735 7F 01 15                clr     sInjPw+1                ; clear sInjPw                              
11844  F738 8D 71                   bsr     addDeadtime             ; Add deadTime                                   
11845  F73A DD A7                   std     injPw                   ; injPw = sInjPw + deatTime
11846  F73C                                                      
11847  F73C                         ;------------------------------------------------------------
11848  F73C                         ; Round injPw up to specific values if within some ranges, 
11849  F73C                         ; Not quite sure why but I think that when the 
11850  F73C                         ; injection time becomes small, injection time is less 
11851  F73C                         ; predictable or simply non linear in some ranges... In
11852  F73C                         ; any case, since these times include the deadtime, they are
11853  F73C                         ; quite small..., not sure any fuel will actually come out?
11854  F73C                         ;
11855  F73C                         ;          injPw <= 840us  -> 840us
11856  F73C                         ;  840us < injPw <= 960us  -> no change
11857  F73C                         ;  960us < injPw <= 1100us -> 1100us
11858  F73C                         ; 1100us < injPw           -> no change
11859  F73C                         ;------------------------------------------------------------
11860  F73C CC 03 48                ldd     #$0348                  ; 
11861  F73F 1D A7                   cmpd1   injPw                   ;                              
11862  F741 24 0E                   bcc     L1888                   ; Branch to use $0348 if injPw <= $0348 (840us)                           
11863  F743 CC 03 C0                ldd     #$03c0                  ; 
11864  F746 1D A7                   cmpd1   injPw                   ;                              
11865  F748 24 09                   bcc     L1889                   ; Branch to use injPw if injPw <= $03c0 (960us)                              
11866  F74A CC 04 4C                ldd     #$044c                  ; 
11867  F74D 1D A7                   cmpd1   injPw                   ;                              
11868  F74F 25 02                   bcs     L1889                   ; Branch to use injPw if injPw > $044c (1100us)                             
11869  F751 DD A7       L1888       std     injPw                   ;                              
11870  F753             
11871  F753                         ;------------------------------------------------------
11872  F753                         ; Update newInjToAct, start with all injectors 
11873  F753                         ; active and remove the ones disabled by obd
11874  F753                         ; and the ones corresponding to missing ignition 
11875  F753                         ; signals
11876  F753                         ;------------------------------------------------------
11877  F753 86 0F       L1889       ldaa    #$0f                      ; All 4 injectors set by default                              
11878  F755 87 A2 01 08             brset   state3, #$01, L1891       ; Branch if startingToCrank                              
11879  F759 8F 85 80 02             brclr   coilChkFlags, #$80, L1890 ; Branch if no error found on ignition
11880  F75D 94 85                   anda    coilChkFlags              ; Disable injectors corresponding to missing ignition
11881  F75F 94 BA       L1890       anda    obdInjCmd                 ; Disable injectors that are off on purpose (OBD)
11882  F761 97 B5       L1891       staa    newInjToAct               ; Update newInjToAct      
11883  F763                                    
11884  F763                         ;-----------------------------------
11885  F763                         ; Code continues in function below......
11886  F763                         ;-----------------------------------
11887  F763                         ;;;;; bra  schedInjSim
11888  F763             
11889  F763             
11890  F763             
11891  F763             
11892  F763             ;******************************************************************
11893  F763             ;
11894  F763             ; Function to schedule interrupts for injectors activation and 
11895  F763             ; deactivation in the case of simultaneous injection. Called from 
11896  F763             ; main code and from above code continuation...
11897  F763             ;
11898  F763             ; Simulataneous injection can be either when startingToCrank or
11899  F763             ; when starting a cold engine or during acceleration (sInjEnr) 
11900  F763             ;
11901  F763             ; injPw need to be initialized with the proper value (e.g. sInjPw)
11902  F763             ; prior to calling this function
11903  F763             ;
11904  F763             ;******************************************************************
11905  F763                         ;--------------------
11906  F763                         ; Update last_t1t2_clk
11907  F763                         ;--------------------
11908  F763 DC 09       schedInjSim ldd     t1t2_clk                ; a = t1t2_clk, current time                                
11909  F765 97 B1                   staa    last_t1t2_clk           ; last_t1t2_clk = t1t2_clk/256                             
11910  F767             
11911  F767                         ;------------------------------------------------------
11912  F767                         ; Schedule interrupt in 2.048ms 
11913  F767                         ;
11914  F767                         ; This might be to revert to previous injector 
11915  F767                         ; settings after 2.048ms ???? t1_outCmpWr
11916  F767                         ; and t2_outCmpWr would need to be triple buffered???
11917  F767                         ;------------------------------------------------------
11918  F767 8B 08                   adda    #$08                    ; d = t1t2_clk + 8*256 (2.048ms)
11919  F769 DD 0B                   std     t1_outCmpWr             ; Store interrupt time for injector #1 and #4
11920  F76B DD 1B                   std     t2_outCmpWr             ; Store interrupt time for injector #2 and #3
11921  F76D             
11922  F76D                         ;--------------------
11923  F76D                         ; Update injToAct
11924  F76D                         ;--------------------
11925  F76D 96 B5                   ldaa    newInjToAct             ;                               
11926  F76F 84 3F                   anda    #$3f                    ; Keep only lower 6 bits (6 injectors max?)
11927  F771 97 B2                   staa    injToAct                ;                              
11928  F773             
11929  F773                         ;-------------------------------------------------------------------
11930  F773                         ; Reset bit of t1_csr and t2_csr according to activated injectors
11931  F773                         ;-------------------------------------------------------------------
11932  F773 96 B5                   ldaa    newInjToAct             ; a = newInjToAct                             
11933  F775 46                      rora                            ; transfer bit 0 to carry                            
11934  F776 24 03                   bcc     L1893                   ; Branch if injector 1 is off                               
11935  F778 02 08 FE                andm    t1_csr, #$fe            ; Injector 1 is activated, reset bit                                 
11936  F77B 46          L1893       rora                            ;                             
11937  F77C 24 03                   bcc     L1894                   ; Branch if injector 3 is off                             
11938  F77E 02 18 FE                andm    t2_csr, #$fe            ; Injector 3 is activated, reset bit
11939  F781 46          L1894       rora                            ;                             
11940  F782 24 03                   bcc     L1895                   ; Branch if injector 4 is off                             
11941  F784 02 18 DF                andm    t2_csr, #$df            ; Injector 4 is activated, reset bit
11942  F787 46          L1895       rora                            ;                             
11943  F788 24 03                   bcc     L1896                   ; Branch if injector 2 is off                             
11944  F78A 02 18 FB                andm    t2_csr, #$fb            ; Injector 2 is activated, reset bit
11945  F78D             
11946  F78D                         ;-------------------------------------------------------------
11947  F78D                         ; Schedule interrupts to activate specified injectors in 10us
11948  F78D                         ;-------------------------------------------------------------
11949  F78D DC 09       L1896       ldd     t1t2_clk                ; d = t1t2_clk
11950  F78F C3 00 0A                addd    #$000a                  ; d = t1t2_clk + 10us
11951  F792 DD 0B                   std     t1_outCmpWr             ; Turn injector on in 10us.                                     
11952  F794 DD 1B                   std     t2_outCmpWr             ; Turn injector on in 10us.                                     
11953  F796             
11954  F796                         ;-------------------------------------------------------------
11955  F796                         ; Compute and store deactivation time 
11956  F796                         ; (common to all injectors when using simultaneous injection)
11957  F796                         ;-------------------------------------------------------------
11958  F796 D3 A7                   addd    injPw                   ; d = t1t2_clk + 10us + injPw
11959  F798 DD A9                   std     inj1_offT               ;                              
11960  F79A DD AB                   std     inj3_offT               ;                              
11961  F79C DD AD                   std     inj4_offT               ;                              
11962  F79E DD AF                   std     inj2_offT               ;                              
11963  F7A0             
11964  F7A0                         ;------------------------------------------------------------------------
11965  F7A0                         ; Schedule interrupts to deactivate all injectors at the specified time
11966  F7A0                         ;------------------------------------------------------------------------
11967  F7A0 03 08 01                orm     t1_csr, #$01            ; Set bit for injector 1
11968  F7A3 03 18 25                orm     t2_csr, #$25            ; Set bits for injector 3 4 and 2
11969  F7A6 DD 0B                   std     t1_outCmpWr             ; Turn injector off at that time?
11970  F7A8 DD 1B                   std     t2_outCmpWr             ; Turn injector off at that time?                                 
11971  F7AA 39          L1897       rts                                                          
11972  F7AB             
11973  F7AB             
11974  F7AB             
11975  F7AB             ;******************************************************************
11976  F7AB             ;
11977  F7AB             ;
11978  F7AB             ; Injectors, add $18*deadTime to injPw (in d)
11979  F7AB             ;
11980  F7AB             ; deadTime is in increment of 24us and injPw in increment of 1us
11981  F7AB             ;
11982  F7AB             ;
11983  F7AB             ;******************************************************************
11984  F7AB DD 5E       addDeadtime std     temp8                   ; temp8 = injPw                               
11985  F7AD 96 A6                   ldaa    deadTime                ; a = deadTime                                
11986  F7AF C6 18                   ldab    #$18                    ; b = $18                            
11987  F7B1 3D                      mul                             ; d = $18*deadTime                          
11988  F7B2 D3 5E                   addd    temp8                   ; d = injPw + $18*deadTime                              
11989  F7B4 24 02                   bcc     L1899                   ; Branch if no overflow                             
11990  F7B6 86 FF                   ldaa    #$ff                    ; Use max of ~$ff00 (65.3ms)                           
11991  F7B8 39          L1899       rts                             ;                             
11992  F7B9             
11993  F7B9             
11994  F7B9             
11995  F7B9             ;******************************************************************
11996  F7B9             ;
11997  F7B9             ; Input capture interrupt 2
11998  F7B9             ;
11999  F7B9             ; This interrupt is triggered whenever the 
12000  F7B9             ; airflow sensor emits one pulse
12001  F7B9             ;
12002  F7B9             ;******************************************************************
12003  F7B9 96 18       inCaptInt2  ldaa    t2_csr                  ; ack/reset interrupt/timer control ???
12004  F7BB 8D 01                   bsr     masProc                                                 
12005  F7BD 3B                      rti                                                          
12006  F7BE             
12007  F7BE             
12008  F7BE             
12009  F7BE             ;******************************************************************
12010  F7BE             ;
12011  F7BE             ; Mas airflow pulse accumulator subroutine 
12012  F7BE             ;
12013  F7BE             ; Called from interrupt and code (polling)
12014  F7BE             ;      
12015  F7BE             ; Assumptions: t2_csr.1 controls the input capture trigger edge 
12016  F7BE             ;              polarity. This would imply (from mafraw calculations)
12017  F7BE             ;              that the airflow sensor pulse frequency is 
12018  F7BE             ;              divided by two by the ECU circuitry. In that case, 
12019  F7BE             ;              counting edges (changing polarity through t2_csr.1 
12020  F7BE             ;              on every interrupt) would correspond to counting 
12021  F7BE             ;              airflow sensor pulses.
12022  F7BE             ;
12023  F7BE             ; Under low airflow, it is called on every rising and falling 
12024  F7BE             ; edge of incoming signal (airflow sensor frequency/2) and it is
12025  F7BE             ; therefore called on every airflow sensor pulse.
12026  F7BE             ;
12027  F7BE             ; When large airflow is detected or when the time between each
12028  F7BE             ; interrupt becomes small, it is called only once for every 2 
12029  F7BE             ; airflow sensor pulses (called scaling) in order to reduce 
12030  F7BE             ; the number of interrupts per sec (CPU load). 
12031  F7BE             ;
12032  F7BE             ; airCntNew0:airCntNew1 is increased by airQuantum = $9c on every 
12033  F7BE             ; call (rising and falling edge) or by 2*airQuantum if we are 
12034  F7BE             ; scaling.
12035  F7BE             ;
12036  F7BE             ;******************************************************************
12037  F7BE                         ;----------------------------------------------
12038  F7BE                         ; Compute t2_diff8 and update t2_lastMas
12039  F7BE                         ;----------------------------------------------
12040  F7BE DC 1D       masProc     ldd     t2_inCapt               ; Read current input capture timer value                                 
12041  F7C0 93 98                   subd    t2_lastMas              ; D = t2_inCapt-t2_lastMas
12042  F7C2 CE 00 C1                ldx     #T200_mas               ;                                                                             
12043  F7C5 BD F8 1F                jsr     masFunc1                ; D = (t2_inCapt-t2_lastMas)/8 with timer based rounding???                                                              
12044  F7C8 DD 9A                   std     t2_diff8                ; t2_diff8 = (t2_inCapt-t2_lastMas)/8 with timer based rounding (see masFunc1)
12045  F7CA DC 1D                   ldd     t2_inCapt               ;                                                                            
12046  F7CC DD 98                   std     t2_lastMas              ; t2_lastMas = t2_inCapt
12047  F7CE             
12048  F7CE                         ;-----------------------------------
12049  F7CE                         ; Re-init counter used in masFunc1
12050  F7CE                         ;-----------------------------------
12051  F7CE 86 1A                   ldaa    #$1a                    ; 130ms                                                                           
12052  F7D0 97 C1                   staa    T200_mas                ;                                                                            
12053  F7D2             
12054  F7D2                         ;--------------------------------------
12055  F7D2                         ; Add scaled airQuantum to airCntNew0
12056  F7D2                         ;--------------------------------------
12057  F7D2 4F                      clra                              ;                                                                           
12058  F7D3 D6 9C                   ldab    airQuantum                ; d = airQuantum
12059  F7D5 8F 9E 80 01             brclr   masCasFlags, #$80, L1902  ; Branch if no scaling
12060  F7D9 05                      asld                              ; scale d = 2*airQuantum
12061  F7DA D3 90       L1902       addd    airCntNew0                ; d = airCntNew0 + airQuantum
12062  F7DC 26 01                   bne     L1903                     ; Branch if result not null                                                                           
12063  F7DE 5C                      incb                              ; Result is null, use min of 1                                                                     
12064  F7DF DD 90       L1903       std     airCntNew0                ; Store airCntNew0 = max(airCntNew0 + airQuantum, 1)                                               
12065  F7E1             
12066  F7E1                         ;----------------------------------
12067  F7E1                         ; Re-init airQuantum with #9c
12068  F7E1                         ;----------------------------------
12069  F7E1 86 9C                   ldaa    #$9c                    ;                                                                           
12070  F7E3 97 9C                   staa    airQuantum              ; airQuantum = $9C                                                                
12071  F7E5             
12072  F7E5                         ;----------------------------------
12073  F7E5                         ; Check if we are using scaling
12074  F7E5                         ;----------------------------------
12075  F7E5 87 9E 80 13             brset   masCasFlags, #$80, L1905      ; branch if scaling by two                                                    
12076  F7E9             
12077  F7E9             
12078  F7E9                         ;-----------------------------------------------------------
12079  F7E9                         ; We are not scaling, check if that needs to change
12080  F7E9                         ; Either if airVol is high (i.e. airVol > $6b, corresponds
12081  F7E9                         ; to about 0.4gramOfAir) or if airflow sensor pulse
12082  F7E9                         ; frequency is high (>500Hz)
12083  F7E9                         ;-----------------------------------------------------------
12084  F7E9 96 E0                   ldaa    airVol                  ;                                                                             
12085  F7EB 81 6B                   cmpa    #$6b                    ;                                                                            
12086  F7ED DC 9A                   ldd     t2_diff8                ; preload d = t2_diff8                                                                                       
12087  F7EF 22 05                   bhi     L1904                   ; branch if airVol > $6b        
12088  F7F1 1C 00 FA                cmpd    #$00fa                  ; $fa*8/1MHz = 2ms -> 500Hz
12089  F7F4 24 19                   bcc     L1907                   ; Branch if t2_diff8 > $00fa (freq<500Hz)  
12090  F7F6             
12091  F7F6                         ;----------------------------------------------------------------------------
12092  F7F6                         ; At this point we were not scaling by 2 but airVol>$6b or t2_diff8 < $00fa
12093  F7F6                         ; (freq>500Hz) we need to activate scaling
12094  F7F6                         ;----------------------------------------------------------------------------
12095  F7F6 05          L1904       asld                            ; t2_diff8 = t2_diff8*2                                                                        
12096  F7F7 03 9E 80                orm     masCasFlags, #$80       ; set scaling bit
12097  F7FA 20 11                   bra     L1906                   ; Go to rest of code                                                                                            
12098  F7FC             
12099  F7FC                         ;------------------------------------------------------
12100  F7FC                         ; We were scaling by 2, check if that needs to change 
12101  F7FC                         ;------------------------------------------------------
12102  F7FC 96 E0       L1905       ldaa    airVol                  ;                                                                                              
12103  F7FE 81 6B                   cmpa    #$6b                    ;                                                                                            
12104  F800 DC 9A                   ldd     t2_diff8                ; preload d=t2_diff8                                                                                              
12105  F802 22 09                   bhi     L1906                   ; branch if airVol>$6b                                                                        
12106  F804 1C 02 71                cmpd    #$0271                  ; airVol<=$6B                                                                                             
12107  F807 25 04                   bcs     L1906                   ; Branch if t2_diff8 < $0271                                                                    
12108  F809             
12109  F809                         ;----------------------------------------------------------------------------
12110  F809                         ; At this point, we were scaling by 2 but airVol<=$6B and t2_diff8 > $271
12111  F809                         ; we can therefore go back to no scaling
12112  F809                         ;----------------------------------------------------------------------------
12113  F809 04                      lsrd                            ; t2_diff8 = t2_diff8/2                                                                        
12114  F80A 02 9E 7F                andm    masCasFlags, #$7f       ; reset scaling bit
12115  F80D             
12116  F80D                         ;----------------------------------
12117  F80D                         ; Update t2_diff8
12118  F80D                         ;----------------------------------
12119  F80D DD 9A       L1906       std     t2_diff8                ; store new value                                                                               
12120  F80F             
12121  F80F                         ;-------------------------------------------------------------------------------
12122  F80F                         ; Change the interrupt trigger polarity if we are not scaling since in that case
12123  F80F                         ; we want interrupts on both rising and falling edges of the incomming signal pulse
12124  F80F                         ; In case of scaling by 2, the polarity remains the same on every interrupt and
12125  F80F                         ; we therefore only receive interrupts on every two edges...
12126  F80F                         ;-------------------------------------------------------------------------------
12127  F80F 87 9E 80 06 L1907       brset   masCasFlags, #$80, L1908 ; branch if we are scaling
12128  F813 96 18                   ldaa    t2_csr                  ; We are not scaling, switch edge trigger polarity
12129  F815 88 02                   eora    #$02                    ; switch edge trigger polarity
12130  F817 97 18                   staa    t2_csr                  ;                                                                                              
12131  F819             
12132  F819                         ;----------------------------
12133  F819                         ; Restart timer and return
12134  F819                         ;----------------------------
12135  F819 86 0C       L1908       ldaa    #$0c                                                 
12136  F81B B7 01 21                staa    T40_mas                                                 
12137  F81E 39                      rts                                                          
12138  F81F             
12139  F81F             
12140  F81F             
12141  F81F             ;******************************************************************
12142  F81F             ;
12143  F81F             ; Divide the time between airflow sensor pulse by 8 with a 
12144  F81F             ; timer based rounding???
12145  F81F             ;
12146  F81F             ; Input is the time between two airflow sensor pulse in D
12147  F81F             ;
12148  F81F             ; Input is also X which points to the timer T200_mas which is init 
12149  F81F             ; to 130ms on every airflow sensor pulse receied.
12150  F81F             ;
12151  F81F             ; output: D = D/8 with timer based rounding if timer not expired (not 0)
12152  F81F             ;         D = 3FFF otherwise
12153  F81F             ;
12154  F81F             ;******************************************************************
12155  F81F 04          masFunc1    lsrd                            ;                                                                       
12156  F820 04                      lsrd                            ;                                                                       
12157  F821 04                      lsrd                            ; d = diff/8                                                      
12158  F822 DD 5E                   std     temp8                   ; temp8 = diff/8                                                                        
12159  F824 A6 00                   ldaa    $00,x                   ; a = timer value 
12160  F826 4D                      tsta                            ; why test, we just loaded in A??????                                   
12161  F827 26 05                   bne     L1910                   ; Branch if counter not zero                                                                       
12162  F829             
12163  F829                         ;-------------------------------
12164  F829                         ; Timer expired, return max value
12165  F829                         ;-------------------------------
12166  F829 CC 3F FF                ldd     #$3fff                  ; If timer expired, return $3fff
12167  F82C 20 11                   bra     L1913                   ;                                                                                           
12168  F82E             
12169  F82E                         ;-----------------------------------------------
12170  F82E                         ; Timer not expired, calculate value to return
12171  F82E                         ; based on timeLeft (in ms)
12172  F82E                         ;
12173  F82E                         ;  0 <= timeLeft < 50   -> diff/8 | $2000
12174  F82E                         ;
12175  F82E                         ; 50 <= timeLeft < 80
12176  F82E                         ;      $diff/8 <  $1000 -> diff/8 | $2000
12177  F82E                         ;      $diff/8 >= $1000 -> diff/8
12178  F82E                         ;
12179  F82E                         ; 80 <= timeLeft < 130  -> diff/8
12180  F82E                         ;
12181  F82E                         ; I think this is basically some kind of round-up
12182  F82E                         ; of the time between airflow sensor pulse when 
12183  F82E                         ; the frequency is low. timeLeft between 0ms and 50ms
12184  F82E                         ; correspond to a time between airflow pulse of 
12185  F82E                         ; between 130ms to 80ms, which correspond to a 
12186  F82E                         ; frequency of 7.7Hz to 20Hz. By setting value bit
12187  F82E                         ; $2000, we are basically making sure the returned
12188  F82E                         ; value corresponds to at least 65ms (15Hz), 
12189  F82E                         ; assuming a 1MHz clock ($2000*8/1000000)
12190  F82E                         ;-----------------------------------------------
12191  F82E 81 10       L1910       cmpa    #$10                    ;                             
12192  F830 24 0B                   bcc     L1912                   ; Branch if time left >=80ms (16/200Hz), return value as is                           
12193  F832 81 0A                   cmpa    #$0a                    ;                             
12194  F834 25 04                   bcs     L1911                   ; Branch if time left <50ms (10/200Hz)
12195  F836 87 5E 10 03             brset   temp8, #$10, L1912      ; Timer is between 50ms<= timer <80ms, branch if diff/8 >= $1000 (value already big enough?, no need to set $2000...)                             
12196  F83A 03 5E 20    L1911       orm     temp8, #$20             ; set value bit $2000 (add that much to diff/8???)                                
12197  F83D DC 5E       L1912       ldd     temp8                   ; Load and return value                              
12198  F83F 39          L1913       rts                             ;                             
12199  F840             
12200  F840             
12201  F840             
12202  F840             
12203  F840             ;******************************************************************
12204  F840             ;
12205  F840             ;
12206  F840             ; Real time Interrupt subroutine 
12207  F840             ; Frequency: 801.28Hz (see rti_freq)
12208  F840             ;
12209  F840             ;
12210  F840             ;******************************************************************
12211  F840 96 26       realTimeInt ldaa    rti_ctl                 ;                                
12212  F842 96 27                   ldaa    rti_freq                ;                                 
12213  F844 7C 00 BB    L1914b      inc     rtiCnt                  ; Increment real time interrupt counter
12214  F847             
12215  F847                         ;-----------------------------------------------------
12216  F847                         ; Check if key is in start and cas signal is active
12217  F847                         ;-----------------------------------------------------
12218  F847 87 06 40 1E             brset   port3, #$40, L1915      ; Bail if key is not is start
12219  F84B 87 16 01 1A             brset   port5, #$01, L1915      ; Bail if cas signal is low 
12220  F84F             
12221  F84F                         ;------------------------------------------
12222  F84F                         ; key is in start and cas signal is active
12223  F84F                         ; reset a few things
12224  F84F                         ;------------------------------------------
12225  F84F 4F                      clra                            ;                             
12226  F850 5F                      clrb                            ;                             
12227  F851 97 61                   staa    casFlags0               ; casFlags0 = 0                              
12228  F853 97 63                   staa    enerFlags               ; enerFlags = 0                             
12229  F855 DD 70                   std     ignFallRelTime0         ; ignFallRelTime0 = 0
12230  F857                                                      
12231  F857                         ;------------------------------------------------------------------------------------
12232  F857                         ; Key is in start and cas signal is active
12233  F857                         ; If no cas interrupt is pending, enable the current coil bit  
12234  F857                         ; and schedule an immediat output compare interrupt to energize it. 
12235  F857                         ;
12236  F857                         ; Basically this makes sure the coil is energized for the whole CAS pulse
12237  F857                         ; during start of crank/cranking...
12238  F857                         ;------------------------------------------------------------------------------------
12239  F857 87 08 80 0E             brset   t1_csr, #$80, L1915     ; Branch if cas interrupt is pending?                                
12240  F85B 96 7B                   ldaa    tdcMask0                ; a = $02 or $04                             
12241  F85D 48                      asla                            ; a = $04 or $08                            
12242  F85E 43                      coma                            ; a = ~($04 or $08)                            
12243  F85F 94 19                   anda    t3_csr0                 ; reset that bit, i.e. energize that coil at scheduled time
12244  F861 97 19                   staa    t3_csr0                 ; update t3_csr0                              
12245  F863 DE 29                   ldx     t3_clock1               ;                                    
12246  F865 08                      inx                             ;                             
12247  F866 08                      inx                             ; x = t3_clock1 + 2, basically in a few microsec                           
12248  F867 DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt for "now" on first output compare register
12249  F869             
12250  F869                         ;------------------------------------------------
12251  F869                         ; increament rtiCnt48 and loop from 47 to 0...
12252  F869                         ; If we loop to 0, also reset the egr and boost 
12253  F869                         ; control solenoid output, i.e. this is the start
12254  F869                         ; of the pulswidth modulation cycle
12255  F869                         ;------------------------------------------------
12256  F869 D6 BC       L1915       ldab    rtiCnt48                ; b = old rtiCnt48
12257  F86B 5C                      incb                            ;                             
12258  F86C D7 BC                   stab    rtiCnt48                ; rtiCnt48 = old rtiCnt48 + 1                                
12259  F86E C1 30                   cmpb    #$30                    ;                             
12260  F870 25 06                   bcs     L1916                   ; Branch if  old rtiCnt48 + 1 < 48
12261  F872 5F                      clrb                            ; b = 0                            
12262  F873 D7 BC                   stab    rtiCnt48                ; rtiCnt48 = 0                                                                                                                                              
12263  F875 02 16 D7                andm    port5, #$d7             ; When rtiCnt48 reaches 48, reset port5.5 and port5.3 
12264  F878             
12265  F878                         ;-----------------------------------------------------------
12266  F878                         ; Set the egr solenoid output if time has come (duty cycle)
12267  F878                         ;-----------------------------------------------------------
12268  F878 F1 01 7E    L1916       cmpb    egrDuty                 ; 
12269  F87B 25 03                   bcs     L1917                   ; Branch if rtiCnt48 < egrDuty                                                                                                                                           
12270  F87D 03 16 08                orm     port5, #$08             ; Set the egr solenoid                                                                                            
12271  F880             
12272  F880                         ;-------------------------------------------------------------------------
12273  F880                         ; Set the boost control solenoid output if time has come (duty cycle)
12274  F880                         ;-------------------------------------------------------------------------
12275  F880 F1 01 81    L1917       cmpb    bcsDuty                 ; Boost control solenoid duty cycle, second threshold?                                                                                         
12276  F883 25 03                   bcs     L1918                   ; Branch if rtiCnt48 < egrDuty                                                                                                                                           
12277  F885 03 16 20                orm     port5, #$20             ; 
12278  F888                                                                                                                                                                        
12279  F888                         ;-------------------------------------------
12280  F888                         ; At this point b = new value of rtiCnt48
12281  F888                         ;
12282  F888                         ; Update boost gauge output at 801.28Hz
12283  F888                         ;-------------------------------------------
12284  F888 B6 01 7F    L1918       ldaa    bGaugeODuty             ; a = bGaugeODuty ("off-duty" cycle)
12285  F88B C1 18                   cmpb    #$18                    ; 
12286  F88D 25 07                   bcs     L1919                   ; branch if rtiCnt48 < 24                                                                     
12287  F88F C0 18                   subb    #$18                    ; b = rtiCnt48-24 (we only need a value from 0 to 24 here, use 24 to 48 as a new 0 to 24...)
12288  F891 8F A2 10 01             brclr   state3, #$10, L1919     ; Branch if notRotating clear                                                                           
12289  F895 4C                      inca                            ; Engine not rotating, a = bGaugeODuty+1 (why?, wiggle the needle a bit?)                                                                        
12290  F896 5D          L1919       tstb                            ; 
12291  F897 26 03                   bne     L1920                   ; Branch if rtiCnt48 != 0                                                                          
12292  F899 02 2F FB                andm    port6, #$fb             ; rtiCnt48=0, start with boost gauge output = 0 at the beginning of cycle
12293  F89C 11          L1920       cba                             ; 
12294  F89D 22 03                   bhi     L1921                   ; Branch if bGaugeODuty > rtiCnt48                                                                          
12295  F89F 03 2F 04                orm     port6, #$04             ; Change boost gauge output to 1 when rtiCnt48 >= bGaugeODuty
12296  F8A2             L1921       .equ    $                       ;   
12297  F8A2             
12298  F8A2                         ;-----------------------------------------------------
12299  F8A2                         ; Branch to next section at 400Hz if time has come
12300  F8A2                         ;-----------------------------------------------------
12301  F8A2 8F BB 01 01 L1921b      brclr   rtiCnt, #$01, L1922     ; Branch once out of two times
12302  F8A6 3B                      rti                             ;                                                                       
12303  F8A7             
12304  F8A7             
12305  F8A7             
12306  F8A7             
12307  F8A7             ;******************************************************************
12308  F8A7             ;
12309  F8A7             ;
12310  F8A7             ; Code executed at 1/2 rate (~400Hz)
12311  F8A7             ;
12312  F8A7             ;
12313  F8A7             ;******************************************************************
12314  F8A7                         ;--------------------------------------------------------------------------------
12315  F8A7                         ; Although we are still in interrupt code , we will re-enable interrupts
12316  F8A7                         ; for the important ones (the coil and cas interrupts) until we get out of here
12317  F8A7                         ;--------------------------------------------------------------------------------
12318  F8A7 02 08 F7    L1922       andm    t1_csr, #$f7             ; reset 0000 1000, disable interrupts from injector 1???
12319  F8AA 02 18 E7                andm    t2_csr, #$e7             ; reset 0001 1000 disable interrupts from injectors 2,3,4 and airflow sensor???
12320  F8AD 02 26 BF                andm    rti_ctl, #$bf            ; disable interrupts from real time interrupt (we are already in it and it is not re-entrant...)
12321  F8B0 02 11 EF                andm    sci_scr, #$ef            ; Disable serial port rx interrupt 
12322  F8B3 0E                      cli                              ; Re-enable all interrupts that were not disabled                                                                                         
12323  F8B4                                                                                 
12324  F8B4                         ;--------------------------------------------------------------------------------
12325  F8B4                         ; Speed sensor update:
12326  F8B4                         ; At 100km/h, reed switch sensor will generate ~reedHz=69Hz square wave (~40cm/cycle)
12327  F8B4                         ; vssValue will reflect the number of interrupt calls during one complete cycle,
12328  F8B4                         ; i.e. the quare wave period measured in 1/400sec
12329  F8B4                         ;--------------------------------------------------------------------------------
12330  F8B4 96 C4                   ldaa    vssCnt1                 ;                                                                                                                       
12331  F8B6 27 03                   beq     L1923                   ;                                                                                                                       
12332  F8B8 4A                      deca                            ;                                                                                                                      
12333  F8B9 97 C4                   staa    vssCnt1                 ;                                                                                                                       
12334  F8BB 96 C5       L1923       ldaa    vssCnt2                 ;                                                                                                                       
12335  F8BD 27 03                   beq     L1924                   ;                                                                                                                       
12336  F8BF 4A                      deca                            ;                                                                                                                      
12337  F8C0 97 C5                   staa    vssCnt2                 ;                                                                                                                       
12338  F8C2 D6 BD       L1924       ldab    rtiReedFlags            ;                                                                                                                       
12339  F8C4 79 00 BD                rol     rtiReedFlags            ;                                                                                                                       
12340  F8C7 96 02                   ldaa    port1                   ;                                                                                                                        
12341  F8C9 49                      rola                            ;                                                                                                                      
12342  F8CA 76 00 BD                ror     rtiReedFlags            ; rtiReedFlags.7 contains latest REED switch value                                                                             
12343  F8CD D8 BD                   eorb    rtiReedFlags            ; B.7 = 1 if reed switch value changed                                                                                  
12344  F8CF 2B 08                   bmi     L1925                   ; Branch if Reed switch value changed                                                                                   
12345  F8D1 96 C5                   ldaa    vssCnt2                 ; No change in reed switch value                                                                                        
12346  F8D3 26 16                   bne     L1927                   ; branch if C5 not yet 0                                                                                                
12347  F8D5 86 E2                   ldaa    #$e2                    ;                                                                                                                       
12348  F8D7 20 10                   bra     L1926                   ; vssCnt reached 0, prepare to store E2 in speedSensor (lowest possible speed)                                          
12349  F8D9             
12350  F8D9                         ;-----------------------------------
12351  F8D9                         ; Reed switch value changed, 
12352  F8D9                         ; update speedSensor pulse counter
12353  F8D9                         ;-----------------------------------
12354  F8D9 C6 C8       L1925       ldab    #$c8                    ;                                                                                                                                                      
12355  F8DB D7 C4                   stab    vssCnt1                 ; Re-initialize vssSlowCnt                                                                                                                              
12356  F8DD 87 BD 80 0A             brset   rtiReedFlags, #$80, L1927 ; branch if new value is 1                                                                                                                               
12357  F8E1 86 E2                   ldaa    #$e2                    ; Reed switch value just changed to 0..                                                                                                                
12358  F8E3 90 C5                   suba    vssCnt2                 ; A = # pulses counted for the last interval                                                                                                            
12359  F8E5 C6 E2                   ldab    #$e2                    ;                                                                                                                                                      
12360  F8E7 D7 C5                   stab    vssCnt2                 ; Re-Initialize vssCnt                                                                                                                                  
12361  F8E9 97 C6       L1926       staa    vss                     ; Store new speedSensor value (number of times interupt was called during an entire pulse (falling edge to falling edge)                                
12362  F8EB             
12363  F8EB             L1927       .equ    $
12364  F8EB             
12365  F8EB 8F BB 03 03 L1927b      brclr   rtiCnt, #$03, L1928     ; branch to other stuff at a frequency "real time int freq."/4                                                                                                       
12366  F8EF 7E F9 F5                jmp     L1950                   ;                                                                                                                                                       
12367  F8F2             
12368  F8F2                         ;----------------------------------
12369  F8F2                         ; Code executed at ~200Hz
12370  F8F2                         ; Read ADC (tpsRaw, battRaw)
12371  F8F2                         ;----------------------------------
12372  F8F2 86 0F       L1928       ldaa    #$0f                    ;                              
12373  F8F4 BD EC 16                jsr     readAdc1                ;                                 
12374  F8F7 0E                      cli                             ;                             
12375  F8F8 D7 D2                   stab    tpsRaw                  ;                               
12376  F8FA 86 0D                   ldaa    #$0d                    ;                             
12377  F8FC BD EC 16                jsr     readAdc1                ;                                 
12378  F8FF 0E                      cli                             ;                             
12379  F900 D7 D0                   stab    battRaw                 ;     
12380  F902                         
12381  F902                         ;-------------------------------------------------------------------------------
12382  F902                         ; Decrement 5 down counters at  $be, $bf, $c0, $c1, $c2 
12383  F902                         ;-------------------------------------------------------------------------------
12384  F902 CE 00 BE                ldx     #T200_40Hz                                                 
12385  F905 C6 05                   ldab    #$05                    ; Loop 5 times, $be, $bf, $c0, $c1, $c2
12386  F907 A6 00       L1929       ldaa    $00,x                                                 
12387  F909 27 02                   beq     L1930                   ; branch if counter already 0                              
12388  F90B 6A 00                   dec     $00,x                   ; decrement  one of $be, $bf, $c0, $c1, $c2
12389  F90D 08          L1930       inx                             ; go to next down counter                            
12390  F90E 5A                      decb                            ;                             
12391  F90F 26 F6                   bne     L1929                   ; loop                              
12392  F911             
12393  F911                         ;------------------------------------------
12394  F911                         ; Check/reset 40Hz counter (T200_40Hz)
12395  F911                         ;------------------------------------------
12396  F911 96 BE                   ldaa    T200_40Hz                  ;
12397  F913 26 06                   bne     L1931                   ; branch if first counter not 0
12398  F915 03 BE 05                orm     T200_40Hz, #$05            ; Reinit counter with 5 (5/200 = 25ms->40Hz)                               
12399  F918 03 BD 01                orm     rtiReedFlags, #$01             ; Set flag at 40 Hz for main loop events 
12400  F91B             
12401  F91B                         ;------------------------------------------
12402  F91B                         ; Check T200_cop and change some output on port 6???
12403  F91B                         ; Could be some kind of monitoring function:
12404  F91B                         ; If main loop goes slower than 20Hz, port6.5 is not
12405  F91B                         ; updated and external check could reset the ECU 
12406  F91B                         ; in that case (COP)
12407  F91B                         ;------------------------------------------
12408  F91B 96 C2       L1931       ldaa    T200_cop                  ;                               
12409  F91D 27 08                   beq     L1932                   ; Branch if T200_cop reached 0 (meaning main loop is executing at less than 20Hz???)  
12410  F91F 0F                      sei                             ;                                               
12411  F920 96 2F                   ldaa    port6                   ; T200_cop not 0, toggle port6.5                             
12412  F922 88 20                   eora    #$20                    ;                             
12413  F924 97 2F                   staa    port6                   ; Toggle bit 
12414  F926 0E                      cli                                                          
12415  F927             
12416  F927                         ;----------------------------------------------------------------------------
12417  F927                         ; Update knock decay:
12418  F927                         ; Decrement knocksum by 1 every time T200s_knock expires and reload timer
12419  F927                         ; T200s_knock with fast or slow decay constant depending on current airVol
12420  F927                         ;----------------------------------------------------------------------------
12421  F927 96 8C       L1932       ldaa    T200s_knock             ; a = T200s_knock, knock attenuation timer                                        
12422  F929 27 03                   beq     L1933                   ; Branch if T200s_knock already expired
12423  F92B 4A                      deca                            ; a = T200s_knock-1                                      
12424  F92C 26 11                   bne     L1935                   ; branch if (T200s_knock-1)!=0 -> store T200s_knock-1 
12425  F92E 0F          L1933       sei                             ; at this point T200s_knock = 0 or 1                                                      
12426  F92F 96 8B                   ldaa    knockSum                ; a = knockSum
12427  F931 27 03                   beq     L1934                   ; Branch if knockSum = 0
12428  F933 7A 00 8B                dec     knockSum                ; knockSum = knockSum-1                                                
12429  F936 0E          L1934       cli                             ;                             
12430  F937 86 78                   ldaa    #$78                    ; a=$78 (200Hz/120 = 1.67Hz, slow attenuation)
12431  F939 87 53 80 02             brset   knockFlags, #$80, L1935 ; Branch if flag indicate that airVol>$49
12432  F93D 86 02                   ldaa    #$02                    ; a=$02 (200Hz/2 = 100Hz, fast attenuation)
12433  F93F 97 8C       L1935       staa    T200s_knock             ; store current knock attenuation count                                    
12434  F941             
12435  F941                         ;---------------------------------------------------------------
12436  F941                         ; Set iscLowBatt.7 flag if battRaw>=10V (with 0.33V hysteresis) 
12437  F941                         ; else reset it. If battRaw<10V the ISC spindle is not moved...
12438  F941                         ;---------------------------------------------------------------
12439  F941 C6 8D                   ldab    #$8d                    ; b= 10.33V = threshold                                                                           
12440  F943 B6 01 65                ldaa    iscLowBatt              ; a = iscLowBatt                                                                                   
12441  F946 2A 02                   bpl     L1936                   ; Branch if iscLowBatt.7 already set, meaning battRaw >=10v last time we were here                                                                                  
12442  F948 C6 88                   ldab    #$88                    ; reduce threshold (hysteresis) to 10.00V                                                                            
12443  F94A D1 D0       L1936       cmpb    battRaw                 ; Check battRaw against 10.00V or 10.33V                                        
12444  F94C 25 05                   bcs     L1937                   ; branch if battRaw > 10.00 or 10.33V                                        
12445  F94E             
12446  F94E                         ;---------------------------------------------------------------------
12447  F94E                         ; battRaw <= 10.00 , clear iscLowBatt and bail, no ISC update
12448  F94E                         ;---------------------------------------------------------------------
12449  F94E 7F 01 65                clr     iscLowBatt              ; battRaw < 10.00 or 10.33V, clear iscLowBatt                                     
12450  F951 20 42                   bra     L1939                   ; Bail
12451  F953             
12452  F953                         ;--------------------------------------------------------------------------
12453  F953                         ; battRaw > 10.00 , set iscLowBatt.7 flag and increase iscLowBatt.0.1 counter by 1
12454  F953                         ; If counter < $03 we don't update the ISC spindle (that means that 
12455  F953                         ; battRaw has to be higher than 10.00V for 4/200 sec before we move
12456  F953                         ; the ISC spindle...
12457  F953                         ;--------------------------------------------------------------------------
12458  F953 8A 80       L1937       oraa    #$80                    ; a = iscLowBatt | $80                             
12459  F955 4C                      inca                            ; a = iscLowBatt | $80 + 1                            
12460  F956 B7 01 65                staa    iscLowBatt              ; iscLowBatt = old iscLowBatt | $80 + 1                              
12461  F959 81 83                   cmpa    #$83                    ;                             
12462  F95B 25 38                   bcs     L1939                   ; Bail if new iscLowBatt.0.1 < $03, no ISC update                             
12463  F95D 86 83                   ldaa    #$83                    ; Use max of iscLowBatt.0.1 = $03                            
12464  F95F B7 01 65                staa    iscLowBatt              ; iscLowBatt = $83 (flag set and counter = $03)                            
12465  F962             
12466  F962                         ;-------------------------
12467  F962                         ; Check ISC complement ???
12468  F962                         ;-------------------------
12469  F962 D6 4A                   ldab    iscPatrnIdx             ; preload b = iscPatrnIdx for later calc                             
12470  F964 96 49                   ldaa    iscStepCurr             ; a = iscStepCurr                               
12471  F966 43                      coma                            ;                             
12472  F967 84 7F                   anda    #$7f                    ; a = ~iscStepCurr & $7f                             
12473  F969 91 48                   cmpa    iscStepCom              ;                                                                                                  
12474  F96B 26 28                   bne     L1939                   ; branch if complement is incorrect???                                                        
12475  F96D             
12476  F96D                         ;----------------------------------
12477  F96D                         ; Complement is OK, continue???
12478  F96D                         ;----------------------------------
12479  F96D                         ;---------------------------------------------------------------
12480  F96D                         ; Section to move the ICS spindle by +/1 step if iscStepCurr != iscStepTarg
12481  F96D                         ; this is where it happens...  code executed at 200Hz...
12482  F96D                         ;---------------------------------------------------------------
12483  F96D 96 49                   ldaa    iscStepCurr             ; a = iscStepCurr                                                                                              
12484  F96F 91 FD                   cmpa    iscStepTarg             ; 
12485  F971 27 22                   beq     L1939                   ; Bail if current ISC step is what we want (no change needed)
12486  F973 4C                      inca                            ; assume a = iscStepCurr + 1                                                                                           
12487  F974 5C                      incb                            ; assume b = iscPatrnIdx + 1                                                                                           
12488  F975 25 04                   bcs     L1938                   ; Branch if iscStepCurr < iscStepTarg (tricky, carry flag is not affected by inca, incb...)
12489  F977 4A                      deca                            ; iscStepCurr >= iscStepTarg, assumption wrong, go in the other direction                                                               
12490  F978 4A                      deca                            ; a = iscStepCurr - 1                                                                                           
12491  F979 5A                      decb                            ;                                                                                            
12492  F97A 5A                      decb                            ; b = iscPatrnIdx - 1                                                                                           
12493  F97B BD E4 B6    L1938       jsr     iscStepComp             ; Update iscStepCurr and iscStepCom with new values
12494  F97E D7 4A                   stab    iscPatrnIdx             ; Update iscPatrnIdx with new value
12495  F980 CE FE EA                ldx     #t_iscPattern           ; x points to t_iscPattern                                                                                              
12496  F983 C4 03                   andb    #$03                    ; b = new iscPatrnIdx & 00000011                                                                                             
12497  F985 3A                      abx                             ; x points to desired pattern                                                                                            
12498  F986 0F                      sei                             ;                                                                                             
12499  F987 96 16                   ldaa    port5                   ; a = port5                                                                                             
12500  F989 84 3F                   anda    #$3f                    ; a = port5 & 00111111
12501  F98B AB 00                   adda    $00,x                   ; a = (port5 & 00111111) + t_iscPattern(iscPatrnIdx)
12502  F98D 97 16                   staa    port5                   ; update port5                                                                                             
12503  F98F 0E                      cli                             ;                                                                                             
12504  F990 86 81                   ldaa    #$81                    ; a = $81 = 129                                                                                            
12505  F992 B7 01 65                staa    iscLowBatt              ; re-init iscLowBatt to $81
12506  F995                                                                                                                                      
12507  F995                         ;------------------------------------------------------
12508  F995                         ; Section of code to update port2.2 (up to ~L1949)
12509  F995                         ; according to TPS/rpm/airVol/idleSwitch/timer?????
12510  F995                         ;
12511  F995                         ; ????Could be airflow sensor filter reset???
12512  F995                         ;------------------------------------------------------
12513  F995 8F E6 10 05 L1939       brclr   state1, #$10, L1941     ; Branch if notRotating clear
12514  F999             
12515  F999                         ;-----------------------------------------
12516  F999                         ; Engine notRotating, clear timer T40s_tps
12517  F999                         ;-----------------------------------------
12518  F999 7F 01 82                clr     T40s_tps                ;                                 
12519  F99C 20 50                   bra     L1948                   ;                              
12520  F99E             
12521  F99E                         ;----------------------------------------------------------------------------
12522  F99E                         ; Engine is at least rotating,
12523  F99E                         ; Check whether tpsRaw has increased by more than 1.5% and is between 26%-50% 
12524  F99E                         ;----------------------------------------------------------------------------
12525  F99E 7F 00 C9    L1941       clr     tempFlagTps             ; tempFlagTps = 0                                                                                                          
12526  F9A1 D6 D2                   ldab    tpsRaw                  ; b=tpsRaw                                                                                                        
12527  F9A3 96 C3                   ldaa    oldTps1                 ;                                                                                                           
12528  F9A5 10                      sba                             ; a = tpsDiff = oldTps1-tpsRaw 
12529  F9A6 23 14                   bls     L1942                   ; branch if new TPS is smaller or equal to old one                                                         
12530  F9A8 81 04                   cmpa    #$04                    ; new tps higher than old one
12531  F9AA 25 18                   bcs     L1944                   ; bail if tpsDiff < 4 (1.5%)                                                                            
12532  F9AC 86 80                   ldaa    #$80                    ; tpsDiff is >=4                                                                                         
12533  F9AE 11                      cba                             ; 
12534  F9AF 23 13                   bls     L1944                   ; bail if tps>=50%
12535  F9B1 C1 43                   cmpb    #$43                    ; tps <50%
12536  F9B3 25 0F                   bcs     L1944                   ; bail if tps<26%                                                                                        
12537  F9B5 7A 00 C9                dec     tempFlagTps             ; at this point tpsDiff and 26%<= tps <50%, set tempFlagTps=$ff                                                                         
12538  F9B8 86 0E                   ldaa    #$0e                    ; set T40s_tps to $0e (0.35s) after branch                                                                            
12539  F9BA 20 05                   bra     L1943                   ;                                                                                                          
12540  F9BC C1 43       L1942       cmpb    #$43                    ; New tps smaller than old one
12541  F9BE 25 04                   bcs     L1944                   ; branch if tps < 26%                                  
12542  F9C0 4F                      clra                            ; tps>26%, clear timer T40s_tps                                       
12543  F9C1 B7 01 82    L1943       staa    T40s_tps                ;                                                             
12544  F9C4             
12545  F9C4                         ;-----------------------------------------------------------------
12546  F9C4                         ; At this point b=tpsRaw and
12547  F9C4                         ; if TPS has increased by more than 1.5% and new value is between 26% and 50%
12548  F9C4                         ;    T40s_tps = $0e and tempFlagTps = $ff 
12549  F9C4                         ; else
12550  F9C4                         ;     tempFlagTps = $00
12551  F9C4                         ;     if new TPS<26%
12552  F9C4                         ;        previous T40s_tps is reset to 0
12553  F9C4                         ;-----------------------------------------------------------------
12554  F9C4 96 C9       L1944       ldaa    tempFlagTps             ;                                                                                                           
12555  F9C6 2B 21                   bmi     L1947                   ; Branch if tempFlagTps=FF (TPS increased to between 26% and 50%)                                     
12556  F9C8 C1 43                   cmpb    #$43                    ; 
12557  F9CA 24 0D                   bcc     L1945                   ; branch if tps>= 26%                                                                                       
12558  F9CC B6 01 82                ldaa    T40s_tps                ; tps<26%                                                                                                          
12559  F9CF 26 18                   bne     L1947                   ; Branch if timer not expired                                                                                                          
12560  F9D1 C1 31                   cmpb    #$31                    ; tps<26% and timer expired
12561  F9D3 24 04                   bcc     L1945                   ; branch if tps>=19%                                                                                        
12562  F9D5 C1 0A                   cmpb    #$0a                    ; tps<19% and timer expired
12563  F9D7 24 10                   bcc     L1947                   ; branch if TPS>=4%                                                                                         
12564  F9D9                                                         ; tps<4% and timer expired
12565  F9D9             
12566  F9D9                         ;---------------------------------------------------------------------
12567  F9D9                         ; no TPS increase to 26% and 50%
12568  F9D9                         ; and tps>=26%
12569  F9D9                         ;     or 19%<=tps<26% and timer expired
12570  F9D9                         ;     or tps<4% and timer expired
12571  F9D9                         ; ......
12572  F9D9                         ;---------------------------------------------------------------------
12573  F9D9 96 DD       L1945       ldaa    rpm31                   ;                                                                                                                                                 
12574  F9DB 81 20                   cmpa    #$20                    ; 1000rpm
12575  F9DD 25 06                   bcs     L1946                   ; branch if rpm<1000                                                                                                                             
12576  F9DF 96 E0                   ldaa    airVol                  ; rpm>=1000                                                                                                                                                 
12577  F9E1 81 40                   cmpa    #$40                    ;                                                                                                                                                
12578  F9E3 24 09                   bcc     L1948                   ; branch if airVol >= $40                                                                                                                         
12579  F9E5 96 06       L1946       ldaa    port3                   ;                                                                                                                                                 
12580  F9E7 2A 05                   bpl     L1948                   ; branch if idle switch off                                                                                                                       
12581  F9E9             
12582  F9E9                         ;---------------------------------------------------------------------
12583  F9E9                         ; Reset port2.2 (Airflow sensor active filter reset?) 
12584  F9E9                         ; under a bunch of conditions 
12585  F9E9                         ;
12586  F9E9                         ; Not completly checked...
12587  F9E9                         ; TPS increased to between 26% and 50%
12588  F9E9                         ; or tps<26% and timer not expired
12589  F9E9                         ; or 4%<=tps<19% and timer expired
12590  F9E9                         ; or no TPS increase to 26% and 50%                  
12591  F9E9                         ;        and tps>=26%                                    
12592  F9E9                         ;           or 19%<=tps<26% and timer expired           
12593  F9E9                         ;           or tps<4% and timer expired                 
12594  F9E9                         ;    and idlSwOn and [ rpm<1000 or ( rpm>1000 and airVol<$40) ]
12595  F9E9                         ; .....
12596  F9E9                         ;---------------------------------------------------------------------
12597  F9E9 02 03 FB    L1947       andm    port2, #$fb             ; reset port output??????                                                                                                                                        
12598  F9EC 20 03                   bra     L1949                   ;             
12599  F9EE                                                                                                                                                             
12600  F9EE                         ;---------------------------------------------------------------------
12601  F9EE                         ; Set port2.2 (Airflow sensor active filter reset?) 
12602  F9EE                         ; under a bunch of conditions...
12603  F9EE                         ;---------------------------------------------------------------------
12604  F9EE 03 03 04    L1948       orm     port2, #$04             ; Set port output???? 
12605  F9F1             
12606  F9F1                         ;--------------------------
12607  F9F1                         ; Update oldTps1 at 200Hz
12608  F9F1                         ;--------------------------
12609  F9F1 96 D2       L1949       ldaa    tpsRaw                  ;                                                                                                                                               
12610  F9F3 97 C3                   staa    oldTps1                 ;                                                                                                                                                  
12611  F9F5             
12612  F9F5                         ;----------------------------------------------
12613  F9F5                         ; Update oldTps2 and tpsDiffMax1 at 100Hz 
12614  F9F5                         ;----------------------------------------------
12615  F9F5 87 BB 07 10 L1950       brset   rtiCnt, #$07, L1953     ; Branch if any of those bits set -> branch 7 out of 8 times
12616  F9F9 96 D2                   ldaa    tpsRaw                  ; Code executed at ~800Hz/8=100Hz, a=tpsRaw                           
12617  F9FB 16                      tab                             ; b=tpsRaw                             
12618  F9FC 90 C7                   suba    oldTps2                 ; a = tpsRaw-oldTps2                             
12619  F9FE 24 01                   bcc     L1951                   ; branch if result positive (tpsRaw>=oldTps2)                             
12620  FA00 4F                      clra                            ; Use min of 0                            
12621  FA01 91 C8       L1951       cmpa    tpsDiffMax1             ;                              
12622  FA03 23 02                   bls     L1952                   ; branch if  (tpsRaw-oldTps2)<=tpsDiffMax1                             
12623  FA05 97 C8                   staa    tpsDiffMax1             ; tpsDiffMax1 = max(tpsDiffMax1, (tpsRaw-oldTps2))                               
12624  FA07 D7 C7       L1952       stab    oldTps2                 ; oldTps2 = tpsRaw                             
12625  FA09             
12626  FA09                         ;------------------------------------------------------
12627  FA09                         ; Update section at 200Hz (800Hz/4) if time has come
12628  FA09                         ;------------------------------------------------------
12629  FA09 87 BB 03 0D L1953       brset   rtiCnt, #$03, L1955     ; Branch if any of those bits set -> branch 3 out of 4 times                                
12630  FA0D             
12631  FA0D                         ;-------------------------------
12632  FA0D                         ; Code executed at 200Hz
12633  FA0D                         ;-------------------------------
12634  FA0D                         ;------------------------------------------------
12635  FA0D                         ; Update T200s_sInj timer and reset sInjEnr 
12636  FA0D                         ; to 0 if timer is expired
12637  FA0D                         ;
12638  FA0D                         ; Basically brings down enrichement to 0 a 
12639  FA0D                         ; little while after it is not needed anymore
12640  FA0D                         ;------------------------------------------------
12641  FA0D B6 01 10                ldaa    T200s_sInj              ; 
12642  FA10 27 05                   beq     L1954                   ; Branch if T200s_sInj already at 0                             
12643  FA12 7A 01 10                dec     T200s_sInj              ; decrement T200s_sInj                             
12644  FA15 26 03                   bne     L1955                   ; Bail if T200s_sInj not 0 yet                             
12645  FA17 7F 01 11    L1954       clr     sInjEnr                 ;
12646  FA1A                                                           
12647  FA1A                         ;-----------------------------------------------------
12648  FA1A                         ; Update section at 100Hz (800Hz/8) if time has come
12649  FA1A                         ;-----------------------------------------------------
12650  FA1A 87 BB 07 62 L1955       brset   rtiCnt, #$07, L1962     ; Branch if any of those bits set -> branch 7 out of 8 times                                
12651  FA1E             
12652  FA1E                         ;-------------------------------
12653  FA1E                         ; Code executed at 100Hz
12654  FA1E                         ;-------------------------------
12655  FA1E                         ;------------------------------------------------------------------
12656  FA1E                         ; Section to increase simultaneous fuel injection time (sInjPw)
12657  FA1E                         ; when the gas pedal is being pressed, simultaneous injection
12658  FA1E                         ; during acceleration... 
12659  FA1E                         ;------------------------------------------------------------------
12660  FA1E 96 D2                   ldaa    tpsRaw                  ; a = tpsRaw
12661  FA20 B0 01 0E                suba    oldTps3                 ; a = tpsRaw - oldTps3                              
12662  FA23 24 01                   bcc     L1956                   ; Branch if result positive                              
12663  FA25 4F                      clra                            ; Use min of 0                             
12664  FA26 B7 01 0F    L1956       staa    tpsDiff100              ; tpsDiff100 = max(tpsRaw - oldTps3, 0)                              
12665  FA29 81 03                   cmpa    #$03                                                 
12666  FA2B 25 4A                   bcs     L1961                   ; Bail if (tpsRaw - oldTps3) < 3                              
12667  FA2D F6 01 0E                ldab    oldTps3                 ;                              
12668  FA30 F1 01 13                cmpb    sInjTpsMax              ;                              
12669  FA33 24 42                   bcc     L1961                   ; Bail if oldTps3 >= sInjTpsMax                             
12670  FA35 87 A2 35 3E             brset   state3, #$35, L1961     ; Bail if "rotatingStopInj but not runningFast" or notRotating or rev limiter active or startingToCrank                                  
12671  FA39 87 06 80 3A             brset   port3, #$80, L1961      ; Bail if idle switch on
12672  FA3D                         
12673  FA3D                         ;---------------------------------------------------------------------
12674  FA3D                         ; At this point, idle switch is off, engine is "running normally?",
12675  FA3D                         ; (tpsRaw - oldTps3) >=3 and oldTps3 < sInjTpsMax
12676  FA3D                         ;
12677  FA3D                         ; Basically means the gas pedal is moving forward, acceleration...
12678  FA3D                         ;
12679  FA3D                         ; Increase simultaneous fuel injection time if not already at max???? 
12680  FA3D                         ; Kind of acceleration enrichement when still using simultaneous 
12681  FA3D                         ; injection????
12682  FA3D                         ;---------------------------------------------------------------------
12683  FA3D B6 01 11                ldaa    sInjEnr                 ; a = sInjEnr                              
12684  FA40 B1 01 12                cmpa    sInjEnrMax              ;                               
12685  FA43 24 32                   bcc     L1961                   ; Bail if sInjEnr >= sInjEnrMax (maximum enrichment reached)                             
12686  FA45 86 28                   ldaa    #$28                    ;                             
12687  FA47 B7 01 10                staa    T200s_sInj              ; Init timer T200s_sInj to $28 (0.2s)                             
12688  FA4A F6 01 0F                ldab    tpsDiff100              ; b = tpsDiff100                              
12689  FA4D 54                      lsrb                            ;                             
12690  FA4E 54                      lsrb                            ; b = tpsDiff100/4                            
12691  FA4F C1 08                   cmpb    #$08                    ;                             
12692  FA51 25 02                   bcs     L1957                   ; Branch if tpsDiff100/4 < 8                              
12693  FA53 C6 08                   ldab    #$08                    ; Use max of 8                            
12694  FA55 CE FD 11    L1957       ldx     #t_sInjEnr              ; x = t_sInjEnr                               
12695  FA58 3A                      abx                             ; s = t_sInjEnr + tpsDiff100/4                           
12696  FA59 A6 00                   ldaa    $00,x                   ; a = t_sInjEnr(tpsDiff100)                             
12697  FA5B F6 01 16                ldab    sInjEnrInc              ; b = sInjEnrInc                             
12698  FA5E 3D                      mul                             ; d = sInjEnrInc * t_sInjEnr(tpsDiff100)                            
12699  FA5F 05                      asld                            ; d = 2 * sInjEnrInc * t_sInjEnr(tpsDiff100)                           
12700  FA60 25 04                   bcs     L1958                   ; Branch to use max if overflow                             
12701  FA62 81 15                   cmpa    #$15                    ;                             
12702  FA64 25 03                   bcs     L1959                   ; Branch if 2 * sInjEnrInc * t_sInjEnr(tpsDiff100) < 15*256                             
12703  FA66 86 15       L1958       ldaa    #$15                    ; 
12704  FA68 5F                      clrb                            ; Use Max of d=$1500 (5.3ms)
12705  FA69 36          L1959       psha                            ; st0 = 2/256 * sInjEnrInc * t_sInjEnr(tpsDiff100)
12706  FA6A F3 01 14                addd    sInjPw                  ; d = 2 * sInjEnrInc * t_sInjEnr(tpsDiff100) + sInjPw                                
12707  FA6D FD 01 14                std     sInjPw                  ; sInjPw = old sInjPw + 2 * sInjEnrInc * t_sInjEnr(tpsDiff100)
12708  FA70 33                      pulb                            ; b =  1/128 * sInjEnrInc * t_sInjEnr(tpsDiff100)
12709  FA71 FB 01 11                addb    sInjEnr                 ;                               
12710  FA74 F7 01 11                stab    sInjEnr                 ; sInjEnr = sInjEnr + 1/128 * sInjEnrInc * t_sInjEnr(tpsDiff100)
12711  FA77                         
12712  FA77                         ;----------------------------                                               
12713  FA77                         ; Update oldTps3 at 100Hz)
12714  FA77                         ;----------------------------                                               
12715  FA77 96 D2       L1961       ldaa    tpsRaw                                                 
12716  FA79 B7 01 0E                staa    oldTps3                                                 
12717  FA7C 0F                      sei                                                          
12718  FA7D             
12719  FA7D                         ;-------------------------------------------------------------                                               
12720  FA7D                         ; Schedule simultaneous injection injector activation and 
12721  FA7D                         ; deactivation at 100Hz, i.e. every 10ms, this is what the 
12722  FA7D                         ; tech manual says...
12723  FA7D                         ;-------------------------------------------------------------                                               
12724  FA7D BD F7 28                jsr     simInject                                                 
12725  FA80             
12726  FA80                         ;----------------------------------
12727  FA80                         ; Re-enable interrupts and return
12728  FA80                         ;----------------------------------
12729  FA80 0F          L1962       sei                                                          
12730  FA81 03 08 18                orm     t1_csr, #$18            ; Re-enable interrupt for                                                                                                      
12731  FA84 03 18 18                orm     t2_csr, #$18            ; Re-enable interrupt for                                                                                                    
12732  FA87 03 26 40                orm     rti_ctl, #$40           ; Re-enable interrupt for                                                                                                     
12733  FA8A 8F FA 02 03             brclr   obdFlags, #$02, L1963   ; Branch if serial output on port 2 was previously init to 1 (means serial rx is also init)                               
12734  FA8E 03 11 10                orm     sci_scr, #$10           ; re-enable serial port "rx interrupt"
12735  FA91 3B          L1963       rti                                                          
12736  FA92             
12737  FA92             
12738  FA92             
12739  FA92             ;******************************************************************
12740  FA92             ;
12741  FA92             ; Output compare interrupt 3
12742  FA92             ;
12743  FA92             ; Triggered when the output compare interrupt for 
12744  FA92             ; coil energization or ignition is triggered.
12745  FA92             ;
12746  FA92             ;
12747  FA92             ;******************************************************************
12748  FA92 8D 01       outCompInt3 bsr     coilFunc                                                 
12749  FA94 3B                      rti                                                          
12750  FA95             
12751  FA95             
12752  FA95             
12753  FA95             ;******************************************************************
12754  FA95             ;
12755  FA95             ;
12756  FA95             ; Called by code and interrupt subroutine when an output 
12757  FA95             ; compare interrupt for coil energization or ignition is
12758  FA95             ; triggered or pending.
12759  FA95             ;
12760  FA95             ;
12761  FA95             ;******************************************************************
12762  FA95                         ;-------------------------------------
12763  FA95                         ; Flush both output compare registers 
12764  FA95                         ; (write fartest possible time)
12765  FA95                         ;-------------------------------------
12766  FA95 DE 29       coilFunc    ldx     t3_clock1               ; x = t3_clock1                                                                      
12767  FA97 09                      dex                             ;                                                              
12768  FA98 DF 2B                   stx     t3_outCmpWr             ; re-init count of first register
12769  FA9A 96 1A                   ldaa    t3_csr1                 ;                                                                     
12770  FA9C DF 2B                   stx     t3_outCmpWr             ; re-init count of second register                                     
12771  FA9E             
12772  FA9E                         ;-------------------------------------------
12773  FA9E                         ; Branch to the right section depending on
12774  FA9E                         ; the current state of affairs
12775  FA9E                         ;-------------------------------------------
12776  FA9E 87 63 02 25             brset   enerFlags, #$02, L1968       ; Branch if coil energization was scheduled and coil is therefore now energized?
12777  FAA2 8F 63 01 39             brclr   enerFlags, #$01, L1971       ; Bail if enerFlags = 0, nothing needs doing.
12778  FAA6             
12779  FAA6                         ;----------------------------------------------------------------------
12780  FAA6                         ; At this point enerFlags=1, the flag indicates coil was energized
12781  FAA6                         ; and the current interrupt was for coil ignition, check if we should
12782  FAA6                         ; schedule schedule coil energization for the next cylinder
12783  FAA6                         ;----------------------------------------------------------------------
12784  FAA6 87 62 01 35             brset   ignFallFlags, #$01, L1971    ; Bail if we decided ignition would be scheduled from the cas falling edge, In that case, energization is unlikely to be done before the cas rising edge...
12785  FAAA 8F 83 FE 15             brclr   tdcCasCount, #$fe, L1967     ; Branch if tdcCasCount = 0 or 1, we are starting to crank??                                     
12786  FAAE             
12787  FAAE                         ;---------------------------------------------------------------------------
12788  FAAE                         ; At this point enerFlags=1 and ignFallFlags = 0 and tdcCasCount >= 2 
12789  FAAE                         ; 
12790  FAAE                         ; Schedule interrupt to energize the coil of the next cylinder 
12791  FAAE                         ; using energization time and TDC of the next cylinder.
12792  FAAE                         ;
12793  FAAE                         ; This might be done in case the energization time falls before the cas
12794  FAAE                         ; rising edge of the next cylinder (at high rpm). This is the only 
12795  FAAE                         ; place we can schedule such an event. If on the cas rising edge the
12796  FAAE                         ; energization already occured and the coil is energized, the code will not 
12797  FAAE                         ; schedule energization again...If it did not occure, the output compare 
12798  FAAE                         ; register will be flushed and energization will be scheduled again?
12799  FAAE                         ;
12800  FAAE                         ; Note that enerFlags is set to 0 instead of 1. Probably because the coil
12801  FAAE                         ; being energized is on the next cylinder, not the current one. The 
12802  FAAE                         ; energization we are doing here is more of a precautionary measure????
12803  FAAE                         ;
12804  FAAE                         ; Note that the second output compare register was already flushed at 
12805  FAAE                         ; the beginning of subroutine. 
12806  FAAE                         ;---------------------------------------------------------------------------
12807  FAAE DC 29                   ldd     t3_clock1                ; d = t3_clock1                                  
12808  FAB0 C3 00 09                addd    #$0009                   ; d = t3_clock1 + $09                             
12809  FAB3 1D 78                   cmpd1   enerAbsTimeNext0         ;                             
12810  FAB5 2A 02                   bpl     L1966                    ; Branch to use t3_clock1 + $09 is enerAbsTimeNext0 is "in the past"
12811  FAB7 DC 78                   ldd     enerAbsTimeNext0         ; enerAbsTimeNext0 is valid, use it                          
12812  FAB9 DD 2B       L1966       std     t3_outCmpWr              ; Schedule interrupt on first output compare register                                  
12813  FABB 96 7C                   ldaa    tdcMask1                 ; a = next tdc mask, not the current one..., $02 or $04
12814  FABD 48                      asla                             ; a = $04 or $08                           
12815  FABE 43                      coma                             ; a = ~($04 or $08)                           
12816  FABF 94 19                   anda    t3_csr0                  ; reset next tdc coil bit, energize that coil at the scheduled time                            
12817  FAC1 97 19                   staa    t3_csr0                  ; update t3_csr0                            
12818  FAC3             
12819  FAC3                         ;--------------------
12820  FAC3                         ; Set enerFlags = 0
12821  FAC3                         ;--------------------
12822  FAC3 4F          L1967       clra                             ;                            
12823  FAC4 97 63                   staa    enerFlags                ;                             
12824  FAC6 39                      rts                              ;                            
12825  FAC7             
12826  FAC7                         ;------------------------------------------------------
12827  FAC7                         ; At this point enerFlags=2, coil energization was 
12828  FAC7                         ; scheduled and coil is therefore now energized...
12829  FAC7                         ;
12830  FAC7                         ; Schedule interrupt  on first output compare register
12831  FAC7                         ; to provoke ignition at the specified time
12832  FAC7                         ; Second output compare register was already 
12833  FAC7                         ; flushed at the beginning of subroutine
12834  FAC7                         ;------------------------------------------------------
12835  FAC7 87 62 01 10 L1968       brset   ignFallFlags, #$01, L1970 ; Branch if flag indicates ignition is to be scheduled on the cas falling edge, it will be done at that time...                              
12836  FACB DC 29                   ldd     t3_clock1                 ; d = t3_clock1                                   
12837  FACD C3 00 08                addd    #$0008                    ; d = t3_clock1 + $08                              
12838  FAD0 1D 76                   cmpd1   ignTime0                  ;                               
12839  FAD2 2A 02                   bpl     L1969                     ; Branch to use t3_clock1 + $08 if ignTime0 is "in the past"                            
12840  FAD4 DC 76                   ldd     ignTime0                  ; ignTime0 is valid, use it                           
12841  FAD6 DD 2B       L1969       std     t3_outCmpWr               ; Schedule interrupt on first output compare register                                  
12842  FAD8 03 19 0C                orm     t3_csr0, #$0c             ; Set both coil bits, i.e. provoke ignition on the energized coil at the scheduled time?                              
12843  FADB             
12844  FADB                         ;----------------------------------------------------
12845  FADB                         ; Set enerFlags = 1 indicating coil is energized?
12846  FADB                         ;----------------------------------------------------
12847  FADB 86 01       L1970       ldaa    #$01                    ;                             
12848  FADD 97 63                   staa    enerFlags               ;                              
12849  FADF 39          L1971       rts                             ;                             
12850  FAE0             
12851  FAE0             
12852  FAE0             
12853  FAE0             ;******************************************************************
12854  FAE0             ;
12855  FAE0             ;
12856  FAE0             ; Interrupt subroutine when a failure occurs (clock monitor??)
12857  FAE0             ;
12858  FAE0             ;
12859  FAE0             ;******************************************************************
12860  FAE0                         ;------------------------------------
12861  FAE0                         ; Clear flag ?????
12862  FAE0                         ;------------------------------------
12863  FAE0 02 14 BF    failureInt  andm    ramControl, #$bf             ; Reset 01000000 since we are here, disable ram??? or other function????
12864  FAE3             
12865  FAE3                         ;-----------------------------------------
12866  FAE3                         ; Disable all outputs, ie.e re-init all 
12867  FAE3                         ; data direction registers to all inputs 
12868  FAE3                         ;-----------------------------------------
12869  FAE3 4F                      clra                            ;                             
12870  FAE4 5F                      clrb                            ;                             
12871  FAE5 DD 00                   std     p1_ddr                  ; Initialize data direction registers for ports 1,2,3,4,5 to all input
12872  FAE7 DD 04                   std     p3_ddr                  ;                               
12873  FAE9 97 15                   staa    p5_ddr                  ; 
12874  FAEB             
12875  FAEB                         ;---------------------------------------------------------------
12876  FAEB                         ; Wait for an interrupt, I assume only system reset  
12877  FAEB                         ; can be called since other interrupts have lower priority, 
12878  FAEB                         ; might be triggered by above action on ramControl???
12879  FAEB                         ;---------------------------------------------------------------
12880  FAEB 3E                      wai                             ; Wait for an interrupt to jump to codeStart?
12881  FAEC             
12882  FAEC                         ;-----------------------------------------
12883  FAEC                         ; I assume we never get here so that 
12884  FAEC                         ; code continuation is from codeStart...
12885  FAEC                         ;-----------------------------------------
12886  FAEC             
12887  FAEC                                                                 
12888  FAEC                                                                 
12889  FAEC                                                                  
12890  FAEC             ;******************************************************************
12891  FAEC             ;
12892  FAEC             ; Code snipet from the first subroutine (jumps here and then 
12893  FAEC             ; jumps back to first subroutine)
12894  FAEC             ;
12895  FAEC             ; This code might have been put here in case the cop function
12896  FAEC             ; above (failureInt) ever skips the "wai" opcode above?? That 
12897  FAEC             ; way we at least are executing some real code instead of 
12898  FAEC             ; trying to execute the table content located further. Cop
12899  FAEC             ; function should kick-in in a short while if everything
12900  FAEC             ; is not back to normal...
12901  FAEC             ;
12902  FAEC             ;******************************************************************
12903  FAEC                         ;----------------------------------------------------
12904  FAEC                         ; We are in closed loop mode, limit the range
12905  FAEC                         ; of o2Fbk to $4d-$d6 or $2a-$d6 depending on ect 
12906  FAEC                         ;----------------------------------------------------
12907  FAEC 96 E9       L1973       ldaa    o2Fbk                   ; a = o2Fbk                              
12908  FAEE D6 D3                   ldab    ectFiltered             ; b = ectFiltered                                    
12909  FAF0 C1 1C                   cmpb    #$1c                    ; 86degC                              
12910  FAF2 25 10                   bcs     L1975                   ; Branch if temperature(ectFiltered) > 86degC                              
12911  FAF4             
12912  FAF4                         ;-------------------------------------------------------
12913  FAF4                         ; temperature(ectFiltered) <= 86degC 
12914  FAF4                         ; Check for o2Fbk min and max of $4d and $d6
12915  FAF4                         ;-------------------------------------------------------
12916  FAF4 81 4D                   cmpa    #$4d                    ;                             
12917  FAF6 24 04                   bcc     L1974                   ; Branch if o2Fbk >= $4d
12918  FAF8 86 4D                   ldaa    #$4d                    ; Use min of $4d
12919  FAFA 20 0D                   bra     L1976                   ; Branch to store new o2Fbk
12920  FAFC 81 D6       L1974       cmpa    #$d6                    ;                             
12921  FAFE 25 0C                   bcs     L1977                   ; Branch if o2Fbk < $d6                               
12922  FB00 86 D6                   ldaa    #$d6                    ; Use max of $d6                            
12923  FB02 20 05                   bra     L1976                   ; Branch to store new o2Fbk                             
12924  FB04             
12925  FB04                         ;--------------------------------------
12926  FB04                         ; temperature(ectFiltered) > 86degC
12927  FB04                         ;--------------------------------------
12928  FB04 81 2A       L1975       cmpa    #$2a                    ;                             
12929  FB06 7E D7 DB                jmp     L1140                   ;                              
12930  FB09             
12931  FB09 7E D7 E7    L1976       jmp     L1142                   ; Jump to store new o2Fbk                              
12932  FB0C 7E D7 EA    L1977       jmp     L1143                   ;                             
12933  FB0F             
12934  FB0F             
12935  FB0F              ;******************************************************************
12936  FB0F             ;
12937  FB0F             ;
12938  FB0F             ; E932 "patch" for rpm calculation, not sure why this is here
12939  FB0F             ;
12940  FB0F             ;******************************************************************
12941  FB0F~            #ifdef E932
12942  FB0F~            L1978       ldab    rpm31                   ;                              
12943  FB0F~                        ldx     #$8840                  ;                               
12944  FB0F~                        jsr     clipOffset              ; b = max(min(rpm31,$88)-$40,0)-> returns b = $00 to $48  (2250rpm to 4250rpm)                                           
12945  FB0F~                        aslb                            ;                             
12946  FB0F~                        tba                             ;                             
12947  FB0F~                        ldx     #t_closedLp2            ;                                     
12948  FB0F~                        jmp     L1120                   ;                              
12949  FB0F             #endif
12950  FB0F             
12951  FB0F             
12952  FB0F             ;******************************************************************
12953  FB0F             ;
12954  FB0F             ; Empty memory block
12955  FB0F             ;
12956  FB0F             ;******************************************************************
12957  FB0F             #ifdef E931
12958  FB0F FF FF FF FF             .byte   $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff 
12958  FB13 FF FF FF FF 
12958  FB17 FF FF FF FF 
12958  FB1B FF FF FF FF 
12959  FB1F FF FF FF                .byte   $ff, $ff, $ff
12960  FB22             
12961  FB22~            #else
12962  FB22~                        .byte   $ff, $ff, $ff, $ff, $ff   
12963  FB22             #endif
12964  FB22             
12965  FB22             
12966  FB22             
12967  FB22             ;******************************************************************
12968  FB22             ;
12969  FB22             ; Resistor strapping flags
12970  FB22             ;
12971  FB22             ; Stored in config1:config2 based on port4 lowest 2 bits (resistor values)
12972  FB22             ;
12973  FB22             ;
12974  FB22             ;******************************************************************
12975  FB22 82 00       t_strap1    .word   $8200                ; Fwd  Federal   
12976  FB24 84 01                   .word   $8401                ; Fwd  California
12977  FB26 82 82                   .word   $8282                ; Awd  Federal    
12978  FB28 84 83                   .word   $8483                ; Awd  California 
12979  FB2A             
12980  FB2A             
12981  FB2A             
12982  FB2A             ;******************************************************************
12983  FB2A             ;
12984  FB2A             ; Indicates which table to use as a function of config resistors
12985  FB2A             ;
12986  FB2A             ;
12987  FB2A             ;
12988  FB2A             ;******************************************************************
12989  FB2A FB EC       t_strap2    .word   L1999                   ; Fwd  Federal    
12990  FB2C FB F8                   .word   L2000                   ; Fwd  California 
12991  FB2E FC 04                   .word   L2001                   ; Awd  Federal    
12992  FB30 FC 10                   .word   L2002                   ; Awd  California 
12993  FB32             
12994  FB32             
12995  FB32             ;******************************************************************
12996  FB32             ;
12997  FB32             ; Resistor strapping device id returned on diagnostic port
12998  FB32             ;
12999  FB32             ;******************************************************************
13000  FB32 E0 22       t_strap3    .word   $e022                   ; Fwd  Federal    
13001  FB34 E0 23                   .word   $e023                   ; Fwd  California 
13002  FB36 E0 22                   .word   $e022                   ; Awd  Federal    
13003  FB38 E0 23                   .word   $e023                   ; Awd  California 
13004  FB3A             
13005  FB3A             
13006  FB3A             
13007  FB3A             ;******************************************************************
13008  FB3A             ;
13009  FB3A             ; Table values are compared to mafRaw16/64 = mafRaw -> (xx/6.25)Hz
13010  FB3A             ;
13011  FB3A             ; These are the 2 thresholds determining which trim range to use,
13012  FB3A             ; low, mid, high. The first threshold delimiting "low" from "mid" 
13013  FB3A             ; corresponds to the first two value. It is 106.5Hz with an hysteresis
13014  FB3A             ; of +/-6Hz. The second threshold  delimiting mid from high correspond
13015  FB3A             ; to the last two values. It is 175Hz with an hysteresis of +/-6.25Hz
13016  FB3A             ;
13017  FB3A             ; Values are 
13018  FB3A             ;
13019  FB3A             ;   $12 = 112.50 Hz 
13020  FB3A             ;   $10 = 100.50 Hz 
13021  FB3A             ;
13022  FB3A             ;   $1d = 181.25 Hz 
13023  FB3A             ;   $1b = 168.75 Hz 
13024  FB3A             ;
13025  FB3A             ;******************************************************************
13026  FB3A 12 10 1D 1B t_ftrimRg   .byte   $12, $10, $1d, $1b    
13027  FB3E             
13028  FB3E             
13029  FB3E             
13030  FB3E             ;******************************************************************
13031  FB3E             ;
13032  FB3E             ; Table of rpm31 values , $23=1094rpm, $20=1000rpm, $1d=906rpm 
13033  FB3E             ;
13034  FB3E             ; Longer for AT
13035  FB3E             ;
13036  FB3E             ;******************************************************************
13037  FB3E 23 20       L1983      .byte   $23, $20
13038  FB40~            #ifdef E932
13039  FB40~                       .byte   $20, $1d    
13040  FB40             #endif
13041  FB40             
13042  FB40             
13043  FB40             
13044  FB40             ;******************************************************************
13045  FB40             ;
13046  FB40             ; Table contains RPM/31.25, interpolated by ECT. Eventually
13047  FB40             ; used as a threshold to determine if the engine is ???.
13048  FB40             ; used in state1 flags update
13049  FB40             ;
13050  FB40             ; Value is increased as a function of loads (see t_rpmEctOff)
13051  FB40             ;
13052  FB40             ;
13053  FB40             ; (1188, 1188, 1594, ....., 3000) 
13054  FB40             ;
13055  FB40             ; IX = FB40 from L1097
13056  FB40             ; ECT
13057  FB40             ;
13058  FB40             ;******************************************************************
13059  FB40 26 26 33 3C t_rpmEct    .byte   $26, $26, $33, $3c, $46, $50, $56, $60     
13059  FB44 46 50 56 60 
13060  FB48             
13061  FB48             
13062  FB48             
13063  FB48             ;******************************************************************
13064  FB48             ;
13065  FB48             ; Table contains RPM/31.25 offsets that will be added to 
13066  FB48             ; initial value of t_rpmEct, basically increasing RPM as a function 
13067  FB48             ; of loads
13068  FB48             ;
13069  FB48             ;       $00 = +0rpm, 
13070  FB48             ;       $08 = +250rpm, 
13071  FB48             ;       $10 = +500rpm
13072  FB48             ;       $1d = +906.25rpm
13073  FB48             ;       $0d = +406.25RPM
13074  FB48             ;
13075  FB48             ;    3 bit index into table, b2 b1 b0 where:
13076  FB48             ;
13077  FB48             ;               b0 is set if ???
13078  FB48             ;               b1 is set if tranmission is engaged
13079  FB48             ;               b2 is set if A/C switch is ON
13080  FB48             ;
13081  FB48             ; IX = FB48 from L1102
13082  FB48             ;
13083  FB48             ;******************************************************************
13084  FB48 08 00       t_rpmEctOff .byte   $08, $00, 
13085  FB4A 10 00                   .byte   $10, $00,
13086  FB4C 1D 0D                   .byte   $1d, $0d, 
13087  FB4E 10 00                   .byte   $10, $00     
13088  FB50             
13089  FB50             
13090  FB50             
13091  FB50             ;******************************************************************
13092  FB50             ;
13093  FB50             ; Interpolated from modified tps and rpm
13094  FB50             ; Seems to be some kind of default air count used when we are
13095  FB50             ; not receiving airflow sensor interrupts
13096  FB50             ;
13097  FB50             ;******************************************************************
13098  FB50             L1986
13099  FB50             #ifdef E931
13100  FB50 62 3D 20 16             .byte   $62, $3d, $20, $16, $12
13100  FB54 12 
13101  FB55 7A 7A 78 6C             .byte   $7a, $7a, $78, $6c, $5c
13101  FB59 5C 
13102  FB5A 7D 7D 9E C2             .byte   $7d, $7d, $9e, $c2, $c0
13102  FB5E C0 
13103  FB5F 7D 7D A0 CD             .byte   $7d, $7d, $a0, $cd, $cc
13103  FB63 CC 
13104  FB64 7D 7D A8 CE             .byte   $7d, $7d, $a8, $ce, $d8
13104  FB68 D8 
13105  FB69 8A 8A BB D0             .byte   $8a, $8a, $bb, $d0, $df
13105  FB6D DF 
13106  FB6E~            #else
13107  FB6E~                        .byte   $4d, $2b, $03, $16, $12     
13108  FB6E~                        .byte   $78, $84, $84, $60, $4a     
13109  FB6E~                        .byte   $7a, $88, $d0, $bd, $a2     
13110  FB6E~                        .byte   $7a, $88, $d2, $e9, $d0     
13111  FB6E~                        .byte   $7a, $88, $de, $ee, $de     
13112  FB6E~                        .byte   $7a, $8a, $da, $ec, $e4     
13113  FB6E             #endif
13114  FB6E             
13115  FB6E             
13116  FB6E             
13117  FB6E             ;******************************************************************
13118  FB6E             ;
13119  FB6E             ; Mas compensation table as a function of airflow sensor frequency
13120  FB6E             ;
13121  FB6E             ;
13122  FB6E             ; Index into t_masComp table are for the following frequencies:
13123  FB6E             ;
13124  FB6E             ;      85   85   A8   B6   BE   C3   C8   CC   D0   D4   D7   DA   DC   E3   E6   E8   EB   EA   EA   E8   E7
13125  FB6E             ; Hz    0   25   50   75   100  125  150  175  200  225  250  275  300  400  500  600  800  1000 1200 1400 1600
13126  FB6E             ;
13127  FB6E             ;******************************************************************
13128  FB6E             t_masComp
13129  FB6E~            #ifdef custMas
13130  FB6E~                        .byte   $85, $85, $A8, $B6, $BE, $C3, $C8, $CC, $D0, $D4, $D7, $DA, $DC, $E3, $E6, $E8, $EB, $EA, $EA, $E8, $E7
13131  FB6E             #else
13132  FB6E             #ifdef E931
13133  FB6E 5B 5B 59 59             .byte   $5b, $5b, $59, $59, $60, $65, $6c, $6e, $6e, $6f, $73, $76, $7a, $81, $82, $84, $87, $85, $7f, $7a, $7f
13133  FB72 60 65 6C 6E 
13133  FB76 6E 6F 73 76 
13133  FB7A 7A 81 82 84 
13133  FB7E 87 85 7F 7A 
13133  FB82 7F 
13134  FB83~            #else
13135  FB83~                        .byte   $5d, $5d, $5c, $5a, $61, $68, $6c, $6f, $70, $74, $76, $77, $7a, $7f, $84, $85, $88, $86, $81, $7f, $7e 
13136  FB83             #endif
13137  FB83             #endif
13138  FB83             
13139  FB83             
13140  FB83             
13141  FB83             ;******************************************************************
13142  FB83             ;
13143  FB83             ; This table is an airflow sensor compensation table (for temperature 
13144  FB83             ; drift, flow characteristic change, etc?) as a function of 
13145  FB83             ; air temperature, barometric pressure and airflow frequency.
13146  FB83             ; Notice that frequency range is short which would mean airflow
13147  FB83             ; sensor only need compensation under low flow conditions...
13148  FB83             ;
13149  FB83             ; Column index are airflow sensor frequency:
13150  FB83             ;
13151  FB83             ;   0Hz 25Hz 50Hz 75Hz 100Hz 125Hz 150Hz 175Hz 200Hz
13152  FB83             ;
13153  FB83             ; Row index are max(min(L1992(iat)*baroFactor,$52)-$22,0)/16,
13154  FB83             ; at 1 bar that would correspond to (from top to bottom):
13155  FB83             ;
13156  FB83             ;   85degC, 84degC, 26degC, -31degC ?? 
13157  FB83             ;
13158  FB83             ; 2G mas table:  $87, $87, $87, $85, $85, $85, $85, $85, $80
13159  FB83             ;                $80, $80, $80, $80, $80, $80, $80, $80, $80 
13160  FB83             ;                $7d, $7d, $78, $7a, $7b, $7c, $7c, $7c, $80 
13161  FB83             ;                $7b, $7b, $75, $78, $7a, $7a, $7a, $7a, $80 
13162  FB83             ; 
13163  FB83             ;
13164  FB83             ;******************************************************************
13165  FB83 7D 7D 7F 81 t_masLin    .byte   $7d, $7d, $7f, $81, $84, $81, $81, $83, $80     
13165  FB87 84 81 81 83 
13165  FB8B 80 
13166  FB8C 80 80 80 80             .byte   $80, $80, $80, $80, $80, $80, $80, $80, $80     
13166  FB90 80 80 80 80 
13166  FB94 80 
13167  FB95 83 83 83 82             .byte   $83, $83, $83, $82, $80, $7d, $7f, $7f, $80     
13167  FB99 80 7D 7F 7F 
13167  FB9D 80 
13168  FB9E 85 85 85 83             .byte   $85, $85, $85, $83, $80, $7d, $7c, $7f, $80     
13168  FBA2 80 7D 7C 7F 
13168  FBA6 80 
13169  FBA7             
13170  FBA7             
13171  FBA7             ;******************************************************************
13172  FBA7             ;
13173  FBA7             ; Interpolated using rpm (max=3000rpm)
13174  FBA7             ;
13175  FBA7             ; Could be maximum air count as a function of RPM, used in 
13176  FBA7             ; conjucntion with L1990 and L1991
13177  FBA7             ;
13178  FBA7             ;******************************************************************
13179  FBA7             t_airCntMax
13180  FBA7             #ifdef E931
13181  FBA7 5A 5A 5B 5B             .byte   $5a, $5a, $5b, $5b, $61, $63, $8f, $a0, $ff, $ff, $ff, $ff, $ff
13181  FBAB 61 63 8F A0 
13181  FBAF FF FF FF FF 
13181  FBB3 FF 
13182  FBB4~            #else
13183  FBB4~                        .byte   $5f, $5f, $5f, $5f, $64, $6c, $73, $ff, $ff, $ff, $ff, $ff, $ff  
13184  FBB4             #endif
13185  FBB4             
13186  FBB4             
13187  FBB4             
13188  FBB4             ;******************************************************************
13189  FBB4             ;
13190  FBB4             ; Interpolated from ectCond
13191  FBB4             ;
13192  FBB4             ; ECT based correction factor for t_airCntMax
13193  FBB4             ;
13194  FBB4             ;******************************************************************
13195  FBB4 80 80 80 84 L1990       .byte   $80, $80, $80, $84, $88, $8b, $8f, $93      
13195  FBB8 88 8B 8F 93 
13196  FBBC             
13197  FBBC             
13198  FBBC             
13199  FBBC             ;******************************************************************
13200  FBBC             ;
13201  FBBC             ; Interpolated from iatCond
13202  FBBC             ;
13203  FBBC             ; IAT based correction factor for t_airCntMax
13204  FBBC             ;
13205  FBBC             ;******************************************************************
13206  FBBC 8C 86 83 80 L1991       .byte   $8c, $86, $83, $80, $7d, $79, $73      
13206  FBC0 7D 79 73 
13207  FBC3             
13208  FBC3             
13209  FBC3             
13210  FBC3             ;******************************************************************
13211  FBC3             ;
13212  FBC3             ; Interpolated from iatCond. Value from table is then compensated for 
13213  FBC3             ; barometric pressure and then used to interpolate t_masLin
13214  FBC3             ;
13215  FBC3             ; in degC
13216  FBC3             ;
13217  FBC3             ;  85  56  38  23  9  -7  -31 ??
13218  FBC3             ;
13219  FBC3             ;******************************************************************
13220  FBC3 45 3B 36 31 L1992       .byte   $45, $3b, $36, $31, $2d, $29, $22      
13220  FBC7 2D 29 22 
13221  FBCA             
13222  FBCA             
13223  FBCA             
13224  FBCA             ;******************************************************************
13225  FBCA             ;
13226  FBCA             ; Close loop table 1, interpolated from rpm
13227  FBCA             ;
13228  FBCA             ; The values of this table are airVolTB thresholds. Closed loop
13229  FBCA             ; only happens when airVolTB < theshold (with hysteresis of $06)
13230  FBCA             ;
13231  FBCA             ; rpm scale  500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13232  FBCA             ;
13233  FBCA             ;******************************************************************
13234  FBCA 9D 9D 9D 9D t_closedLp1 .byte   $9d, $9d, $9d, $9d, $9d, $80, $68, $55, $00, $00      
13234  FBCE 9D 80 68 55 
13234  FBD2 00 00 
13235  FBD4             
13236  FBD4             
13237  FBD4             
13238  FBD4             ;******************************************************************
13239  FBD4             ;
13240  FBD4             ; Close loop table 2, interpolated from rpm
13241  FBD4             ;
13242  FBD4             ; The values of this table are airVolTB thresholds. Once we are 
13243  FBD4             ; in closed loop, we will remain in closed loop as long as airVolTB
13244  FBD4             ; does not exceed the threshold of this table  (with hysteresis of 
13245  FBD4             ; 6) for more than 12sec or 20sec.
13246  FBD4             ;
13247  FBD4             ; rpm scale  500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13248  FBD4             ;
13249  FBD4             ;******************************************************************
13250  FBD4             t_closedLp2
13251  FBD4             #ifdef E931
13252  FBD4 9D 9D 9D A6             .byte   $9d, $9d, $9d, $a6, $ae, $ae, $9d, $73, $00, $00
13252  FBD8 AE AE 9D 73 
13252  FBDC 00 00 
13253  FBDE~            #else
13254  FBDE~                        .byte   $c3, $cd, $da, $eb, $cd, $aa, $68, $5f, $55, $00      
13255  FBDE             #endif
13256  FBDE             
13257  FBDE             
13258  FBDE             
13259  FBDE             ;******************************************************************
13260  FBDE             ;
13261  FBDE             ; Closed loop table 3, interpolated from rpm
13262  FBDE             ;
13263  FBDE             ; Values are tspRaw threshold. Open loop only happens 
13264  FBDE             ; when tpsRaw > threshold  (with hysteresis of $0d to go
13265  FBDE             ; back to closed loop)
13266  FBDE             ;
13267  FBDE             ; rpm scale  500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13268  FBDE             ;
13269  FBDE             ;******************************************************************
13270  FBDE             t_closedLp3
13271  FBDE             #ifdef E931
13272  FBDE 5C 66 73 8D             .byte   $5c, $66, $73, $8d, $8d, $85, $71, $5c, $00, $00
13272  FBE2 8D 85 71 5C 
13272  FBE6 00 00 
13273  FBE8~            #else
13274  FBE8~                        .byte   $5c, $5c, $73, $8d, $94, $8a, $66, $33, $00, $00      
13275  FBE8             #endif
13276  FBE8             
13277  FBE8             
13278  FBE8             
13279  FBE8             ;******************************************************************
13280  FBE8             ;
13281  FBE8             ; Closed loop fuel adjustment values,
13282  FBE8             ;
13283  FBE8             ; First value is used in low trim range under low speed/rpm, 
13284  FBE8             ; second value in other cases
13285  FBE8             ;
13286  FBE8             ; Values are used in closed loop mode to adjust fuel amount:
13287  FBE8             ;
13288  FBE8             ;       o2FuelAdj = o2Fbk +/-  t_closedLpV1(xx) or t_closedLpV2(xx) or $02
13289  FBE8             ;
13290  FBE8             ; where +/- depends on o2Raw (lean or rich). 
13291  FBE8             ; Basically this controls how fast we change the mixture based on o2Fbk
13292  FBE8             ;
13293  FBE8             ;******************************************************************
13294  FBE8~            #ifdef E932
13295  FBE8~            t_closedLpV2       .byte   $03, $07     
13296  FBE8             #endif
13297  FBE8             
13298  FBE8             
13299  FBE8             
13300  FBE8             ;******************************************************************
13301  FBE8             ;
13302  FBE8             ; Closed loop fuel adjustment values,
13303  FBE8             ;
13304  FBE8             ; First value is used in low trim range under low speed/rpm, 
13305  FBE8             ; second value in other cases
13306  FBE8             ;
13307  FBE8             ; Values are used in closed loop mode to adjust fuel amount:
13308  FBE8             ;
13309  FBE8             ;       o2FuelAdj = o2Fbk +/-  t_closedLpV1(xx) or t_closedLpV2(xx) or $02
13310  FBE8             ;
13311  FBE8             ; where +/- depends on o2Raw (lean or rich). 
13312  FBE8             ; Basically this controls how fast we change the mixture based on o2Fbk
13313  FBE8             ;
13314  FBE8             ;******************************************************************
13315  FBE8 03 07       t_closedLpV1       .byte   $03, $07
13316  FBEA             
13317  FBEA             
13318  FBEA             
13319  FBEA             ;******************************************************************
13320  FBEA             ;
13321  FBEA             ; Default o2Fbk decrease and increase values (in that order)
13322  FBEA             ; when T40_o2Fbk is expired
13323  FBEA             ;
13324  FBEA             ;
13325  FBEA             ;******************************************************************
13326  FBEA 20 15       t_o2Fbk1    .byte   $20, $15     
13327  FBEC             
13328  FBEC             
13329  FBEC             
13330  FBEC             ;******************************************************************
13331  FBEC             ;
13332  FBEC             ; Tables of o2Fbk decrease/increase values. One table for 
13333  FBEC             ; each possible resistor strapping combinations
13334  FBEC             ;
13335  FBEC             ; Table format:
13336  FBEC             ;          First sub-table of six values: o2Fbk decrease values
13337  FBEC             ;          Last  sub-table of six values: 02Fbk increase values
13338  FBEC             ;      
13339  FBEC             ; Within each sub-table of six value we have
13340  FBEC             ;          First  pair: rpm < ~1500rpm
13341  FBEC             ;          Second pair: ~1500rpm < rpm < 2100rpm
13342  FBEC             ;          Third  pair: rpm > 2100rpm
13343  FBEC             ;
13344  FBEC             ; Within each pair we have
13345  FBEC             ;          First  value: airVolTB < ~40
13346  FBEC             ;          Second value: airVolTB > ~40
13347  FBEC             ;
13348  FBEC             ;******************************************************************
13349  FBEC             #ifdef E931
13350  FBEC 32 42 36 47 L1999       .byte   $32, $42, $36, $47, $35, $43, $2e, $42, $36, $49, $37, $51     ; Fwd  Federal    
13350  FBF0 35 43 2E 42 
13350  FBF4 36 49 37 51 
13351  FBF8 32 42 36 41 L2000       .byte   $32, $42, $36, $41, $31, $3d, $2e, $42, $36, $4f, $3b, $57     ; Fwd  California 
13351  FBFC 31 3D 2E 42 
13351  FC00 36 4F 3B 57 
13352  FC04 32 42 36 45 L2001       .byte   $32, $42, $36, $45, $34, $43, $2e, $42, $36, $4b, $38, $51     ; Awd  Federal    
13352  FC08 34 43 2E 42 
13352  FC0C 36 4B 38 51 
13353  FC10 32 42 36 41 L2002       .byte   $32, $42, $36, $41, $31, $3b, $2e, $42, $36, $4f, $3b, $59     ; Awd  California 
13353  FC14 31 3B 2E 42 
13353  FC18 36 4F 3B 59 
13354  FC1C~            #else
13355  FC1C~            L1999       .byte   $32, $46, $40, $50, $42, $52, $2e, $46, $40, $50, $42, $62     ; Fwd  Federal    
13356  FC1C~            L2000       .byte   $32, $46, $40, $49, $3c, $4b, $2e, $46, $40, $57, $48, $69     ; Fwd  California 
13357  FC1C~            L2001       .byte   $32, $46, $40, $4f, $41, $52, $2e, $46, $40, $51, $43, $62     ; Awd  Federal    
13358  FC1C~            L2002       .byte   $32, $46, $40, $49, $3c, $48, $2e, $46, $40, $57, $48, $6c     ; Awd  California 
13359  FC1C             #endif
13360  FC1C             
13361  FC1C             
13362  FC1C             ;******************************************************************
13363  FC1C             ;
13364  FC1C             ; Table of relative air density as a function of temperature
13365  FC1C             ; Factor of 1.0 correspond to around 25.6degC
13366  FC1C             ; Interpolated from iatCond
13367  FC1C             ;
13368  FC1C             ; Fits the gas law quite well, taking the two extreme 
13369  FC1C             ; points (85degC and -31degC) and using Kelvins, we have
13370  FC1C             ;
13371  FC1C             ;             T1/T2 = density2/density1
13372  FC1C             ;
13373  FC1C             ; In theory
13374  FC1C             ;             (273+85)/(273-31) = 1.479
13375  FC1C             ;
13376  FC1C             ; The table gives us
13377  FC1C             ;
13378  FC1C             ;              density2/density1 = 1.23/0.828 = 1.486 
13379  FC1C             ;
13380  FC1C             ; This is a 0.5% difference.
13381  FC1C             ;
13382  FC1C             ;
13383  FC1C             ;        degC    85     56     38    23     9    -7    -31 
13384  FC1C             ; table value   $6a    $73    $7a    $81   $87   $8f   $9e
13385  FC1C             ;     density  0.828  0.898  0.953  1.01  1.05   1.12  1.23 
13386  FC1C             ;
13387  FC1C             ;
13388  FC1C             ;******************************************************************
13389  FC1C 6A 73 7A 81 t_airDens   .byte   $6a, $73, $7a, $81, $87, $8f, $9e      
13389  FC20 87 8F 9E 
13390  FC23             
13391  FC23             
13392  FC23             ;******************************************************************
13393  FC23             ;
13394  FC23             ; Fuel enrichment factor as a function of airVolCond
13395  FC23             ; The value of this table reduces the enrichement of t_ectEnr 
13396  FC23             ; down to 0 as airflow is increased
13397  FC23             ;
13398  FC23             ;******************************************************************
13399  FC23 80 80 80 80 t_airEnr    .byte   $80, $80, $80, $80, $76, $4f, $38, $38, $2d, $2a, $20, $20     
13399  FC27 76 4F 38 38 
13399  FC2B 2D 2A 20 20 
13400  FC2F             
13401  FC2F             
13402  FC2F             
13403  FC2F             ;******************************************************************
13404  FC2F             ;
13405  FC2F             ; Fuel enrichment factor as a function of ect (from 0% to 47% 
13406  FC2F             ; enrichment in cold temp). This value is reduced by a factor taken 
13407  FC2F             ; from t_airEnr when airflow is increased, see code
13408  FC2F             ;
13409  FC2F             ;******************************************************************
13410  FC2F             t_ectEnr
13411  FC2F             #ifdef E931
13412  FC2F 80 80 87 89             .byte   $80, $80, $87, $89, $8f, $9d, $ab, $bc
13412  FC33 8F 9D AB BC 
13413  FC37~            #else
13414  FC37~                        .byte   $80, $80, $87, $89, $8f, $9a, $a4, $b5     
13415  FC37             #endif
13416  FC37             
13417  FC37             
13418  FC37             
13419  FC37             ;******************************************************************
13420  FC37             ;
13421  FC37             ; Seem to contain enrichment values as a function of ECT
13422  FC37             ; (run richer during warm-up/start-up)
13423  FC37             ; $09 when hot, $80 when cold..., seems a bit high??????
13424  FC37             ;
13425  FC37             ;  fuel enrichment applied = ($80+2*xx)/$80, enrich=$80=100%=no enrichment
13426  FC37             ;
13427  FC37             ;  value xx  $09    $0d   $10    $1a    $27    $33    $4d    $80 
13428  FC37             ;  enrich    1.14   1.20  1.26   1.40   1.60   1.80   2.2    3.00
13429  FC37             ;
13430  FC37             ;******************************************************************
13431  FC37 09 0D 10 1A t_enrWarmup .byte   $09, $0d, $10, $1a, $27, $33, $4d, $80   
13431  FC3B 27 33 4D 80 
13432  FC3F             
13433  FC3F             
13434  FC3F             ;******************************************************************
13435  FC3F             ;
13436  FC3F             ; Fuel map, value of $80 represent an enrichment factor of 1.0 
13437  FC3F             ;
13438  FC3F             ;  rpm  500 1000 1500 2000 2500 3000 3500 4000 4500 5000 5500 6000 6500 7000
13439  FC3F             ;       
13440  FC3F             ;       
13441  FC3F             ;******************************************************************
13442  FC3F             t_fuelMap      
13443  FC3F~            #ifdef custFuelMap
13444  FC3F~                        .byte   $84, $82, $81, $80, $80, $80, $80, $80, $80, $80, $80, $80, $80, $80
13445  FC3F~                        .byte   $87, $85, $84, $82, $82, $82, $82, $84, $85, $85, $85, $85, $85, $85
13446  FC3F~                        .byte   $90, $8e, $8c, $8b, $8a, $8b, $8d, $8f, $8f, $90, $91, $91, $91, $91
13447  FC3F~                        .byte   $94, $94, $94, $96, $98, $9a, $9c, $9e, $a0, $a2, $a4, $a6, $a8, $aa
13448  FC3F~                        .byte   $a5, $a6, $a9, $ae, $b2, $b6, $b8, $b8, $ba, $ba, $ba, $ba, $bc, $bc
13449  FC3F~                        .byte   $b0, $b6, $b9, $bc, $c0, $c2, $c3, $c3, $c4, $c5, $c6, $c6, $c6, $c6
13450  FC3F~                        .byte   $b2, $b8, $bb, $be, $c2, $c4, $c5, $c5, $c6, $c7, $c8, $c8, $c8, $c8
13451  FC3F~                        .byte   $b4, $ba, $bd, $c0, $c4, $c6, $c7, $c7, $c8, $c9, $ca, $ca, $ca, $ca
13452  FC3F~                        .byte   $b6, $bc, $bf, $c2, $c6, $c8, $c9, $c9, $ca, $cb, $cc, $cc, $cc, $cc
13453  FC3F~                        .byte   $b8, $be, $c1, $c4, $c8, $ca, $cb, $cb, $cc, $cd, $ce, $ce, $ce, $ce
13454  FC3F~                        .byte   $b9, $bf, $c2, $c5, $c9, $cb, $cc, $cc, $cd, $ce, $cf, $cf, $cf, $cf
13455  FC3F~                        .byte   $ba, $c0, $c3, $c6, $ca, $cc, $cd, $cd, $ce, $cf, $d0, $d0, $d0, $d0
13456  FC3F             #else
13457  FC3F             #ifdef E931
13458  FC3F 8D 85 80 7C             .byte   $8d, $85, $80, $7c, $7f, $7f, $80, $82, $85, $85, $85, $98, $98, $a0
13458  FC43 7F 7F 80 82 
13458  FC47 85 85 85 98 
13458  FC4B 98 A0 
13459  FC4D 8D 85 80 7C             .byte   $8d, $85, $80, $7c, $7f, $7f, $80, $83, $85, $85, $85, $98, $98, $a0
13459  FC51 7F 7F 80 83 
13459  FC55 85 85 85 98 
13459  FC59 98 A0 
13460  FC5B 8D 85 80 80             .byte   $8d, $85, $80, $80, $80, $80, $80, $80, $80, $80, $80, $98, $98, $a0
13460  FC5F 80 80 80 80 
13460  FC63 80 80 80 98 
13460  FC67 98 A0 
13461  FC69 8D 86 80 80             .byte   $8d, $86, $80, $80, $80, $80, $80, $83, $84, $8a, $96, $98, $9f, $a7
13461  FC6D 80 80 80 83 
13461  FC71 84 8A 96 98 
13461  FC75 9F A7 
13462  FC77 91 86 80 80             .byte   $91, $86, $80, $80, $80, $80, $80, $85, $8f, $96, $98, $a8, $a8, $ae
13462  FC7B 80 80 80 85 
13462  FC7F 8F 96 98 A8 
13462  FC83 A8 AE 
13463  FC85 92 9C 98 80             .byte   $92, $9c, $98, $80, $80, $80, $86, $90, $98, $a0, $a6, $af, $af, $b6
13463  FC89 80 80 86 90 
13463  FC8D 98 A0 A6 AF 
13463  FC91 AF B6 
13464  FC93 94 9E 98 80             .byte   $94, $9e, $98, $80, $80, $87, $91, $98, $a5, $a8, $b3, $b6, $b6, $be
13464  FC97 80 87 91 98 
13464  FC9B A5 A8 B3 B6 
13464  FC9F B6 BE 
13465  FCA1 94 9E 98 98             .byte   $94, $9e, $98, $98, $95, $93, $98, $a0, $ac, $b0, $b8, $bb, $be, $c5
13465  FCA5 95 93 98 A0 
13465  FCA9 AC B0 B8 BB 
13465  FCAD BE C5 
13466  FCAF 94 9E 98 98             .byte   $94, $9e, $98, $98, $96, $a0, $a8, $a8, $b3, $b8, $bd, $c0, $c6, $ca
13466  FCB3 96 A0 A8 A8 
13466  FCB7 B3 B8 BD C0 
13466  FCBB C6 CA 
13467  FCBD 94 9E 98 98             .byte   $94, $9e, $98, $98, $a7, $b4, $ae, $b3, $ba, $bf, $c3, $c4, $ca, $ca
13467  FCC1 A7 B4 AE B3 
13467  FCC5 BA BF C3 C4 
13467  FCC9 CA CA 
13468  FCCB 94 9E 98 98             .byte   $94, $9e, $98, $98, $a7, $b6, $b8, $b9, $c4, $c8, $ca, $c8, $ca, $ca
13468  FCCF A7 B6 B8 B9 
13468  FCD3 C4 C8 CA C8 
13468  FCD7 CA CA 
13469  FCD9 94 9E 98 98             .byte   $94, $9e, $98, $98, $a7, $b6, $b8, $b9, $ca, $ca, $ca, $c8, $ca, $ca
13469  FCDD A7 B6 B8 B9 
13469  FCE1 CA CA CA C8 
13469  FCE5 CA CA 
13470  FCE7             
13471  FCE7~            #else
13472  FCE7~                        .byte   $8d, $85, $80, $7e, $7c, $7c, $7c, $7c, $85, $89, $9a, $a0, $a0, $a3       
13473  FCE7~                        .byte   $8d, $85, $80, $7e, $7c, $7c, $7c, $7c, $85, $89, $9a, $a0, $a0, $a3       
13474  FCE7~                        .byte   $8d, $85, $80, $7e, $7c, $7c, $7c, $7c, $85, $89, $9a, $a0, $a0, $a3       
13475  FCE7~                        .byte   $8d, $85, $80, $7e, $7c, $7c, $7c, $8a, $90, $96, $a0, $a3, $a6, $a9       
13476  FCE7~                        .byte   $91, $85, $80, $7e, $7c, $7c, $86, $90, $9a, $a0, $a4, $a9, $aa, $ad       
13477  FCE7~                        .byte   $97, $97, $80, $7e, $7c, $94, $91, $9c, $a0, $a3, $aa, $ac, $b2, $b5       
13478  FCE7~                        .byte   $97, $97, $99, $7e, $92, $94, $95, $a2, $a8, $a8, $ad, $b3, $b9, $bb       
13479  FCE7~                        .byte   $97, $97, $99, $92, $92, $98, $9f, $a8, $ac, $ad, $b2, $b9, $bb, $be       
13480  FCE7~                        .byte   $97, $97, $99, $92, $9c, $a2, $a7, $ac, $b3, $b4, $b7, $bc, $bc, $c0       
13481  FCE7~                        .byte   $97, $97, $99, $a4, $a9, $ac, $ad, $b0, $b7, $bb, $bd, $bc, $c0, $c0       
13482  FCE7~                        .byte   $97, $97, $99, $aa, $ae, $b0, $b2, $b6, $bd, $c0, $c0, $c0, $c0, $c0       
13483  FCE7~                        .byte   $97, $97, $99, $aa, $ae, $b0, $b2, $b6, $bd, $c0, $c0, $c0, $c0, $c0       
13484  FCE7             #endif
13485  FCE7             #endif
13486  FCE7             
13487  FCE7             
13488  FCE7             
13489  FCE7             ;******************************************************************
13490  FCE7             ;
13491  FCE7             ;
13492  FCE7             ; Injector deatime as a function of battery voltage 
13493  FCE7             ;
13494  FCE7             ; Each unit correspond to 24us ($08 = 192us)
13495  FCE7             ;
13496  FCE7             ;
13497  FCE7             ; Volts: 4.7, 7.0, 9.4, 11.7, 14.1, 16.4, 18.8
13498  FCE7             ;
13499  FCE7             ;******************************************************************
13500  FCE7             t_deadtime
13501  FCE7~            #ifdef custDeadTime
13502  FCE7~                        ; Denso 660 .byte   $b0, $5f, $37, $2a, $22, $1e, $1a
13503  FCE7~                        ; Worchester, fuel trim =  125,105, 100? .byte   $b5, $64, $3c, $2f, $27, $23, $1f
13504  FCE7~                        ; Worchester, fuel trim = <81, 102, 100? .byte   $bc, $6b, $43, $36, $2e, $2a, $26
13505  FCE7~                        ; Worchester, fuel trim = <81, 100, 103  .byte   $b9, $68, $40, $33, $2b, $27, $23
13506  FCE7~                        .byte   $b7, $66, $3e, $31, $29, $25, $21
13507  FCE7             #else
13508  FCE7             #ifdef E931
13509  FCE7 A9 58 30 23             .byte   $a9, $58, $30, $23, $1b, $17, $13
13509  FCEB 1B 17 13 
13510  FCEE~            #else
13511  FCEE~                        .byte   $a8, $5a, $32, $26, $1a, $17, $11      
13512  FCEE             #endif
13513  FCEE             #endif
13514  FCEE             
13515  FCEE             
13516  FCEE             
13517  FCEE             ;******************************************************************
13518  FCEE             ;
13519  FCEE             ; Table used for the calculation of injPwStart
13520  FCEE             ;
13521  FCEE             ; non constant sample spacing:
13522  FCEE             ;
13523  FCEE             ;   ectCond/32          ectCond<$c0     
13524  FCEE             ;   (2*ectCond-$c0)/32  ectCond>=$c0
13525  FCEE             ;
13526  FCEE             ;   scale in degC:
13527  FCEE             ;   
13528  FCEE             ;        86 80 52 35 21 8 -7 -16 -29 
13529  FCEE             ;
13530  FCEE             ;******************************************************************
13531  FCEE             L2008 
13532  FCEE             #ifdef E931
13533  FCEE 07 07 0D 14             .byte   $07, $07, $0d, $14, $22, $36, $60, $83, $a6 
13533  FCF2 22 36 60 83 
13533  FCF6 A6 
13534  FCF7~            #else
13535  FCF7~                        .byte   $07, $07, $0d, $14, $22, $39, $65, $8a, $af     
13536  FCF7             #endif
13537  FCF7             
13538  FCF7             
13539  FCF7             
13540  FCF7             ;******************************************************************
13541  FCF7             ;
13542  FCF7             ; ect
13543  FCF7             ;
13544  FCF7             ;
13545  FCF7             ;******************************************************************
13546  FCF7 17 17 28 45 t_accEnr2a  .byte   $17, $17, $28, $45, $60, $70, $80, $80     
13546  FCFB 60 70 80 80 
13547  FCFF             
13548  FCFF             
13549  FCFF             
13550  FCFF             ;******************************************************************
13551  FCFF             ;
13552  FCFF             ; rpm
13553  FCFF             ;
13554  FCFF             ;
13555  FCFF             ;******************************************************************
13556  FCFF FF B0 A8 80 t_accEnr1   .byte   $ff, $b0, $a8, $80, $80, $88, $90, $a0, $b0, $c0     
13556  FD03 80 88 90 A0 
13556  FD07 B0 C0 
13557  FD09             
13558  FD09             
13559  FD09             
13560  FD09             ;******************************************************************
13561  FD09             ;
13562  FD09             ; Table is interpolated from ect and used to initialize
13563  FD09             ; accEnrDecay. Basically the values in this table are
13564  FD09             ; the decay factor applied to accEnr on each iteration
13565  FD09             ;
13566  FD09             ;     accEnr = accEnr * (1-t_accEnrDecay(ect)/256)
13567  FD09             ;
13568  FD09             ; Slower decay under cold conditions...
13569  FD09             ;
13570  FD09             ;******************************************************************
13571  FD09 A0 A0 F3 F6 t_accEnrDecay   .byte   $a0, $a0, $f3, $f6, $f7, $f8, $f9, $fa     
13571  FD0D F7 F8 F9 FA 
13572  FD11             
13573  FD11             
13574  FD11             
13575  FD11             ;******************************************************************
13576  FD11             ;
13577  FD11             ; Interpolated from tpsDiff100/4
13578  FD11             ;
13579  FD11             ; Used to compute fuel enrichement when doing simultaneous 
13580  FD11             ; injection under acceleration. It is basically a multipler
13581  FD11             ; of the basic enrichment time (sInjEnrInc) depending on 
13582  FD11             ; how much acceleration is requested, i.e. how fast the pedal is 
13583  FD11             ; moving
13584  FD11             ;
13585  FD11             ;******************************************************************
13586  FD11 03 04 05 07 t_sInjEnr       .byte   $03, $04, $05, $07, $09, $0b, $0e, $11, $18     
13586  FD15 09 0B 0E 11 
13586  FD19 18 
13587  FD1A             
13588  FD1A             
13589  FD1A             
13590  FD1A             ;******************************************************************
13591  FD1A             ;
13592  FD1A             ; Table interpolated from ect. Used in the calculation
13593  FD1A             ; of sInjEnrInc, fuel enrichment factor for sim injection 
13594  FD1A             ; during acceleration
13595  FD1A             ;
13596  FD1A             ;******************************************************************
13597  FD1A 00 00 04 12 L2013       .byte   $00, $00, $04, $12, $18, $20, $30, $40     
13597  FD1E 18 20 30 40 
13598  FD22             
13599  FD22             
13600  FD22             
13601  FD22             ;******************************************************************
13602  FD22             ;
13603  FD22             ; Values are used as a maximum threshold on TPS when calculating fuel 
13604  FD22             ; enrichement for simultaneous injection
13605  FD22             ;
13606  FD22             ; rpm scale: 500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13607  FD22             ;
13608  FD22             ;******************************************************************
13609  FD22 5B 6C 76 85 t_sInjTpsMax  .byte   $5b, $6c, $76, $85, $94, $b3, $cd, $cd, $cd, $cd   
13609  FD26 94 B3 CD CD 
13609  FD2A CD CD 
13610  FD2C             
13611  FD2C             
13612  FD2C             
13613  FD2C             ;******************************************************************
13614  FD2C             ;
13615  FD2C             ; IX = FD2C from L1213
13616  FD2C             ; 5 10 15 20 25 30 35 40 45 50 x 100 RPM
13617  FD2C             ;
13618  FD2C             ;******************************************************************
13619  FD2C 30 28 20 20 L2015       .byte   $30, $28, $20, $20, $20, $20, $20, $20, $20, $20   
13619  FD30 20 20 20 20 
13619  FD34 20 20 
13620  FD36             
13621  FD36             
13622  FD36             
13623  FD36             ;******************************************************************
13624  FD36             ;
13625  FD36             ; XX = FD36 from L1207
13626  FD36             ;
13627  FD36             ;******************************************************************
13628  FD36 50 50 8C B4 t_decEnr2       .byte   $50, $50, $8c, $b4, $f0, $f0, $ff, $ff    
13628  FD3A F0 F0 FF FF 
13629  FD3E             
13630  FD3E             
13631  FD3E             
13632  FD3E             ;******************************************************************
13633  FD3E             ;
13634  FD3E             ; IX = FD3E from L1206
13635  FD3E             ;
13636  FD3E             ;******************************************************************
13637  FD3E 1A 20 26 2D t_decEnr1       .byte   $1a, $20, $26, $2d, $33, $4d, $66, $80, $c0, $ff    
13637  FD42 33 4D 66 80 
13637  FD46 C0 FF 
13638  FD48             
13639  FD48             
13640  FD48             
13641  FD48             ;******************************************************************
13642  FD48             ;
13643  FD48             ; Table of timing values under high octane conditions, values are shifted by
13644  FD48             ; 10deg in oder to allow for timing retard (0 = -10deg advance, 18 = 8 deg advance)
13645  FD48             ; It contains timing values to use when octane=255 (no knock)
13646  FD48             ;
13647  FD48             ; Timing used is interpolated from 
13648  FD48             ;
13649  FD48             ;       timingOct = alpha * t_timingHiOct(rpm, load) + (1-alpha) * t_timingLoOct(rpm, load)
13650  FD48             ;
13651  FD48             ; where alpha = octane/255, 0<= alpha <=1
13652  FD48             ;
13653  FD48             ;  rpm  500 1000 1500 2000 2500 3000 3500 4000 4500 5000 5500 6000 6500 7000 7500 8000
13654  FD48             ;
13655  FD48             ;******************************************************************
13656  FD48             t_timingHiOct
13657  FD48~            #ifdef custTimingMap
13658  FD48~                        .byte   $14, $1a, $23, $26, $29, $2b, $2e, $30, $32, $32, $32, $32, $32, $32, $32, $32
13659  FD48~                        .byte   $14, $1a, $22, $25, $26, $27, $2a, $2b, $2c, $2c, $2c, $2c, $2c, $2c, $2d, $2d
13660  FD48~                        .byte   $13, $18, $1e, $20, $21, $24, $27, $27, $27, $27, $27, $27, $28, $2a, $2b, $2b
13661  FD48~                        .byte   $12, $16, $18, $1c, $1d, $1e, $21, $23, $24, $24, $25, $25, $26, $28, $29, $29
13662  FD48~                        .byte   $11, $12, $16, $18, $19, $1a, $1c, $1f, $21, $22, $23, $23, $26, $28, $28, $28
13663  FD48~                        .byte   $10, $11, $12, $14, $15, $16, $17, $19, $1a, $1c, $1d, $1e, $20, $22, $24, $24
13664  FD48~                        .byte   $0f, $10, $11, $12, $13, $14, $15, $16, $17, $19, $1a, $1b, $1d, $1f, $21, $21
13665  FD48~                        .byte   $0d, $0d, $0e, $0f, $10, $12, $13, $14, $15, $17, $18, $19, $1b, $1d, $1f, $1f
13666  FD48~                        .byte   $0b, $0c, $0c, $0d, $0e, $10, $11, $12, $13, $15, $16, $17, $19, $1b, $1c, $1d
13667  FD48~                        .byte   $0a, $0b, $0b, $0c, $0d, $0e, $0f, $10, $11, $13, $14, $15, $17, $19, $1a, $1b
13668  FD48~                        .byte   $09, $0a, $0a, $0b, $0b, $0c, $0d, $0e, $0f, $11, $12, $13, $15, $17, $18, $19
13669  FD48~                        .byte   $08, $09, $09, $0a, $0a, $0b, $0c, $0c, $0d, $0f, $10, $11, $13, $15, $16, $17
13670  FD48             #else
13671  FD48             #ifdef E931
13672  FD48 12 17 1C 22             .byte   $12, $17, $1c, $22, $28, $2f, $30, $31, $32, $33, $36, $37, $37, $37, $37, $37 
13672  FD4C 28 2F 30 31 
13672  FD50 32 33 36 37 
13672  FD54 37 37 37 37 
13673  FD58 12 17 1D 23             .byte   $12, $17, $1d, $23, $27, $2d, $2e, $30, $30, $32, $34, $37, $37, $37, $37, $37 
13673  FD5C 27 2D 2E 30 
13673  FD60 30 32 34 37 
13673  FD64 37 37 37 37 
13674  FD68 12 18 1F 25             .byte   $12, $18, $1f, $25, $28, $2b, $2d, $2f, $32, $32, $32, $32, $32, $32, $32, $32
13674  FD6C 28 2B 2D 2F 
13674  FD70 32 32 32 32 
13674  FD74 32 32 32 32 
13675  FD78 12 1A 22 26             .byte   $12, $1a, $22, $26, $28, $29, $2a, $2d, $2d, $2d, $2d, $2d, $2f, $2f, $2f, $2f 
13675  FD7C 28 29 2A 2D 
13675  FD80 2D 2D 2D 2D 
13675  FD84 2F 2F 2F 2F 
13676  FD88 12 1A 22 25             .byte   $12, $1a, $22, $25, $25, $27, $28, $2b, $2b, $2b, $2b, $2b, $2b, $2b, $2d, $2d 
13676  FD8C 25 27 28 2B 
13676  FD90 2B 2B 2B 2B 
13676  FD94 2B 2B 2D 2D 
13677  FD98 12 18 20 22             .byte   $12, $18, $20, $22, $22, $23, $26, $28, $28, $28, $28, $28, $29, $2a, $2c, $2d 
13677  FD9C 22 23 26 28 
13677  FDA0 28 28 28 28 
13677  FDA4 29 2A 2C 2D 
13678  FDA8 12 18 19 1C             .byte   $12, $18, $19, $1c, $1d, $1f, $24, $25, $25, $25, $26, $26, $27, $29, $2b, $29 
13678  FDAC 1D 1F 24 25 
13678  FDB0 25 25 26 26 
13678  FDB4 27 29 2B 29 
13679  FDB8 0F 16 18 1C             .byte   $0f, $16, $18, $1c, $19, $19, $1e, $22, $24, $24, $25, $25, $26, $28, $28, $24 
13679  FDBC 19 19 1E 22 
13679  FDC0 24 24 25 25 
13679  FDC4 26 28 28 24 
13680  FDC8 0C 12 16 18             .byte   $0c, $12, $16, $18, $19, $17, $19, $1e, $22, $22, $23, $23, $26, $28, $26, $20 
13680  FDCC 19 17 19 1E 
13680  FDD0 22 22 23 23 
13680  FDD4 26 28 26 20 
13681  FDD8 0A 0F 13 16             .byte   $0a, $0f, $13, $16, $17, $17, $15, $19, $1d, $1f, $20, $21, $23, $27, $22, $1d 
13681  FDDC 17 17 15 19 
13681  FDE0 1D 1F 20 21 
13681  FDE4 23 27 22 1D 
13682  FDE8 08 0D 11 14             .byte   $08, $0d, $11, $14, $15, $16, $15, $19, $19, $1c, $1c, $1d, $20, $23, $1e, $1d 
13682  FDEC 15 16 15 19 
13682  FDF0 19 1C 1C 1D 
13682  FDF4 20 23 1E 1D 
13683  FDF8 06 0B 0F 12             .byte   $06, $0b, $0f, $12, $13, $14, $14, $18, $19, $1c, $1c, $1d, $20, $22, $1e, $1c 
13683  FDFC 13 14 14 18 
13683  FE00 19 1C 1C 1D 
13683  FE04 20 22 1E 1C 
13684  FE08~            #else
13685  FE08~                        .byte   $12, $17, $1c, $22, $28, $2f, $30, $31, $32, $33, $36, $37, $37, $37, $37, $37      
13686  FE08~                        .byte   $12, $17, $1d, $23, $27, $2d, $2d, $2d, $2d, $30, $33, $37, $37, $37, $37, $37      
13687  FE08~                        .byte   $12, $18, $1e, $25, $28, $2a, $2a, $2e, $2e, $2f, $2e, $2d, $2d, $2d, $2a, $2a      
13688  FE08~                        .byte   $12, $19, $1f, $23, $24, $28, $28, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a      
13689  FE08~                        .byte   $12, $1a, $20, $21, $22, $24, $25, $27, $27, $27, $27, $27, $28, $28, $28, $28      
13690  FE08~                        .byte   $12, $1a, $1d, $20, $21, $22, $23, $24, $25, $25, $26, $26, $27, $27, $27, $27      
13691  FE08~                        .byte   $12, $16, $18, $19, $1c, $1e, $20, $22, $24, $24, $25, $26, $26, $27, $26, $24      
13692  FE08~                        .byte   $0f, $14, $16, $16, $14, $16, $1a, $22, $24, $24, $24, $24, $25, $27, $24, $22      
13693  FE08~                        .byte   $0c, $12, $14, $16, $12, $13, $17, $1d, $21, $22, $22, $22, $24, $26, $22, $20      
13694  FE08~                        .byte   $0a, $10, $12, $14, $0f, $10, $15, $1a, $1d, $20, $20, $20, $22, $24, $20, $1e      
13695  FE08~                        .byte   $08, $0e, $10, $12, $0d, $10, $15, $19, $1c, $1f, $1f, $1f, $21, $22, $1f, $1e      
13696  FE08~                        .byte   $06, $0c, $0e, $10, $0c, $0e, $15, $19, $1c, $1e, $1e, $1f, $21, $20, $1f, $1d      
13697  FE08             #endif
13698  FE08             #endif
13699  FE08             
13700  FE08             
13701  FE08             
13702  FE08             ;******************************************************************
13703  FE08             ;
13704  FE08             ; Table of timing values under low octane conditions values are shifted by
13705  FE08             ; 10deg in oder to allow for timing retard (0 = -10deg advance, 18 = 8 deg advance)
13706  FE08             ; It contains timing values to use when octane=0 (lots of knock)
13707  FE08             ;
13708  FE08             ; Timing applied is interpolated from 
13709  FE08             ;
13710  FE08             ;       timingOct = alpha * t_timingHiOct(rpm, load) + (1-alpha) * t_timingLoOct(rpm, load)
13711  FE08             ;
13712  FE08             ; where alpha = octane/255, 0<= alpha <=1
13713  FE08             ;
13714  FE08             ; Note that the first three rows of t_timingLoOct have been eliminated from 
13715  FE08             ; this table (t_timingLoOct correspond to the last 9 rows of t_timingHiOct)
13716  FE08             ;
13717  FE08             ;
13718  FE08             ;******************************************************************
13719  FE08             t_timingLoOct
13720  FE08~            #ifdef custOctaneMap
13721  FE08~                        .byte   $12, $16, $18, $1c, $1d, $1e, $21, $23, $24, $24, $25, $25, $26, $28, $29, $2a
13722  FE08~                        .byte   $11, $12, $16, $18, $19, $1a, $1c, $1f, $21, $22, $23, $24, $25, $27, $28, $29
13723  FE08~                        .byte   $10, $11, $12, $14, $15, $16, $17, $19, $1a, $1c, $1d, $1e, $20, $22, $24, $24
13724  FE08~                        .byte   $0f, $10, $11, $12, $13, $14, $15, $16, $17, $19, $1a, $1b, $1d, $1f, $21, $21
13725  FE08~                        .byte   $0b, $0d, $0e, $0f, $10, $12, $13, $14, $15, $17, $18, $19, $1b, $1d, $1f, $1f
13726  FE08~                        .byte   $0a, $0c, $0c, $0d, $0e, $10, $11, $12, $13, $15, $16, $17, $19, $1b, $1c, $1d
13727  FE08~                        .byte   $09, $0b, $0b, $0c, $0d, $0e, $0f, $10, $11, $13, $14, $15, $17, $19, $1a, $1b
13728  FE08~                        .byte   $08, $0a, $0a, $0b, $0b, $0c, $0d, $0e, $0f, $11, $12, $13, $15, $17, $18, $19
13729  FE08~                        .byte   $07, $08, $09, $0a, $0a, $0b, $0c, $0c, $0d, $0f, $10, $11, $13, $15, $16, $17
13730  FE08             #else
13731  FE08             #ifdef E931
13732  FE08 12 1A 22 26             .byte   $12, $1a, $22, $26, $28, $29, $2a, $2d, $2d, $2d, $2d, $2d, $2f, $2f, $2f, $2f 
13732  FE0C 28 29 2A 2D 
13732  FE10 2D 2D 2D 2D 
13732  FE14 2F 2F 2F 2F 
13733  FE18 12 19 1E 21             .byte   $12, $19, $1e, $21, $22, $24, $27, $2a, $2a, $2a, $2a, $2a, $2c, $2c, $2d, $2d 
13733  FE1C 22 24 27 2A 
13733  FE20 2A 2A 2A 2A 
13733  FE24 2C 2C 2D 2D 
13734  FE28 0C 13 19 1D             .byte   $0c, $13, $19, $1d, $1e, $20, $24, $27, $28, $28, $28, $28, $28, $2a, $2a, $27 
13734  FE2C 1E 20 24 27 
13734  FE30 28 28 28 28 
13734  FE34 28 2A 2A 27 
13735  FE38 09 0C 11 14             .byte   $09, $0c, $11, $14, $15, $1b, $21, $24, $25, $25, $25, $25, $25, $25, $24, $20 
13735  FE3C 15 1B 21 24 
13735  FE40 25 25 25 25 
13735  FE44 25 25 24 20 
13736  FE48 07 0C 0D 0E             .byte   $07, $0c, $0d, $0e, $11, $13, $1b, $1f, $1f, $21, $23, $24, $24, $22, $22, $1c 
13736  FE4C 11 13 1B 1F 
13736  FE50 1F 21 23 24 
13736  FE54 24 22 22 1C 
13737  FE58 05 0A 0B 0C             .byte   $05, $0a, $0b, $0c, $0e, $0e, $14, $18, $1d, $1e, $1e, $1f, $21, $21, $20, $1a 
13737  FE5C 0E 0E 14 18 
13737  FE60 1D 1E 1E 1F 
13737  FE64 21 21 20 1A 
13738  FE68 03 08 09 0A             .byte   $03, $08, $09, $0a, $0c, $0c, $0f, $16, $18, $1a, $1c, $1c, $1d, $20, $1e, $18 
13738  FE6C 0C 0C 0F 16 
13738  FE70 18 1A 1C 1C 
13738  FE74 1D 20 1E 18 
13739  FE78 01 06 07 08             .byte   $01, $06, $07, $08, $0b, $0b, $0e, $10, $15, $17, $17, $18, $18, $1a, $18, $16 
13739  FE7C 0B 0B 0E 10 
13739  FE80 15 17 17 18 
13739  FE84 18 1A 18 16 
13740  FE88 00 04 05 06             .byte   $00, $04, $05, $06, $0a, $0a, $0c, $0e, $12, $13, $14, $16, $16, $18, $16, $14 
13740  FE8C 0A 0A 0C 0E 
13740  FE90 12 13 14 16 
13740  FE94 16 18 16 14 
13741  FE98~            #else
13742  FE98~                        .byte   $12, $19, $1f, $23, $24, $28, $28, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a      
13743  FE98~                        .byte   $12, $1c, $21, $23, $24, $26, $28, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a      
13744  FE98~                        .byte   $12, $14, $19, $1b, $1e, $20, $24, $27, $26, $29, $29, $29, $2a, $2a, $2a, $2a      
13745  FE98~                        .byte   $0c, $10, $12, $14, $16, $18, $1c, $26, $26, $26, $25, $24, $26, $27, $27, $24      
13746  FE98~                        .byte   $0b, $0f, $0d, $0e, $0e, $11, $16, $1b, $1d, $20, $1c, $1b, $21, $22, $22, $1c      
13747  FE98~                        .byte   $09, $0d, $0b, $0c, $0c, $0c, $10, $17, $18, $1a, $1a, $19, $1e, $20, $1e, $18      
13748  FE98~                        .byte   $07, $0b, $09, $0a, $0a, $0b, $0e, $12, $15, $17, $17, $18, $1b, $1d, $1a, $16      
13749  FE98~                        .byte   $05, $09, $07, $08, $08, $09, $0d, $0f, $12, $15, $15, $16, $19, $1a, $18, $14      
13750  FE98~                        .byte   $03, $07, $05, $06, $06, $07, $0b, $0d, $10, $13, $13, $14, $17, $18, $16, $12      
13751  FE98             #endif
13752  FE98             #endif
13753  FE98             
13754  FE98             
13755  FE98             ;******************************************************************
13756  FE98             ;
13757  FE98             ; Interpolated from ect, used in timing advance calculations
13758  FE98             ;
13759  FE98             ;       $81 =  1 deg advance
13760  FE98             ;       $80 =  0 deg
13761  FE98             ;       $7f = -1 deg advance
13762  FE98             ;
13763  FE98             ;******************************************************************
13764  FE98 80 80 80 80 L2020       .byte   $80, $80, $80, $80, $80, $84, $88, $8b      
13764  FE9C 80 84 88 8B 
13765  FEA0             
13766  FEA0             
13767  FEA0             
13768  FEA0             ;******************************************************************
13769  FEA0             ;
13770  FEA0             ; Interpolated from iat, values used in 
13771  FEA0             ; timing advance calculations
13772  FEA0             ;
13773  FEA0             ;       $81 =  1 deg advance
13774  FEA0             ;       $80 =  0 deg
13775  FEA0             ;       $7f = -1 deg advance
13776  FEA0             ;
13777  FEA0             ;******************************************************************
13778  FEA0 7D 7F 80 80 L2021       .byte   $7d, $7f, $80, $80, $80, $7f, $7e    
13778  FEA4 80 7F 7E 
13779  FEA7             
13780  FEA7             
13781  FEA7             
13782  FEA7             ;******************************************************************
13783  FEA7             ;
13784  FEA7             ; Interpolated from battRaw. Values are basic coil 
13785  FEA7             ; energization time, each unit correspond to 64usec?
13786  FEA7             ;
13787  FEA7             ;
13788  FEA7             ; Voltages: 9.38v  10.56v  11.73v  12.9v  14.1v  15.2v  16.4v  17.6v  18.8v 
13789  FEA7             ;
13790  FEA7             ;******************************************************************
13791  FEA7 BC 9C 7A 64 t_enerLen       .byte   $bc, $9c, $7a, $64, $56, $49, $42, $3a, $37    
13791  FEAB 56 49 42 3A 
13791  FEAF 37 
13792  FEB0             
13793  FEB0             
13794  FEB0             
13795  FEB0             ;******************************************************************
13796  FEB0             ;
13797  FEB0             ; Interpolated from ect, This is the isc step offset added to the
13798  FEB0             ; base isc step when the engine is started.
13799  FEB0             ;
13800  FEB0             ;
13801  FEB0             ;******************************************************************
13802  FEB0 1F 1A 1B 1C L2023       .byte   $1f, $1a, $1b, $1c, $21, $2b, $3b, $46     
13802  FEB4 21 2B 3B 46 
13803  FEB8             
13804  FEB8             
13805  FEB8             
13806  FEB8             ;******************************************************************
13807  FEB8             ;
13808  FEB8             ; Interpolated from ect, values xx are loaded 
13809  FEB8             ; into T40_iscStart to produce 40/xx Hz
13810  FEB8             ;
13811  FEB8             ;******************************************************************
13812  FEB8 07 07 07 07 L2024       .byte   $07, $07, $07, $07, $07, $08, $0a, $0c     
13812  FEBC 07 08 0A 0C 
13813  FEC0             
13814  FEC0             
13815  FEC0             
13816  FEC0             
13817  FEC0             ;******************************************************************
13818  FEC0             ;
13819  FEC0             ; Target idle speed as a function of ect
13820  FEC0             ;
13821  FEC0             ;       idle speed = xx * 7.8125
13822  FEC0             ;
13823  FEC0             ; default = 750, 750, 1000, 1148, 1273, 1398, 1500, 1648   
13824  FEC0             ;******************************************************************
13825  FEC0 60 60 80 93 t_idleSpd   .byte   idleVal, idleVal, $80, $93, $a3, $b3, $c0, $d3    
13825  FEC4 A3 B3 C0 D3 
13826  FEC8             
13827  FEC8             
13828  FEC8             
13829  FEC8             ;******************************************************************
13830  FEC8             ;
13831  FEC8             ; AT specific table (in drive???)
13832  FEC8             ;
13833  FEC8             ;       idle speed = xx * 7.8125
13834  FEC8             ;
13835  FEC8             ;   default = 648,  648,  797,  898,  1000, 1047, 1101, 1148
13836  FEC8             ;******************************************************************
13837  FEC8~            #ifdef E932
13838  FEC8~            t_idleSpdDr .byte   idleDrVal, idleDrVal, $66, $73, $80, $86, $8d, $93     
13839  FEC8             #endif
13840  FEC8             
13841  FEC8             
13842  FEC8             
13843  FEC8             ;******************************************************************
13844  FEC8             ;
13845  FEC8             ; Target or basic ISC step value as a function of ect
13846  FEC8             ; Used for instance to set iscStepTarg during basic 
13847  FEC8             ; idle speed adjustment
13848  FEC8             ;
13849  FEC8             ;******************************************************************
13850  FEC8             t_iscStEct0
13851  FEC8             #ifdef E931
13852  FEC8 09 12 2E 3B             .byte   $09, $12, $2e, $3b, $3c, $41, $4a, $54
13852  FECC 3C 41 4A 54 
13853  FED0~            #else
13854  FED0~                        .byte   $09, $10, $34, $3f, $46, $50, $5a, $64    
13855  FED0             #endif
13856  FED0             
13857  FED0             
13858  FED0             
13859  FED0             ;******************************************************************
13860  FED0             ;
13861  FED0             ; Target ISC step value as a function of ect
13862  FED0             ;
13863  FED0             ; AT specific table. This table corresponds to t_iscStEct0
13864  FED0             ; but is used when AT is in drive
13865  FED0             ;
13866  FED0             ;******************************************************************
13867  FED0~            #ifdef E932
13868  FED0~            t_iscStEct1       .byte   $0c, $13, $3c, $46, $4e, $58, $64, $6e  
13869  FED0             #endif
13870  FED0             
13871  FED0             
13872  FED0             ;******************************************************************
13873  FED0             ;
13874  FED0             ; Interpolated from conditionned TPS (conTps) (see main code)
13875  FED0             ;
13876  FED0             ; This is related to the minimum isc step to use when the idle
13877  FED0             ; switch transition from off to on and rpm8 goes too low (500rpm)
13878  FED0             ; We don't want the engine to stall...
13879  FED0             ;
13880  FED0             ;
13881  FED0             ;******************************************************************
13882  FED0 09 23 2C 3B t_iscStStall    .byte   $09, $23, $2c, $3b, $45, $4c, $53     
13882  FED4 45 4C 53 
13883  FED7             
13884  FED7             
13885  FED7             
13886  FED7             ;******************************************************************
13887  FED7             ;
13888  FED7             ; AT specific table, equivalent of t_iscStStall when not in park/neutral 
13889  FED7             ;
13890  FED7             ;******************************************************************
13891  FED7~            #ifdef E932
13892  FED7~            L2030       .byte   $09, $23, $45, $4f, $4f, $4f, $4f     
13893  FED7             #endif
13894  FED7             
13895  FED7             
13896  FED7             
13897  FED7             ;******************************************************************
13898  FED7             ;
13899  FED7             ; Interpolated from ect, contains ISC step values
13900  FED7             ;
13901  FED7             ;******************************************************************
13902  FED7 5A 5A 5A 64 L2031       .byte   $5a, $5a, $5a, $64, $6e, $78, $78, $78     
13902  FEDB 6E 78 78 78 
13903  FEDF             
13904  FEDF             
13905  FEDF             
13906  FEDF             ;******************************************************************
13907  FEDF             ;
13908  FEDF             ; Table is interpolated from (rpm4/2 - idleSpdTarg)/4. 
13909  FEDF             ; Values are timer values (40Hz) used to update T40s_iscStable
13910  FEDF             ; when idle switch is off (isc is considered stable when this 
13911  FEDF             ; timer expires...).
13912  FEDF             ;
13913  FEDF             ;******************************************************************
13914  FEDF 50 50 6E 82 t_iscStableIdleSw  .byte   $50, $50, $6e, $82, $96, $aa, $be, $d2, $e6, $f4, $ff   
13914  FEE3 96 AA BE D2 
13914  FEE7 E6 F4 FF 
13915  FEEA             
13916  FEEA             
13917  FEEA             
13918  FEEA             ;******************************************************************
13919  FEEA             ;
13920  FEEA             ; ISC pattern sequence to load to port5 bit 6 
13921  FEEA             ; and 7 to move the ISC spindle 
13922  FEEA             ;
13923  FEEA             ;
13924  FEEA             ;                       --> move spindle
13925  FEEA             ;           bit 7      1 0 0 1 
13926  FEEA             ;           bit 6      0 0 1 1
13927  FEEA             ;
13928  FEEA             ;******************************************************************
13929  FEEA 80 00 40 C0 t_iscPattern  .byte   $80, $00, $40, $c0     
13930  FEEE             
13931  FEEE             
13932  FEEE             
13933  FEEE             ;******************************************************************
13934  FEEE             ;
13935  FEEE             ; ISC step offset as a function of barometric pressure?
13936  FEEE             ; The value in this table is added to iscStepCurr to compensate 
13937  FEEE             ; for barometric pressure
13938  FEEE             ;
13939  FEEE             ; Table interpolated with baroCond (0.45bar to 0.92bar)
13940  FEEE             ; which means there is no offset ($00) when baroCond > 0.92bar
13941  FEEE             ;
13942  FEEE             ;******************************************************************
13943  FEEE 1A 12 09 04 t_iscStBaro .byte   $1a, $12, $09, $04, $00    
13943  FEF2 00 
13944  FEF3             
13945  FEF3             
13946  FEF3             
13947  FEF3             ;******************************************************************
13948  FEF3             ;
13949  FEF3             ; Interpolated from 4 * abs(idleSpdTarg - rpm8), the difference 
13950  FEF3             ; between target idle speed and the current rpm
13951  FEF3             ;
13952  FEF3             ; Values are compared to iscStepTarg 
13953  FEF3             ;
13954  FEF3             ;******************************************************************
13955  FEF3 00 02 06 0A L2035       .byte   $00, $02, $06, $0a, $0d, $0e, $0e, $0f, $0f      
13955  FEF7 0D 0E 0E 0F 
13955  FEFB 0F 
13956  FEFC             
13957  FEFC             
13958  FEFC             
13959  FEFC             ;******************************************************************
13960  FEFC             ;
13961  FEFC             ; Used in the calculation of the default air count when we are
13962  FEFC             ; not receiving airflow sensor interrupts, interpolated from ect
13963  FEFC             ; Seem to be some kind of tps offset...
13964  FEFC             ;
13965  FEFC             ;******************************************************************
13966  FEFC 00 00 00 02 L2036       .byte   $00, $00, $00, $02, $03, $04, $0a, $10     
13966  FF00 03 04 0A 10 
13967  FF04             
13968  FF04             
13969  FF04             
13970  FF04             ;******************************************************************
13971  FF04             ;
13972  FF04             ; Open loop minimum fuel enrichment table ($80=100) 
13973  FF04             ; interpolated by TPS
13974  FF04             ;
13975  FF04             ;
13976  FF04             ;******************************************************************
13977  FF04 78 80 90 92 t_tpsEnr    .byte   $78, $80, $90, $92    
13978  FF08             
13979  FF08             
13980  FF08             
13981  FF08             ;******************************************************************
13982  FF08             ;
13983  FF08             ; Interpolated from rpm, contains airVolB thresholds used in 
13984  FF08             ; timing advance calculations, used in conjuction with L2021
13985  FF08             ;
13986  FF08             ;     500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13987  FF08             ;
13988  FF08             ;******************************************************************
13989  FF08 00 00 71 71 L2038       .byte   $00, $00, $71, $71, $71, $80, $90, $a0, $a0, $a0    
13989  FF0C 71 80 90 A0 
13989  FF10 A0 A0 
13990  FF12             
13991  FF12             
13992  FF12             
13993  FF12             ;******************************************************************
13994  FF12             ;
13995  FF12             ; Table contains airCnt0 thresholds as a function of RPM
13996  FF12             ;
13997  FF12             ;    airCnt0 > $57*L2039(rpm)/16 ?
13998  FF12             ;
13999  FF12             ;    5 10 15 20 25 30 35 40 45 50 x 100 RPM
14000  FF12             ;
14001  FF12             ;******************************************************************
14002  FF12 6D 6D 85 B4 L2039       .byte   $6d, $6d, $85, $b4, $c8, $d0, $d6, $f0, $ff, $ff     
14002  FF16 C8 D0 D6 F0 
14002  FF1A FF FF 
14003  FF1C             
14004  FF1C             
14005  FF1C             
14006  FF1C             ;******************************************************************
14007  FF1C             ;
14008  FF1C             ; Acceleration enrichment
14009  FF1C             ;
14010  FF1C             ; Interpolated from L2040(min(oldAirCnt0/256,5))
14011  FF1C             ;
14012  FF1C             ;******************************************************************
14013  FF1C 0B 0B 0D 10 L2040       .byte   $0b, $0b, $0d, $10, $15, $1b      
14013  FF20 15 1B 
14014  FF22             
14015  FF22             
14016  FF22             
14017  FF22             ;******************************************************************
14018  FF22             ;
14019  FF22             ; Interpolated from f(rpm4)
14020  FF22             ;
14021  FF22             ; Table contain airVol threshold values 
14022  FF22             ;
14023  FF22             ;******************************************************************
14024  FF22 FF FF FF FF L2041       .byte   $ff, $ff, $ff, $ff, $ff, $9b, $a0, $a5, $b8, $c8, $d0, $ff   
14024  FF26 FF 9B A0 A5 
14024  FF2A B8 C8 D0 FF 
14025  FF2E             
14026  FF2E             
14027  FF2E             
14028  FF2E             ;******************************************************************
14029  FF2E             ;
14030  FF2E             ; Table used for the calculation of injPwStart
14031  FF2E             ; Only factored-in if injCount<5 (when the engine starts to crank??)
14032  FF2E             ;
14033  FF2E             ; non constant sample spacing:
14034  FF2E             ;
14035  FF2E             ;   ectCond/32          if ectCond<$c0     
14036  FF2E             ;   (2*ectCond-$c0)/32  if ectCond>=$c0
14037  FF2E             ;
14038  FF2E             ;   scale in degC:
14039  FF2E             ;   
14040  FF2E             ;        86 80 52 35 21 8 -7 -16 -29 
14041  FF2E             ;
14042  FF2E             ;******************************************************************
14043  FF2E 00 00 00 00 L2042       .byte   $00, $00, $00, $00, $00, $00, $00, $20, $40      
14043  FF32 00 00 00 20 
14043  FF36 40 
14044  FF37             
14045  FF37             
14046  FF37             
14047  FF37             ;******************************************************************
14048  FF37             ;
14049  FF37             ;
14050  FF37             ; Boost gauge scale interpolated from airVolT/16
14051  FF37             ;
14052  FF37             ;
14053  FF37             ;******************************************************************
14054  FF37 02 05 08 0A t_bGauge       .byte   $02, $05, $08, $0a, $0d, $0f, $11, $13, $14     
14054  FF3B 0D 0F 11 13 
14054  FF3F 14 
14055  FF40             
14056  FF40             
14057  FF40             
14058  FF40             ;******************************************************************
14059  FF40             ;
14060  FF40             ; EGR solenoid duty cycle 
14061  FF40             ; as a function of rpm(column) and airVol(row)
14062  FF40             ;
14063  FF40             ;******************************************************************
14064  FF40             t_egrDutyFact 
14065  FF40             #ifdef E931
14066  FF40 00 00 00 00             .byte   $00, $00, $00, $00, $00, $00, $00, $00
14066  FF44 00 00 00 00 
14067  FF48 00 00 00 5B             .byte   $00, $00, $00, $5b, $56, $4c, $4d, $00
14067  FF4C 56 4C 4D 00 
14068  FF50 00 00 00 5B             .byte   $00, $00, $00, $5b, $56, $4c, $4d, $00
14068  FF54 56 4C 4D 00 
14069  FF58 00 00 00 5B             .byte   $00, $00, $00, $5b, $56, $60, $5c, $00
14069  FF5C 56 60 5C 00 
14070  FF60 00 00 60 76             .byte   $00, $00, $60, $76, $6c, $5f, $5b, $00
14070  FF64 6C 5F 5B 00 
14071  FF68 80 80 80 7D             .byte   $80, $80, $80, $7d, $6e, $5f, $60, $00
14071  FF6C 6E 5F 60 00 
14072  FF70 80 80 80 80             .byte   $80, $80, $80, $80, $76, $68, $61, $00
14072  FF74 76 68 61 00 
14073  FF78 80 80 80 80             .byte   $80, $80, $80, $80, $80, $60, $61, $00
14073  FF7C 80 60 61 00 
14074  FF80 00 80 80 80             .byte   $00, $80, $80, $80, $80, $78, $6e, $00
14074  FF84 80 78 6E 00 
14075  FF88~            #else
14076  FF88~                        .byte   $00, $00, $00, $00, $00, $00, $00, $00     
14077  FF88~                        .byte   $00, $00, $00, $5a, $40, $3b, $41, $00     
14078  FF88~                        .byte   $00, $00, $00, $5a, $40, $3b, $41, $00     
14079  FF88~                        .byte   $00, $00, $00, $4c, $48, $5a, $56, $00     
14080  FF88~                        .byte   $00, $00, $53, $4d, $5d, $57, $55, $00     
14081  FF88~                        .byte   $80, $80, $68, $6a, $5c, $57, $53, $00     
14082  FF88~                        .byte   $80, $80, $80, $6e, $5f, $57, $55, $00     
14083  FF88~                        .byte   $80, $80, $80, $80, $5f, $5a, $56, $00     
14084  FF88~                        .byte   $00, $80, $80, $80, $80, $80, $80, $00     
14085  FF88             #endif
14086  FF88             
14087  FF88             
14088  FF88             
14089  FF88             
14090  FF88             ;******************************************************************
14091  FF88             ;
14092  FF88             ; EGR solenoid duty cycle as a function of ECT
14093  FF88             ;
14094  FF88             ; Value of $00 to $80 will produce 
14095  FF88             ; 0 to 100% duty cycle 
14096  FF88             ; 
14097  FF88             ;
14098  FF88             ;******************************************************************
14099  FF88 80 80 5B 4F t_egrDuty   .byte   $80, $80, $5b, $4f, $00, $00, $00, $00     
14099  FF8C 00 00 00 00 
14100  FF90             
14101  FF90             
14102  FF90             
14103  FF90             ;******************************************************************
14104  FF90             ;
14105  FF90             ; Interpolated from iat, values are used as minimum egrt
14106  FF90             ; temperature for egrt sensor to be considered as working correctly
14107  FF90             ;
14108  FF90             ; if temperature(egrtRaw) < L2046(iat) then egrt is probably in error
14109  FF90             ;
14110  FF90             ;
14111  FF90             ; in degCC for E931: 83 83 53 41 31 -31 -68
14112  FF90             ;
14113  FF90             ;******************************************************************
14114  FF90             L2046
14115  FF90             #ifdef E931
14116  FF90 9A 9A AE B6             .byte   $9a, $9a, $ae, $b6, $bd, $e6, $ff
14116  FF94 BD E6 FF 
14117  FF97~            #else
14118  FF97~                        .byte   $9a, $9a, $a4, $ab, $bd, $e6, $ff      
14119  FF97             #endif
14120  FF97             
14121  FF97             
14122  FF97             
14123  FF97             ;******************************************************************
14124  FF97             ;
14125  FF97             ; Interpolated from rpm, values are used as minimum airVol
14126  FF97             ; to verify if egrt sensor is working properly
14127  FF97             ;
14128  FF97             ;     500 1000 1500 2000 2500 3000 3500 4000 4500 5000
14129  FF97             ;
14130  FF97             ;******************************************************************
14131  FF97             L2047 
14132  FF97             #ifdef E931
14133  FF97 60 60 58 44             .byte   $60, $60, $58, $44, $35, $33, $30, $30, $30, $30
14133  FF9B 35 33 30 30 
14133  FF9F 30 30 
14134  FFA1~            #else
14135  FFA1~                        .byte   $60, $60, $60, $4c, $40, $38, $33, $30, $30, $30    
14136  FFA1             #endif
14137  FFA1             
14138  FFA1             
14139  FFA1             
14140  FFA1             ;******************************************************************
14141  FFA1             ;
14142  FFA1             ; Interpolated from rpm, values are used as maxmimum airVol
14143  FFA1             ; to verify if egrt sensor is working properly
14144  FFA1             ;
14145  FFA1             ;     500 1000 1500 2000 2500 3000 3500 4000 4500 5000
14146  FFA1             ;
14147  FFA1             ;******************************************************************
14148  FFA1             L2048 
14149  FFA1             #ifdef E931
14150  FFA1 60 60 68 88             .byte   $60, $60, $68, $88, $98, $9c, $a4, $88, $88, $88
14150  FFA5 98 9C A4 88 
14150  FFA9 88 88 
14151  FFAB~            #else
14152  FFAB~                        .byte   $60, $60, $78, $98, $a8, $b0, $b0, $b0, $b0, $b0     
14153  FFAB             #endif
14154  FFAB             
14155  FFAB             
14156  FFAB             
14157  FFAB             ;******************************************************************
14158  FFAB             ;
14159  FFAB             ; Table interpolated from ect
14160  FFAB             ;
14161  FFAB             ;******************************************************************
14162  FFAB 1C 1E 30 53 t_accEnr2b       .byte   $1c, $1e, $30, $53, $73, $86, $9a, $9a    
14162  FFAF 73 86 9A 9A 
14163  FFB3             
14164  FFB3             
14165  FFB3             
14166  FFB3             ;******************************************************************
14167  FFB3             ;
14168  FFB3             ; Table interpolated from ect. Used in the calculation
14169  FFB3             ; of sInjEnrInc, fuel enrichment factor for sim injection 
14170  FFB3             ; during acceleration
14171  FFB3             ;
14172  FFB3             ;******************************************************************
14173  FFB3 10 14 18 29 L2050       .byte   $10, $14, $18, $29, $30, $3a, $4d, $60      
14173  FFB7 30 3A 4D 60 
14174  FFBB             
14175  FFBB             
14176  FFBB             
14177  FFBB             ;******************************************************************
14178  FFBB             ;
14179  FFBB             ; Table interpolated from ect. Values are timer thresholds (2Hz timer)
14180  FFBB             ; used in deciding acceleration enrichment factor and simultaneous 
14181  FFBB             ; injection enrichment
14182  FFBB             ;
14183  FFBB             ;******************************************************************
14184  FFBB 1E 22 2E 36 L2051       .byte   $1e, $22, $2e, $36, $3c, $42, $4a, $56       
14184  FFBF 3C 42 4A 56 
14185  FFC3             
14186  FFC3             
14187  FFC3             
14188  FFC3             ;******************************************************************
14189  FFC3             ;
14190  FFC3             ; Piecewise linear rpm transformation data
14191  FFC3             ;
14192  FFC3             ; Using pwiseLin with this table, we get input(x)/output(y) relationship:
14193  FFC3             ;
14194  FFC3             ;           $00<=x<=$03 -> y = 0 
14195  FFC3             ;           $04<=x<=$07 -> y = x-$03 
14196  FFC3             ;           $08<=x<=$1c -> y = (x+$02)/2
14197  FFC3             ;           $1d<=x      -> y = ($1c+$02)/2
14198  FFC3             ;
14199  FFC3             ;    First row is 
14200  FFC3             ;           max, offset
14201  FFC3             ;    Other rows (i=1 to n) are
14202  FFC3             ;           addVal(i), nshift(i), compVal(i)  
14203  FFC3             ;
14204  FFC3             ;******************************************************************
14205  FFC3 1C 03       L2052       .byte   $1c, $03, 
14206  FFC5 00 01 05                .byte   $00, $01, $05, 
14207  FFC8 05 02 FF                .byte   $05, $02, $ff      
14208  FFCB             
14209  FFCB             
14210  FFCB             
14211  FFCB             ;******************************************************************
14212  FFCB             ;
14213  FFCB             ; Piecewise linear rpm transformation data
14214  FFCB             ;
14215  FFCB             ; Using pwiseLin with this table, we get input(x)/output(y) relationship:
14216  FFCB             ;
14217  FFCB             ;           $00<=x<=$02 -> y = 0 
14218  FFCB             ;           $03<=x<=$03 -> y = (x-$02)/2 
14219  FFCB             ;           $04<=x<=$10 -> y = x/4 
14220  FFCB             ;           $11<=x      -> y = $10/4
14221  FFCB             ;
14222  FFCB             ;    First row is 
14223  FFCB             ;           max, offset
14224  FFCB             ;    Other rows (i=1 to n) are
14225  FFCB             ;           addVal(i), nshift(i), compVal(i)  
14226  FFCB             ;
14227  FFCB             ;******************************************************************
14228  FFCB 10 02       L2053       .byte   $10, $02, 
14229  FFCD 00 02 02                .byte   $00, $02, $02, 
14230  FFD0 02 03 FF                .byte   $02, $03, $ff
14231  FFD3             
14232  FFD3             
14233  FFD3             
14234  FFD3             ;******************************************************************
14235  FFD3             ;
14236  FFD3             ; Piecewise linear mafRaw16 (gramOfAir/sec) transformation data
14237  FFD3             ; Note that this table is the same in 2G ECUs so that it doesn't need
14238  FFD3             ; to be changed if 2G maf is used...
14239  FFD3             ;
14240  FFD3             ; The output of pwiseLin using this table is used to interpolate t_masComp
14241  FFD3             ; This means that t_masComp is a table with non-constant spacing between values
14242  FFD3             ; The spacing is given by the transformation in this table...
14243  FFD3             ;
14244  FFD3             ; Using pwiseLin with this table, we get input(x)/output(y) relationship:
14245  FFD3             ;
14246  FFD3             ;           $00<=x<=$0b -> y = x 
14247  FFD3             ;           $0c<=x<=$17 -> y = (x+$24)/4 
14248  FFD3             ;           $18<=x<=$40 -> y = (x+$60)/8 
14249  FFD3             ;           $41<=x      -> y = ($40+$60)/8
14250  FFD3             ;
14251  FFD3             ;    First row is 
14252  FFD3             ;           max, offset
14253  FFD3             ;    Other rows (i=1 to n) are
14254  FFD3             ;           addVal(i), nshift(i), compVal(i)  
14255  FFD3             ;
14256  FFD3             ;******************************************************************
14257  FFD3 40 00       L2054       .byte   $40, $00, 
14258  FFD5 00 01 0C                .byte   $00, $01, $0c, 
14259  FFD8 24 03 18                .byte   $24, $03, $18, 
14260  FFDB 60 04 FF                .byte   $60, $04, $ff 
14261  FFDE                         
14262  FFDE             ;******************************************************************
14263  FFDE             ;
14264  FFDE             ; Unused??????
14265  FFDE             ;
14266  FFDE             ;******************************************************************
14267  FFDE 01 01       L2055       .byte    $01, $01     
14268  FFE0             
14269  FFE0             
14270  FFE0             
14271  FFE0             ;******************************************************************
14272  FFE0             ;
14273  FFE0             ; Interrupt vector
14274  FFE0             ;      
14275  FFE0             ;      
14276  FFE0             ;
14277  FFE0             ;******************************************************************
14278  FFE0~            #if  (codeOffset > 0)
14279  FFE0~                        .fill   intVector-$, $ff
14280  FFE0             #endif
14281  FFE0             intVector   .org    $ffe0
14282  FFE0 EA 0B                   .word   serialRxInt   ; Serial port Rx interrupt subroutine
14283  FFE2 D0 3E                   .word   reset         ; ???
14284  FFE4 F8 40                   .word   realTimeInt   ; Real time interrupt (801.28Hz)
14285  FFE6 D0 3E                   .word   reset         ; ???                     
14286  FFE8 D0 3E                   .word   reset         ; ???
14287  FFEA D0 3E                   .word   reset         ; ???                            
14288  FFEC FA 92                   .word   outCompInt3   ; Output compare interrupt3 (coil power transistor activation/deactivation)
14289  FFEE F6 1E                   .word   outCompInt2   ; Output compare interrupt2 (injector 2 or 3 activation/deactivation)                            
14290  FFF0 F6 13                   .word   outCompInt1   ; Output compare interrupt1 (injector 1 or 4 activation/deactivation)                         
14291  FFF2 D0 3E                   .word   reset         ; ???
14292  FFF4 F7 B9                   .word   inCaptInt2    ; Input capture interrupt 2 (airflow sensor pulse)
14293  FFF6 EC 6D                   .word   inCaptInt1    ; Input capture interrupt 1 (cas rising or falling edge)
14294  FFF8 D0 3E                   .word   reset         ; Illegal opcode trap?
14295  FFFA D0 3E                   .word   reset         ; Cop failure?
14296  FFFC FA E0                   .word   failureInt    ; Timer clock failure?
14297  FFFE CE FF                   .word   codeStart     ; System reset              
14298  10000                         .end
14299  10000             
14300  10000             
14301  10000             
14302  10000             
tasm: Number of errors = 0
