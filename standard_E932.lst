0001   0000             ;****************************************************************************************************
0002   0000             ;*
0003   0000             ;* GENERAL NOTES
0004   0000             ;* -------------
0005   0000             ;*
0006   0000             ;* CPU
0007   0000             ;* ----
0008   0000             ;* The microcomputer chip used in the 1G DSM ECU seems to be a custom application 
0009   0000             ;* built around the 6801 architecture, Check the 6801, 6803, 6301, 68HC11 at places 
0010   0000             ;* such as alldatasheet.com, etc. CPU clock frequency is assumed to be 2MHz, i.e. 
0011   0000             ;* the inctructions cycle time is 0.5us.
0012   0000             ;*
0013   0000             ;* Assembly binary verifications: 
0014   0000             ;* ------------------------------
0015   0000             ;*
0016   0000             ;*    The 2 binaries produced without any customization ("enableCustom" definition is
0017   0000             ;*    commented-out) have been verified to be identical to the E931 and E932 eprom 
0018   0000             ;*    images at hand.
0019   0000             ;*
0020   0000             ;*    To check the validity of symbolic substitution, the entire code section and tables 
0021   0000             ;*    was offset by $0200 using "codeOffset" and the corresponding binary was tested on
0022   0000             ;*    my car (E932) without any problems for weeks. Additional tests were conducted by
0023   0000             ;*    writing inline code in several part of the code and no adverse effect was ever noted.
0024   0000             ;*
0025   0000             ;*    To check the validity of symbolic substitution for ram addresses, every ram location
0026   0000             ;*    starting at $0057 was offset by 1 (i.e. temp1 was at memory address $58 instead of 
0027   0000             ;*    $57, etc) and the corresponding binary was tested on my car (E932) without any problems
0028   0000             ;*    during car startup and engine revving. No additional test performed.
0029   0000             ;*
0030   0000             ;*    This means that the code can be modified inline and in most cases, ram memories can 
0031   0000             ;*    be moved around by changing the label addresses. Note however that some groups of
0032   0000             ;*    ram memories have to be moved in blocks because the code assumes they are contiguous.
0033   0000             ;*    e.g. the temp1 to temp9 variables, the inj1_offT, inj3_offT, inj4_offT and inj2_offT
0034   0000             ;*    variables, etc.
0035   0000             ;*
0036   0000             ;* Ram memory: 
0037   0000             ;* -----------
0038   0000             ;*    Memory from $0040 to $01bf is backed-up by battery, meaning it is preserved when the
0039   0000             ;*    ECU is powered-off as long as battery power is supplied. However, memory from $0057 to
0040   0000             ;*    $0190 is cleared to 0 by the code every time the ECU is powered-on. That can be however
0041   0000             ;*    changed by modifying the code... Battery backup was checked by disabling memory reset using
0042   0000             ;*    the "noRamReset"  and then check ram memory at $018f to see if it gets preserved after power 
0043   0000             ;*    off/on cycle, and it did. During the test, $018f was used as a distance counter using 
0044   0000             ;*    the reed switch.
0045   0000             ;*
0046   0000             ;* Comments: 
0047   0000             ;* --------
0048   0000             ;*   Some comments use variable names quite loosly. For instance, multi-byte variables
0049   0000             ;*   such as [airCnt0:airCnt1:airCnt2] might be refered to as only airCnt0. airCnt0
0050   0000             ;*   might therefore refer to the single byte airCnt0, to the 16 bit value 
0051   0000             ;*   [airCnt0:airCnt1] or to the 24 bit complete variable, depending on the context.
0052   0000             ;*
0053   0000             ;*   Comments were added incrementally as my knowledge of code and variables
0054   0000             ;*   increased. As new knowledge was learned, old comments were updated or corrected
0055   0000             ;*   as much as possible but not necessarily all of them, so beware... In the end, the
0056   0000             ;*   code is the only truth... Some small areas of the code were also never completly
0057   0000             ;*   understood as a general understanding was reached and I did not care to go further
0058   0000             ;*   e.g. airflow sensor active filter reset
0059   0000             ;*
0060   0000             ;* Opcodes: 
0061   0000             ;* --------
0062   0000             ;*    -cmpd: cmpd1 is used for some addressing modes instead of cmpd since 
0063   0000             ;*           TASM does not support unusual mitsubishi ECU cmpd opcodes..   
0064   0000             ;*
0065   0000             ;*    -brclr: branch if ALL the given bits are clear
0066   0000             ;*
0067   0000             ;*    -brset: branch if ANY of the given bits are set (as opposed to usual 
0068   0000             ;*            implementation of ALL bits set...)
0069   0000             ;*
0070   0000             ;*    -The addressing mode using Y indexing also implicitly
0071   0000             ;*     modifies the y register. It seems that y is increased
0072   0000             ;*     by 1 or 2 depending whether the instruction is a 8 bit
0073   0000             ;*     or 16 bits operation... The following cases are confirmed
0074   0000             ;*
0075   0000             ;*         cmpa $00,y  -> y = y + 1 
0076   0000             ;*         cmpb $00,y  -> y = y + 1 
0077   0000             ;*         ldaa $00,y  -> y = y + 1
0078   0000             ;*         suba $00,y  -> y = y + 1
0079   0000             ;*         ldx  $00,y  -> y = y + 2
0080   0000             ;*         std  $00,y  -> y = y + 2
0081   0000             ;*
0082   0000             ;*                
0083   0000             ;* Telemark assembler:
0084   0000             ;* --------------------
0085   0000             ;*    This assembler does not provide warning messages when code assembles to
0086   0000             ;*    the same memory space, e.g. you insert code in the middle of the file 
0087   0000             ;*    which result in the rest of the code to be offset by N bytes. This
0088   0000             ;*    results in the interrupt vector table to be overwritten. No warning 
0089   0000             ;*    is given. The only way to know about it is to manually check the listing 
0090   0000             ;*    file produced by the assembler. Check that the buffer space between 
0091   0000             ;*    sections is all "$ff". Check that there is no code spilage over .org 
0092   0000             ;*    statements. Check that the address space does not exceed $ffff. Use the 
0093   0000             ;*    "codeOffset" at the beginnng of the file to correct the problem.
0094   0000             ;*              
0095   0000             ;*              
0096   0000             ;* Fuel injector and coil power transistor control
0097   0000             ;* ------------------------------------------------
0098   0000             ;*    Although the 4 fuel injectors and the 2 coil power transistors are mapped to
0099   0000             ;*    regular ports (port1, port2 and port5) which can be read to know the current
0100   0000             ;*    state of these outputs, they are also mapped in hardware to output compare
0101   0000             ;*    registers in order to activate or deactivate them at specific time instants.
0102   0000             ;*    Writing to the ports might therefore not work unless the output compare 
0103   0000             ;*    configuration registers are changed to disable harware control of these 
0104   0000             ;*    outputs. This might not be possible unless an "output enable" bit exists,
0105   0000             ;*    which I haven't found at this point...
0106   0000             ;*    Another way to activate or deactivate them would be to use the output
0107   0000             ;*    compare registers (as currently done by the ECU code) and provoke an 
0108   0000             ;*    immediat output change.
0109   0000             ;*
0110   0000             ;*    Here is my current understanding of how injector scheduling works, not 
0111   0000             ;*    everything is clear to me so don't take this as gospel...:
0112   0000             ;*    The output compare registers for the fuel injectors seem to be at least double
0113   0000             ;*    buffered and maybe triple buffered (see schedInjSim routine). That means that 
0114   0000             ;*    up to 3 different output compare values can be written to t1_outCmpWr and t2_outCmpWr
0115   0000             ;*    to activate or deactivate the injectors at those time instants. Each time a value
0116   0000             ;*    is written to t1_outCmpWr or t2_outCmpWr, the corresponding injector state
0117   0000             ;*    is also internally stored. That means that to activate injector #1 at time X,
0118   0000             ;*    you would first reset bit 0 of t1_csr, corresponding to injector #1 and then
0119   0000             ;*    write X to t1_outCmpWr. You could then immediately schedule the deactivation
0120   0000             ;*    of injector #1 by setting bit 0 of t1_csr to 1 and then write the deactivation 
0121   0000             ;*    time to t1_outCmpWr. When one of the output compare register stored value matches 
0122   0000             ;*    the clock at t1t2_clk, the injector is activated/deactivated and the corresponding
0123   0000             ;*    interrupt routine is called (if the interrupt mask is clear...) at outCompInt1 or 
0124   0000             ;*    outCompInt2.
0125   0000             ;*
0126   0000             ;*    Here is my current understanding of how the coil power transistor scheduling 
0127   0000             ;*    works, not everything is clear to me so don't take this as gospel...: t3_outCmpWr
0128   0000             ;*    is the output compare register used to activate or deactivate the coil power 
0129   0000             ;*    transistors (energize the coil and provoke ignition at the specified time instants)
0130   0000             ;*    To energize the coil for cylinder 1 and 4 at time X you would write X to t3_outCmpWr 
0131   0000             ;*    and reset(0) bit 2 of t3_csr0. At time X, t3_csr0.2 would be loaded into port5.1 
0132   0000             ;*    which would energize the coil. t3_csr0.2 should not be changed until that happens.
0133   0000             ;*    In the code, most of the time 2 successive values (the same one) are written to t3_outCmpWr 
0134   0000             ;*    but there are some instances where only 1 value is written. My impression is that
0135   0000             ;*    the first value serves to activate/deactivate the coil power transistor at the 
0136   0000             ;*    specified instant while the second one only serves to generate an interrupt
0137   0000             ;*    in order to call the outCompInt3 routine. Hence when only the coil need
0138   0000             ;*    to be activated/deactivated without calling outCompInt3, you would only write 
0139   0000             ;*    one value. If in addition you want to have outCompInt3 called when the coil 
0140   0000             ;*    is energized/ignited, you would write two successive values (corresponding to the 
0141   0000             ;*    same time...). This is all speculation of course... As for the 2 clocks at t3_clock1
0142   0000             ;*    and t3_clock1, I assume they are connected to the same internal clock at 250KHz
0143   0000             ;*    but might be input capture registers latched when one of the two output compare 
0144   0000             ;*    at t3_outCmpWr is triggered??????? Again speculation, this is the part of the code
0145   0000             ;*    I understand the least...
0146   0000             ;*
0147   0000             ;*
0148   0000             ;* Timing diagram 
0149   0000             ;* --------------          
0150   0000             ;*
0151   0000             ;* -4 cylinders = 2 rotations = 2 * 360degrees = 720 degrees
0152   0000             ;*
0153   0000             ;* -For sequential injection, fuel injection starts on the cas falling edge 
0154   0000             ;*  i.e. cylinder #1 injection starts at -5 BTDC of #3 TDC
0155   0000             ;*
0156   0000             ;* -Simultaneous injection of all 4 injectors is performed when starting to 
0157   0000             ;*  crank or starting a cold engine or during acceleration, check the tech manual
0158   0000             ;*  and code for more details. Simultaneous injection starts on the 5deg BTDC
0159   0000             ;*  cas signal except in the case of acceleration where it starts when an
0160   0000             ;*  injector is deactivated and no other injector is active (i.e. at the 
0161   0000             ;*  beginning of the time period where no injector is active)
0162   0000             ;*
0163   0000             ;* -Coil energization is usually scheduled (the energization time is loaded into
0164   0000             ;*  the output compare register, energization will occur at the specified time)
0165   0000             ;*  from the cas rising edge. Coil ignition can be scheduled when energization
0166   0000             ;*  occurs (output compare interrupt) or on the cas falling edge depending on 
0167   0000             ;*  the desired timing. Note however that coil energization can also be scheduled
0168   0000             ;*  when ignition occurs on the preceeding cylinder. This would correspond to 
0169   0000             ;*  scheduling ignition before the cas rising edge (at high rpm I assume). Coil
0170   0000             ;*  energization can also be scheduled on the cas falling edge when the desired
0171   0000             ;*  timing is high (e.g. 10deg ATDC). As this shows, there are several combinations 
0172   0000             ;*  and the complexity of the code to handle the coil reflects that fact.
0173   0000             ;*  
0174   0000             ;*           
0175   0000             ;*                         No 1 TDC         No 3 TDC          No 4 TDC          No 2 TDC
0176   0000             ;*                            :                 :                 :                 :
0177   0000             ;*                   ___________                         _____ 
0178   0000             ;* TDC sensor       |           |                       |     |
0179   0000             ;* signal           |         : |               :       |     |   :                 :
0180   0000             ;*              ____|___________|_______________________|_____|________________________
0181   0000             ;*  degrees        85           55                      85   15
0182   0000             ;* (BTDC/ATDC)                :                 :                 :                 :
0183   0000             ;*                    ______            ______            ______            ______ 
0184   0000             ;* CAS sensor        |      |          |      |          |      |          |      |
0185   0000             ;* signal            |      | :        |      | :        |      | :        |      | :
0186   0000             ;*              _____|______|__________|______|__________|______|__________|______|____
0187   0000             ;*  degrees          75     5 :       75      5 :       75      5 :        75     5 :
0188   0000             ;*  (BTDC)                    :                 :                 :                 :
0189   0000             ;*           
0190   0000             ;*                            :                 :                 :                 : 
0191   0000             ;*  No 1 cyl.     compression :   combustion    :    exhaust      :     intake      : compression
0192   0000             ;*  No 3 cyl.       intake    :   compression   :   combustion    :     exhaust     :  intake     
0193   0000             ;*  No 4 cyl.       exhaust   :     intake      :   compression   :    combustion   :  exhaust    
0194   0000             ;*  No 2 cyl.     combustion  :     exhaust     :    intake       :    compression  : combustion  
0195   0000             ;*           
0196   0000             ;*           
0197   0000             ;*           
0198   0000             ;* Airflow calculations dependencies, more details in code
0199   0000             ;* --------------------------------------------------------
0200   0000             ;*           
0201   0000             ;* masProc: airflow sensor interrupt, increases [airCntNew0:airCntNew1] 
0202   0000             ;*    |     by airQuantum for every airflow sensor pulse received
0203   0000             ;*    |
0204   0000             ;*    | 
0205   0000             ;*    |
0206   0000             ;*    |--> [airCntNew0:airCntNew1]: Increased by airQuantum for every airflow sensor pulse
0207   0000             ;*             |                    Reset and used as input to [airCnt0:airCnt1:airCnt2]
0208   0000             ;*             |                    on every cas falling edge, i.e. air is counted twice
0209   0000             ;*             |                    per rotation, once for every cylinder cycle... It can 
0210   0000             ;*             |                    therefore be seen as the air count per cylinder.
0211   0000             ;*             |
0212   0000             ;*             |--> [airCnt0:airCnt1:airCnt2]: Filtered version of 256*[airCntNew0:airCntNew1]
0213   0000             ;*                        |                    exponential averaging is used.
0214   0000             ;*                        |
0215   0000             ;*                        |
0216   0000             ;*                        |
0217   0000             ;*                        |--> mafraw16: 16 bit airflow sensor pulse frequency (mafraw16/10.24)Hz
0218   0000             ;*                        |       |      mafraw16 = 8205*[airCnt0:airCnt1]/Tcas
0219   0000             ;*                        |       |
0220   0000             ;*                        |       |
0221   0000             ;*                        |       |--> mafraw: 8 bit airflow sensor pulse frequency (6.25*mafraw)Hz
0222   0000             ;*                        |                    mafraw: = mafraw16/64
0223   0000             ;*                        |
0224   0000             ;*                        |
0225   0000             ;*                        |
0226   0000             ;*                        |--> airVol16: Equals [airCnt0:airCnt1] * masScalar/65536
0227   0000             ;*                        |       |
0228   0000             ;*                        |       |
0229   0000             ;*                        |       |
0230   0000             ;*                        |       |--> airVol   : Equals airVol16/2
0231   0000             ;*                        |       |--> airVolT  : Equals airVol16/2 * iatCompFact/128
0232   0000             ;*                        |       |--> airVolTB : Equals airVol16/2 * iatCompFact/128 * baroFact/128
0233   0000             ;*                        |       |--> airVolB  : Equals airVol16/2 * baroFact/128
0234   0000             ;*                        |
0235   0000             ;*                        |
0236   0000             ;*                        |--> injPw: Injector pulse width in "normal" operation, 
0237   0000             ;*                                    injPw = [airCnt0:airCnt1] * injFactor/256  + other corrections
0238   0000             ;*
0239   0000             ;*
0240   0000             ;*
0241   0000             ;* Discussion on MAS compensation factors
0242   0000             ;* ---------------------------------------
0243   0000             ;*
0244   0000             ;*     Total airflow sensor compensation is made-up of:
0245   0000             ;*     
0246   0000             ;*          totMasComp(freq,iat,baro) = masComp + t_masComp(freq) + t_masLin(freq,iat,baro)
0247   0000             ;*     
0248   0000             ;*     where maxComp is a fixed offset ($64 for 1G and $40 for 2G) and t_masComp and t_masLin
0249   0000             ;*     are table values interpolated from frequency, intake air temperature and barometric 
0250   0000             ;*     pressure. t_masComp(freq) is basically compensation for the airflow sensor charcteristic
0251   0000             ;*     curve as a function of frequency (to linearize the number of pulse per sec vs. the volume
0252   0000             ;*     of air passing through the sensor) while t_masLin(freq,iat,baro) is a smaller factor
0253   0000             ;*     probably compensating for temperature drift (electronic) and airflow characteristic 
0254   0000             ;*     change as a function of air density???
0255   0000             ;*     
0256   0000             ;*     Assuming the following:
0257   0000             ;*     
0258   0000             ;*         -injComp     = 100% (for 260cc injectors at 36psi)
0259   0000             ;*         -workFtrim   = 100%
0260   0000             ;*         -o2FuelAdj   = 100%
0261   0000             ;*         -iatCompFact = 100% (at 25.6degC)
0262   0000             ;*         -baroFact    = 100% (~1 bar)
0263   0000             ;*         -openLoopEnr = 100%
0264   0000             ;*         -coldTempEnr = 100%
0265   0000             ;*         -enrWarmup   = 0%
0266   0000             ;*     
0267   0000             ;*     
0268   0000             ;*     Then the injector pulswidth is calculated by the ECU as (excluding deadtime)
0269   0000             ;*     
0270   0000             ;*         injPw(usec/cylinder) = numPulsePerCasInterrupts *$9c * totMasComp * 16/256
0271   0000             ;*                              = numPulsePerCasInterrupts * totMasComp * 9.75
0272   0000             ;*     
0273   0000             ;*     If we also assume a 14.7 air to fuel ratio, Dair=1.18 air density (g/litre) at 25degC, 
0274   0000             ;*     Dgas=0.775 fuel density (g/cc) then we would need 23900 usec of injection per 
0275   0000             ;*     litre of air using the same 260cc at 36psi, working that factor into the equation, we 
0276   0000             ;*     get
0277   0000             ;*     
0278   0000             ;*         injPw(usec/cylinder) = numPulsePerCasInterrupts * totMasComp * 9.75
0279   0000             ;*                              = numPulsePerCasInterrupts * totMasComp/2452 * 2452 * 9.75 
0280   0000             ;*                              = numPulsePerCasInterrupts * totMasComp/2452 * 23900usecOfInjection/litreOfAir
0281   0000             ;*     
0282   0000             ;*     This means that under the above assumptions, totMasComp/2452 has units of 
0283   0000             ;*     litreOfAirPerAirflowSensorPulse. 
0284   0000             ;*     
0285   0000             ;*     The factor 2452 is similar to the one provided by J. Oberholtzer, I think. 
0286   0000             ;*     The exact value must be somewhere in that range...
0287   0000             ;*     
0288   0000             ;*     masScalar is also used for maf compensation ($5e86,24198 for 1G, $7A03,31235 for 2g) 
0289   0000             ;*     for controls other than fuel injection. It probably correspond to some metric of
0290   0000             ;*     the totMasComp curve (average or max under given conditions). From 1G and 2G numbers,
0291   0000             ;*     It could correspond to the max of the masComp + t_masComp(freq) curve multiplied 
0292   0000             ;*     by 0.808*128? It could also correspond to the masComp + t_masComp(freq) curve
0293   0000             ;*     sampled at around 69Hz and multiplied by 128.
0294   0000             ;*     
0295   0000             ;*          masScalar = maxTotMasComp*0.808*128 = totMasComp(69Hz)*128
0296   0000             ;*     
0297   0000             ;*     We then have in the case of masScalar = maxTotMasComp*0.808*128:
0298   0000             ;*     
0299   0000             ;*         airVol16 = numPulsePerCasInterrupts * $9c * masScalar / 65536
0300   0000             ;*                  = numPulsePerCasInterrupts * $9c * maxTotMasComp*0.808*128 / 65536
0301   0000             ;*                  = numPulsePerCasInterrupts * maxTotMasComp * 0.2462
0302   0000             ;*                  = numPulsePerCasInterrupts * maxTotMasComp/2452 * 2452*0.2462
0303   0000             ;*                  = numPulsePerCasInterrupts * maxTotMasComp/2452 * 603.68
0304   0000             ;*     
0305   0000             ;*     since totMasComp/2452 is litreOfAirPerAirflowSensorPulse, we have
0306   0000             ;*     
0307   0000             ;*         airVol16 = numPulsePerCasInterrupts * litreOfAirPerAirflowSensorPulse * 603.68
0308   0000             ;*     
0309   0000             ;*     Using again 1.18g/litre air density we get
0310   0000             ;*     
0311   0000             ;*         airVol16 = numPulsePerCasInterrupts * litreOfAirPerAirflowSensorPulse *1.18 * 603.68/1.18
0312   0000             ;*                  = numPulsePerCasInterrupts * gramsOfAirPerAirflowSensorPulse * 512
0313   0000             ;*                  = gramsOfAirPerCasInterrupts * 512
0314   0000             ;*     
0315   0000             ;*     In that case, airVol16/512 can be seen has having units of gramsOfAirPerCasInterrupts 
0316   0000             ;*     (grams of air entering one cylinder). Note that the factor of 512 is not random, the
0317   0000             ;*     factor 0.808 is used to get it in that case...
0318   0000             ;*     
0319   0000             ;*     The load index values used to interpolate the fuel map is then
0320   0000             ;*     
0321   0000             ;*         airVol16/2 <= 96
0322   0000             ;*     
0323   0000             ;*             loadIndex = (airVol16/2-32)/16 
0324   0000             ;*                       = (gramsOfAirPerCasInterrupts*512/2 -32)/16
0325   0000             ;*                       = gramsOfAirPerCasInterrupts*16-2
0326   0000             ;*     
0327   0000             ;*         airVol16/2 >= 96
0328   0000             ;*     
0329   0000             ;*             loadIndex = gramsOfAirPerCasInterrupts * 512/2 * 0.668/16
0330   0000             ;*                       = gramsOfAirPerCasInterrupts*10.69
0331   0000             ;*     
0332   0000             ;*     Which correspond to (gramsOfAirPerCasInterrupts for each index value)
0333   0000             ;*     
0334   0000             ;*            0      1      2       3       4       5       6      7       8       9       10     11
0335   0000             ;*          0.125  0.1875  0.25  0.3125  0.3750  0.4678  0.5614 0.6549  0.7485  0.8421  0.9356  1.0292
0336   0000             ;*     
0337   0000             ;*     gramsOfAirPerRevolution would be twice those values. Notice that the max value of 1.0292
0338   0000             ;*     correspond to about 250HP when BSFC=0.55 which is in the range of the stock 1G 195HP...
0339   0000             ;*     
0340   0000             ;*     Also notice that the 8 bit airflow airVol = airVol16/2 will saturate to $ff when 
0341   0000             ;*     airVol16/2 = 255 which correspond to gramsOfAirPerCasInterrupts = 1 gram. airVolT
0342   0000             ;*     airVolTB and airVolB will also saturate in the same range...
0343   0000             ;*     
0344   0000             ;*     We can now compare these results with the stock boost gauge. It has a max range 
0345   0000             ;*     of 1Kg per sq cm which equals 14.2 psi. The boost gauge duty cycle is given by 
0346   0000             ;*     
0347   0000             ;*         bGaugeODuty = t_bGauge(airVolT/32)/24
0348   0000             ;*     
0349   0000             ;*     When maximum airVolT = 255 = iatCompFact*airVol16/2, bGaugeODuty = 20/24 = 0.83.
0350   0000             ;*     At 25.6 degC, iatCompFact = 1.0 and therefore airVol16=510 which translates to
0351   0000             ;*     1g of air. boost gauge duty of 0.83 correspond to approx. 10.9psi (by eye...). 
0352   0000             ;*     Assuming a displacement of 0.5litre per cylinder and charge air density of  1.18 
0353   0000             ;*     (25degC, probably too low for that psi range, unless you have a perfect intercooler..) 
0354   0000             ;*     we would get 1.18*0.5*(10.9+14.5)/14.5 = 1.03g of air per cylinder (cas 
0355   0000             ;*     interrupt). This is quite close to the 1.0g we had earlier.
0356   0000             ;*     
0357   0000             ;*     The 0psi point on the gauge correspond to a duty cycle of about 40.5% which 
0358   0000             ;*     correspond to bGaugeODuty=9.75/24 which from t_bGauge correspond to 
0359   0000             ;*     airVolT/32=2.875 which means airVolT = 92. with iatCompFact = 1.0 @25degC, 
0360   0000             ;*     we get airVol16 = 2*airVolT/iatCompFact = 184 which correspond to 0.36grams of air 
0361   0000             ;*     Assuming a displacement of 0.5litre per cylinder and charge air density of 1.18@25degC
0362   0000             ;*     we would get 1.18*0.5 = 0.59g of air per cylinder (cas interrupt) at 0psi. Compared to 
0363   0000             ;*     0.36g we had earlier this is a large error but then there are several factor not taken onto 
0364   0000             ;*     account in the calculations, I suppose???.
0365   0000             ;*     
0366   0000             ;*     
0367   0000             ;* Engine coolant and intake air temperature 
0368   0000             ;* ------------------------------------------
0369   0000             ;*
0370   0000             ;*     Approximate sensor curves (temperature 
0371   0000             ;*     against ADC value, taken from MMCD). The
0372   0000             ;*     control points in the service manual are
0373   0000             ;*     quite close (0 to 2 degC off).
0374   0000             ;*
0375   0000             ;*
0376   0000             ;*       ADC   ECT   IAT          ADC  ECT   IAT         ADC  ECT   IAT        ADC   ECT    IAT 
0377   0000             ;*               degC                    degC                    degC                   degC
0378   0000             ;*                                   
0379   0000             ;*       $00  158.0  184.0        $40  52.0  56.0        $80  21.0  23.0       $c0   -7.0   -7.0  
0380   0000             ;*       $01  154.4  178.1        $41  51.3  55.3        $81  20.6  22.5       $c1   -7.5   -7.6  
0381   0000             ;*       $02  150.9  172.5        $42  50.7  54.6        $82  20.2  22.1       $c2   -8.1   -8.2  
0382   0000             ;*       $03  147.5  167.2        $43  50.1  53.9        $83  19.8  21.7       $c3   -8.6   -8.8  
0383   0000             ;*       $04  144.2  162.0        $44  49.5  53.3        $84  19.4  21.2       $c4   -9.2   -9.4  
0384   0000             ;*       $05  140.9  157.1        $45  48.9  52.6        $85  19.0  20.8       $c5   -9.8  -10.1  
0385   0000             ;*       $06  137.7  152.4        $46  48.3  52.0        $86  18.7  20.4       $c6  -10.4  -10.7  
0386   0000             ;*       $07  134.6  148.0        $47  47.7  51.3        $87  18.3  19.9       $c7  -10.9  -11.3  
0387   0000             ;*       $08  131.6  143.7        $48  47.2  50.7        $88  17.9  19.5       $c8  -11.5  -12.0  
0388   0000             ;*       $09  128.6  139.6        $49  46.6  50.1        $89  17.6  19.0       $c9  -12.1  -12.6  
0389   0000             ;*       $0a  125.7  135.7        $4a  46.1  49.4        $8a  17.2  18.6       $ca  -12.7  -13.2  
0390   0000             ;*       $0b  122.9  132.0        $4b  45.6  48.8        $8b  16.9  18.2       $cb  -13.2  -13.9  
0391   0000             ;*       $0c  120.2  128.5        $4c  45.0  48.2        $8c  16.5  17.7       $cc  -13.8  -14.5  
0392   0000             ;*       $0d  117.5  125.1        $4d  44.5  47.7        $8d  16.1  17.3       $cd  -14.3  -15.1  
0393   0000             ;*       $0e  114.9  121.9        $4e  44.0  47.1        $8e  15.7  16.8       $ce  -14.9  -15.7  
0394   0000             ;*       $0f  112.4  118.8        $4f  43.5  46.5        $8f  15.3  16.4       $cf  -15.4  -16.3  
0395   0000             ;*       $10  110.0  116.0        $50  43.0  46.0        $90  15.0  16.0       $d0  -16.0  -17.0  
0396   0000             ;*       $11  107.6  113.2        $51  42.4  45.4        $91  14.5  15.5       $d1  -16.5  -17.6  
0397   0000             ;*       $12  105.3  110.6        $52  41.9  44.9        $92  14.1  15.1       $d2  -17.0  -18.2  
0398   0000             ;*       $13  103.0  108.1        $53  41.4  44.3        $93  13.7  14.6       $d3  -17.5  -18.8  
0399   0000             ;*       $14  100.8  105.8        $54  40.9  43.8        $94  13.3  14.2       $d4  -18.0  -19.4  
0400   0000             ;*       $15   98.7  103.5        $55  40.4  43.3        $95  12.9  13.7       $d5  -18.6  -20.1  
0401   0000             ;*       $16   96.7  101.4        $56  39.9  42.8        $96  12.4  13.3       $d6  -19.2  -20.8  
0402   0000             ;*       $17   94.7   99.4        $57  39.3  42.3        $97  12.0  12.8       $d7  -19.8  -21.5  
0403   0000             ;*       $18   92.8   97.5        $58  38.8  41.8        $98  11.5  12.4       $d8  -20.5  -22.3  
0404   0000             ;*       $19   91.0   95.7        $59  38.3  41.4        $99  11.1  12.0       $d9  -21.3  -23.1  
0405   0000             ;*       $1a   89.2   93.9        $5a  37.8  40.9        $9a  10.6  11.5       $da  -22.1  -24.0  
0406   0000             ;*       $1b   87.5   92.3        $5b  37.3  40.4        $9b  10.2  11.1       $db  -23.0  -24.9  
0407   0000             ;*       $1c   85.9   90.7        $5c  36.9  39.9        $9c   9.7  10.7       $dc  -24.0  -26.0  
0408   0000             ;*       $1d   84.3   89.2        $5d  36.4  39.4        $9d   9.3  10.2       $dd  -25.0  -27.1  
0409   0000             ;*       $1e   82.8   87.7        $5e  35.9  38.9        $9e   8.8   9.8       $de  -26.2  -28.3  
0410   0000             ;*       $1f   81.3   86.3        $5f  35.4  38.4        $9f   8.4   9.4       $df  -27.5  -29.6  
0411   0000             ;*       $20   80.0   85.0        $60  35.0  38.0        $a0   8.0   9.0       $e0  -29.0  -31.0  
0412   0000             ;*       $21   78.6   83.6        $61  34.5  37.5        $a1   7.5   8.5       $e1  -30.5  -32.5  
0413   0000             ;*       $22   77.4   82.4        $62  34.0  37.0        $a2   7.1   8.1       $e2  -32.2  -34.1  
0414   0000             ;*       $23   76.2   81.1        $63  33.6  36.4        $a3   6.6   7.7       $e3  -33.9  -35.7  
0415   0000             ;*       $24   75.0   79.9        $64  33.1  35.9        $a4   6.2   7.3       $e4  -35.8  -37.5  
0416   0000             ;*       $25   73.9   78.8        $65  32.7  35.4        $a5   5.8   6.9       $e5  -37.7  -39.3  
0417   0000             ;*       $26   72.9   77.7        $66  32.3  34.9        $a6   5.3   6.4       $e6  -39.7  -41.2  
0418   0000             ;*       $27   71.9   76.6        $67  31.8  34.4        $a7   4.9   6.0       $e7  -41.7  -43.0  
0419   0000             ;*       $28   70.9   75.5        $68  31.4  33.9        $a8   4.5   5.6       $e8  -43.7  -44.9  
0420   0000             ;*       $29   69.9   74.5        $69  31.0  33.4        $a9   4.0   5.2       $e9  -45.8  -46.8  
0421   0000             ;*       $2a   69.0   73.5        $6a  30.5  32.9        $aa   3.6   4.7       $ea  -47.8  -48.7  
0422   0000             ;*       $2b   68.1   72.5        $6b  30.1  32.4        $ab   3.2   4.3       $eb  -49.8  -50.6  
0423   0000             ;*       $2c   67.3   71.5        $6c  29.7  31.9        $ac   2.7   3.8       $ec  -51.8  -52.4  
0424   0000             ;*       $2d   66.4   70.6        $6d  29.3  31.4        $ad   2.3   3.4       $ed  -53.7  -54.1  
0425   0000             ;*       $2e   65.6   69.7        $6e  28.8  30.9        $ae   1.8   2.9       $ee  -55.5  -55.8  
0426   0000             ;*       $2f   64.8   68.8        $6f  28.4  30.4        $af   1.4   2.4       $ef  -57.3  -57.4  
0427   0000             ;*       $30   64.0   68.0        $70  28.0  30.0        $b0   1.0   2.0       $f0  -59.0  -59.0  
0428   0000             ;*       $31   63.1   67.1        $71  27.5  29.5        $b1   0.5   1.5       $f1  -59.0  -59.0  
0429   0000             ;*       $32   62.3   66.3        $72  27.1  29.0        $b2   0.0   0.9       $f2  -59.0  -59.0  
0430   0000             ;*       $33   61.5   65.5        $73  26.6  28.6        $b3  -0.3   0.4       $f3  -59.0  -59.0  
0431   0000             ;*       $34   60.7   64.7        $74  26.2  28.1        $b4  -0.8  -0.0       $f4  -59.0  -59.0  
0432   0000             ;*       $35   59.9   63.9        $75  25.7  27.7        $b5  -1.3  -0.5       $f5  -59.0  -59.0  
0433   0000             ;*       $36   59.2   63.1        $76  25.3  27.2        $b6  -1.8  -1.1       $f6  -59.0  -59.0  
0434   0000             ;*       $37   58.4   62.3        $77  24.8  26.8        $b7  -2.3  -1.6       $f7  -59.0  -59.0  
0435   0000             ;*       $38   57.6   61.6        $78  24.4  26.4        $b8  -2.8  -2.2       $f8  -59.0  -59.0  
0436   0000             ;*       $39   56.9   60.9        $79  23.9  25.9        $b9  -3.3  -2.8       $f9  -59.0  -59.0  
0437   0000             ;*       $3a   56.1   60.1        $7a  23.5  25.5        $ba  -3.8  -3.3       $fa  -59.0  -59.0  
0438   0000             ;*       $3b   55.4   59.4        $7b  23.0  25.1        $bb  -4.3  -3.9       $fb  -59.0  -59.0  
0439   0000             ;*       $3c   54.7   58.7        $7c  22.6  24.7        $bc  -4.8  -4.5       $fc  -59.0  -59.0  
0440   0000             ;*       $3d   54.0   58.0        $7d  22.2  24.2        $bd  -5.3  -5.1       $fd  -59.0  -59.0  
0441   0000             ;*       $3e   53.3   57.3        $7e  21.8  23.8        $be  -5.9  -5.7       $fe  -59.0  -59.0  
0442   0000             ;*       $3f   52.6   56.6        $7f  21.4  23.4        $bf  -6.4  -6.3       $ff  -59.0  -59.0  
0443   0000             ;*
0444   0000             ;*
0445   0000             ;*
0446   0000             ;*     
0447   0000             ;****************************************************************************************************
0448   0000             
0449   0000             ;***************************************************************
0450   0000             ;*
0451   0000             ;*
0452   0000             ;* Assembler general settings
0453   0000             ;*
0454   0000             ;*
0455   0000             ;*
0456   0000             ;***************************************************************
0457   0000                         .msfirst                        ; Assembler endian setting, do not change
0458   0000                         .define   E932                  ; E931 or E932 depending on desired output
0459   0000                         ;.define   enableCustom          ; Define to enable custom features below, comment-out to get the original E931 or E932 binaries
0460   0000             
0461   0000~            #ifdef enableCustom
0462   0000~                        ;-----------------
0463   0000~                        ; Custom settings 
0464   0000~                        ;-----------------
0465   0000~            codeOffset  .equ      $0100                 ; Allows to move all the code up in the eprom to make space for new code, Original offset is 0.
0466   0000~                        .define   ftrimMax     $b3      ; Maximum fuel trim adjustement (xx/$80)%, $b3=140%
0467   0000~                        .define   fuelMapClip  $d0      ; Fuel map max value (will be clippped to this in code)
0468   0000~                        .define   injComp      $31      ; Injector size compensation referenced to $80=100% for 260cc at 36psi: 390cc(4E,43psi);450(4A);510(41);550(3D);600(38);650(33);660(32);680(31);700(30);750(2C);800(2A);850(27);
0469   0000~                        .define   idleVal      $64      ; Idle speed /8, Normal $60
0470   0000~                        .define   idleDrVal    $57      ; Idle speed /8, Normal $53
0471   0000~                        .define   fuelCutVal   $ff      ; Fuel cut value, Original $a0
0472   0000~                        .define   masComp      $40      ; Mas multiplier (1G:$64, 2G:$40)
0473   0000~                        .define   masScalar    $7a03    ; Mas scalar (1G:$5e86, 2G:$7a03)
0474   0000~                        .define   baudRate     $02      ; BaudRate divider->00(125000baud),01(15625baud),02(1953baud),03(488baud)
0475   0000~            
0476   0000~                        .define   custDeadTime          ; Use custom injector deadtime table
0477   0000~                        .define   custMas               ; Use custom MAS table
0478   0000~                        .define   custFuelMap           ; Use custom fuel map
0479   0000~                        .define   custTimingMap         ; Use custom timing map
0480   0000~                        .define   custOctaneMap         ; Use custom octane map
0481   0000~                        .define   octaneReset           ; Reset octane on every start
0482   0000~                        .define   extLoadRange          ; Extended load range for timing, fuel and octane maps...
0483   0000~                        .define   extLoadRange2         ; Use temperature compensation for load calc when extLoadRange is enabled
0484   0000~                        .define   batteryGauge          ; Battery gauge instead of boost gauge
0485   0000~                        .define   masLog2X              ; Double the MAS logging range
0486   0000~                        ;.define  noFuelCut             ; Remove fuel cut altogether
0487   0000~                        ;.define  noRamReset            ; 
0488   0000~                        .define  noClosedLoop          ; Remove closed loop mode, for testing...
0489   0000~            
0490   0000             #else
0491   0000~            #ifdef E931
0492   0000~                        ;--------------------------------------
0493   0000~                        ; Default values for original 931 ECU
0494   0000~                        ;--------------------------------------
0495   0000~            codeOffset  .equ      $0000                ; 
0496   0000~                        .define   ftrimMax     $b3     ;
0497   0000~                        .define   fuelMapClip  $ca     ;
0498   0000~                        .define   injComp      $4a     ; 450cc injectors used at 36psi...
0499   0000~                        .define   idleVal      $60     ;
0500   0000~                        .define   fuelCutVal   $a0     ; 
0501   0000~                        .define   masComp      $64     ; 
0502   0000~                        .define   masScalar    $5e86   ;                                              
0503   0000~                        .define   baudRate     $02     ; 
0504   0000             #else
0505   0000                         ;--------------------------------------
0506   0000                         ; Default values for original 932 ECU
0507   0000                         ;--------------------------------------
0508   0000             codeOffset  .equ      $0000                ;
0509   0000                         .define   ftrimMax     $b0     ;
0510   0000                         .define   fuelMapClip  $c0     ;
0511   0000                         .define   injComp      $4e     ; 390cc injectors used at 43psi, the value reflects that pressure difference compared to E931
0512   0000                         .define   idleVal      $60     ;
0513   0000                         .define   idleDrVal    $53     ; 
0514   0000                         .define   fuelCutVal   $a0     ; 
0515   0000                         .define   masComp      $64     ; 
0516   0000                         .define   masScalar    $5e86   ;                                              
0517   0000                         .define   baudRate     $02     ; 
0518   0000             #endif
0519   0000             #endif
0520   0000             
0521   0000             
0522   0000             
0523   0000             ;***************************************************************
0524   0000             ;*
0525   0000             ;*
0526   0000             ;* Microcontroller registers
0527   0000             ;*
0528   0000             ;*
0529   0000             ;***************************************************************
0530   0000             p1_ddr           .EQU     $0000                  ; Port 1 data direction register. Initialized with $7E=01111110  (0=intput, 1=output)
0531   0000             p2_ddr           .EQU     $0001                  ; Port 2 data direction register. Initialized with $16=00010110
0532   0000             port1            .EQU     $0002                  ; Port 1 Data register                                             
0533   0000                                                              ;    bit 0 (0x01):  in  - Unused but varies(seems to have correlation with CAS), by extrapolation, set to out for injector #5 or #6 on other ECUs?                                                 
0534   0000                                                              ;    bit 1 (0x02):  out - Set to 0 to activate injector #3?                                             
0535   0000                                                              ;    bit 2 (0x04):  out - Set to 0 to activate injector #2?                                            
0536   0000                                                              ;    bit 3 (0x08):  out - Set to 0 to activate injector #4?                                              
0537   0000                                                              ;    bit 4 (0x10):  out - Fuel pump relay
0538   0000                                                              ;    bit 5 (0x20):  out - Air cond. clutch
0539   0000                                                              ;    bit 6 (0x40):  out - ???, reset to 0 on init and first sub    
0540   0000                                                              ;    bit 7 (0x80):  in  - Reed switch, 4 square pulse (square wave) per odometer rotation, each of the 4 complete square wave correspond to ~40cm (20cm for each rising or falling edge)
0541   0000             port2            .EQU     $0003                  ; Port 2 Data register
0542   0000                                                              ;    bit 0 (0x01):  in  - Unused but varies (seems to have correlation with CAS), by extrapolation, set to out for injector #5 or #6 on other ECUs?                                                                                                           
0543   0000                                                              ;    bit 1 (0x02):  out - Set to 0 to activate injector #1?                                                                                                             
0544   0000                                                              ;    bit 2 (0x04):  out - Airflow sensor active filter reset. Set/reset depending on tps,rpm,airVol,idleSwitch??????   (in serial clock)-  Connected to serial port clock???
0545   0000                                                              ;    bit 3 (0x08):  in  - Connected to serial port input (if serial RE is enabled) and test connector serial interface                                                                              
0546   0000                                                              ;    bit 4 (0x10):  out - Connected to serial port output (if serial TE is enabled) and test connector serial interface, controlled directly to output heart beat code to test connector
0547   0000                                                              ;    bit 5 (0x20):  in  - 0, ECU Operating mode PC0 (latched on ECU reset)                                                               
0548   0000                                                              ;    bit 6 (0x40):  in  - 1, ECU Operating mode PC1                                                                                      
0549   0000                                                              ;    bit 7 (0x80):  in  - 0, ECU Operating mode PC2                                                                                      
0550   0000             p3_ddr           .EQU     $0004                  ; Port 3 data direction register, Initialized to 0 (all input) 
0551   0000             p4_ddr           .EQU     $0005                  ; Port 4 data direction register, Initialized to 0 (all input) 
0552   0000             port3            .EQU     $0006                  ; Port 3 Data register                                         
0553   0000                                                              ;    bit 0 (0x01):  in  - IG2 related, 0 when IG2 at +12V??? (ABS unit?????)  see around Md4d4 and M23db?                                    
0554   0000                                                              ;    bit 1 (0x02):  in  - IG1. 0 when IG1 at +12V. Set to 1 when power has been turned off and control relay is about to turn off. i.e. ECU is going to loose power in a short while.
0555   0000                                                              ;    bit 2 (0x04):  in  - Top dead center sensor signal (TDC). Set to 0 when TDC signal is active
0556   0000                                                              ;    bit 3 (0x08):  in  - Set to 1 if power steering pump is activated
0557   0000                                                              ;    bit 4 (0x10):  in  - Air cond. switch (1=off). 0 indicate that AC should be activated, if possible... Connected to the output of the A/C control unit through the the ECT switch (switch cuts signal therefore asking ECU to cut clutch...)
0558   0000                                                              ;    bit 5 (0x20):  in  - Inhibitor switch (A/T only) Set to 1 when transmission is in park or neutral
0559   0000                                                              ;    bit 6 (0x40):  in  - 0 if key is in start position
0560   0000                                                              ;    bit 7 (0x80):  in  - Set to 1 when the idle switch is on
0561   0000             port4            .EQU     $0007                  ; Port 4 data register 
0562   0000                                                              ;    bit 0 (0x01):  in  - c0, set when config resistor R129 is installed. used in conjucntion with c1 in #t_strap1 lookup, FEDERAL (0) or CALIFORNIA (1)                                                
0563   0000                                                              ;    bit 1 (0x02):  in  - c1, set when config resistor R130 is installed. used in conjucntion with c0 in #t_strap1 lookup, FWD (0) or AWD (1)                                                
0564   0000                                                              ;    bit 2 (0x04):  in  - Signal from the ignition sensing circuit. Toggled on every ignition signal sent to the coil (toggled on every cylinder ignition if the power transistor output changed...), stays at the given level from one ignition to the other
0565   0000                                                              ;    bit 3 (0x08):  in  - Set to 1 when ECU test mode terminal is grounded                
0566   0000                                                              ;    bit 4 (0x10):  in  - Set to 1 when the timing terminal is grounded                                                 
0567   0000                                                              ;    bit 5 (0x20):  in  - Knock sensor feedback? (set to 1 indicates it works...)???                                                
0568   0000                                                              ;    bit 6 (0x40):  in  - Fuel pump driven feedback? 0 when FP is driven?                                               
0569   0000                                                              ;    bit 7 (0x80):  in  - Injector driven feedback. Set to 0 when injector circuit is working properly??? Bit is tested when an injector to test was just deactivated and no other injector is active??? Bit might be loaded on the falling edge of the injector driving current???
0570   0000                                                              ;                         Service manual says injector is bad if injector is not continuously driven for 4 sec during idle or cranking. 4 sec is implemented by fault code regular code... So this bit would be "injector driven" bit
0571   0000             t1_csr           .EQU     $0008                  ; Dual of $18, Timer1 control and status register, dual of t2_csr                                                             
0572   0000                                                              ;    bit 0 (0x01): Injector 1 activation/deactivation bit. Bit is transfered to port2.1 when a t1 or t2 output compare interrupt is generated???
0573   0000                                                              ;    bit 1 (0x02): cas edge detection polarity, set to 0 to trigger an interrupt on the CAS rising edge, set to 1 to trigger an interrupt on the CAS falling edge
0574   0000                                                              ;    bit 2 (0x04): By extrapolation, set to 0 when injector 5/6 is on????
0575   0000                                                              ;    bit 3 (0x08): Set to 1 to enable outCompInt1 interrupts (injector 1 only or 1 and 4)?
0576   0000                                                              ;    bit 4 (0x10): Set to 1 to enable inCaptInt1 interrupts (cas)?
0577   0000                                                              ;    bit 5 (0x20): By extrapolation, set to 0 when injector 5/6 is on????
0578   0000                                                              ;    bit 6 (0x40): 1 indicate that outCompInt1 interrupt is pending/has been activated (injector #1 or #4 activation/deactivation)                                                                                               
0579   0000                                                              ;    bit 7 (0x80): 1 indicate that inCaptInt1 interrupt is pending/has been activated (cas)
0580   0000             t1t2_clk         .EQU     $0009   ;:$000a        ; Free running counter at 1MHz for t1 and t2 timer functions
0581   0000             t1_outCmpWr      .EQU     $000b   ;:$000c        ; Dual of $001B, Output compare register, value is compared to t1t2_clk and when a match occurs, injector ports are loaded with the values indicated in t1_csr. Seems 2 or 3 successive value can be written (injector activation and deactivation times...)
0582   0000             t1_inCapt        .EQU     $000d   ;:$000e        ; Cas sensor input capture register. Contains the value of t1t2_clk when the cas sensor "edge" was detected
0583   0000             L000f            .EQU     $000f                  ; Init to 0??????????????
0584   0000             sci_baud         .EQU     $0010                  ; Serial communication rate and mode control register (clock source = 2MHz)                     
0585   0000                                                              ;    bit 0 (0x01): SS0, [SS1:SS0] is baud rate divider, 00(16) 01(128) 10(1024) 11(4096), assuming basic clock of 2MHZ, we get 125000baud, 15625baud, 1953baud, 488baud                           
0586   0000                                                              ;    bit 1 (0x02): SS1                            
0587   0000                                                              ;    bit 2 (0x04): CC0, [CC1:CC0] is the mode control register                          
0588   0000                                                              ;    bit 3 (0x08): CC1                            
0589   0000                                                              ;    bit 4 (0x10): NU?                                                                
0590   0000                                                              ;    bit 5 (0x20): NU?                                                                
0591   0000                                                              ;    bit 6 (0x40): NU?                                                                
0592   0000                                                              ;    bit 7 (0x80): NU?                                                                
0593   0000             sci_scr          .EQU     $0011                  ; Serial communication status and control register?                             
0594   0000                                                              ;    bit 0 (0x01): WU   - Wake-up on idle line                                     
0595   0000                                                              ;    bit 1 (0x02): TE   - transmit enable, set to 1                                
0596   0000                                                              ;    bit 2 (0x04): TIE  - Tx interrupt enable, reset to 0                          
0597   0000                                                              ;    bit 3 (0x08): RE   - Rx enable, checked for set before tx                     
0598   0000                                                              ;    bit 4 (0x10): RIE  - Rx interrupt enable,  Reset/set to 0/1 in real time int        
0599   0000                                                              ;    bit 5 (0x20): TDRE - transmit data register empty                             
0600   0000                                                              ;    bit 6 (0x40)  ORFE - Overrun and framing error                                
0601   0000                                                              ;    bit 7 (0x80): RDRF - Read data register full                                  
0602   0000             sci_rx           .EQU     $0012                  ; SCI data read register   
0603   0000             sci_tx           .EQU     $0013                  ; SCI data write register  
0604   0000             ramControl       .EQU     $0014                  ; RAM control register/battery saving status register
0605   0000                                                              ;    bit 0 (0x01): Init to 0? 
0606   0000                                                              ;    bit 1 (0x02): Init to 0?
0607   0000                                                              ;    bit 2 (0x04): Init to 0?
0608   0000                                                              ;    bit 3 (0x08): Init to 0?
0609   0000                                                              ;    bit 4 (0x10): Init to 0?
0610   0000                                                              ;    bit 5 (0x20): Init to 0?
0611   0000                                                              ;    bit 6 (0x40): Ram enable bit??? Set to 1 after the fresh reset initialization is done, reset to 0 in failureInt?
0612   0000                                                              ;    bit 7 (0x80): Power standby bit, Set to 1 after the fresh reset initialization is done, reset to 0 if we loose standby power (i.e. 0 when ram content was not preserved after a power-off) 
0613   0000             p5_ddr           .EQU     $0015                  ; Port 5 data direction register, Initialized to $#fe (1111 1110)
0614   0000             port5            .EQU     $0016                  ; Port 5      
0615   0000                                                              ;    bit 0 (0x01): in  - CAS, crank angle sensor signal. Set to 0 when the CAS signal is activated                                                                                  
0616   0000                                                              ;    bit 1 (0x02): out - Power transistor output for cyl 1 and 4. Set to 0 to energize the coil. 
0617   0000                                                              ;    bit 2 (0x04): out - Power transistor output for cyl 2 and 3. Set to 0 to energize the coil. 
0618   0000                                                              ;    bit 3 (0x08): out - EGR control solenoid output
0619   0000                                                              ;    bit 4 (0x10): out - Fuel pressure solenoid output (0=activated)                                                                                
0620   0000                                                              ;    bit 5 (0x20): out - Boost control solenoid output
0621   0000                                                              ;    bit 6 (0x40): out - ISC step control, see table t_iscPattern                                                                 
0622   0000                                                              ;    bit 7 (0x80): out - ISC step control, see table t_iscPattern                                                                 
0623   0000             L0017            .EQU     $0017                  ; Init to 0?????
0624   0000             t2_csr           .EQU     $0018                  ; Timer2 control and status register, uses the same clock as timer 1 (t1t2_clk)
0625   0000                                                              ;    bit 0 (0x01): Injector 3 activation/deactivation bit. Bit is transfered to port1.1 when a t1 or t2 output compare interrupt is generated
0626   0000                                                              ;    bit 1 (0x02): Airflow sensor edge detection polarity (0=rising edge, 1=falling edge, or the opposite?). See masProc subroutine header
0627   0000                                                              ;    bit 2 (0x04): Injector 2 activation/deactivation bit. Bit is transfered to port1.2 when a t1 or t2 output compare interrupt is generated
0628   0000                                                              ;    bit 3 (0x08): Set to 1 to enable outCompInt2 interrupts (injectors 2, 3 and maybe 4)?
0629   0000                                                              ;    bit 4 (0x10): Set to 1 to enable inCaptInt2 interrupts (airflow sensor)?
0630   0000                                                              ;    bit 5 (0x20): Injector 4 activation/deactivation bit. Bit is transfered to port1.3 when a t1 or t2 output compare interrupt is generated
0631   0000                                                              ;    bit 6 (0x40): 1 indicate that outCompInt2 interrupt is pending/has been activated (injectors #2 or #3 activation/deactivation)                                                                                               
0632   0000                                                              ;    bit 7 (0x80): 1 indicate that inCaptInt2 interruot is pending/has been activated (airflow sensor pulse)  
0633   0000             t3_csr0          .EQU     $0019                  ; Normally the dual of $0009 but since the ECU didn't need the equivalent of t1t2_clk for timer 2 (timer 1 and timer 2 both use t1t2_clk), it is used for something else...
0634   0000                                                              ; timer 3 (coil) control ans status register 0 ???
0635   0000                                                              ;    bit 0 (0x01): 0 all the time except, set to 1 when no cas interrupt received for 1.275sec???
0636   0000                                                              ;    bit 1 (0x02): 1 on every loop
0637   0000                                                              ;    bit 2 (0x04): 1 Set to 0 when the output compare interrupt need to energize coil for cylinder 1 or 4, i.e. bit will be loaded in port5.1 when interrupt occur
0638   0000                                                              ;    bit 3 (0x08): 1 Set to 0 when the output compare interrupt need to energize coil for cylinder 2 or 3, i.e. bit will be loaded in port5.2 when interrupt occur
0639   0000                                                              ;    bit 4 (0x10): 1 on init but not on every loop, Used to decide which of t3_clock1 or t3_clock2 should be used upon a CAS interrupt???
0640   0000                                                              ;    bit 5 (0x20): 0 on every loop
0641   0000                                                              ;    bit 6 (0x40): 1 on every loop
0642   0000                                                              ;    bit 7 (0x80): 0 on every loop
0643   0000             t3_csr1          .EQU     $001a                  ; Normally the dual of $000a but since the ECU didn't need the equivalent of t1t2_clk for timer 2 (timer 1 and timer 2 both use t1t2_clk), it is used for something else...
0644   0000                                                              ; timer 3 (coil) control ans status register 1???
0645   0000                                                              ;    bit 0 (0x01): 0 Cylinder 1/4 or 2/3 ?? output compare detection polarity?
0646   0000                                                              ;    bit 1 (0x02): 1 Cylinder 1/4 or 2/3 ?? output compare detection polarity?
0647   0000                                                              ;    bit 2 (0x04): 0 Cylinder 1/4 or 2/3 ?? output compare detection polarity?
0648   0000                                                              ;    bit 3 (0x08): 1 Cylinder 1/4 or 2/3 ?? output compare detection polarity?
0649   0000                                                              ;    bit 4 (0x10): 0
0650   0000                                                              ;    bit 5 (0x20): 0
0651   0000                                                              ;    bit 6 (0x40): 0 1 indicate that the outCompInt3 interrupt is pending/has been activated???                                                                                               
0652   0000                                                              ;    bit 7 (0x80): 0
0653   0000             t2_outCmpWr      .EQU     $001b   ;:$001c        ; Dual of $0b:$0c, Output compare register, value is compared to t1t2_clk and when a match occurs, injector ports are loaded with the values indicated in t2_csr. seems 2 or 3 successive value can be written (injector activation and deactivation times...)
0654   0000             t2_inCapt        .EQU     $001d   ;:$001e        ; Dual of $0d:$0e, Airflow sensor input capture register. Contains the value of t1t2_clk when an airflow sensor pulse edge detected
0655   0000             adc_ctl          .EQU     $001f                  ; ADC control; [bit 3 = start bit?, bit 2:0 = channel select ]???
0656   0000                                                              ;    bit 0 (0x01): c0 [c2:c1:c0] is the port number to use aas input to the A/D converter                                                                      
0657   0000                                                              ;    bit 1 (0x02): c1                                                                       
0658   0000                                                              ;    bit 2 (0x04): c2                                                                       
0659   0000                                                              ;    bit 3 (0x08): Start bit, set to 1 to start A/D conversion                                                                         
0660   0000                                                              ;    bit 4 (0x10): ?                                                                       
0661   0000                                                              ;    bit 5 (0x20): ?                                                                       
0662   0000                                                              ;    bit 6 (0x40): ?
0663   0000                                                              ;    bit 7 (0x80): ?                                                                       
0664   0000             adc_data         .EQU     $0020                  ; 8 bit A to D converter result data
0665   0000             L0021            .EQU     $0021                  ; Unused?
0666   0000             L0022            .EQU     $0022                  ; Unused?
0667   0000             L0023            .EQU     $0023                  ; Unused?
0668   0000             L0024            .EQU     $0024                  ; Init to 0?
0669   0000             L0025            .EQU     $0025                  ; Unused?
0670   0000             rti_ctl          .EQU     $0026                  ; Timer control and status register for real time interrupt? init to $4D = 0100 1101
0671   0000                                                              ;    bit 0 (0x01): ?                                                                       
0672   0000                                                              ;    bit 1 (0x02): ?                                                                       
0673   0000                                                              ;    bit 2 (0x04): ?                                                                       
0674   0000                                                              ;    bit 3 (0x08): ?                                                                       
0675   0000                                                              ;    bit 4 (0x10): ?                                                                       
0676   0000                                                              ;    bit 5 (0x20): ?                                                                       
0677   0000                                                              ;    bit 6 (0x40): Set to 1 to enable rti interrupts?
0678   0000                                                              ;    bit 7 (0x80): ?                                                                       
0679   0000             rti_freq         .EQU     $0027                  ; Real time interrupt frequency setting: Freq = 125000/(256-x) where x is the content of rti_freq
0680   0000             L0028            .EQU     $0028                  ; Unused?
0681   0000             t3_clock1        .EQU     $0029   ;:$002a        ; Readable counter. Frequency seems to be 250KHz (2MHz/8).
0682   0000             t3_outCmpWr      .EQU     $002b   ;:$002c        ; Writable output compare register for counters at $0029:$002A and $002D:$002E
0683   0000                                                              ; Seems to be double buffered...
0684   0000             t3_clock2        .EQU     $002d   ;:$002e        ; Dual of $0029. I think it always has the same value as t3_clock1 but ipon a cas interrupt, the code decides between t3_clock1 and t3_clock2???
0685   0000             port6            .EQU     $002f                  ; Port 6 (all output, no data direction register?)                                             
0686   0000                                                              ;    bit 0 (0x01): out - Write 1 to reset instant knock count???
0687   0000                                                              ;    bit 1 (0x02): out - ??? Set to 0 when rpm>4688rpm, set to 1 when rpm<4600, could be some kind of ECU board filter setting for the knock sensor???
0688   0000                                                              ;    bit 2 (0x04): out - Boost gauge output
0689   0000                                                              ;    bit 3 (0x08): out - Check engine (CE) light
0690   0000                                                              ;    bit 4 (0x10): out - Reset to 0 to activate purge solenoid?
0691   0000                                                              ;    bit 5 (0x20): out - Toggled at F924 if main loop frequency >20Hz, could be tied to ECU reset in case of trouble (COP clock)
0692   0000                                                              ;    bit 6 (0x40): out - Not used?                                                         
0693   0000                                                              ;    bit 7 (0x80): out - Not used?                                                         
0694   0000                              
0695   0000                              ;------------------------------
0696   0000                              ; Block of 16 probably unused 
0697   0000                              ; microcontroller registers??? 
0698   0000                              ;------------------------------
0699   0000             L0030            .EQU     $0030                  ; Unused
0700   0000             L0031            .EQU     $0031                  ; Unused
0701   0000             L0032            .EQU     $0032                  ; Unused
0702   0000             L0033            .EQU     $0033                  ; Unused
0703   0000             L0034            .EQU     $0034                  ; Unused
0704   0000             L0035            .EQU     $0035                  ; Unused
0705   0000             L0036            .EQU     $0036                  ; Unused
0706   0000             L0037            .EQU     $0037                  ; Unused
0707   0000             L0038            .EQU     $0038                  ; Unused
0708   0000             L0039            .EQU     $0039                  ; Unused
0709   0000             L003a            .EQU     $003a                  ; Unused
0710   0000             L003b            .EQU     $003b                  ; Unused
0711   0000             L003c            .EQU     $003c                  ; Unused
0712   0000             L003d            .EQU     $003d                  ; Unused
0713   0000             L003e            .EQU     $003e                  ; Unused
0714   0000             L003f            .EQU     $003f                  ; Unused 
0715   0000                         
0716   0000             
0717   0000             
0718   0000             ;***************************************************************
0719   0000             ;*
0720   0000             ;*
0721   0000             ;* Block of RAM used to preserve settings when the ECU is off 
0722   0000             ;* (This block is not cleared to 0 when the ECU is powered-on)
0723   0000             ;*
0724   0000             ;*
0725   0000             ;***************************************************************
0726   0000             ftrim_low        .EQU     $0040                  ; Fuel trim low  (.78x)%                     
0727   0000             ftrim_mid        .EQU     $0041                  ; Fuel trim mid  (.78x)%                     
0728   0000             ftrim_hi         .EQU     $0042                  ; Fuel trim high (.78x)%                     
0729   0000             ftrimCntr        .EQU     $0043                  ; Fuel trim counter. This counter is increased/decreased by 5 (+/-5 at 40Hz) whenever a fuel trim is below/above o2Fbk threshold. The fuel trim is increased/decreased by 1 whenever this counter rools over, giving an effective update rate of 40Hz/(256/5)=0.78125Hz for the fuel trims update                                           
0730   0000             isc0             .EQU     $0044   ;:$0045        ; iscm (isc0 or isc1) are 16 bit long term correction factors/feedback for the isc step adjustment. It is centered at $8000 (100%, no correction). Init to $8c00, A value higher than $8000 indicate that we need to increase the isc step since the current rpm is lower than the desired one
0731   0000                                                              ; The isc step used is increased/decreased by iscm/256 - $80. iscm is updated from the short term iscYn variable.The isc step used is increased/decreased by iscm/256 - $80
0732   0000                                                              ; isc0 is the long term learning variable when A/C is off, 16 bits, see iscPointers function
0733   0000             isc1             .EQU     $0046   ;:$0047        ; isc1 is the long term learning variable when A/C is on, 16 bits, see iscPointers function
0734   0000             iscStepCom       .EQU     $0048                  ; isc step complement, shlould be equal to  ~iscStepCurr & $7f. Not sure of its utility???
0735   0000             iscStepCurr      .EQU     $0049                  ; Current isc step (x) range of 0 to 120 (or 13x???)                             
0736   0000             iscPatrnIdx      .EQU     $004a                  ; Current ISC pattern index, two lower bits are used as index into t_iscPattern to update port5.6.7 in order to move the ISC spindle...                                          
0737   0000             iscFlags0        .EQU     $004b                  ; Flag register for ISC updating
0738   0000                                                              ;    bit 0 (0x01): Set to 1 once the isc calibration is started. This means we initialized iscStepCurr to 135 and set the iscStepTarg to 0. The spindle will therefore be moved to the minimum position irrespective of the starting position, which will allow us to know its real position... Reset to 0 once calibration is finished and ISC is back to iscStepCurr=6
0739   0000                                                              ;    bit 1 (0x02): Set to 1 once the isc calibration is finished. i.e. once iscStepCurr reached 0. See bit 0.  Reset to 0 once calibration is finished and ISC is back to iscStepCurr=6
0740   0000                                                              ;    bit 2 (0x04): Set when basic idle speed adjustment mode is active 
0741   0000                                                              ;    bit 3 (0x08): Set to 1 when a fixed isc step is used because the engine is running but we are not receiving airflow sensor interrupts. 
0742   0000                                                              ;    bit 4 (0x10): Set to 1 when a fixed isc step is used because the ECU is about to loose power 
0743   0000                                                              ;    bit 5 (0x20): Set to 1 when ISC min calibration need to be performed, i.e. move the spindle 135 steps toward 0, that ensures the spindle is positionned at the minimum position, wherever we started from... Reset to 0 once calibration is finished and ISC is back to iscStepCurr=6
0744   0000                                                              ;    bit 6 (0x40): Set to 1 when the ISC max calibration has been performed, see bit 7
0745   0000                                                              ;    bit 7 (0x80): Set to 1 when ISC max calibration need to be performed. Max calibration is achieved by setting iscStepTarg to 135, wait for iscStepCurr to reach 135 (higher than max usable valu of 120) and then set iscStepCurr to 120 since this is the max usable value 
0746   0000             stFaultHi        .EQU     $004c                  ; Stored faults, High byte. Notice we say its high byte because it is the ECU convention to store high byte before low byte and it is also used that way in the code                   
0747   0000             stFaultLo        .EQU     $004d                  ; Stored faults, Low byte. 
0748   0000             faultHi          .EQU     $004e                  ; Faults, high byte. Notice we say its high byte because it is the ECU convention to store high byte before low byte and it is also used that way in the code                   
0749   0000             faultLo          .EQU     $004f                  ; Faults, low byte                         
0750   0000             o2BadCnt         .EQU     $0050                  ; Used to test the o2 sensor, 0 when 02 sensor not in fault or not tested, 1 or greater when o2 sensor is bad. Can only increase by 1 each time the ECU is turned on and sensor is tested
0751   0000             egrtBadCnt       .EQU     $0051                  ; Used to test the egrt sensor, 0 when egrt sensor not in fault or not tested, 1 or greater when egrt sensor is bad. Can only increase by 1 each time the ECU is turned on and sensor is tested
0752   0000             octane           .EQU     $0052                  ; Octane value used in timing advance calculation with min 0(bad fuel...), max 255 (no knock). Updated at 2.5Hz from knockSum under specific circumstances (decremented by 1 if knocksum>5, incremented by 1 if knocksum<3)
0753   0000             knockFlags       .EQU     $0053                  ; Flags related to knock sensor
0754   0000                                                              ;    bit 0 (0x01): 
0755   0000                                                              ;    bit 1 (0x02): 
0756   0000                                                              ;    bit 2 (0x04): 
0757   0000                                                              ;    bit 3 (0x08): 
0758   0000                                                              ;    bit 4 (0x10): 
0759   0000                                                              ;    bit 5 (0x20): 
0760   0000                                                              ;    bit 6 (0x40): Set to 1 when engine has been runnning for more than 1 sec
0761   0000                                                              ;    bit 7 (0x80): Set to 1 when airVol>$49, used to know whether engine is under high or loaw load for knockSum and knockSum decay calculations
0762   0000             L0054            .EQU     $0054                  ; UNUSED?
0763   0000             config1          .EQU     $0055                  ; Configuration flags depending on config resistors, Loaded with t_strap1[port4& (#$03 << 1)]
0764   0000                                                              ;    bit 0 (0x01): 
0765   0000                                                              ;    bit 1 (0x02): 
0766   0000                                                              ;    bit 2 (0x04): 
0767   0000                                                              ;    bit 3 (0x08): 
0768   0000                                                              ;    bit 4 (0x10): 
0769   0000                                                              ;    bit 5 (0x20): 
0770   0000                                                              ;    bit 6 (0x40): 
0771   0000                                                              ;    bit 7 (0x80): 
0772   0000             config2          .EQU     $0056                  ; Configuration flags depending on config resistors, Loaded with t_strap1[port4& (#$03 << 1)+1]  
0773   0000                                                              ;    bit 0 (0x01): 
0774   0000                                                              ;    bit 1 (0x02): 
0775   0000                                                              ;    bit 2 (0x04): 
0776   0000                                                              ;    bit 3 (0x08): 
0777   0000                                                              ;    bit 4 (0x10): 
0778   0000                                                              ;    bit 5 (0x20): 
0779   0000                                                              ;    bit 6 (0x40): 
0780   0000                                                              ;    bit 7 (0x80): 
0781   0000                                                                       
0782   0000                                                                                                         
0783   0000                                                                                                        
0784   0000             ;***************************************************************
0785   0000             ;*
0786   0000             ;*
0787   0000             ;* RAM, cleared to 0 when the ECU is powered-on
0788   0000             ;*
0789   0000             ;*
0790   0000             ;***************************************************************
0791   0000             ramClearStart    .EQU     $0057
0792   0000             temp1            .EQU     $0057                  ;
0793   0000             temp2            .EQU     $0058                  ;
0794   0000             temp3            .EQU     $0059                  ;
0795   0000             temp4            .EQU     $005a                  ;
0796   0000             temp5            .EQU     $005b                  ;
0797   0000             temp6            .EQU     $005c                  ;
0798   0000             temp7            .EQU     $005d                  ;
0799   0000             temp8            .EQU     $005e                  ;
0800   0000             temp9            .EQU     $005f                  ;
0801   0000             realT2X          .EQU     $0060                  ; Unused
0802   0000             casFlags0        .EQU     $0061                  ; Flag register
0803   0000                                                              ;    bit 0 (0x01): Bit is set to 1 when rpm(Tcas) >= 505, reset when rpm(Tcas) < 401 (hysteresis)
0804   0000                                                              ;    bit 1 (0x02): Old value of bit 0 
0805   0000                                                              ;    bit 2 (0x04): 1 if rpm(Tcas) >  1775rpm
0806   0000                                                              ;    bit 3 (0x08): Old value of bit 2 
0807   0000                                                              ;    bit 4 (0x10): 1 if rpm(Tcas) >  1540rpm 
0808   0000                                                              ;    bit 5 (0x20): 1 if rpm(Tcas) >  4801rpm
0809   0000                                                              ;    bit 6 (0x40): Set to 1 if timing adjustment mode is active
0810   0000                                                              ;    bit 7 (0x80): Unused?
0811   0000             ignFallFlags     .EQU     $0062                  ; Coil ignition scheduling on the cas falling edge
0812   0000                                                              ;    bit 0 (0x01): Set to 1 when coil ignition was not scheduled on the CAS 
0813   0000                                                              ;                  rising edge and therefore need to be scheduled on the CAS falling edge?
0814   0000                                                              ;    bit 1 (0x02): not used
0815   0000                                                              ;    bit 2 (0x04): not used 
0816   0000                                                              ;    bit 3 (0x08): not used
0817   0000                                                              ;    bit 4 (0x10): not used
0818   0000                                                              ;    bit 5 (0x20): not used
0819   0000                                                              ;    bit 6 (0x40): not used
0820   0000                                                              ;    bit 7 (0x80): not used
0821   0000             enerFlags        .EQU     $0063                  ; Coil energization state, bit 0 and 1 are mutually exclusive, they are never set at the same time...
0822   0000                                                              ; Note that when rpm is low, these flags might not be set as indicated (during cranking?)
0823   0000                                                              ;    bit 0 (0x01): Set to 1 when coil is currently energized?
0824   0000                                                              ;    bit 1 (0x02): Set to 1 when coil energization has been scheduled?
0825   0000                                                              ;    bit 2 (0x04): not used
0826   0000                                                              ;    bit 3 (0x08): not used
0827   0000                                                              ;    bit 4 (0x10): not used
0828   0000                                                              ;    bit 5 (0x20): not used
0829   0000                                                              ;    bit 6 (0x40): not used
0830   0000                                                              ;    bit 7 (0x80): not used
0831   0000             TcasLast0        .EQU     $0064                  ; TcasLast0:TcasLast1 (250KHz clock) is identical to TcasNew0:TcasNew1 but it has been validated for range. Basically it is the last Tcas value that was valid
0832   0000             TcasLast1        .EQU     $0065                  ; See TcasLast0 
0833   0000             TcasNew0         .EQU     $0066                  ; TcasNew0:TcasNew1 (250KHz clock) is the new value of Tcas calculated during the CAS interrupt 
0834   0000             TcasNew1         .EQU     $0067                  ; See TcasNew0
0835   0000             casRiseTime0     .EQU     $0068                  ; casRiseTime0:casRiseTime1 (250KHz clock) is the clock value when the last CAS rising edge interrupt occured  
0836   0000             casRiseTime1     .EQU     $0069                  ; See casRiseTime0
0837   0000             casFallTime0     .EQU     $006a                  ; casFallTime0:casFallTime1 (250KHz clock) is the clock value when the last CAS falling edge interrupt occured  
0838   0000             casFallTime1     .EQU     $006b                  ; See casFallTime0
0839   0000             timCas0          .EQU     $006c                  ; The current ignition timing (xx/256*90)degrees referenced to the CAS pulse rising edge (75deg BTDC), [timCas0:timCas1] =  256 * (75.77 - degAdv)/90, calculated from tim61 + $002a
0840   0000             timCas1          .EQU     $006d                  ; See timCas0
0841   0000             ignRelTime0      .EQU     $006e                  ; [ignRelTime0:ignRelTime1] is the current ignition time minus 72us measured in 1/250000 sec (timer clock) and referenced to the CAS rising edge (75deg BTDC). Calculated from timCas0: [ignRelTime0:ignRelTime1] = [TcasNew0:TcasNew1]/2 * [timCas0:timCas1]/256 - $0012
0842   0000             ignRelTime1      .EQU     $006f                  ; See ignRelTime0
0843   0000             ignFallRelTime0  .EQU     $0070                  ;
0844   0000             ignFallRelTime1  .EQU     $0071                  ;
0845   0000             enerLenX0        .EQU     $0072                  ;
0846   0000             enerLenX1        .EQU     $0073                  ;
0847   0000             enerAbsTime0     .EQU     $0074                  ;
0848   0000             enerAbsTime1     .EQU     $0075                  ;
0849   0000             ignTime0         .EQU     $0076                  ;
0850   0000             ignTime1         .EQU     $0077                  ;
0851   0000             enerAbsTimeNext0 .EQU     $0078                  ;
0852   0000             enerAbsTimeNext1 .EQU     $0079                  ;
0853   0000             TcasLast128      .EQU     $007a                  ; Set to TcasLast0/128
0854   0000             tdcMask0         .EQU     $007b                  ; tdcMask0:tdcMask1 contains $0204 when TDC signal is active (cylinder 1 or 4) on the CAS rising edge, $0402 otherwise. Toggled on every CAS rising edge
0855   0000             tdcMask1         .EQU     $007c                  ; See tdcMask0
0856   0000             tim61            .EQU     $007d                  ; Current timing (xx/256*90)degrees referenced to 61deg BTDC, tim61 = 256 * (61 - degAdv) / 90, where degAdv is the timing advance in degrees. Calculated from tim61Tot0
0857   0000             temp20           .EQU     $007e                  ; 
0858   0000             temp21           .EQU     $007f                  ;
0859   0000             temp22           .EQU     $0080                  ;
0860   0000             temp23           .EQU     $0081                  ;
0861   0000             temp24           .EQU     $0082                  ;
0862   0000             tdcCasCount      .EQU     $0083                  ; CAS rising edge counter when key is not in start, incremented on every CAS rising edge up to a maximum value of 6, used in TDC synch. operation
0863   0000             T40s_casInt      .EQU     $0084                  ; Initialized to 1.275sec on every CAS rising edge interrupt and decremented in first subroutine at ~40Hz. Will reach 0 (expire) only when no CAS interrupt was received for over 1.275sec, i.e. engine is really not rotating or something is wrong?
0864   0000             coilChkFlags     .EQU     $0085                  ; Flag register used to validate the ignition signal using the ignition coil sensing circuit
0865   0000                                                              ;    bit 0 (0x01): Injector 1, set to 1 to indicate that the injector can be used, 0 indicate injector is disabled because ignition is not happening on the corresponding cylinder
0866   0000                                                              ;    bit 1 (0x02): Injector 3, set to 1 to indicate that the injector can be used, 0 indicate injector is disabled because ignition is not happening on the corresponding cylinder
0867   0000                                                              ;    bit 2 (0x04): Injector 4, set to 1 to indicate that the injector can be used, 0 indicate injector is disabled because ignition is not happening on the corresponding cylinder
0868   0000                                                              ;    bit 3 (0x08): Injector 2, set to 1 to indicate that the injector can be used, 0 indicate injector is disabled because ignition is not happening on the corresponding cylinder
0869   0000                                                              ;    bit 4 (0x10): 
0870   0000                                                              ;    bit 5 (0x20): Set to 1 when engine is running and rpm<5000 and 8V<=battRaw<=18V, meaning we can proceed with checking the ignition
0871   0000                                                              ;    bit 6 (0x40): 
0872   0000                                                              ;    bit 7 (0x80): Set to 1 when we detected that several ignition signals were missing, ignition is not working properly.
0873   0000             p4Latched        .EQU     $0086                  ; Loaded with port4 and checked for bit #$04 in CAS interrupt
0874   0000             timAdjFlags      .EQU     $0087                  ; Timing adjustment mode flags
0875   0000                                                              ;    bit 0 (0x01): Set when rpm31>2000rpm, reset when rpm31 goes lower than 1813rpm (hysteresis) 
0876   0000                                                              ;    bit 1 (0x02): 
0877   0000                                                              ;    bit 2 (0x04): 
0878   0000                                                              ;    bit 3 (0x08): 
0879   0000                                                              ;    bit 4 (0x10): 
0880   0000                                                              ;    bit 5 (0x20): 
0881   0000                                                              ;    bit 6 (0x40):
0882   0000                                                              ;    bit 7 (0x80): Set to 1 when timing adjustment mode is active (timing terminal is grounded but the ECU test mode terminal is not grounded
0883   0000             tim61Tot0        .EQU     $0088                  ; New target timing (xx/256*90)degrees referenced to 61deg BTDC. knockSum is added to this value in order to retard timing further and then a maximum rate of change of 22.5deg/iteration is applied. The result becomes the new timing to apply (tim61 and timCas0:timCas1). Calculated from advTotal
0884   0000             enerLen          .EQU     $0089                  ; Coil energization time as loaded from the t_enerLen(battRaw) table. Actual energization time used might be different, longer...
0885   0000             timingAdv        .EQU     $008a                  ; Current timing advance, (x-10)degrees, timingAdv = degAdv+10, Calculated from tim61
0886   0000             knockSum         .EQU     $008b                  ; Current knock sum value
0887   0000             T200s_knock      .EQU     $008c                  ; Knock attenuation timer decremented at 200Hz and looping at 1.67Hz or 100Hz depending on airVol, knockSum is decremented by 1 every time this timer expires 
0888   0000             airCnt0          .EQU     $008d                  ; [airCnt0:airCnt1:airCnt2] is the exponentially averaged 24 bit air count (input is 16 bit [airCntNew0:airCntNew1]*256)
0889   0000             airCnt1          .EQU     $008e                  ; See airCnt0
0890   0000             airCnt2          .EQU     $008f                  ; See airCnt0
0891   0000             airCntNew0       .EQU     $0090                  ; airCntNew0:airCntNew1 is the 16 bits air count used as input to [airCnt0:airCnt1:airCnt2]. It is equal (N+r) * $9c where N is the number of airflow sensor pulse counted by the mas interrupt between each cas interrupt (1 cas interrupt for every cylinder cycle, 4 per every 2 engine rotations) r<=1 is a "remainder" proportional to the time elapsed since the last interrupt... 
0892   0000             airCntNew1       .EQU     $0091                  ; See airCntNew0
0893   0000             oldAirCnt0       .EQU     $0092   ;:$0093        ; This is the old value of airCnt0:airCnt1 used to compute some kind of air count derivative
0894   0000             airDiffPos       .EQU     $0094                  ; Contains airCnt0-oldAirCnt0 when the difference is positive, This is kind of the derivative of air count which is positive when air count is increasing (acceleration)
0895   0000             airDiffNeg       .EQU     $0095                  ; Contains abs(airCnt0-oldAirCnt0) when the difference is negative (contains oldAirCnt0-airCnt0...). This is kind of the derivative of air count which is negative when air count is decreasing (decceleration)
0896   0000             t1_lastCas       .EQU     $0096   ;:$0097        ; Latest value of t1_inCapt when CAS interrupt was called
0897   0000             t2_lastMas       .EQU     $0098   ;:$0099        ; Latest value of t2_inCapt when MAS interrupt was called                                                                             
0898   0000             t2_diff8         .EQU     $009a   ;:$009b        ; Time between 2 edges (2 edges per pulse...) of the airflow sensor with timer based rounding (see code), calculated on each mas interrupts from t2_inCapt/8
0899   0000             airQuantum       .EQU     $009c                  ; This value ($9c) is the the "amount of air" corresponding to 1 airflow sensor pulse. Using a non unitary value allows the ECU to interpolate the airflow in between pulses, i.e. if at the time we calculate airflow we are at 2/3 in between two pulses then we add 2/3 of airQuantum...  
0900   0000                                                              ; It is added to [airCntNew0:airCntNew1] on each mas interrupt call (accumulates N times $9C...).  A ratio is also applied to this value when it is added to [airCntNew0:airCntNew1] for the last time (partial count in between pulses) before airCnt0 is calculated.
0901   0000             L009d            .EQU     $009d                  ; Not used?
0902   0000             masCasFlags      .EQU     $009e                  ; Flag register
0903   0000                                                              ;    bit 0 (0x01): Bit is set when the CAS rising edge interrupt code is executed to flag event to main loop. Flag is read from main loop to update rpmX4Filt and then reset
0904   0000                                                              ;    bit 1 (0x02): 
0905   0000                                                              ;    bit 2 (0x04): 
0906   0000                                                              ;    bit 3 (0x08): 
0907   0000                                                              ;    bit 4 (0x10): 
0908   0000                                                              ;    bit 5 (0x20): 
0909   0000                                                              ;    bit 6 (0x40):
0910   0000                                                              ;    bit 7 (0x80): Scaling for the airflow sensor pulse counting. Set to 0 when we count both the rising and falling edge of the airflow sensor pulse. Set to 0 in case we count only the rising edges (or only the falling ones)
0911   0000             airFiltFact      .EQU     $009f                  ; airCnt0 exponential averaging factor with alpha = airFiltFact/256, 0<=alpha<=1, basically used to filter the air count: new airCnt0 = alpha * old airCnt0 + (1-alpha)*newAirCntValue, possible values in the code are $b3(70%), $d1(82%) or $e4(89%) 
0912   0000             airCntMax        .EQU     $00a0                  ; Air count based on rpm, ect and iat, 8*airCntMax is used as a maximum on airCnt0 or when engine not rotating/starting to rotate 
0913   0000             accEnr           .EQU     $00a1                  ; Acceleration enrichment (100x/255)%. This value is actually  updated with min(airCnt0-oldAirCnt0,$48) under acceleration, see code. Max value is $48 from code
0914   0000             state3           .EQU     $00a2                  ; Flag register   
0915   0000                                                              ;    bit 0 (0x01): Copied from same bit in state1 (1=startingToCrank)
0916   0000                                                              ;    bit 1 (0x02): Copied from same bit in state1 (1=no pulse accumulator interrupts)
0917   0000                                                              ;    bit 2 (0x04): Set when RPM exceeds threshold (rev limiter)
0918   0000                                                              ;    bit 3 (0x08): Copied from same bit in state1 (1=rotatingStopInj)
0919   0000                                                              ;    bit 4 (0x10): Copied from same bit in state1 (1=notRotating)
0920   0000                                                              ;    bit 5 (0x20): Set if rotatingStopInj and not runningFast 
0921   0000                                                              ;    bit 6 (0x40):
0922   0000                                                              ;    bit 7 (0x80): Set to injFlags0.7 (1 when startingToCrankColdEngine)
0923   0000             injFactor        .EQU     $00a3   ;:$00a4        ; Global injector factor used to calculate injPw from [airCnt0:airCnt1],  
0924   0000                                                              ; injFactor = 16*totMasComp * injComp/128 * [workFtrim + o2FuelAdj + 2*$80]/512 * iatCompFact/128 * baroFact/128 * openLoopEnr/128 * coldTempEnr/128  * (2*enrWarmup + $80)/128
0925   0000             oldReedVal       .EQU     $00a5                  ;
0926   0000             deadTime         .EQU     $00a6                  ; Injector deadtime in increment of 24uS as a function of batteryVoltage
0927   0000             injPw            .EQU     $00a7   ;:$00a8        ; 16 bit injector pulse width in microseconds. Logger reports high and low bytes: (.256 highByte)mS
0928   0000             inj1_offT        .EQU     $00a9   ;:$00aa        ; Injector #1? deactivation time (relative to timer count at t1t2_clk/t1_outCmpWr/t2_outCmpWr)  
0929   0000             inj3_offT        .EQU     $00ab   ;:$00ac        ; Injector #3? deactivation time (relative to timer count at t1t2_clk/t1_outCmpWr/t2_outCmpWr)  
0930   0000             inj4_offT        .EQU     $00ad   ;:$00ae        ; Injector #4? deactivation time (relative to timer count at t1t2_clk/t1_outCmpWr/t2_outCmpWr)  
0931   0000             inj2_offT        .EQU     $00af   ;:$00b0        ; Injector #2? deactivation time (relative to timer count at t1t2_clk/t1_outCmpWr/t2_outCmpWr)  
0932   0000             last_t1t2_clk    .EQU     $00b1                  ; Initialized to  t1t2_clk/256 on CAS falling edge, every one of them??? 
0933   0000             injToAct         .EQU     $00b2                  ; Indicate which injectors are currently active or should be activated, Set to 1 for an active injector 
0934   0000                                                              ;    bit 0 (0x01): Inj 1?  
0935   0000                                                              ;    bit 1 (0x02): Inj 3? 
0936   0000                                                              ;    bit 2 (0x04): Inj 4? 
0937   0000                                                              ;    bit 3 (0x08): Inj 2? 
0938   0000                                                              ;    bit 4 (0x10): 
0939   0000                                                              ;    bit 5 (0x20): 
0940   0000                                                              ;    bit 6 (0x40): 
0941   0000                                                              ;    bit 7 (0x80): 
0942   0000             tdcCasFlags      .EQU     $00b3                  ; Init to 5
0943   0000                                                              ;    bit 0 (0x01): c0, c2:c1:c0 used as a down counter (on every CAS pulse falling edge) initialized with 5. Reset to 0 when the CAS pulse falling edge correpond to the cylinder #1 TDC pulse (see bit 7)
0944   0000                                                              ;    bit 1 (0x02): c1
0945   0000                                                              ;    bit 2 (0x04): c2
0946   0000                                                              ;    bit 3 (0x08): Set to the last value of TDC bit on port3. 2
0947   0000                                                              ;    bit 4 (0x10):
0948   0000                                                              ;    bit 5 (0x20):
0949   0000                                                              ;    bit 6 (0x40):
0950   0000                                                              ;    bit 7 (0x80): Set to 1 when cylinder #1 TDC is detected on the CAS falling edge. Set to 1 when we detect that TDC bit on port3.2 has changed from 1 to 0 (falling edge) from one CAS falling edge to the other. That basically indicate cylinder #1 TDC  
0951   0000             casCylIndex      .EQU     $00b4                  ; Cas current cylinder index (0,1,2,3 -> cyl #2,#1,#3,#4). Counter looping from 0 to 3 and increased on every CAS falling edge. re-init to 0 when TDC of cylinder #1 is detected (tdcCasFlags.7 set). 
0952   0000                                                              ;    bit 0 (0x01): Inj 1?  
0953   0000                                                              ;    bit 1 (0x02): Inj 3? 
0954   0000                                                              ;    bit 2 (0x04): Inj 4? 
0955   0000                                                              ;    bit 3 (0x08): Inj 2? 
0956   0000                                                              ;    bit 4 (0x10): 
0957   0000                                                              ;    bit 5 (0x20): 
0958   0000                                                              ;    bit 6 (0x40): 
0959   0000                                                              ;    bit 7 (0x80): 
0960   0000             newInjToAct      .EQU     $00b5                  ; Indicate which injector should be activated (also, bit 7 is set when doing simultaneous injection). Mostly updated on the CAS falling edge
0961   0000                                                              ;    bit 0 (0x01): Inj 1?  
0962   0000                                                              ;    bit 1 (0x02): Inj 3? 
0963   0000                                                              ;    bit 2 (0x04): Inj 4? 
0964   0000                                                              ;    bit 3 (0x08): Inj 2? 
0965   0000                                                              ;    bit 4 (0x10): Inj 5/6?
0966   0000                                                              ;    bit 5 (0x20): Inj 5/6?
0967   0000                                                              ;    bit 6 (0x40): 
0968   0000                                                              ;    bit 7 (0x80): Set to 1 when when we should be doing simultaneous injection on all 4 cylinders, 0 indicate sequential injection
0969   0000             tdcCheck         .EQU     $00b6                  ; Init to 8 on the cas falling edge of the cylinder #1 TDC, decremented by 1 on every cas falling edge. Used to check that TDC sensor is working correctly, it should never reach 0...
0970   0000             oldInjToAct      .EQU     $00b7                  ; Old value of injToAct (before it was updated)
0971   0000             injToTest        .EQU     $00b8                  ; The current injector to test for proper operation (set to 1 to test), 1 bit per injector. Testing proceed from bit 0 to bit 3. We stay on the same injector if it is found to be bad, see around L1884
0972   0000                                                              ;    bit 0 (0x01): Inj 1?  
0973   0000                                                              ;    bit 1 (0x02): Inj 3? 
0974   0000                                                              ;    bit 2 (0x04): Inj 4? 
0975   0000                                                              ;    bit 3 (0x08): Inj 2? 
0976   0000                                                              ;    bit 4 (0x10): 
0977   0000                                                              ;    bit 5 (0x20): 
0978   0000                                                              ;    bit 6 (0x40): 
0979   0000                                                              ;    bit 7 (0x80): 
0980   0000             injBad           .EQU     $00b9                  ; Injector testing flags
0981   0000                                                              ;    bit 0 (0x01): Set to 1 when one of the injector is not working correctly based on injector feedback bit, see injToTest
0982   0000                                                              ;    bit 1 (0x02): Not used
0983   0000                                                              ;    bit 2 (0x04): Not used
0984   0000                                                              ;    bit 3 (0x08): Not used
0985   0000                                                              ;    bit 4 (0x10): Not used
0986   0000                                                              ;    bit 5 (0x20): Not used
0987   0000                                                              ;    bit 6 (0x40): Not used
0988   0000                                                              ;    bit 7 (0x80): Not used
0989   0000             obdInjCmd        .EQU     $00ba                  ; processing of OBD code bit 0 to 5 correspond to injectors being turned on/off                                                                                                    
0990   0000                                                              ;    bit 0 (0x01): Inj. 1, Set to 0 if injector is currently turned off by obd command, 1 in normal operation 
0991   0000                                                              ;    bit 1 (0x02): Inj. 3, See bit 0
0992   0000                                                              ;    bit 2 (0x04): Inj. 4, See bit 0
0993   0000                                                              ;    bit 3 (0x08): Inj. 2, See bit 0
0994   0000                                                              ;    bit 4 (0x10): Inj 5/6 See bit 0
0995   0000                                                              ;    bit 5 (0x20): Inj 5/6 See bit 0
0996   0000                                                              ;    bit 6 (0x40): Not used 
0997   0000                                                              ;    bit 7 (0x80): Not used
0998   0000             rtiCnt           .EQU     $00bb                  ; free counter increased on every real time interrupt (~800Hz), used to execute some functions only 1 out of N times (check count value)                                                         
0999   0000             rtiCnt48         .EQU     $00bc                  ; counter increased on every real time interrupt, maximum value is 2F (47), period 48.                                                                                                  
1000   0000             rtiReedFlags     .EQU     $00bd                  ; Flag register                                                                                                                                                                                 
1001   0000                                                              ;    bit 0 (0x01): Bit is set in real time int. at 40Hz when T200_40Hz reach 0 (T200_40Hz loop from 5 to 0 at 200Hz)
1002   0000                                                              ;    bit 1 (0x02): not used?
1003   0000                                                              ;    bit 2 (0x04): not used?
1004   0000                                                              ;    bit 3 (0x08): not used?
1005   0000                                                              ;    bit 4 (0x10): not used?
1006   0000                                                              ;    bit 5 (0x20): not used?
1007   0000                                                              ;    bit 6 (0x40): not used?
1008   0000                                                              ;    bit 7 (0x80): Latest reed switch value
1009   0000                              
1010   0000                              ;-------------------------------------------------
1011   0000                              ; $be-$c2, series of timers (counting down to 0)
1012   0000                              ; (see L1929) decremented in real time interrupt 
1013   0000                              ; at ~200Hz
1014   0000                              ;-------------------------------------------------
1015   0000             T200_40Hz        .EQU     $00be                  ; Loops from from 5 to 0 producing 40Hz for main loop (set rtiReedFlags.0)
1016   0000             T200_casRise     .EQU     $00bf                  ; Used by CAS interrupt as a timeout to validate the time in between CAS interrupts when RPM is very low and 16 bit timers roll over. Timer initialized on every cas rising edge
1017   0000             T200_casFall     .EQU     $00c0                  ; Used by CAS interrupt as a timeout to validate the time in between CAS interrupts when RPM is very low and 16 bit timers roll over. Timer initialized on every cas falling edge
1018   0000             T200_mas         .EQU     $00c1                  ; Used by the mas subroutine to know when the pulses are getting too close together (and we need to apply scaling). Re-initialized to 130ms on every airflow sensor interrupt (every pulse received)
1019   0000             T200_cop         .EQU     $00c2                  ; Used to toggle port6.5 if main loop executes at more than 20Hz, could be some sort of COP to reset ECU in case main loop goes slower than 20Hz.
1020   0000                              
1021   0000             oldTps1          .EQU     $00c3                  ; Set to "old" TPS value for comparison with new during cranking?                                                                                                                   
1022   0000             vssCnt1          .EQU     $00c4                  ; Counter Initialized to $#C8 every time the reed switch change value, decreased at real time int. frequency down to 0; Will be 0 only when when speed is lower than X (very slow speed?)
1023   0000             vssCnt2          .EQU     $00c5                  ; Counter used for speed sensor calculation, initialized to $E2, decreased on every call, speed = $E2-current value of this register                                                
1024   0000             vss              .EQU     $00c6                  ; "Vehicle speed sensor", actually computed from the reed switch transitions. Value is the period in 1/400sec of one complete reed switch square wave, approx 40cm. Speed in km/h is approximately given by 3.6*400*0.4/xx
1025   0000             oldTps2          .EQU     $00c7                  ;
1026   0000             tpsDiffMax1      .EQU     $00c8                  ; Maximum positive rate of change of tpsRaw seen during 1 main loop execution. (high value means driver is stepping on the gas, value of 0 means throttle is at constant position or decreasing). Set to the maximum value of tpsRaw-oldTps2 (updated at 100Hz) 
1027   0000             tempFlagTps      .EQU     $00c9                  ; Used as a temp flag during port2.2 activation/deactivation (aiflow sensor active filter reset???). Set to $ff when tpsRaw has increased by more than 1.5% and is between 26%-50%, $00 otherwise
1028   0000             L00ca            .EQU     $00ca                  ; Init to 6 but never used. Notice it is located in front of the 8 memories used to store ADC values? It also correspond to obd code $ca which erases all fault codes...
1029   0000             ectRaw           .EQU     $00cb                  ; Engine coolant temperature, see curve at beginning of file 
1030   0000             iatRaw           .EQU     $00cc                  ; Raw intake air temperature, see curve at beginning of file 
1031   0000             baroRaw          .EQU     $00cd                  ; Atmostpheric pressure: (.00486x)bar            
1032   0000             o2Raw            .EQU     $00ce                  ; Oxygen sensor (.0195x)v.                    
1033   0000             egrtRaw          .EQU     $00cf                  ; Exhaust gas recirculation temperature, unknown temperature curve, used this formula for now (-2.7x + 597.7)deg F              
1034   0000             battRaw          .EQU     $00d0                  ; Battery voltage (.0733x)v.                          
1035   0000             knockSensor      .EQU     $00d1                  ; Knock sensor                                
1036   0000             tpsRaw           .EQU     $00d2                  ; Throttle position sensor (100x/255)%               
1037   0000             ectFiltered      .EQU     $00d3                  ; This is the engine coolant tempterature that has been validated and then filtered to limit its rate of change to a few degrees per sec...
1038   0000             iatChecked       .EQU     $00d4                  ; Validated intake air temperature
1039   0000             baroChecked      .EQU     $00d5                  ; Verified barometer voltage, $cd=1bar
1040   0000             state2           .EQU     $00d6                  ;    bit 0 (0x01): Set if ectRaw >236 OR <5, FAULT VALUE = 30                                                                               
1041   0000                                                              ;    bit 1 (0x02): Set if iatRaw >234 OR <14, FAULT VALUE = 123                                                                             
1042   0000                                                              ;    bit 2 (0x04): Set if baroRaw >228 OR <100, FAULT VALUE = 205                                                                           
1043   0000                                                              ;    bit 3 (0x08): Set when timer T40_mas expires, which means no pulse accumulator interrupt was received for over 0.3s-> no air is getting in or something wrong...
1044   0000                                                              ;    bit 4 (0x10): Engine collant temp related?                                                                                                 
1045   0000                                                              ;    bit 5 (0x20): Set to 1 if knock senor is not working???. Set to ^(port4Snap.5)
1046   0000                                                              ;    bit 6 (0x40):                                                                                                                              
1047   0000                                                              ;    bit 7 (0x80):                                                                                                                              
1048   0000             port3Snap0       .EQU     $00d7                  ; Loaded with port3 with some values reset by code depending on ???,                
1049   0000                                                              ; used in idle speed calc? -> load that need to be considered in calc of idle speed 
1050   0000                                                              ;    bit 0 (0x01): IG2 related, 0 when IG2 at +12V, ABS unit?  only used used for fuel trim on E931 only, see around Md4d4?                                                                     
1051   0000                                                              ;    bit 1 (0x02): IG1 related? 0 when IG1 at +12V.                                                                                                                                            
1052   0000                                                              ;    bit 2 (0x04): always reset to 0????
1053   0000                                                              ;    bit 3 (0x08): Set to 1 if power steering pump is on
1054   0000                                                              ;    bit 4 (0x10): AC switch (1=off) -> always set if ??? (config resistor???)                 
1055   0000                                                              ;    bit 5 (0x20): Park/neutral -> always set by code???                                  
1056   0000                                                              ;    bit 6 (0x40): 0 if key in start?
1057   0000                                                              ;    bit 7 (0x80): idle position switch (1=on)?                                        
1058   0000             port4Snap        .EQU     $00d8                  ; Snapshot of port4 & 01111000
1059   0000                                                              ;    bit 0 (0x01):                                                                     
1060   0000                                                              ;    bit 1 (0x02):                                                                     
1061   0000                                                              ;    bit 2 (0x04): 
1062   0000                                                              ;    bit 3 (0x08): 1 when ECU test mode terminal grounded               
1063   0000                                                              ;    bit 4 (0x10): 1 when timing terminal grounded                     
1064   0000                                                              ;    bit 5 (0x20): knock sensor related (set indicates it works...)
1065   0000                                                              ;    bit 6 (0x40): Fuel pump driven feedback?                      
1066   0000                                                              ;    bit 7 (0x80): 
1067   0000             Tclocks          .EQU     $00d9                  ; State Flags for software counters, Updated from scratch (zero) on every main loop execution 
1068   0000                                                              ;    bit 0 (0x01): Set at ~40Hz, set when 40Hz flag from real time interrupt was processed during loop (40Hz counters where decremented if required)
1069   0000                                                              ;    bit 1 (0x02): Set at ~10Hz
1070   0000                                                              ;    bit 2 (0x04): Set at ~2Hz, Used by heart beat mode
1071   0000                                                              ;    bit 3 (0x08): Set at ~0.5Hz
1072   0000                                                              ;    bit 4 (0x10): Not used?                                                       
1073   0000                                                              ;    bit 5 (0x20): Not used?                                                       
1074   0000                                                              ;    bit 6 (0x40): Not used?                                                       
1075   0000                                                              ;    bit 7 (0x80): Not used?                                                       
1076   0000             rpm4             .EQU     $00da   ;:$00db        ; RPM/3.90625                                                       
1077   0000             rpm8             .EQU     $00dc                  ; RPM/7.8125                                                        
1078   0000             rpm31            .EQU     $00dd                  ; RPM/31.25 (engine rpm = RPM31p25 * 31.25)                         
1079   0000             airVol16         .EQU     $00de   ;:$00df        ; Air volume, 16 bit, airVol16 = [airCnt0:airCnt1] * masScalar/65536
1080   0000             airVol           .EQU     $00e0                  ; Air volume,  8 bit,   airVol = airVol16/2
1081   0000             airVolT          .EQU     $00e1                  ; Air volume,  8 bit,  airVolT = airVol16/2 * iatCompFact/128
1082   0000             airVolTB         .EQU     $00e2                  ; Air volume,  8 bit, airVolTB = airVol16/2 * iatCompFact/128 * baroFact/128
1083   0000             airVolB          .EQU     $00e3                  ; Air volume,  8 bit,  airVolB = airVol16/2 *    baroFact/128
1084   0000             mafRaw           .EQU     $00e4                  ; 8 bit airflow sensor pulse frequency  (6.25x)Hz, calculated from mafRaw16 (mafRaw = mafRaw16/64)
1085   0000             ftrimFlags       .EQU     $00e5                  ; Flag register for fuel trim???
1086   0000                                                              ;    bit 0 (0x01): c0: c1c0 form the current trim range (00=low, 01=mid, 10=high) updated according to mafRaw16
1087   0000                                                              ;    bit 1 (0x02): c1
1088   0000                                                              ;    bit 2 (0x04): Set (E931 only) when speed exceed threshold (24km/h) with hysteresis, 
1089   0000                                                              ;    bit 3 (0x08): Set (E931 only) if port3Snap0.0 & port3.0 are both set on E931 when speed exceed 24km/h?
1090   0000                                                              ;    bit 4 (0x10): Set when rpm > L1983(xx) ~1000rpm with hysteresis  
1091   0000                                                              ;    bit 5 (0x20): 
1092   0000                                                              ;    bit 6 (0x40): 
1093   0000                                                              ;    bit 7 (0x80):  Set when airVolT >24, reset when airVolT<=15. Theshold is 19.5 with +/-4.5 hysteresis
1094   0000             state1           .EQU     $00e6                  ; State flags mainly used to track engine start-up stages and running condition (not rotating, startingToCrank, etc.). Bits 0 to 4 will be clear when engine is running normally
1095   0000                                                              ;    bit 0 (0x01): stage1 (startingToCrank?): 1 indicate engine is just rotating but no TDC signal seen yet????, reset to 0 once CAS/TDC??? or engine rpm>~400rpm
1096   0000                                                              ;    bit 1 (0x02): no pulse accumulator interrupts ?: 1 indicate we did not receive a valid pulse accumulator interrupts for a long time, see state2
1097   0000                                                              ;    bit 2 (0x04): stage3 (runningFast): 1 indicate the ECU has detected that the engine rpm was too high for current conditions?
1098   0000                                                              ;    bit 3 (0x08): stage2 (rotatingStopInj): 1 indicate engine should be running or be started but something is preventing us from doing fuel injection (fuel cut, CAS not working, etc.). Injection could still proceed if runningFast is set
1099   0000                                                              ;    bit 4 (0x10): stage0 (notRotating): 1 indicate state1 was calculated but nothing to report, set to 1 on init subr. reset to 0 when engine is rotating
1100   0000                                                              ;    bit 5 (0x20): state1Calculated: 1 indicate state 1 was calculated, never reset?
1101   0000                                                              ;    bit 6 (0x40): Not used?                                                                          
1102   0000                                                              ;    bit 7 (0x80): closedLoop: 1 indicate closed loop mode, 0 indicate open loop                                  
1103   0000             injFlags0        .EQU     $00e7                  ; Flags related to injectors
1104   0000                                                              ;    bit 0 (0x01): Flag is 0 on reset (meaning injectors interrupts not yet initiated?) and set to 1 once sInjPw is initialized. If required, first interrupt for injectors is also scheduled when initializing this flag to 1
1105   0000                                                              ;    bit 1 (0x02): ??? 
1106   0000                                                              ;    bit 2 (0x04): Set when rpm>=437.5
1107   0000                                                              ;    bit 3 (0x08): ???
1108   0000                                                              ;    bit 4 (0x10): 
1109   0000                                                              ;    bit 5 (0x20): Set when temperature(ectFiltered) < -8degC, updated only when engine is notRotating
1110   0000                                                              ;    bit 6 (0x40): 
1111   0000                                                              ;    bit 7 (0x80): Set to 1 if startingToCrankColdEngine. Fuel should be injected simultaneously in all cylinders twice per rotation (every cas)
1112   0000             closedLpFlags    .EQU     $00e8                  ; Flags relaed to closed loop mode, 02 sensor, fuel trims
1113   0000                                                              ;    bit 0 (0x01): Set to 1 when the air volume (airVolTB) is too high to use closed loop mode (first threshold) 
1114   0000                                                              ;    bit 1 (0x02): Set to 1 when we should be using closed loop mode??? (might not use it anyway...)
1115   0000                                                              ;    bit 2 (0x04): 
1116   0000                                                              ;    bit 3 (0x08): 
1117   0000                                                              ;    bit 4 (0x10): 
1118   0000                                                              ;    bit 5 (0x20): 
1119   0000                                                              ;    bit 6 (0x40): o2 sensor bad flag. Set to 1 when the o2 sensor voltage did not switch from lean to rich or rich to lean for a certain amount of time in closed loop. Also set to 1 if notRotating
1120   0000                                                              ;    bit 7 (0x80): rich/lean flag, set to 1 o2Raw >= 0.6v (rich), Set to 0 if o2Raw < 0.6v (lean), updated once o2 sensor has warmed-up
1121   0000             o2Fbk            .EQU     $00e9   ;:$00ea        ; Oxygen feedback trim (16 bits actually used, most of the time only highest byte is used...) (.78x)% -> 100% = $80
1122   0000             o2Fbk_dec        .EQU     $00eb                  ; o2Fbk is decreased using this value when in closed loop and running rich
1123   0000             o2Fbk_inc        .EQU     $00ec                  ; o2Fbk is increased using this value when in closed loop and running lean
1124   0000             iscY0            .EQU     $00ed                  ; iscYn variables are short term correction factors/feedback for the isc step adjustment. It is centered at $80 (100%, no correction). A value higher than $80 indicate that we need to increase the isc step since the current rpm is lower than the desired one
1125   0000                                                              ; The isc step used is increased/decreased by iscYn-$80
1126   0000                                                              ; iscY0 is the ISC learning variable when A/C is off and PS is off, see iscPointers function. Value of $80=100% 
1127   0000             iscY1            .EQU     $00ee                  ; iscY1 is the ISC learning variable when A/C is on and PS is off, see iscPointers function. Value of $80=100%
1128   0000             iscY2            .EQU     $00ef                  ; iscY2 is the ISC learning variable when PS is on, see iscPointers function. Value of $80=100%
1129   0000             iscStepMax       .EQU     $00f0                  ; Maximum value applied to iscStepCurr in code
1130   0000             port3Snap1       .EQU     $00f1                  ; Loaded with port3Snap0 with some values set by code depending on ???,                
1131   0000                                                              ;    bit 0 (0x01): IG2 related, 0 when IG2 at +12V, ABS unit?  only used used for fuel trim on E931 only, see around Md4d4?
1132   0000                                                              ;    bit 1 (0x02): IG1 related? 0 when IG1 at +12V.                                                                        
1133   0000                                                              ;    bit 2 (0x04): Set to 1 if vssCnt1 != 0 (car speed > 2.9km/h???)
1134   0000                                                              ;    bit 3 (0x08): Set to 1 if power steering pump is on
1135   0000                                                              ;    bit 4 (0x10): AC switch (1=off) 
1136   0000                                                              ;    bit 5 (0x20): Park/neutral -> always set by code                                   
1137   0000                                                              ;    bit 6 (0x40): 0 if key in start?                                                   
1138   0000                                                              ;    bit 7 (0x80): idle position switch (1=on)?                                        
1139   0000             oldP3Snap1       .EQU     $00f2                  ; Old value of port3Snap1
1140   0000             iscLrnFlags      .EQU     $00f3                  ; Isc leanrning flags, all flags are reset to 0 in basic idle speed adjustment mode.  All flags except bit 0 are reset to 0 when notRotating or startingToCrank
1141   0000                                                              ;    bit 0 (0x01): Set to 1 when engine is notRotating or startingToCrank, reset to 0 when engine is running
1142   0000                                                              ;    bit 1 (0x02): 
1143   0000                                                              ;    bit 2 (0x04): Set to 1 when the engine is running too slow? i.e. temperature(ectFiltered) > 55degC, rpm8 < 500rpm, engine is running, T40_acOnTrans is expired 
1144   0000                                                              ;    bit 3 (0x08): 
1145   0000                                                              ;    bit 4 (0x10): Set to 1 when conditions are good to update the isc leanrning variables.
1146   0000                                                              ;    bit 5 (0x20): Set to 1 when iscStStall has been updated, i.e. when idle switch is off and iscFlags1.7 = 0 and rpm8>=500. Reset to 0 when iscStStall is reset to 0???
1147   0000                                                              ;    bit 6 (0x40): 
1148   0000                                                              ;    bit 7 (0x80): 
1149   0000             iscFlags1        .EQU     $00f4                  ; Flag register
1150   0000                                                              ;    bit 0 (0x01): Set to 1 when engine not rotating or is running (basic idle speed adjustment mode is not active). Reset to 0 when key in start and iscStTargSpec = iscStepCurr
1151   0000                                                              ;    bit 1 (0x02): 
1152   0000                                                              ;    bit 2 (0x04): 
1153   0000                                                              ;    bit 3 (0x08): 
1154   0000                                                              ;    bit 4 (0x10): 
1155   0000                                                              ;    bit 5 (0x20): Set to 1 when  engine StartingToCrank and temperature(iat) < 75degC. Only changed during startingToCrank. Used is setting isc step during cold engine startup
1156   0000                                                              ;    bit 6 (0x40): 
1157   0000                                                              ;    bit 7 (0x80): Set to 1 when tps has been high and airVol low for more than 0.5sec (tpsRaw >= 86% and airVol < $3a)
1158   0000             T_maxAdv         .EQU     $00f5                  ; E931 only, used to ramp down the effect of maxAdv 
1159   0000             maxAdv           .EQU     $00f6                  ; E931 only, maximum value of timing advance timingOct for E931 when engine is runningFast (timingOct is clipped to that value), T_maxAdv is used to ramp-down its effect with time
1160   0000             L00f7            .EQU     $00f7                  ; Unused?
1161   0000             varFlags0        .EQU     $00f8                  ; Various flags...
1162   0000                                                              ;    bit 0 (0x01): Used in A/C cutoff for AT, 1 indicates TPS exceeded 82% the last time we checked it...
1163   0000                                                              ;    bit 1 (0x02): Hot start flag, set to 1 when startingToCrank and open loop and temperature(iatChecked) >= 60degC and  temperature(ectFiltered) >= 93degC (hot start), used to increase fuel enrichement (reduce vapor lock maybe???)                              
1164   0000                                                              ;    bit 2 (0x04): 
1165   0000                                                              ;    bit 3 (0x08): 
1166   0000                                                              ;    bit 4 (0x10): 
1167   0000                                                              ;    bit 5 (0x20): Second priority, Set to 1 when purge solenoid is to be deactivated since min conditions for normal purge activation are not met
1168   0000                                                              ;    bit 6 (0x40): First priority, Set to 1 when purge solenoid is to be activated by OBD command or normal activation criteria
1169   0000                                                              ;    bit 7 (0x80): Third priority, Set to 1 when purge solenoid should be deactivated. This flag is toggled between 0 and 1 to implement pulsewidth modulation (very long period) of purge solenoid when the other two higher priority flags are not set  
1170   0000             fpsBcsFlags      .EQU     $00f9                  ; Flags related to fuel pressure solenoid and boost control solenoid
1171   0000                                                              ;    bit 0 (0x01): 
1172   0000                                                              ;    bit 1 (0x02): 
1173   0000                                                              ;    bit 2 (0x04): Set to 1 when the fuel pressure solenoid was just deactivated (set to 1 only when bit 7 goes from 1 to 0). Reset to 0 at any other time
1174   0000                                                              ;    bit 3 (0x08): Set to 1 when ECU decides that fuel pressure solenoid should be activated to reduce vapor lock 
1175   0000                                                              ;    bit 4 (0x10): bcs, Set to 1 when mafRaw16 is above $4e ($4a for E932) with hysteresis, low threshold is $38
1176   0000                                                              ;    bit 5 (0x20): bcs, Set to 1 when octane is above $c0 with hysteresis, low threshold is $9a
1177   0000                                                              ;    bit 6 (0x40): bcs
1178   0000                                                              ;    bit 7 (0x80): 
1179   0000             obdFlags         .EQU     $00fa                  ; Current state of diagnostic port command/query processing
1180   0000                                                              ;    bit 0 (0x01): 1 toggle bit on every second "subroutine 1" loop                                                                                                                                                  
1181   0000                                                              ;    bit 1 (0x02): 1 if serial output on port 2 is initialized.                                                                                                                                                      
1182   0000                                                              ;    bit 2 (0x04): ?a                                                                                                                                                                                                
1183   0000                                                              ;    bit 3 (0x08): ?a                                                                                                                                                                                                
1184   0000                                                              ;    bit 4 (0x10): ?a                                                                                                                                                                                                
1185   0000                                                              ;    bit 5 (0x20): ?a                                                                                                                                                                                                
1186   0000                                                              ;    bit 6 (0x40): Set to 1 when a new OBD code was stored in obdCode? reset when obdCode has been processed.
1187   0000                                                              ;    bit 7 (0x80): Set to 1 to indicate that a response to the query/command is being sent on the diagnostic port (new requests will be ignored)
1188   0000             obdActCmd        .EQU     $00fb                  ; processing of OBD code, contains which actuator is being currently processed. Set to 0 when actuator is off
1189   0000                                                              ;    bit 0 (0x01): Purge solenoid
1190   0000                                                              ;    bit 1 (0x02): Fuel pump
1191   0000                                                              ;    bit 2 (0x04): Fuel pressure solenoid
1192   0000                                                              ;    bit 3 (0x08): Egr solemoid
1193   0000                                                              ;    bit 4 (0x10): Unused
1194   0000                                                              ;    bit 5 (0x20): Boost control solenoid
1195   0000                                                              ;    bit 6 (0x40): Unused
1196   0000                                                              ;    bit 7 (0x80): Unused
1197   0000             validFlags       .EQU     $00fc                  ; Flag related to the validation of sensors...
1198   0000                                                              ;    bit 0 (0x01): Set to 1 when T40_engRot is expired (no CAS interrupt received for a long time)  
1199   0000                                                              ;    bit 1 (0x02): Set to 1 when the condition of the o2 sensor was determined (good or not). Only reset when car key is put in off I think
1200   0000                                                              ;    bit 2 (0x04): Set to 1 when the condition of the egrt sensor was determined (good or not). Only reset when car key is put if off I think
1201   0000                                                              ;    bit 3 (0x08): 
1202   0000                                                              ;    bit 4 (0x10): 
1203   0000                                                              ;    bit 5 (0x20): 
1204   0000                                                              ;    bit 6 (0x40): 
1205   0000                                                              ;    bit 7 (0x80): Set to 1 if o2Raw > 0.6V (rich), 0 otherwise 
1206   0000             iscStepTarg      .EQU     $00fd                  ; Target ISC step, that's the target value for iscStepCurr
1207   0000             idleSpdTarg      .EQU     $00fe                  ; Current target idle speed (xx*7.8125)rpm based on ect, A/C switch, etc.
1208   0000             airCntDef        .EQU     $00ff                  ; airCntDef*8*256 is the default value of [airCnt0:airCnt1:airCnt2] when mas interrupts are not being received, calculated from rpm, tps, ect, tables
1209   0000             injPwStart       .EQU     $0100   ;:$0101        ; The value of injPw used when engine is "rotating" (start-up). Calculated from fixed values (no air count)
1210   0000             oldFtrimFlg      .EQU     $0102                  ; Old value of ftrimFlags
1211   0000             accEnrDecay      .EQU     $0103                  ; Acceleration enrichment decay factor. accEnr is multiplied by (1-accEnrDecay/256) on each iteration. Initialized from a table as a function of ect.
1212   0000             accEnrTimer      .EQU     $0104                  ; Timer used to continue applying acceleration enrichement for 4 iterations after airflow is below minimum threshold (accEnrMinAf). 
1213   0000             accEnrMinAf      .EQU     $0105   ;:$0106        ; Minimum value of airCnt0 above/below which acceleration/deceleration enrichment should be applied (for acceleration, when airflow goes below, we stop applying acc enrichment after 4 iterations, see accEnrTimer. For decelaration, we stop reducing injPw as soon as we are above threshold)
1214   0000             decEnr           .EQU     $0107                  ; Deceleration enrichment (100x/255)%. This value is actually  updated with min(airCnt0-oldAirCnt0,$ff) under deceleration, see code. Max value is $ff from code
1215   0000             accEnrFact       .EQU     $0108   ;:$0109        ; Factor used in increasing injPw during acceleration enrichment
1216   0000             decEnrFact       .EQU     $010a   ;:$010b        ; Factor used in decreasing injPw during deceleration enrichment
1217   0000             accEnrDiffT      .EQU     $010c                  ; Minimum value of (airCnt0-oldAirCnt0) required to update decEnr or accEnr
1218   0000             accEnrTmr2       .EQU     $010d                  ; Timer used to hold accEnr for 4 or 5 iterations when it is getting small, before decreasing it to 0. 
1219   0000             oldTps3          .EQU     $010e                  ; Old value of tpsRaw calculated at 100Hz, used to compute tpsDiff100
1220   0000             tpsDiff100       .EQU     $010f                  ; Used to interpolate t_sInjEnr. Correspond to max(tpsRaw-oldTps3,0) calculated at 100Hz, used in the calculation of sInjEnr.
1221   0000             T200s_sInj       .EQU     $0110                  ; sInjEnr is reset to 0 when this timer expires (0.2sec after conditions don't warrant having sInjEnr anymore) 
1222   0000             sInjEnr          .EQU     $0111                  ; Kind of acceleration fuel enrichement when still using simultaneous injection?
1223   0000             sInjEnrMax       .EQU     $0112                  ; Maximum value applied to sInjEnr 
1224   0000             sInjTpsMax       .EQU     $0113                  ; sInjEnr is only increased if oldTps3 <= sInjTpsMax 
1225   0000             sInjPw           .EQU     $0114   ;:$0115        ; Injector pulsewidth used when simulataneous injection is used
1226   0000             sInjEnrInc       .EQU     $0116                  ; sInjEnr is increased by sInjEnrInc/128 * t_sInjEnr(tpsDiff100) = sInjEnrMax/32 * t_sInjEnr(tpsDiff100) at 100Hz under specific scenario
1227   0000                              
1228   0000                              ;----------------------------------------------------
1229   0000                              ; $117-$132, series of software timers (counting down to 0)
1230   0000                              ; decremented in subroutine 4 at ~40Hz
1231   0000                              ;----------------------------------------------------
1232   0000             T40_2hz          .EQU     $0117                  ; set to $14 on init and loop at $14 (produces 2Hz)
1233   0000             T40_0p5hz        .EQU     $0118                  ; set to $50 on init and loop at $50 (produces 0.5Hz)
1234   0000             T40_start        .EQU     $0119                  ; Set to $ff when key in start, start counting when key no more in start?
1235   0000             T40_crank        .EQU     $011a                  ; Set to $ff when startingToCrank, starts counting when engine is no more startingToCrank (engine running or other state...)
1236   0000             T40_baro         .EQU     $011b                  ; Used to ignore barometric sensor input if battery<8V and 0.35s after battery>8V (baro sensor sensitive to voltage...). Sensor is ignore when timer is not 0
1237   0000             T40_stInj0       .EQU     $011c                  ; Starts counting from 1 sec when rotatingStopInj flag is activated. Used to activate T40_stInj1
1238   0000             T40_stInj1       .EQU     $011d                  ; Initialized to 2 sec when T40_stInj0 expires (ongoing rotatingStopInj for more than 1sec) starts counting when rotatingStopInj is deactivated. This timer is therefore non-zero 1 sec after rotatingStopInj starts and 2 sec after is stops
1239   0000             T40_o2Fbk        .EQU     $011e                  ; Timer will only be 0 when the low trim range will have been selected for more than 4 sec. Used to eventually calculate o2Fbk_dec,o2Fbk_inc, how fast o2 feedback is adjusting...
1240   0000             T40_ftrim2       .EQU     $011f                  ; Used on E931 as an additional condition to update fuel trims
1241   0000             T40_engRot       .EQU     $0120                  ; Kind of an "engine rotating" flag, This timer is re-initialized to 0.6s or 1.2s on every CAS interrupt, will reach 0 only if no CAS int. is received (engine not rotating or very slowy) for more than that time (rpm<0.83/K???)
1242   0000             T40_mas          .EQU     $0121                  ; This timer is periodically initialized to 12 (0.3s) and will reach 0 only if no mas interrupt is received for that long (no air is getting in or something is wrong...)
1243   0000             T40_fuelCut      .EQU     $0122                  ; Fuel cut timer, fuel cut is applied only when this timer reach 0: After air flow threshold is exceeded for more than 1s
1244   0000             T40_ftrim        .EQU     $0123                  ; Fuel trim update timer. Fuel trim are not updated unless this timer is expired (=0). It is set to 5 sec when condition are stable, i.e. fuel trim are update only after conditions are stable for more than 5 sec
1245   0000             T40_noPower      .EQU     $0124                  ; Timer is init at 0.125sec on every loop when ECU receives power? Will reach 0 when the ECU is about to turn-off (ECU relay turns-off after a few seconds...)
1246   0000             T40_revving      .EQU     $0125                  ; Timer used in updating iscStStall. Re-init to 0.5sec if  tpsRaw < 86% or airVol >= $3a. Timer will start counting when tpsRaw>86% and airVol < $3a and will expire 0.5sec later. Keeps track of rapid throttle plate opening in stalling calculations???
1247   0000             T40_iscLrn       .EQU     $0126                  ; Timer looping at 40 (produces 1 Hz) used to update isc0/isc1 and iscY1/iscY2/iscY3 at 1Hz (isc learning...)
1248   0000             T40_stall        .EQU     $0127                  ; Used to update iscStStall at ~2Hz
1249   0000             T40_acOnTrans    .EQU     $0128                  ; Used to filter out (0.1sec) the impact of A/C being turned-on (transcient load) when evaluating whether the engine is running too slow (<500rpm) 
1250   0000             T40_iscStart     .EQU     $0129                  ; Used to decrement iscStStartMaster as a function of time upon engine startup
1251   0000             T40_checkTargRpm .EQU     $012a                  ; Timer used to schedule every 1sec the comparison between current rpm to target rpm and adjust isc if necessary
1252   0000             T40_iSpAdj       .EQU     $012b                  ; Timer is 0 when Idle speed adjustment mode is active. Set to 0.2sec after both timing adjustment and ECU test mode terminals are grounded. i.e. idle speed adjustement mode is applied 0.2sec after terminals are grounded...
1253   0000             T40_21           .EQU     $012c                  ; For E932, used to decrement iscStBaseAcAdj at 2.22Hz
1254   0000             T40_obdCmd       .EQU     $012d                  ; Implement the processing of OBD command code, set to $f0 (6 seconds at 40Hz) if an injector is off or an actuator on
1255   0000             T40_acOn         .EQU     $012e                  ; Implement min time before engaging A/C clutch after A/C button is pressed
1256   0000             T40_acOnRpm      .EQU     $012f                  ; Implement min time before engaging A/C clutch after RPM > 438 (after car is started-up)
1257   0000             T40_acCut        .EQU     $0130                  ; Implement the 5s A/C cutoff when TPS goes above (and stays above) 82% in AT (5 sec countdown)
1258   0000             T40_26           .EQU     $0131                  ; Unused (but decremented...)
1259   0000             T40_27           .EQU     $0132                  ; Unused (but decremented...)
1260   0000                              
1261   0000                              
1262   0000                              ;-----------------------------------------
1263   0000                              ; Software timer at ~40Hz decremented individually
1264   0000                              ;-----------------------------------------
1265   0000             T40s_Idle        .EQU     $0133                  ; Only decremented under some specific conditions, init with $1e(0.75s) when idle switch is off, will reach 0 when idle switch has been on for more than 0.75s, used to condition idle flag with A/C switch. 
1266   0000                              
1267   0000                              ;----------------------------------------------------
1268   0000                              ; $134-$13f, series of software timers (counting down to 0)
1269   0000                              ; decremented in subroutine 4 at ~2Hz
1270   0000                              ;----------------------------------------------------
1271   0000             T2_crank         .EQU     $0134                  ; Set to $ff when startingToCrank, starts counting when engine is no more startingToCrank (engine running or other state...)
1272   0000             T2_EcuPower      .EQU     $0135                  ; Starts counting from $ff when the ECU receives power, used to blink the "check engine" light when the ECU is turned on. 
1273   0000             T2_closedLp      .EQU     $0136                  ; Used to prolong closed loop mode when we go over an airVolTB threshold for a short period of time, Init to 12sec or 20sec
1274   0000             T2_o2Sensor      .EQU     $0137                  ; Used to validate the o2 sensor voltage. If timer expires with the o2 sensor voltage never switching (rich/lean) then o2 sensor is not working correctly...
1275   0000             T2_hotEnrich     .EQU     $0138                  ; Used for fuel enrichement during 120sec after starting engine under very hot intake air temperature (reduce vapor lock???)
1276   0000             T2_airVolT       .EQU     $0139                  ; Set to 5 sec whenever airVolT>24. Will expire once airVolT<=15 for more than 5sec
1277   0000             T2_6             .EQU     $013a                  ; Unused? (but decremented...)
1278   0000             T2_snsrChk       .EQU     $013b                  ; Sensor is flagged as bad only when it has been consistently been tested as bad for 4sec. T2_snsrChk implement that 4sec. Initialized to 4 sec everytime sensrChkIdx is reset to 0
1279   0000             T2_o2Chk         .EQU     $013c                  ; Used in o2 sensor testing/validation. re-initialized to 30sec as long as all the testing pre-conditions are not met or as long as we are running rich. Starts counting when we are running lean and pre-conditions are met...
1280   0000             T2_egrtChk       .EQU     $013d                  ; Used in egrt sensor testing/validation.
1281   0000             T2_stCrank       .EQU     $013e                  ; Init to $ff when startingToCrank or when engine just started rotating, starts counting after state change 
1282   0000             T2_11            .EQU     $013f                  ; Unused? (but decremented...)
1283   0000                              
1284   0000                              ;---------------------------------------------------
1285   0000                              ; 140-144, series of software timers (counting down to 0)
1286   0000                              ; decremented in subroutine 4 at ~0.5Hz
1287   0000                              ;---------------------------------------------------
1288   0000             T0p5_crank1      .EQU     $0140                  ; Set to $ff when startingToCrank, starts counting when engine is no more startingToCrank (engine running or other state...)
1289   0000             T0p5_crCold      .EQU     $0141                  ; Basically not null for 120sec after a cold engine is being cranked/started. Initialized to 120sec when startingToCrank and temperature(ectFiltered) <= 88degC or to 0 if startingToCrank and temperature(ectFiltered) >88degC. Never updated otherwise. Starts counting when we are not startingToCrank. Reset to 0 when notRotating. 
1290   0000             T0p5_purge       .EQU     $0142                  ; Used to implement pulsewidth modulation of the purge solenoid (if some conditions are met), period is very long, 236sec
1291   0000             T0p5_crank2      .EQU     $0143                  ; Similar to T0p5_crank1
1292   0000             T0p5_ect         .EQU     $0144                  ; Reloaded with 5 min on every loop. Starts counting from 5 min only when ect equals exactly 41degC, used in ECT sensor fault routine. Since ect should not stay at that temp for long, counter should never reach 0???
1293   0000                              
1294   0000             Tcas             .EQU     $0145   ;:$0146        ; Tcas (125KHz clock, half the real clock...) is the time(s) per cas interrupt * 125000, rpm = 60/(2*Tcas/125000), Tcas = 60/(2*rpm/125000)    (there are 4 cas interrupt for every 2 engine rotations). Tcas is calculated from [TcasLast0:TcasLast1]/2
1295   0000             TcasOld          .EQU     $0147   ;:$0148        ; previous value of Tcas
1296   0000             airDiffPos1      .EQU     $0149                  ; airDiffPos is transfered to it in subroutine 1
1297   0000             airDiffNeg1      .EQU     $014a                  ; airDiffNeg is transfered to it in subroutine 1
1298   0000             mafRaw16         .EQU     $014b   ;:$014c        ; 16 bit mafRaw, Airflow sensor pulse frequency (x/10.24)Hz, calculated from filtered air count (airCnt0:airCnt1) and rpm
1299   0000             tpsDiffMax2      .EQU     $014d                  ; Value tpsDiffMax1 is transfered here on every main loop execution    
1300   0000             ectCond          .EQU     $014e                  ; Conditionned ect for table interpolation, calculated from ectFiltered, see around L1035 
1301   0000             iatCond          .EQU     $014f                  ; Condtionned intake air temperature -> validated and offset/clipped  = max(min(iatChecked,$e0)-$20,0)     
1302   0000             airVolCond       .EQU     $0150                  ; Conditionned airVol used in table interpolation
1303   0000             rpmIndex1        .EQU     $0151                  ; Set to min(max(RPM31p25-500rpm,0),4500rpm), used in 2D interpolation of t_egrDutyFact (column) 
1304   0000             baroCond         .EQU     $0152                  ; Conditionned barometric pressure, non-linear range of $00 to $80 (0.45bar to 0.92bar): 1:1 from $00 to $40 and 2:1 from $40 to $80 
1305   0000             injMasComp       .EQU     $0153   ;:$0154        ; totMasComp*16 * injComp/128
1306   0000             totMasComp       .EQU     $0155   ;:$0156        ; Total mas compensation factor, (masComp+t_masComp(xx))* masLinComp/128
1307   0000             masLinComp       .EQU     $0157                  ; Interpolated t_masLin, compensate for airflow sensor non-linearity as a function of iat, baro and airflow sensor frequency
1308   0000             L0158            .EQU     $0158                  ; Not used????
1309   0000             openLoopEnr      .EQU     $0159                  ; Open loop enrichement factor, based on timing/knock fuel enrichment conditionned on tps and timer based enrichement
1310   0000             o2FuelAdj        .EQU     $015a                  ; Factor to increase/reduce fuel depending on o2 sensor voltage/feedback, value from 0 to 255, $80=100%->no fuel adjustment. o2FuelAdj = o2Fbk +/-  t_closedLpV1(xx) or t_closedLpV2(xx)
1311   0000             workFtrim        .EQU     $015b                  ; Working fuel trim, the fuel trim selected according to current fuel trim range
1312   0000             coldTempEnr      .EQU     $015c                  ; Fuel enrichement factor for cold engine under low airflow conditions, Value of $80=100% means no enrichement
1313   0000             enrWarmup        .EQU     $015d                  ; Current fuel enrichment during warmup/startup, enrichement factor = (2*enrWarmup+$80)/$80
1314   0000             T_enrWarm        .EQU     $015e                  ; Counter used to lower enrWarmup as a function of time down to 0 
1315   0000             iatCompFact      .EQU     $015f                  ; Air density factor as a function of temperature ($80=1.0)
1316   0000             baroFact         .EQU     $0160                  ; Barometric pressure factor, pressure=(baroFact/128)bar
1317   0000             timFuelEnr       .EQU     $0161                  ; Fuel enrich based on knock/timing??? (Temporarily the timing map value)
1318   0000             T40s_iscStable   .EQU     $0162                  ; Timer is re-initialized to various values (highest of new and current is kept) every time a ISC impacting load is detected (i.e power steering pump is turned on). Timer is decremented only when iscStepTarg=iscStepCurr, i.e. idle speed target is reached. 
1319   0000                                                              ; It will therefore reach 0 only when the ISC step has reached its target and stayed there for a while, ISC is stable...
1320   0000             iscStStall       .EQU     $0163                  ; This is the minimum isc step to use when the idle switch transition from off to on. It is decreased by 3 at ~20Hz???. I suppose this is to smooth the rapid change of airflow when the throttle plate closes and reduce the possibility of stalling the engine
1321   0000             iscStStartUsed   .EQU     $0164                  ; This is the current value of the offset to add to base isc step when the engine was just started. It is slowly decreased (following iscStStartMaster) until the isc step stabilizes. It then stays constant. Whatever value remains after stabilization is used to update iscYn learning variables
1322   0000             iscLowBatt       .EQU     $0165                  ; Keep track of battery condition for ISC spindle updating. Bit 7 is set when battRaw >= 10V (with hysteresis). 2 lower bits used as counter (3 max) as to how many consecutive times battRaw >= 10V, ISC spindle is not moved until this counter is $03
1323   0000             iscStTargSpec    .EQU     $0166                  ; The value that will be stored in iscStepTarg when the engine is runnning but iscLrnFlags.1 is set
1324   0000             iscStBase        .EQU     $0167                  ; Basic ISC step as a function of ECT
1325   0000             iscStBaseAc      .EQU     $0168                  ; iscStBase corrected for A/C and transmission load
1326   0000             iscStBaseCSt     .EQU     $0169                  ; iscStBase corrected for cold start period, i.e. high ISC step at start and then decreasing towards iscStBase over 120sec. Set to 0 after 120sec
1327   0000             iscStBarOff      .EQU     $016a                  ; Offset to add to the basic ISC step to compensate for barometric pressure
1328   0000             iscStBaseAcAdj   .EQU     $016b                  ; For E932, used to adjust iscStBaseAc when transmission is engaged, i.e. drive, decremented down to 0 at 2.22Hz...  
1329   0000             idleSpdInit      .EQU     $016c                  ; Preliminary idle speed target (xx*7.8125)rpm, t_idleSpd(ect) or t_idleSpdDr(ect), used in the computation of idleSpdTarg
1330   0000             idleSpdMin       .EQU     $016d                  ; Minimum idle speed target (xx*7.8125)rpm, used in the computation of idleSpdTarg
1331   0000             L016e            .EQU     $016e                  ; Unused?
1332   0000             advTotal         .EQU     $016f                  ; Sum of the timing (xx-10)degrees BTDC from the timing maps (timingOct) and of three other timing corrections (advEct-$80, advIat-$80, advRpm-$80)
1333   0000             timingOct        .EQU     $0170                  ; Base timing (xx-10)degrees corrrected for octane: timingOct = alpha * t_timingHiOct(rpm, load) + (1-alpha) * t_timingLoOct(rpm, load)    where alpha = octane/255
1334   0000             advEct           .EQU     $0171                  ; Ect based timing correction (xx-$80)degrees
1335   0000             advIat           .EQU     $0172                  ; Iat based timing correction (xx-$80)degrees
1336   0000             advRpm           .EQU     $0173                  ; Rpm based timing correction (xx-$80)degrees
1337   0000             coilChkCnt       .EQU     $0174                  ; Used to set an error flag if the ignition coil sensing circuit shows that the ignition is not working properly 
1338   0000             coilHist         .EQU     $0175                  ; coilHist basically contains the ignition coil sensing circuit history (0 or 1 from port4.2) for the last 8 CAS interrupts, bit 7 being the oldest and bit 0 the newest
1339   0000             T40s_octane      .EQU     $0176                  ; octane timer decremented at 40Hz and looping at $10. octane is updated when timer reaches 0 (at 2.5Hz total)
1340   0000             knockTimer       .EQU     $0177                  ; Used in the validation of the raw knock sensor voltage received from the ADC
1341   0000             egrtTimerThr     .EQU     $0178                  ; Timer threshold (compared to T0p5_crank2) used to decide whether enough time has elapsed to test the egrt sensor (180sec or 360sec), threshold is ect based
1342   0000             sensrChkIdx      .EQU     $0179                  ; The current index in table t_snsrChk indicating which sensor is to be checked/tested next.
1343   0000             obdCode          .EQU     $017a                  ; Contain the latest code received from OBD connector
1344   0000             errCodeIdx       .EQU     $017b                  ; Processing of diagnoctic port error code output (heart beat mode), 
1345   0000                                                              ; c4:c3:c2:c1:c0 is the index of the current error being output
1346   0000                                                              ; d2:d1:d0 are used as a small 2Hz timer to produce the "heart beat"...
1347   0000                                                              ;     bit 0 (0x01): c0 
1348   0000                                                              ;     bit 1 (0x02): c1
1349   0000                                                              ;     bit 2 (0x04): c2
1350   0000                                                              ;     bit 3 (0x08): c3
1351   0000                                                              ;     bit 4 (0x10): c4
1352   0000                                                              ;     bit 5 (0x20): d0
1353   0000                                                              ;     bit 6 (0x40): d1
1354   0000                                                              ;     bit 7 (0x80): d2
1355   0000             errCodeProc      .EQU     $017c                  ; Loaded with the error code (t_snsrChkCode) being output to the test connector (heart beat mode) and then updated as the code is being output.
1356   0000                                                              ;     bit 0 (0x01): a0  a3:a2:a1:a0 is the number of short pulse left to output to connector
1357   0000                                                              ;     bit 1 (0x02): a1
1358   0000                                                              ;     bit 2 (0x04): a2
1359   0000                                                              ;     bit 3 (0x08): a3
1360   0000                                                              ;     bit 4 (0x10): b0 b2:b1:b0 is the number of long pulse left to output to connector
1361   0000                                                              ;     bit 5 (0x20): b1
1362   0000                                                              ;     bit 6 (0x40): b2
1363   0000                                                              ;     bit 7 (0x80): c0 Set to 1 when a new code is loaded, reset to 0 at midpoint between long and short pulses
1364   0000             egrDuty128       .EQU     $017d                  ; EGR solenoid Duty cycle value from 0 to $80 produces 0 to 100% (not sure of correspondance)
1365   0000             egrDuty          .EQU     $017e                  ; EGR solenoid Duty cycle (48-value)/48, value of table at FF88 interpolated by ECT
1366   0000             bGaugeODuty      .EQU     $017f                  ; Boost gauge "off-duty" cycle, value between $00 and $18, $00 corresponding to the maximum of the boost gauge scale
1367   0000             T40s_bcs         .EQU     $0180                  ; bcs timer, decremented at 40Hz, loops at $14 (20), bcs duty cycle is updated when this timer reaches 0 (at 2Hz)
1368   0000             bcsDuty          .EQU     $0181                  ; bcs duty cycle, duty cycle = (48-value)/48
1369   0000             T40s_tps         .EQU     $0182                  ;
1370   0000             ectStCrank       .EQU     $0183                  ; Loaded with ectFiltered when engine is startingToCrank, used in ect sensor check
1371   0000             rpmX4Filt        .EQU     $0184   ;:$0185        ; Filtered version of 16*rpm4 (xx*16/3.90625)rpm. Filtering is achieved using exponential averaging with alpha = 0.90625
1372   0000             injCount         .EQU     $0186                  ; Used in the calculation of injPwStart. Incremented by 1 (255 max) every time injPw !=0 in interrupt rountine (fuel is injected)
1373   0000             airCntMin0       .EQU     $0187                  ; [airCntMin0:airCntMin1] is the minimum value of [airCntNew0:airCntNew1] before it is used for airCnt0 calcuations
1374   0000             airCntMin1       .EQU     $0188                  ; See airCntMin0
1375   0000             
1376   0000             
1377   0000                               ;------------------------------------------------------------
1378   0000                               ; Unused memory block, except for iscStStartMaster
1379   0000                               ;
1380   0000                               ; Also provides a buffer space in case of stack overflow...
1381   0000                               ; Memories should always be 0 else it means the stack 
1382   0000                               ; overflowed in this region... 
1383   0000                               ;------------------------------------------------------------
1384   0000             L0189            .EQU     $0189                  ;
1385   0000             L018a            .EQU     $018a                  ;
1386   0000             L018b            .EQU     $018b                  ;
1387   0000             L018c            .EQU     $018c                  ;
1388   0000             iscStStartMaster .EQU     $018d                  ; This is the master isc step offset used upon engine startup. It is initialized with a value from table and then decreased as a function of time down to 0. See iscStStartUsed for more details...
1389   0000             L018e            .EQU     $018e                  ;
1390   0000             L018f            .EQU     $018f                  ;
1391   0000             L0190            .EQU     $0190                  ; Memory cleared up to (and including) here
1392   0000             ramClearEnd      .EQU     $0190                  ;
1393   0000                              
1394   0000                               ;--------------------------------------------
1395   0000                               ; Memory below is reserved for the stack
1396   0000                               ;--------------------------------------------
1397   0000             L0191            .EQU     $0191                  ;                             
1398   0000             L0192            .EQU     $0192                  ; 
1399   0000             L0193            .EQU     $0193                  ; 
1400   0000             L0194            .EQU     $0194                  ; 
1401   0000             L0195            .EQU     $0195                  ; 
1402   0000             L0196            .EQU     $0196                  ; 
1403   0000             L0197            .EQU     $0197                  ; 
1404   0000             L0198            .EQU     $0198                  ; 
1405   0000             L0199            .EQU     $0199                  ; 
1406   0000             L019a            .EQU     $019a                  ; 
1407   0000             L019b            .EQU     $019b                  ; 
1408   0000             L019c            .EQU     $019c                  ; 
1409   0000             L019d            .EQU     $019d                  ; 
1410   0000             L019e            .EQU     $019e                  ; 
1411   0000             L019f            .EQU     $019f                  ; 
1412   0000             L01a0            .EQU     $01a0                  ; 
1413   0000             L01a1            .EQU     $01a1                  ; 
1414   0000             L01a2            .EQU     $01a2                  ; 
1415   0000             L01a3            .EQU     $01a3                  ; 
1416   0000             L01a4            .EQU     $01a4                  ; 
1417   0000             L01a5            .EQU     $01a5                  ; 
1418   0000             L01a6            .EQU     $01a6                  ; 
1419   0000             L01a7            .EQU     $01a7                  ; 
1420   0000             L01a8            .EQU     $01a8                  ; 
1421   0000             L01a9            .EQU     $01a9                  ; 
1422   0000             L01aa            .EQU     $01aa                  ; 
1423   0000             L01ab            .EQU     $01ab                  ; 
1424   0000             L01ac            .EQU     $01ac                  ; 
1425   0000             L01ad            .EQU     $01ad                  ; 
1426   0000             L01ae            .EQU     $01ae                  ; 
1427   0000             L01af            .EQU     $01af                  ; 
1428   0000             L01b0            .EQU     $01b0                  ; 
1429   0000             L01b1            .EQU     $01b1                  ; 
1430   0000             L01b2            .EQU     $01b2                  ; 
1431   0000             L01b3            .EQU     $01b3                  ; 
1432   0000             L01b4            .EQU     $01b4                  ; 
1433   0000             L01b5            .EQU     $01b5                  ; 
1434   0000             L01b6            .EQU     $01b6                  ; 
1435   0000             L01b7            .EQU     $01b7                  ; 
1436   0000             L01b8            .EQU     $01b8                  ; 
1437   0000             L01b9            .EQU     $01b9                  ; 
1438   0000             L01ba            .EQU     $01ba                  ; 
1439   0000             L01bb            .EQU     $01bb                  ; 
1440   0000             L01bc            .EQU     $01bc                  ; 
1441   0000             L01bd            .EQU     $01bd                  ; 
1442   0000             L01be            .EQU     $01be                  ; 
1443   0000             stack            .EQU     $01bf                  ; Top of stack location(grows backward (push-> SP=SP-1)
1444   0000                         
1445   0000               
1446   0000                                         
1447   0000             ;***************************************************************
1448   0000             ;*
1449   0000             ;*
1450   0000             ;* Unused/Unavailable memory?
1451   0000             ;*
1452   0000             ;*
1453   0000             ;***************************************************************
1454   0000             empty1      .EQU    $01C0   ;:$01FF
1455   0000             
1456   0000             
1457   0000             
1458   0000             ;******************************************************************
1459   0000             ;
1460   0000             ;
1461   0000             ; 32KB chip address range start
1462   0000             ;
1463   0000             ;
1464   0000             ;******************************************************************
1465   8000             epromStart   .org    $8000
1466   8000             
1467   8000             
1468   8000             
1469   8000             ;******************************************************************
1470   8000             ;
1471   8000             ;
1472   8000             ; Battery gauge code
1473   8000             ;
1474   8000             ; 0psi boost ~12.14V ~ 40% duty
1475   8000             ;
1476   8000             ;
1477   8000             ;
1478   8000             ;******************************************************************
1479   8000 FF FF FF FF             .fill   newCode-$, $ff
1479   8004 FF FF FF FF 
1479   8008 FF FF FF FF 
1479   800C FF FF FF FF 
1479   8010 FF FF FF FF 
1479   8014 FF FF FF FF 
1479   8018 FF FF FF FF 
1479   801C FF FF FF FF 
1479   8020 FF FF FF FF 
1479   8024 FF FF FF FF 
1479   8028 FF FF FF FF 
1479   802C FF FF FF FF 
1479   8030 FF FF FF FF 
1479   8034 FF FF FF FF 
1479   8038 FF FF FF FF 
1479   803C FF FF FF FF 
1479   8040 FF FF FF FF 
1479   8044 FF FF FF FF 
1479   8048 FF FF FF FF 
1479   804C FF FF FF FF 
1479   8050 FF FF FF FF 
1479   8054 FF FF FF FF 
1479   8058 FF FF FF FF 
1479   805C FF FF FF FF 
1479   8060 FF FF FF FF 
1479   8064 FF FF FF FF 
1479   8068 FF FF FF FF 
1479   806C FF FF FF FF 
1479   8070 FF FF FF FF 
1479   8074 FF FF FF FF 
1479   8078 FF FF FF FF 
1479   807C FF FF FF FF 
1479   8080 FF FF FF FF 
1479   8084 FF FF FF FF 
1479   8088 FF FF FF FF 
1479   808C FF FF FF FF 
1479   8090 FF FF FF FF 
1479   8094 FF FF FF FF 
1479   8098 FF FF FF FF 
1479   809C FF FF FF FF 
1479   80A0 FF FF FF FF 
1479   80A4 FF FF FF FF 
1479   80A8 FF FF FF FF 
1479   80AC FF FF FF FF 
1479   80B0 FF FF FF FF 
1479   80B4 FF FF FF FF 
1479   80B8 FF FF FF FF 
1479   80BC FF FF FF FF 
1479   80C0 FF FF FF FF 
1479   80C4 FF FF FF FF 
1479   80C8 FF FF FF FF 
1479   80CC FF FF FF FF 
1479   80D0 FF FF FF FF 
1479   80D4 FF FF FF FF 
1479   80D8 FF FF FF FF 
1479   80DC FF FF FF FF 
1479   80E0 FF FF FF FF 
1479   80E4 FF FF FF FF 
1479   80E8 FF FF FF FF 
1479   80EC FF FF FF FF 
1479   80F0 FF FF FF FF 
1479   80F4 FF FF FF FF 
1479   80F8 FF FF FF FF 
1479   80FC FF FF FF FF 
1479   8100 FF FF FF FF 
1479   8104 FF FF FF FF 
1479   8108 FF FF FF FF 
1479   810C FF FF FF FF 
1479   8110 FF FF FF FF 
1479   8114 FF FF FF FF 
1479   8118 FF FF FF FF 
1479   811C FF FF FF FF 
1479   8120 FF FF FF FF 
1479   8124 FF FF FF FF 
1479   8128 FF FF FF FF 
1479   812C FF FF FF FF 
1479   8130 FF FF FF FF 
1479   8134 FF FF FF FF 
1479   8138 FF FF FF FF 
1479   813C FF FF FF FF 
1479   8140 FF FF FF FF 
1479   8144 FF FF FF FF 
1479   8148 FF FF FF FF 
1479   814C FF FF FF FF 
1479   8150 FF FF FF FF 
1479   8154 FF FF FF FF 
1479   8158 FF FF FF FF 
1479   815C FF FF FF FF 
1479   8160 FF FF FF FF 
1479   8164 FF FF FF FF 
1479   8168 FF FF FF FF 
1479   816C FF FF FF FF 
1479   8170 FF FF FF FF 
1479   8174 FF FF FF FF 
1479   8178 FF FF FF FF 
1479   817C FF FF FF FF 
1479   8180 FF FF FF FF 
1479   8184 FF FF FF FF 
1479   8188 FF FF FF FF 
1479   818C FF FF FF FF 
1479   8190 FF FF FF FF 
1479   8194 FF FF FF FF 
1479   8198 FF FF FF FF 
1479   819C FF FF FF FF 
1479   81A0 FF FF FF FF 
1479   81A4 FF FF FF FF 
1479   81A8 FF FF FF FF 
1479   81AC FF FF FF FF 
1479   81B0 FF FF FF FF 
1479   81B4 FF FF FF FF 
1479   81B8 FF FF FF FF 
1479   81BC FF FF FF FF 
1479   81C0 FF FF FF FF 
1479   81C4 FF FF FF FF 
1479   81C8 FF FF FF FF 
1479   81CC FF FF FF FF 
1479   81D0 FF FF FF FF 
1479   81D4 FF FF FF FF 
1479   81D8 FF FF FF FF 
1479   81DC FF FF FF FF 
1479   81E0 FF FF FF FF 
1479   81E4 FF FF FF FF 
1479   81E8 FF FF FF FF 
1479   81EC FF FF FF FF 
1479   81F0 FF FF FF FF 
1479   81F4 FF FF FF FF 
1479   81F8 FF FF FF FF 
1479   81FC FF FF FF FF 
1479   8200 FF FF FF FF 
1479   8204 FF FF FF FF 
1479   8208 FF FF FF FF 
1479   820C FF FF FF FF 
1479   8210 FF FF FF FF 
1479   8214 FF FF FF FF 
1479   8218 FF FF FF FF 
1479   821C FF FF FF FF 
1479   8220 FF FF FF FF 
1479   8224 FF FF FF FF 
1479   8228 FF FF FF FF 
1479   822C FF FF FF FF 
1479   8230 FF FF FF FF 
1479   8234 FF FF FF FF 
1479   8238 FF FF FF FF 
1479   823C FF FF FF FF 
1479   8240 FF FF FF FF 
1479   8244 FF FF FF FF 
1479   8248 FF FF FF FF 
1479   824C FF FF FF FF 
1479   8250 FF FF FF FF 
1479   8254 FF FF FF FF 
1479   8258 FF FF FF FF 
1479   825C FF FF FF FF 
1479   8260 FF FF FF FF 
1479   8264 FF FF FF FF 
1479   8268 FF FF FF FF 
1479   826C FF FF FF FF 
1479   8270 FF FF FF FF 
1479   8274 FF FF FF FF 
1479   8278 FF FF FF FF 
1479   827C FF FF FF FF 
1479   8280 FF FF FF FF 
1479   8284 FF FF FF FF 
1479   8288 FF FF FF FF 
1479   828C FF FF FF FF 
1479   8290 FF FF FF FF 
1479   8294 FF FF FF FF 
1479   8298 FF FF FF FF 
1479   829C FF FF FF FF 
1479   82A0 FF FF FF FF 
1479   82A4 FF FF FF FF 
1479   82A8 FF FF FF FF 
1479   82AC FF FF FF FF 
1479   82B0 FF FF FF FF 
1479   82B4 FF FF FF FF 
1479   82B8 FF FF FF FF 
1479   82BC FF FF FF FF 
1479   82C0 FF FF FF FF 
1479   82C4 FF FF FF FF 
1479   82C8 FF FF FF FF 
1479   82CC FF FF FF FF 
1479   82D0 FF FF FF FF 
1479   82D4 FF FF FF FF 
1479   82D8 FF FF FF FF 
1479   82DC FF FF FF FF 
1479   82E0 FF FF FF FF 
1479   82E4 FF FF FF FF 
1479   82E8 FF FF FF FF 
1479   82EC FF FF FF FF 
1479   82F0 FF FF FF FF 
1479   82F4 FF FF FF FF 
1479   82F8 FF FF FF FF 
1479   82FC FF FF FF FF 
1479   8300 FF FF FF FF 
1479   8304 FF FF FF FF 
1479   8308 FF FF FF FF 
1479   830C FF FF FF FF 
1479   8310 FF FF FF FF 
1479   8314 FF FF FF FF 
1479   8318 FF FF FF FF 
1479   831C FF FF FF FF 
1479   8320 FF FF FF FF 
1479   8324 FF FF FF FF 
1479   8328 FF FF FF FF 
1479   832C FF FF FF FF 
1479   8330 FF FF FF FF 
1479   8334 FF FF FF FF 
1479   8338 FF FF FF FF 
1479   833C FF FF FF FF 
1479   8340 FF FF FF FF 
1479   8344 FF FF FF FF 
1479   8348 FF FF FF FF 
1479   834C FF FF FF FF 
1479   8350 FF FF FF FF 
1479   8354 FF FF FF FF 
1479   8358 FF FF FF FF 
1479   835C FF FF FF FF 
1479   8360 FF FF FF FF 
1479   8364 FF FF FF FF 
1479   8368 FF FF FF FF 
1479   836C FF FF FF FF 
1479   8370 FF FF FF FF 
1479   8374 FF FF FF FF 
1479   8378 FF FF FF FF 
1479   837C FF FF FF FF 
1479   8380 FF FF FF FF 
1479   8384 FF FF FF FF 
1479   8388 FF FF FF FF 
1479   838C FF FF FF FF 
1479   8390 FF FF FF FF 
1479   8394 FF FF FF FF 
1479   8398 FF FF FF FF 
1479   839C FF FF FF FF 
1479   83A0 FF FF FF FF 
1479   83A4 FF FF FF FF 
1479   83A8 FF FF FF FF 
1479   83AC FF FF FF FF 
1479   83B0 FF FF FF FF 
1479   83B4 FF FF FF FF 
1479   83B8 FF FF FF FF 
1479   83BC FF FF FF FF 
1479   83C0 FF FF FF FF 
1479   83C4 FF FF FF FF 
1479   83C8 FF FF FF FF 
1479   83CC FF FF FF FF 
1479   83D0 FF FF FF FF 
1479   83D4 FF FF FF FF 
1479   83D8 FF FF FF FF 
1479   83DC FF FF FF FF 
1479   83E0 FF FF FF FF 
1479   83E4 FF FF FF FF 
1479   83E8 FF FF FF FF 
1479   83EC FF FF FF FF 
1479   83F0 FF FF FF FF 
1479   83F4 FF FF FF FF 
1479   83F8 FF FF FF FF 
1479   83FC FF FF FF FF 
1479   8400 FF FF FF FF 
1479   8404 FF FF FF FF 
1479   8408 FF FF FF FF 
1479   840C FF FF FF FF 
1479   8410 FF FF FF FF 
1479   8414 FF FF FF FF 
1479   8418 FF FF FF FF 
1479   841C FF FF FF FF 
1479   8420 FF FF FF FF 
1479   8424 FF FF FF FF 
1479   8428 FF FF FF FF 
1479   842C FF FF FF FF 
1479   8430 FF FF FF FF 
1479   8434 FF FF FF FF 
1479   8438 FF FF FF FF 
1479   843C FF FF FF FF 
1479   8440 FF FF FF FF 
1479   8444 FF FF FF FF 
1479   8448 FF FF FF FF 
1479   844C FF FF FF FF 
1479   8450 FF FF FF FF 
1479   8454 FF FF FF FF 
1479   8458 FF FF FF FF 
1479   845C FF FF FF FF 
1479   8460 FF FF FF FF 
1479   8464 FF FF FF FF 
1479   8468 FF FF FF FF 
1479   846C FF FF FF FF 
1479   8470 FF FF FF FF 
1479   8474 FF FF FF FF 
1479   8478 FF FF FF FF 
1479   847C FF FF FF FF 
1479   8480 FF FF FF FF 
1479   8484 FF FF FF FF 
1479   8488 FF FF FF FF 
1479   848C FF FF FF FF 
1479   8490 FF FF FF FF 
1479   8494 FF FF FF FF 
1479   8498 FF FF FF FF 
1479   849C FF FF FF FF 
1479   84A0 FF FF FF FF 
1479   84A4 FF FF FF FF 
1479   84A8 FF FF FF FF 
1479   84AC FF FF FF FF 
1479   84B0 FF FF FF FF 
1479   84B4 FF FF FF FF 
1479   84B8 FF FF FF FF 
1479   84BC FF FF FF FF 
1479   84C0 FF FF FF FF 
1479   84C4 FF FF FF FF 
1479   84C8 FF FF FF FF 
1479   84CC FF FF FF FF 
1479   84D0 FF FF FF FF 
1479   84D4 FF FF FF FF 
1479   84D8 FF FF FF FF 
1479   84DC FF FF FF FF 
1479   84E0 FF FF FF FF 
1479   84E4 FF FF FF FF 
1479   84E8 FF FF FF FF 
1479   84EC FF FF FF FF 
1479   84F0 FF FF FF FF 
1479   84F4 FF FF FF FF 
1479   84F8 FF FF FF FF 
1479   84FC FF FF FF FF 
1479   8500 FF FF FF FF 
1479   8504 FF FF FF FF 
1479   8508 FF FF FF FF 
1479   850C FF FF FF FF 
1479   8510 FF FF FF FF 
1479   8514 FF FF FF FF 
1479   8518 FF FF FF FF 
1479   851C FF FF FF FF 
1479   8520 FF FF FF FF 
1479   8524 FF FF FF FF 
1479   8528 FF FF FF FF 
1479   852C FF FF FF FF 
1479   8530 FF FF FF FF 
1479   8534 FF FF FF FF 
1479   8538 FF FF FF FF 
1479   853C FF FF FF FF 
1479   8540 FF FF FF FF 
1479   8544 FF FF FF FF 
1479   8548 FF FF FF FF 
1479   854C FF FF FF FF 
1479   8550 FF FF FF FF 
1479   8554 FF FF FF FF 
1479   8558 FF FF FF FF 
1479   855C FF FF FF FF 
1479   8560 FF FF FF FF 
1479   8564 FF FF FF FF 
1479   8568 FF FF FF FF 
1479   856C FF FF FF FF 
1479   8570 FF FF FF FF 
1479   8574 FF FF FF FF 
1479   8578 FF FF FF FF 
1479   857C FF FF FF FF 
1479   8580 FF FF FF FF 
1479   8584 FF FF FF FF 
1479   8588 FF FF FF FF 
1479   858C FF FF FF FF 
1479   8590 FF FF FF FF 
1479   8594 FF FF FF FF 
1479   8598 FF FF FF FF 
1479   859C FF FF FF FF 
1479   85A0 FF FF FF FF 
1479   85A4 FF FF FF FF 
1479   85A8 FF FF FF FF 
1479   85AC FF FF FF FF 
1479   85B0 FF FF FF FF 
1479   85B4 FF FF FF FF 
1479   85B8 FF FF FF FF 
1479   85BC FF FF FF FF 
1479   85C0 FF FF FF FF 
1479   85C4 FF FF FF FF 
1479   85C8 FF FF FF FF 
1479   85CC FF FF FF FF 
1479   85D0 FF FF FF FF 
1479   85D4 FF FF FF FF 
1479   85D8 FF FF FF FF 
1479   85DC FF FF FF FF 
1479   85E0 FF FF FF FF 
1479   85E4 FF FF FF FF 
1479   85E8 FF FF FF FF 
1479   85EC FF FF FF FF 
1479   85F0 FF FF FF FF 
1479   85F4 FF FF FF FF 
1479   85F8 FF FF FF FF 
1479   85FC FF FF FF FF 
1479   8600 FF FF FF FF 
1479   8604 FF FF FF FF 
1479   8608 FF FF FF FF 
1479   860C FF FF FF FF 
1479   8610 FF FF FF FF 
1479   8614 FF FF FF FF 
1479   8618 FF FF FF FF 
1479   861C FF FF FF FF 
1479   8620 FF FF FF FF 
1479   8624 FF FF FF FF 
1479   8628 FF FF FF FF 
1479   862C FF FF FF FF 
1479   8630 FF FF FF FF 
1479   8634 FF FF FF FF 
1479   8638 FF FF FF FF 
1479   863C FF FF FF FF 
1479   8640 FF FF FF FF 
1479   8644 FF FF FF FF 
1479   8648 FF FF FF FF 
1479   864C FF FF FF FF 
1479   8650 FF FF FF FF 
1479   8654 FF FF FF FF 
1479   8658 FF FF FF FF 
1479   865C FF FF FF FF 
1479   8660 FF FF FF FF 
1479   8664 FF FF FF FF 
1479   8668 FF FF FF FF 
1479   866C FF FF FF FF 
1479   8670 FF FF FF FF 
1479   8674 FF FF FF FF 
1479   8678 FF FF FF FF 
1479   867C FF FF FF FF 
1479   8680 FF FF FF FF 
1479   8684 FF FF FF FF 
1479   8688 FF FF FF FF 
1479   868C FF FF FF FF 
1479   8690 FF FF FF FF 
1479   8694 FF FF FF FF 
1479   8698 FF FF FF FF 
1479   869C FF FF FF FF 
1479   86A0 FF FF FF FF 
1479   86A4 FF FF FF FF 
1479   86A8 FF FF FF FF 
1479   86AC FF FF FF FF 
1479   86B0 FF FF FF FF 
1479   86B4 FF FF FF FF 
1479   86B8 FF FF FF FF 
1479   86BC FF FF FF FF 
1479   86C0 FF FF FF FF 
1479   86C4 FF FF FF FF 
1479   86C8 FF FF FF FF 
1479   86CC FF FF FF FF 
1479   86D0 FF FF FF FF 
1479   86D4 FF FF FF FF 
1479   86D8 FF FF FF FF 
1479   86DC FF FF FF FF 
1479   86E0 FF FF FF FF 
1479   86E4 FF FF FF FF 
1479   86E8 FF FF FF FF 
1479   86EC FF FF FF FF 
1479   86F0 FF FF FF FF 
1479   86F4 FF FF FF FF 
1479   86F8 FF FF FF FF 
1479   86FC FF FF FF FF 
1479   8700 FF FF FF FF 
1479   8704 FF FF FF FF 
1479   8708 FF FF FF FF 
1479   870C FF FF FF FF 
1479   8710 FF FF FF FF 
1479   8714 FF FF FF FF 
1479   8718 FF FF FF FF 
1479   871C FF FF FF FF 
1479   8720 FF FF FF FF 
1479   8724 FF FF FF FF 
1479   8728 FF FF FF FF 
1479   872C FF FF FF FF 
1479   8730 FF FF FF FF 
1479   8734 FF FF FF FF 
1479   8738 FF FF FF FF 
1479   873C FF FF FF FF 
1479   8740 FF FF FF FF 
1479   8744 FF FF FF FF 
1479   8748 FF FF FF FF 
1479   874C FF FF FF FF 
1479   8750 FF FF FF FF 
1479   8754 FF FF FF FF 
1479   8758 FF FF FF FF 
1479   875C FF FF FF FF 
1479   8760 FF FF FF FF 
1479   8764 FF FF FF FF 
1479   8768 FF FF FF FF 
1479   876C FF FF FF FF 
1479   8770 FF FF FF FF 
1479   8774 FF FF FF FF 
1479   8778 FF FF FF FF 
1479   877C FF FF FF FF 
1479   8780 FF FF FF FF 
1479   8784 FF FF FF FF 
1479   8788 FF FF FF FF 
1479   878C FF FF FF FF 
1479   8790 FF FF FF FF 
1479   8794 FF FF FF FF 
1479   8798 FF FF FF FF 
1479   879C FF FF FF FF 
1479   87A0 FF FF FF FF 
1479   87A4 FF FF FF FF 
1479   87A8 FF FF FF FF 
1479   87AC FF FF FF FF 
1479   87B0 FF FF FF FF 
1479   87B4 FF FF FF FF 
1479   87B8 FF FF FF FF 
1479   87BC FF FF FF FF 
1479   87C0 FF FF FF FF 
1479   87C4 FF FF FF FF 
1479   87C8 FF FF FF FF 
1479   87CC FF FF FF FF 
1479   87D0 FF FF FF FF 
1479   87D4 FF FF FF FF 
1479   87D8 FF FF FF FF 
1479   87DC FF FF FF FF 
1479   87E0 FF FF FF FF 
1479   87E4 FF FF FF FF 
1479   87E8 FF FF FF FF 
1479   87EC FF FF FF FF 
1479   87F0 FF FF FF FF 
1479   87F4 FF FF FF FF 
1479   87F8 FF FF FF FF 
1479   87FC FF FF FF FF 
1479   8800 FF FF FF FF 
1479   8804 FF FF FF FF 
1479   8808 FF FF FF FF 
1479   880C FF FF FF FF 
1479   8810 FF FF FF FF 
1479   8814 FF FF FF FF 
1479   8818 FF FF FF FF 
1479   881C FF FF FF FF 
1479   8820 FF FF FF FF 
1479   8824 FF FF FF FF 
1479   8828 FF FF FF FF 
1479   882C FF FF FF FF 
1479   8830 FF FF FF FF 
1479   8834 FF FF FF FF 
1479   8838 FF FF FF FF 
1479   883C FF FF FF FF 
1479   8840 FF FF FF FF 
1479   8844 FF FF FF FF 
1479   8848 FF FF FF FF 
1479   884C FF FF FF FF 
1479   8850 FF FF FF FF 
1479   8854 FF FF FF FF 
1479   8858 FF FF FF FF 
1479   885C FF FF FF FF 
1479   8860 FF FF FF FF 
1479   8864 FF FF FF FF 
1479   8868 FF FF FF FF 
1479   886C FF FF FF FF 
1479   8870 FF FF FF FF 
1479   8874 FF FF FF FF 
1479   8878 FF FF FF FF 
1479   887C FF FF FF FF 
1479   8880 FF FF FF FF 
1479   8884 FF FF FF FF 
1479   8888 FF FF FF FF 
1479   888C FF FF FF FF 
1479   8890 FF FF FF FF 
1479   8894 FF FF FF FF 
1479   8898 FF FF FF FF 
1479   889C FF FF FF FF 
1479   88A0 FF FF FF FF 
1479   88A4 FF FF FF FF 
1479   88A8 FF FF FF FF 
1479   88AC FF FF FF FF 
1479   88B0 FF FF FF FF 
1479   88B4 FF FF FF FF 
1479   88B8 FF FF FF FF 
1479   88BC FF FF FF FF 
1479   88C0 FF FF FF FF 
1479   88C4 FF FF FF FF 
1479   88C8 FF FF FF FF 
1479   88CC FF FF FF FF 
1479   88D0 FF FF FF FF 
1479   88D4 FF FF FF FF 
1479   88D8 FF FF FF FF 
1479   88DC FF FF FF FF 
1479   88E0 FF FF FF FF 
1479   88E4 FF FF FF FF 
1479   88E8 FF FF FF FF 
1479   88EC FF FF FF FF 
1479   88F0 FF FF FF FF 
1479   88F4 FF FF FF FF 
1479   88F8 FF FF FF FF 
1479   88FC FF FF FF FF 
1479   8900 FF FF FF FF 
1479   8904 FF FF FF FF 
1479   8908 FF FF FF FF 
1479   890C FF FF FF FF 
1479   8910 FF FF FF FF 
1479   8914 FF FF FF FF 
1479   8918 FF FF FF FF 
1479   891C FF FF FF FF 
1479   8920 FF FF FF FF 
1479   8924 FF FF FF FF 
1479   8928 FF FF FF FF 
1479   892C FF FF FF FF 
1479   8930 FF FF FF FF 
1479   8934 FF FF FF FF 
1479   8938 FF FF FF FF 
1479   893C FF FF FF FF 
1479   8940 FF FF FF FF 
1479   8944 FF FF FF FF 
1479   8948 FF FF FF FF 
1479   894C FF FF FF FF 
1479   8950 FF FF FF FF 
1479   8954 FF FF FF FF 
1479   8958 FF FF FF FF 
1479   895C FF FF FF FF 
1479   8960 FF FF FF FF 
1479   8964 FF FF FF FF 
1479   8968 FF FF FF FF 
1479   896C FF FF FF FF 
1479   8970 FF FF FF FF 
1479   8974 FF FF FF FF 
1479   8978 FF FF FF FF 
1479   897C FF FF FF FF 
1479   8980 FF FF FF FF 
1479   8984 FF FF FF FF 
1479   8988 FF FF FF FF 
1479   898C FF FF FF FF 
1479   8990 FF FF FF FF 
1479   8994 FF FF FF FF 
1479   8998 FF FF FF FF 
1479   899C FF FF FF FF 
1479   89A0 FF FF FF FF 
1479   89A4 FF FF FF FF 
1479   89A8 FF FF FF FF 
1479   89AC FF FF FF FF 
1479   89B0 FF FF FF FF 
1479   89B4 FF FF FF FF 
1479   89B8 FF FF FF FF 
1479   89BC FF FF FF FF 
1479   89C0 FF FF FF FF 
1479   89C4 FF FF FF FF 
1479   89C8 FF FF FF FF 
1479   89CC FF FF FF FF 
1479   89D0 FF FF FF FF 
1479   89D4 FF FF FF FF 
1479   89D8 FF FF FF FF 
1479   89DC FF FF FF FF 
1479   89E0 FF FF FF FF 
1479   89E4 FF FF FF FF 
1479   89E8 FF FF FF FF 
1479   89EC FF FF FF FF 
1479   89F0 FF FF FF FF 
1479   89F4 FF FF FF FF 
1479   89F8 FF FF FF FF 
1479   89FC FF FF FF FF 
1479   8A00 FF FF FF FF 
1479   8A04 FF FF FF FF 
1479   8A08 FF FF FF FF 
1479   8A0C FF FF FF FF 
1479   8A10 FF FF FF FF 
1479   8A14 FF FF FF FF 
1479   8A18 FF FF FF FF 
1479   8A1C FF FF FF FF 
1479   8A20 FF FF FF FF 
1479   8A24 FF FF FF FF 
1479   8A28 FF FF FF FF 
1479   8A2C FF FF FF FF 
1479   8A30 FF FF FF FF 
1479   8A34 FF FF FF FF 
1479   8A38 FF FF FF FF 
1479   8A3C FF FF FF FF 
1479   8A40 FF FF FF FF 
1479   8A44 FF FF FF FF 
1479   8A48 FF FF FF FF 
1479   8A4C FF FF FF FF 
1479   8A50 FF FF FF FF 
1479   8A54 FF FF FF FF 
1479   8A58 FF FF FF FF 
1479   8A5C FF FF FF FF 
1479   8A60 FF FF FF FF 
1479   8A64 FF FF FF FF 
1479   8A68 FF FF FF FF 
1479   8A6C FF FF FF FF 
1479   8A70 FF FF FF FF 
1479   8A74 FF FF FF FF 
1479   8A78 FF FF FF FF 
1479   8A7C FF FF FF FF 
1479   8A80 FF FF FF FF 
1479   8A84 FF FF FF FF 
1479   8A88 FF FF FF FF 
1479   8A8C FF FF FF FF 
1479   8A90 FF FF FF FF 
1479   8A94 FF FF FF FF 
1479   8A98 FF FF FF FF 
1479   8A9C FF FF FF FF 
1479   8AA0 FF FF FF FF 
1479   8AA4 FF FF FF FF 
1479   8AA8 FF FF FF FF 
1479   8AAC FF FF FF FF 
1479   8AB0 FF FF FF FF 
1479   8AB4 FF FF FF FF 
1479   8AB8 FF FF FF FF 
1479   8ABC FF FF FF FF 
1479   8AC0 FF FF FF FF 
1479   8AC4 FF FF FF FF 
1479   8AC8 FF FF FF FF 
1479   8ACC FF FF FF FF 
1479   8AD0 FF FF FF FF 
1479   8AD4 FF FF FF FF 
1479   8AD8 FF FF FF FF 
1479   8ADC FF FF FF FF 
1479   8AE0 FF FF FF FF 
1479   8AE4 FF FF FF FF 
1479   8AE8 FF FF FF FF 
1479   8AEC FF FF FF FF 
1479   8AF0 FF FF FF FF 
1479   8AF4 FF FF FF FF 
1479   8AF8 FF FF FF FF 
1479   8AFC FF FF FF FF 
1479   8B00 FF FF FF FF 
1479   8B04 FF FF FF FF 
1479   8B08 FF FF FF FF 
1479   8B0C FF FF FF FF 
1479   8B10 FF FF FF FF 
1479   8B14 FF FF FF FF 
1479   8B18 FF FF FF FF 
1479   8B1C FF FF FF FF 
1479   8B20 FF FF FF FF 
1479   8B24 FF FF FF FF 
1479   8B28 FF FF FF FF 
1479   8B2C FF FF FF FF 
1479   8B30 FF FF FF FF 
1479   8B34 FF FF FF FF 
1479   8B38 FF FF FF FF 
1479   8B3C FF FF FF FF 
1479   8B40 FF FF FF FF 
1479   8B44 FF FF FF FF 
1479   8B48 FF FF FF FF 
1479   8B4C FF FF FF FF 
1479   8B50 FF FF FF FF 
1479   8B54 FF FF FF FF 
1479   8B58 FF FF FF FF 
1479   8B5C FF FF FF FF 
1479   8B60 FF FF FF FF 
1479   8B64 FF FF FF FF 
1479   8B68 FF FF FF FF 
1479   8B6C FF FF FF FF 
1479   8B70 FF FF FF FF 
1479   8B74 FF FF FF FF 
1479   8B78 FF FF FF FF 
1479   8B7C FF FF FF FF 
1479   8B80 FF FF FF FF 
1479   8B84 FF FF FF FF 
1479   8B88 FF FF FF FF 
1479   8B8C FF FF FF FF 
1479   8B90 FF FF FF FF 
1479   8B94 FF FF FF FF 
1479   8B98 FF FF FF FF 
1479   8B9C FF FF FF FF 
1479   8BA0 FF FF FF FF 
1479   8BA4 FF FF FF FF 
1479   8BA8 FF FF FF FF 
1479   8BAC FF FF FF FF 
1479   8BB0 FF FF FF FF 
1479   8BB4 FF FF FF FF 
1479   8BB8 FF FF FF FF 
1479   8BBC FF FF FF FF 
1479   8BC0 FF FF FF FF 
1479   8BC4 FF FF FF FF 
1479   8BC8 FF FF FF FF 
1479   8BCC FF FF FF FF 
1479   8BD0 FF FF FF FF 
1479   8BD4 FF FF FF FF 
1479   8BD8 FF FF FF FF 
1479   8BDC FF FF FF FF 
1479   8BE0 FF FF FF FF 
1479   8BE4 FF FF FF FF 
1479   8BE8 FF FF FF FF 
1479   8BEC FF FF FF FF 
1479   8BF0 FF FF FF FF 
1479   8BF4 FF FF FF FF 
1479   8BF8 FF FF FF FF 
1479   8BFC FF FF FF FF 
1479   8C00 FF FF FF FF 
1479   8C04 FF FF FF FF 
1479   8C08 FF FF FF FF 
1479   8C0C FF FF FF FF 
1479   8C10 FF FF FF FF 
1479   8C14 FF FF FF FF 
1479   8C18 FF FF FF FF 
1479   8C1C FF FF FF FF 
1479   8C20 FF FF FF FF 
1479   8C24 FF FF FF FF 
1479   8C28 FF FF FF FF 
1479   8C2C FF FF FF FF 
1479   8C30 FF FF FF FF 
1479   8C34 FF FF FF FF 
1479   8C38 FF FF FF FF 
1479   8C3C FF FF FF FF 
1479   8C40 FF FF FF FF 
1479   8C44 FF FF FF FF 
1479   8C48 FF FF FF FF 
1479   8C4C FF FF FF FF 
1479   8C50 FF FF FF FF 
1479   8C54 FF FF FF FF 
1479   8C58 FF FF FF FF 
1479   8C5C FF FF FF FF 
1479   8C60 FF FF FF FF 
1479   8C64 FF FF FF FF 
1479   8C68 FF FF FF FF 
1479   8C6C FF FF FF FF 
1479   8C70 FF FF FF FF 
1479   8C74 FF FF FF FF 
1479   8C78 FF FF FF FF 
1479   8C7C FF FF FF FF 
1479   8C80 FF FF FF FF 
1479   8C84 FF FF FF FF 
1479   8C88 FF FF FF FF 
1479   8C8C FF FF FF FF 
1479   8C90 FF FF FF FF 
1479   8C94 FF FF FF FF 
1479   8C98 FF FF FF FF 
1479   8C9C FF FF FF FF 
1479   8CA0 FF FF FF FF 
1479   8CA4 FF FF FF FF 
1479   8CA8 FF FF FF FF 
1479   8CAC FF FF FF FF 
1479   8CB0 FF FF FF FF 
1479   8CB4 FF FF FF FF 
1479   8CB8 FF FF FF FF 
1479   8CBC FF FF FF FF 
1479   8CC0 FF FF FF FF 
1479   8CC4 FF FF FF FF 
1479   8CC8 FF FF FF FF 
1479   8CCC FF FF FF FF 
1479   8CD0 FF FF FF FF 
1479   8CD4 FF FF FF FF 
1479   8CD8 FF FF FF FF 
1479   8CDC FF FF FF FF 
1479   8CE0 FF FF FF FF 
1479   8CE4 FF FF FF FF 
1479   8CE8 FF FF FF FF 
1479   8CEC FF FF FF FF 
1479   8CF0 FF FF FF FF 
1479   8CF4 FF FF FF FF 
1479   8CF8 FF FF FF FF 
1479   8CFC FF FF FF FF 
1479   8D00 FF FF FF FF 
1479   8D04 FF FF FF FF 
1479   8D08 FF FF FF FF 
1479   8D0C FF FF FF FF 
1479   8D10 FF FF FF FF 
1479   8D14 FF FF FF FF 
1479   8D18 FF FF FF FF 
1479   8D1C FF FF FF FF 
1479   8D20 FF FF FF FF 
1479   8D24 FF FF FF FF 
1479   8D28 FF FF FF FF 
1479   8D2C FF FF FF FF 
1479   8D30 FF FF FF FF 
1479   8D34 FF FF FF FF 
1479   8D38 FF FF FF FF 
1479   8D3C FF FF FF FF 
1479   8D40 FF FF FF FF 
1479   8D44 FF FF FF FF 
1479   8D48 FF FF FF FF 
1479   8D4C FF FF FF FF 
1479   8D50 FF FF FF FF 
1479   8D54 FF FF FF FF 
1479   8D58 FF FF FF FF 
1479   8D5C FF FF FF FF 
1479   8D60 FF FF FF FF 
1479   8D64 FF FF FF FF 
1479   8D68 FF FF FF FF 
1479   8D6C FF FF FF FF 
1479   8D70 FF FF FF FF 
1479   8D74 FF FF FF FF 
1479   8D78 FF FF FF FF 
1479   8D7C FF FF FF FF 
1479   8D80 FF FF FF FF 
1479   8D84 FF FF FF FF 
1479   8D88 FF FF FF FF 
1479   8D8C FF FF FF FF 
1479   8D90 FF FF FF FF 
1479   8D94 FF FF FF FF 
1479   8D98 FF FF FF FF 
1479   8D9C FF FF FF FF 
1479   8DA0 FF FF FF FF 
1479   8DA4 FF FF FF FF 
1479   8DA8 FF FF FF FF 
1479   8DAC FF FF FF FF 
1479   8DB0 FF FF FF FF 
1479   8DB4 FF FF FF FF 
1479   8DB8 FF FF FF FF 
1479   8DBC FF FF FF FF 
1479   8DC0 FF FF FF FF 
1479   8DC4 FF FF FF FF 
1479   8DC8 FF FF FF FF 
1479   8DCC FF FF FF FF 
1479   8DD0 FF FF FF FF 
1479   8DD4 FF FF FF FF 
1479   8DD8 FF FF FF FF 
1479   8DDC FF FF FF FF 
1479   8DE0 FF FF FF FF 
1479   8DE4 FF FF FF FF 
1479   8DE8 FF FF FF FF 
1479   8DEC FF FF FF FF 
1479   8DF0 FF FF FF FF 
1479   8DF4 FF FF FF FF 
1479   8DF8 FF FF FF FF 
1479   8DFC FF FF FF FF 
1479   8E00 FF FF FF FF 
1479   8E04 FF FF FF FF 
1479   8E08 FF FF FF FF 
1479   8E0C FF FF FF FF 
1479   8E10 FF FF FF FF 
1479   8E14 FF FF FF FF 
1479   8E18 FF FF FF FF 
1479   8E1C FF FF FF FF 
1479   8E20 FF FF FF FF 
1479   8E24 FF FF FF FF 
1479   8E28 FF FF FF FF 
1479   8E2C FF FF FF FF 
1479   8E30 FF FF FF FF 
1479   8E34 FF FF FF FF 
1479   8E38 FF FF FF FF 
1479   8E3C FF FF FF FF 
1479   8E40 FF FF FF FF 
1479   8E44 FF FF FF FF 
1479   8E48 FF FF FF FF 
1479   8E4C FF FF FF FF 
1479   8E50 FF FF FF FF 
1479   8E54 FF FF FF FF 
1479   8E58 FF FF FF FF 
1479   8E5C FF FF FF FF 
1479   8E60 FF FF FF FF 
1479   8E64 FF FF FF FF 
1479   8E68 FF FF FF FF 
1479   8E6C FF FF FF FF 
1479   8E70 FF FF FF FF 
1479   8E74 FF FF FF FF 
1479   8E78 FF FF FF FF 
1479   8E7C FF FF FF FF 
1479   8E80 FF FF FF FF 
1479   8E84 FF FF FF FF 
1479   8E88 FF FF FF FF 
1479   8E8C FF FF FF FF 
1479   8E90 FF FF FF FF 
1479   8E94 FF FF FF FF 
1479   8E98 FF FF FF FF 
1479   8E9C FF FF FF FF 
1479   8EA0 FF FF FF FF 
1479   8EA4 FF FF FF FF 
1479   8EA8 FF FF FF FF 
1479   8EAC FF FF FF FF 
1479   8EB0 FF FF FF FF 
1479   8EB4 FF FF FF FF 
1479   8EB8 FF FF FF FF 
1479   8EBC FF FF FF FF 
1479   8EC0 FF FF FF FF 
1479   8EC4 FF FF FF FF 
1479   8EC8 FF FF FF FF 
1479   8ECC FF FF FF FF 
1479   8ED0 FF FF FF FF 
1479   8ED4 FF FF FF FF 
1479   8ED8 FF FF FF FF 
1479   8EDC FF FF FF FF 
1479   8EE0 FF FF FF FF 
1479   8EE4 FF FF FF FF 
1479   8EE8 FF FF FF FF 
1479   8EEC FF FF FF FF 
1479   8EF0 FF FF FF FF 
1479   8EF4 FF FF FF FF 
1479   8EF8 FF FF FF FF 
1479   8EFC FF FF FF FF 
1479   8F00 FF FF FF FF 
1479   8F04 FF FF FF FF 
1479   8F08 FF FF FF FF 
1479   8F0C FF FF FF FF 
1479   8F10 FF FF FF FF 
1479   8F14 FF FF FF FF 
1479   8F18 FF FF FF FF 
1479   8F1C FF FF FF FF 
1479   8F20 FF FF FF FF 
1479   8F24 FF FF FF FF 
1479   8F28 FF FF FF FF 
1479   8F2C FF FF FF FF 
1479   8F30 FF FF FF FF 
1479   8F34 FF FF FF FF 
1479   8F38 FF FF FF FF 
1479   8F3C FF FF FF FF 
1479   8F40 FF FF FF FF 
1479   8F44 FF FF FF FF 
1479   8F48 FF FF FF FF 
1479   8F4C FF FF FF FF 
1479   8F50 FF FF FF FF 
1479   8F54 FF FF FF FF 
1479   8F58 FF FF FF FF 
1479   8F5C FF FF FF FF 
1479   8F60 FF FF FF FF 
1479   8F64 FF FF FF FF 
1479   8F68 FF FF FF FF 
1479   8F6C FF FF FF FF 
1479   8F70 FF FF FF FF 
1479   8F74 FF FF FF FF 
1479   8F78 FF FF FF FF 
1479   8F7C FF FF FF FF 
1479   8F80 FF FF FF FF 
1479   8F84 FF FF FF FF 
1479   8F88 FF FF FF FF 
1479   8F8C FF FF FF FF 
1479   8F90 FF FF FF FF 
1479   8F94 FF FF FF FF 
1479   8F98 FF FF FF FF 
1479   8F9C FF FF FF FF 
1479   8FA0 FF FF FF FF 
1479   8FA4 FF FF FF FF 
1479   8FA8 FF FF FF FF 
1479   8FAC FF FF FF FF 
1479   8FB0 FF FF FF FF 
1479   8FB4 FF FF FF FF 
1479   8FB8 FF FF FF FF 
1479   8FBC FF FF FF FF 
1479   8FC0 FF FF FF FF 
1479   8FC4 FF FF FF FF 
1479   8FC8 FF FF FF FF 
1479   8FCC FF FF FF FF 
1479   8FD0 FF FF FF FF 
1479   8FD4 FF FF FF FF 
1479   8FD8 FF FF FF FF 
1479   8FDC FF FF FF FF 
1479   8FE0 FF FF FF FF 
1479   8FE4 FF FF FF FF 
1479   8FE8 FF FF FF FF 
1479   8FEC FF FF FF FF 
1479   8FF0 FF FF FF FF 
1479   8FF4 FF FF FF FF 
1479   8FF8 FF FF FF FF 
1479   8FFC FF FF FF FF 
1479   9000 FF FF FF FF 
1479   9004 FF FF FF FF 
1479   9008 FF FF FF FF 
1479   900C FF FF FF FF 
1479   9010 FF FF FF FF 
1479   9014 FF FF FF FF 
1479   9018 FF FF FF FF 
1479   901C FF FF FF FF 
1479   9020 FF FF FF FF 
1479   9024 FF FF FF FF 
1479   9028 FF FF FF FF 
1479   902C FF FF FF FF 
1479   9030 FF FF FF FF 
1479   9034 FF FF FF FF 
1479   9038 FF FF FF FF 
1479   903C FF FF FF FF 
1479   9040 FF FF FF FF 
1479   9044 FF FF FF FF 
1479   9048 FF FF FF FF 
1479   904C FF FF FF FF 
1479   9050 FF FF FF FF 
1479   9054 FF FF FF FF 
1479   9058 FF FF FF FF 
1479   905C FF FF FF FF 
1479   9060 FF FF FF FF 
1479   9064 FF FF FF FF 
1479   9068 FF FF FF FF 
1479   906C FF FF FF FF 
1479   9070 FF FF FF FF 
1479   9074 FF FF FF FF 
1479   9078 FF FF FF FF 
1479   907C FF FF FF FF 
1479   9080 FF FF FF FF 
1479   9084 FF FF FF FF 
1479   9088 FF FF FF FF 
1479   908C FF FF FF FF 
1479   9090 FF FF FF FF 
1479   9094 FF FF FF FF 
1479   9098 FF FF FF FF 
1479   909C FF FF FF FF 
1479   90A0 FF FF FF FF 
1479   90A4 FF FF FF FF 
1479   90A8 FF FF FF FF 
1479   90AC FF FF FF FF 
1479   90B0 FF FF FF FF 
1479   90B4 FF FF FF FF 
1479   90B8 FF FF FF FF 
1479   90BC FF FF FF FF 
1479   90C0 FF FF FF FF 
1479   90C4 FF FF FF FF 
1479   90C8 FF FF FF FF 
1479   90CC FF FF FF FF 
1479   90D0 FF FF FF FF 
1479   90D4 FF FF FF FF 
1479   90D8 FF FF FF FF 
1479   90DC FF FF FF FF 
1479   90E0 FF FF FF FF 
1479   90E4 FF FF FF FF 
1479   90E8 FF FF FF FF 
1479   90EC FF FF FF FF 
1479   90F0 FF FF FF FF 
1479   90F4 FF FF FF FF 
1479   90F8 FF FF FF FF 
1479   90FC FF FF FF FF 
1479   9100 FF FF FF FF 
1479   9104 FF FF FF FF 
1479   9108 FF FF FF FF 
1479   910C FF FF FF FF 
1479   9110 FF FF FF FF 
1479   9114 FF FF FF FF 
1479   9118 FF FF FF FF 
1479   911C FF FF FF FF 
1479   9120 FF FF FF FF 
1479   9124 FF FF FF FF 
1479   9128 FF FF FF FF 
1479   912C FF FF FF FF 
1479   9130 FF FF FF FF 
1479   9134 FF FF FF FF 
1479   9138 FF FF FF FF 
1479   913C FF FF FF FF 
1479   9140 FF FF FF FF 
1479   9144 FF FF FF FF 
1479   9148 FF FF FF FF 
1479   914C FF FF FF FF 
1479   9150 FF FF FF FF 
1479   9154 FF FF FF FF 
1479   9158 FF FF FF FF 
1479   915C FF FF FF FF 
1479   9160 FF FF FF FF 
1479   9164 FF FF FF FF 
1479   9168 FF FF FF FF 
1479   916C FF FF FF FF 
1479   9170 FF FF FF FF 
1479   9174 FF FF FF FF 
1479   9178 FF FF FF FF 
1479   917C FF FF FF FF 
1479   9180 FF FF FF FF 
1479   9184 FF FF FF FF 
1479   9188 FF FF FF FF 
1479   918C FF FF FF FF 
1479   9190 FF FF FF FF 
1479   9194 FF FF FF FF 
1479   9198 FF FF FF FF 
1479   919C FF FF FF FF 
1479   91A0 FF FF FF FF 
1479   91A4 FF FF FF FF 
1479   91A8 FF FF FF FF 
1479   91AC FF FF FF FF 
1479   91B0 FF FF FF FF 
1479   91B4 FF FF FF FF 
1479   91B8 FF FF FF FF 
1479   91BC FF FF FF FF 
1479   91C0 FF FF FF FF 
1479   91C4 FF FF FF FF 
1479   91C8 FF FF FF FF 
1479   91CC FF FF FF FF 
1479   91D0 FF FF FF FF 
1479   91D4 FF FF FF FF 
1479   91D8 FF FF FF FF 
1479   91DC FF FF FF FF 
1479   91E0 FF FF FF FF 
1479   91E4 FF FF FF FF 
1479   91E8 FF FF FF FF 
1479   91EC FF FF FF FF 
1479   91F0 FF FF FF FF 
1479   91F4 FF FF FF FF 
1479   91F8 FF FF FF FF 
1479   91FC FF FF FF FF 
1479   9200 FF FF FF FF 
1479   9204 FF FF FF FF 
1479   9208 FF FF FF FF 
1479   920C FF FF FF FF 
1479   9210 FF FF FF FF 
1479   9214 FF FF FF FF 
1479   9218 FF FF FF FF 
1479   921C FF FF FF FF 
1479   9220 FF FF FF FF 
1479   9224 FF FF FF FF 
1479   9228 FF FF FF FF 
1479   922C FF FF FF FF 
1479   9230 FF FF FF FF 
1479   9234 FF FF FF FF 
1479   9238 FF FF FF FF 
1479   923C FF FF FF FF 
1479   9240 FF FF FF FF 
1479   9244 FF FF FF FF 
1479   9248 FF FF FF FF 
1479   924C FF FF FF FF 
1479   9250 FF FF FF FF 
1479   9254 FF FF FF FF 
1479   9258 FF FF FF FF 
1479   925C FF FF FF FF 
1479   9260 FF FF FF FF 
1479   9264 FF FF FF FF 
1479   9268 FF FF FF FF 
1479   926C FF FF FF FF 
1479   9270 FF FF FF FF 
1479   9274 FF FF FF FF 
1479   9278 FF FF FF FF 
1479   927C FF FF FF FF 
1479   9280 FF FF FF FF 
1479   9284 FF FF FF FF 
1479   9288 FF FF FF FF 
1479   928C FF FF FF FF 
1479   9290 FF FF FF FF 
1479   9294 FF FF FF FF 
1479   9298 FF FF FF FF 
1479   929C FF FF FF FF 
1479   92A0 FF FF FF FF 
1479   92A4 FF FF FF FF 
1479   92A8 FF FF FF FF 
1479   92AC FF FF FF FF 
1479   92B0 FF FF FF FF 
1479   92B4 FF FF FF FF 
1479   92B8 FF FF FF FF 
1479   92BC FF FF FF FF 
1479   92C0 FF FF FF FF 
1479   92C4 FF FF FF FF 
1479   92C8 FF FF FF FF 
1479   92CC FF FF FF FF 
1479   92D0 FF FF FF FF 
1479   92D4 FF FF FF FF 
1479   92D8 FF FF FF FF 
1479   92DC FF FF FF FF 
1479   92E0 FF FF FF FF 
1479   92E4 FF FF FF FF 
1479   92E8 FF FF FF FF 
1479   92EC FF FF FF FF 
1479   92F0 FF FF FF FF 
1479   92F4 FF FF FF FF 
1479   92F8 FF FF FF FF 
1479   92FC FF FF FF FF 
1479   9300 FF FF FF FF 
1479   9304 FF FF FF FF 
1479   9308 FF FF FF FF 
1479   930C FF FF FF FF 
1479   9310 FF FF FF FF 
1479   9314 FF FF FF FF 
1479   9318 FF FF FF FF 
1479   931C FF FF FF FF 
1479   9320 FF FF FF FF 
1479   9324 FF FF FF FF 
1479   9328 FF FF FF FF 
1479   932C FF FF FF FF 
1479   9330 FF FF FF FF 
1479   9334 FF FF FF FF 
1479   9338 FF FF FF FF 
1479   933C FF FF FF FF 
1479   9340 FF FF FF FF 
1479   9344 FF FF FF FF 
1479   9348 FF FF FF FF 
1479   934C FF FF FF FF 
1479   9350 FF FF FF FF 
1479   9354 FF FF FF FF 
1479   9358 FF FF FF FF 
1479   935C FF FF FF FF 
1479   9360 FF FF FF FF 
1479   9364 FF FF FF FF 
1479   9368 FF FF FF FF 
1479   936C FF FF FF FF 
1479   9370 FF FF FF FF 
1479   9374 FF FF FF FF 
1479   9378 FF FF FF FF 
1479   937C FF FF FF FF 
1479   9380 FF FF FF FF 
1479   9384 FF FF FF FF 
1479   9388 FF FF FF FF 
1479   938C FF FF FF FF 
1479   9390 FF FF FF FF 
1479   9394 FF FF FF FF 
1479   9398 FF FF FF FF 
1479   939C FF FF FF FF 
1479   93A0 FF FF FF FF 
1479   93A4 FF FF FF FF 
1479   93A8 FF FF FF FF 
1479   93AC FF FF FF FF 
1479   93B0 FF FF FF FF 
1479   93B4 FF FF FF FF 
1479   93B8 FF FF FF FF 
1479   93BC FF FF FF FF 
1479   93C0 FF FF FF FF 
1479   93C4 FF FF FF FF 
1479   93C8 FF FF FF FF 
1479   93CC FF FF FF FF 
1479   93D0 FF FF FF FF 
1479   93D4 FF FF FF FF 
1479   93D8 FF FF FF FF 
1479   93DC FF FF FF FF 
1479   93E0 FF FF FF FF 
1479   93E4 FF FF FF FF 
1479   93E8 FF FF FF FF 
1479   93EC FF FF FF FF 
1479   93F0 FF FF FF FF 
1479   93F4 FF FF FF FF 
1479   93F8 FF FF FF FF 
1479   93FC FF FF FF FF 
1479   9400 FF FF FF FF 
1479   9404 FF FF FF FF 
1479   9408 FF FF FF FF 
1479   940C FF FF FF FF 
1479   9410 FF FF FF FF 
1479   9414 FF FF FF FF 
1479   9418 FF FF FF FF 
1479   941C FF FF FF FF 
1479   9420 FF FF FF FF 
1479   9424 FF FF FF FF 
1479   9428 FF FF FF FF 
1479   942C FF FF FF FF 
1479   9430 FF FF FF FF 
1479   9434 FF FF FF FF 
1479   9438 FF FF FF FF 
1479   943C FF FF FF FF 
1479   9440 FF FF FF FF 
1479   9444 FF FF FF FF 
1479   9448 FF FF FF FF 
1479   944C FF FF FF FF 
1479   9450 FF FF FF FF 
1479   9454 FF FF FF FF 
1479   9458 FF FF FF FF 
1479   945C FF FF FF FF 
1479   9460 FF FF FF FF 
1479   9464 FF FF FF FF 
1479   9468 FF FF FF FF 
1479   946C FF FF FF FF 
1479   9470 FF FF FF FF 
1479   9474 FF FF FF FF 
1479   9478 FF FF FF FF 
1479   947C FF FF FF FF 
1479   9480 FF FF FF FF 
1479   9484 FF FF FF FF 
1479   9488 FF FF FF FF 
1479   948C FF FF FF FF 
1479   9490 FF FF FF FF 
1479   9494 FF FF FF FF 
1479   9498 FF FF FF FF 
1479   949C FF FF FF FF 
1479   94A0 FF FF FF FF 
1479   94A4 FF FF FF FF 
1479   94A8 FF FF FF FF 
1479   94AC FF FF FF FF 
1479   94B0 FF FF FF FF 
1479   94B4 FF FF FF FF 
1479   94B8 FF FF FF FF 
1479   94BC FF FF FF FF 
1479   94C0 FF FF FF FF 
1479   94C4 FF FF FF FF 
1479   94C8 FF FF FF FF 
1479   94CC FF FF FF FF 
1479   94D0 FF FF FF FF 
1479   94D4 FF FF FF FF 
1479   94D8 FF FF FF FF 
1479   94DC FF FF FF FF 
1479   94E0 FF FF FF FF 
1479   94E4 FF FF FF FF 
1479   94E8 FF FF FF FF 
1479   94EC FF FF FF FF 
1479   94F0 FF FF FF FF 
1479   94F4 FF FF FF FF 
1479   94F8 FF FF FF FF 
1479   94FC FF FF FF FF 
1479   9500 FF FF FF FF 
1479   9504 FF FF FF FF 
1479   9508 FF FF FF FF 
1479   950C FF FF FF FF 
1479   9510 FF FF FF FF 
1479   9514 FF FF FF FF 
1479   9518 FF FF FF FF 
1479   951C FF FF FF FF 
1479   9520 FF FF FF FF 
1479   9524 FF FF FF FF 
1479   9528 FF FF FF FF 
1479   952C FF FF FF FF 
1479   9530 FF FF FF FF 
1479   9534 FF FF FF FF 
1479   9538 FF FF FF FF 
1479   953C FF FF FF FF 
1479   9540 FF FF FF FF 
1479   9544 FF FF FF FF 
1479   9548 FF FF FF FF 
1479   954C FF FF FF FF 
1479   9550 FF FF FF FF 
1479   9554 FF FF FF FF 
1479   9558 FF FF FF FF 
1479   955C FF FF FF FF 
1479   9560 FF FF FF FF 
1479   9564 FF FF FF FF 
1479   9568 FF FF FF FF 
1479   956C FF FF FF FF 
1479   9570 FF FF FF FF 
1479   9574 FF FF FF FF 
1479   9578 FF FF FF FF 
1479   957C FF FF FF FF 
1479   9580 FF FF FF FF 
1479   9584 FF FF FF FF 
1479   9588 FF FF FF FF 
1479   958C FF FF FF FF 
1479   9590 FF FF FF FF 
1479   9594 FF FF FF FF 
1479   9598 FF FF FF FF 
1479   959C FF FF FF FF 
1479   95A0 FF FF FF FF 
1479   95A4 FF FF FF FF 
1479   95A8 FF FF FF FF 
1479   95AC FF FF FF FF 
1479   95B0 FF FF FF FF 
1479   95B4 FF FF FF FF 
1479   95B8 FF FF FF FF 
1479   95BC FF FF FF FF 
1479   95C0 FF FF FF FF 
1479   95C4 FF FF FF FF 
1479   95C8 FF FF FF FF 
1479   95CC FF FF FF FF 
1479   95D0 FF FF FF FF 
1479   95D4 FF FF FF FF 
1479   95D8 FF FF FF FF 
1479   95DC FF FF FF FF 
1479   95E0 FF FF FF FF 
1479   95E4 FF FF FF FF 
1479   95E8 FF FF FF FF 
1479   95EC FF FF FF FF 
1479   95F0 FF FF FF FF 
1479   95F4 FF FF FF FF 
1479   95F8 FF FF FF FF 
1479   95FC FF FF FF FF 
1479   9600 FF FF FF FF 
1479   9604 FF FF FF FF 
1479   9608 FF FF FF FF 
1479   960C FF FF FF FF 
1479   9610 FF FF FF FF 
1479   9614 FF FF FF FF 
1479   9618 FF FF FF FF 
1479   961C FF FF FF FF 
1479   9620 FF FF FF FF 
1479   9624 FF FF FF FF 
1479   9628 FF FF FF FF 
1479   962C FF FF FF FF 
1479   9630 FF FF FF FF 
1479   9634 FF FF FF FF 
1479   9638 FF FF FF FF 
1479   963C FF FF FF FF 
1479   9640 FF FF FF FF 
1479   9644 FF FF FF FF 
1479   9648 FF FF FF FF 
1479   964C FF FF FF FF 
1479   9650 FF FF FF FF 
1479   9654 FF FF FF FF 
1479   9658 FF FF FF FF 
1479   965C FF FF FF FF 
1479   9660 FF FF FF FF 
1479   9664 FF FF FF FF 
1479   9668 FF FF FF FF 
1479   966C FF FF FF FF 
1479   9670 FF FF FF FF 
1479   9674 FF FF FF FF 
1479   9678 FF FF FF FF 
1479   967C FF FF FF FF 
1479   9680 FF FF FF FF 
1479   9684 FF FF FF FF 
1479   9688 FF FF FF FF 
1479   968C FF FF FF FF 
1479   9690 FF FF FF FF 
1479   9694 FF FF FF FF 
1479   9698 FF FF FF FF 
1479   969C FF FF FF FF 
1479   96A0 FF FF FF FF 
1479   96A4 FF FF FF FF 
1479   96A8 FF FF FF FF 
1479   96AC FF FF FF FF 
1479   96B0 FF FF FF FF 
1479   96B4 FF FF FF FF 
1479   96B8 FF FF FF FF 
1479   96BC FF FF FF FF 
1479   96C0 FF FF FF FF 
1479   96C4 FF FF FF FF 
1479   96C8 FF FF FF FF 
1479   96CC FF FF FF FF 
1479   96D0 FF FF FF FF 
1479   96D4 FF FF FF FF 
1479   96D8 FF FF FF FF 
1479   96DC FF FF FF FF 
1479   96E0 FF FF FF FF 
1479   96E4 FF FF FF FF 
1479   96E8 FF FF FF FF 
1479   96EC FF FF FF FF 
1479   96F0 FF FF FF FF 
1479   96F4 FF FF FF FF 
1479   96F8 FF FF FF FF 
1479   96FC FF FF FF FF 
1479   9700 FF FF FF FF 
1479   9704 FF FF FF FF 
1479   9708 FF FF FF FF 
1479   970C FF FF FF FF 
1479   9710 FF FF FF FF 
1479   9714 FF FF FF FF 
1479   9718 FF FF FF FF 
1479   971C FF FF FF FF 
1479   9720 FF FF FF FF 
1479   9724 FF FF FF FF 
1479   9728 FF FF FF FF 
1479   972C FF FF FF FF 
1479   9730 FF FF FF FF 
1479   9734 FF FF FF FF 
1479   9738 FF FF FF FF 
1479   973C FF FF FF FF 
1479   9740 FF FF FF FF 
1479   9744 FF FF FF FF 
1479   9748 FF FF FF FF 
1479   974C FF FF FF FF 
1479   9750 FF FF FF FF 
1479   9754 FF FF FF FF 
1479   9758 FF FF FF FF 
1479   975C FF FF FF FF 
1479   9760 FF FF FF FF 
1479   9764 FF FF FF FF 
1479   9768 FF FF FF FF 
1479   976C FF FF FF FF 
1479   9770 FF FF FF FF 
1479   9774 FF FF FF FF 
1479   9778 FF FF FF FF 
1479   977C FF FF FF FF 
1479   9780 FF FF FF FF 
1479   9784 FF FF FF FF 
1479   9788 FF FF FF FF 
1479   978C FF FF FF FF 
1479   9790 FF FF FF FF 
1479   9794 FF FF FF FF 
1479   9798 FF FF FF FF 
1479   979C FF FF FF FF 
1479   97A0 FF FF FF FF 
1479   97A4 FF FF FF FF 
1479   97A8 FF FF FF FF 
1479   97AC FF FF FF FF 
1479   97B0 FF FF FF FF 
1479   97B4 FF FF FF FF 
1479   97B8 FF FF FF FF 
1479   97BC FF FF FF FF 
1479   97C0 FF FF FF FF 
1479   97C4 FF FF FF FF 
1479   97C8 FF FF FF FF 
1479   97CC FF FF FF FF 
1479   97D0 FF FF FF FF 
1479   97D4 FF FF FF FF 
1479   97D8 FF FF FF FF 
1479   97DC FF FF FF FF 
1479   97E0 FF FF FF FF 
1479   97E4 FF FF FF FF 
1479   97E8 FF FF FF FF 
1479   97EC FF FF FF FF 
1479   97F0 FF FF FF FF 
1479   97F4 FF FF FF FF 
1479   97F8 FF FF FF FF 
1479   97FC FF FF FF FF 
1479   9800 FF FF FF FF 
1479   9804 FF FF FF FF 
1479   9808 FF FF FF FF 
1479   980C FF FF FF FF 
1479   9810 FF FF FF FF 
1479   9814 FF FF FF FF 
1479   9818 FF FF FF FF 
1479   981C FF FF FF FF 
1479   9820 FF FF FF FF 
1479   9824 FF FF FF FF 
1479   9828 FF FF FF FF 
1479   982C FF FF FF FF 
1479   9830 FF FF FF FF 
1479   9834 FF FF FF FF 
1479   9838 FF FF FF FF 
1479   983C FF FF FF FF 
1479   9840 FF FF FF FF 
1479   9844 FF FF FF FF 
1479   9848 FF FF FF FF 
1479   984C FF FF FF FF 
1479   9850 FF FF FF FF 
1479   9854 FF FF FF FF 
1479   9858 FF FF FF FF 
1479   985C FF FF FF FF 
1479   9860 FF FF FF FF 
1479   9864 FF FF FF FF 
1479   9868 FF FF FF FF 
1479   986C FF FF FF FF 
1479   9870 FF FF FF FF 
1479   9874 FF FF FF FF 
1479   9878 FF FF FF FF 
1479   987C FF FF FF FF 
1479   9880 FF FF FF FF 
1479   9884 FF FF FF FF 
1479   9888 FF FF FF FF 
1479   988C FF FF FF FF 
1479   9890 FF FF FF FF 
1479   9894 FF FF FF FF 
1479   9898 FF FF FF FF 
1479   989C FF FF FF FF 
1479   98A0 FF FF FF FF 
1479   98A4 FF FF FF FF 
1479   98A8 FF FF FF FF 
1479   98AC FF FF FF FF 
1479   98B0 FF FF FF FF 
1479   98B4 FF FF FF FF 
1479   98B8 FF FF FF FF 
1479   98BC FF FF FF FF 
1479   98C0 FF FF FF FF 
1479   98C4 FF FF FF FF 
1479   98C8 FF FF FF FF 
1479   98CC FF FF FF FF 
1479   98D0 FF FF FF FF 
1479   98D4 FF FF FF FF 
1479   98D8 FF FF FF FF 
1479   98DC FF FF FF FF 
1479   98E0 FF FF FF FF 
1479   98E4 FF FF FF FF 
1479   98E8 FF FF FF FF 
1479   98EC FF FF FF FF 
1479   98F0 FF FF FF FF 
1479   98F4 FF FF FF FF 
1479   98F8 FF FF FF FF 
1479   98FC FF FF FF FF 
1479   9900 FF FF FF FF 
1479   9904 FF FF FF FF 
1479   9908 FF FF FF FF 
1479   990C FF FF FF FF 
1479   9910 FF FF FF FF 
1479   9914 FF FF FF FF 
1479   9918 FF FF FF FF 
1479   991C FF FF FF FF 
1479   9920 FF FF FF FF 
1479   9924 FF FF FF FF 
1479   9928 FF FF FF FF 
1479   992C FF FF FF FF 
1479   9930 FF FF FF FF 
1479   9934 FF FF FF FF 
1479   9938 FF FF FF FF 
1479   993C FF FF FF FF 
1479   9940 FF FF FF FF 
1479   9944 FF FF FF FF 
1479   9948 FF FF FF FF 
1479   994C FF FF FF FF 
1479   9950 FF FF FF FF 
1479   9954 FF FF FF FF 
1479   9958 FF FF FF FF 
1479   995C FF FF FF FF 
1479   9960 FF FF FF FF 
1479   9964 FF FF FF FF 
1479   9968 FF FF FF FF 
1479   996C FF FF FF FF 
1479   9970 FF FF FF FF 
1479   9974 FF FF FF FF 
1479   9978 FF FF FF FF 
1479   997C FF FF FF FF 
1479   9980 FF FF FF FF 
1479   9984 FF FF FF FF 
1479   9988 FF FF FF FF 
1479   998C FF FF FF FF 
1479   9990 FF FF FF FF 
1479   9994 FF FF FF FF 
1479   9998 FF FF FF FF 
1479   999C FF FF FF FF 
1479   99A0 FF FF FF FF 
1479   99A4 FF FF FF FF 
1479   99A8 FF FF FF FF 
1479   99AC FF FF FF FF 
1479   99B0 FF FF FF FF 
1479   99B4 FF FF FF FF 
1479   99B8 FF FF FF FF 
1479   99BC FF FF FF FF 
1479   99C0 FF FF FF FF 
1479   99C4 FF FF FF FF 
1479   99C8 FF FF FF FF 
1479   99CC FF FF FF FF 
1479   99D0 FF FF FF FF 
1479   99D4 FF FF FF FF 
1479   99D8 FF FF FF FF 
1479   99DC FF FF FF FF 
1479   99E0 FF FF FF FF 
1479   99E4 FF FF FF FF 
1479   99E8 FF FF FF FF 
1479   99EC FF FF FF FF 
1479   99F0 FF FF FF FF 
1479   99F4 FF FF FF FF 
1479   99F8 FF FF FF FF 
1479   99FC FF FF FF FF 
1479   9A00 FF FF FF FF 
1479   9A04 FF FF FF FF 
1479   9A08 FF FF FF FF 
1479   9A0C FF FF FF FF 
1479   9A10 FF FF FF FF 
1479   9A14 FF FF FF FF 
1479   9A18 FF FF FF FF 
1479   9A1C FF FF FF FF 
1479   9A20 FF FF FF FF 
1479   9A24 FF FF FF FF 
1479   9A28 FF FF FF FF 
1479   9A2C FF FF FF FF 
1479   9A30 FF FF FF FF 
1479   9A34 FF FF FF FF 
1479   9A38 FF FF FF FF 
1479   9A3C FF FF FF FF 
1479   9A40 FF FF FF FF 
1479   9A44 FF FF FF FF 
1479   9A48 FF FF FF FF 
1479   9A4C FF FF FF FF 
1479   9A50 FF FF FF FF 
1479   9A54 FF FF FF FF 
1479   9A58 FF FF FF FF 
1479   9A5C FF FF FF FF 
1479   9A60 FF FF FF FF 
1479   9A64 FF FF FF FF 
1479   9A68 FF FF FF FF 
1479   9A6C FF FF FF FF 
1479   9A70 FF FF FF FF 
1479   9A74 FF FF FF FF 
1479   9A78 FF FF FF FF 
1479   9A7C FF FF FF FF 
1479   9A80 FF FF FF FF 
1479   9A84 FF FF FF FF 
1479   9A88 FF FF FF FF 
1479   9A8C FF FF FF FF 
1479   9A90 FF FF FF FF 
1479   9A94 FF FF FF FF 
1479   9A98 FF FF FF FF 
1479   9A9C FF FF FF FF 
1479   9AA0 FF FF FF FF 
1479   9AA4 FF FF FF FF 
1479   9AA8 FF FF FF FF 
1479   9AAC FF FF FF FF 
1479   9AB0 FF FF FF FF 
1479   9AB4 FF FF FF FF 
1479   9AB8 FF FF FF FF 
1479   9ABC FF FF FF FF 
1479   9AC0 FF FF FF FF 
1479   9AC4 FF FF FF FF 
1479   9AC8 FF FF FF FF 
1479   9ACC FF FF FF FF 
1479   9AD0 FF FF FF FF 
1479   9AD4 FF FF FF FF 
1479   9AD8 FF FF FF FF 
1479   9ADC FF FF FF FF 
1479   9AE0 FF FF FF FF 
1479   9AE4 FF FF FF FF 
1479   9AE8 FF FF FF FF 
1479   9AEC FF FF FF FF 
1479   9AF0 FF FF FF FF 
1479   9AF4 FF FF FF FF 
1479   9AF8 FF FF FF FF 
1479   9AFC FF FF FF FF 
1479   9B00 FF FF FF FF 
1479   9B04 FF FF FF FF 
1479   9B08 FF FF FF FF 
1479   9B0C FF FF FF FF 
1479   9B10 FF FF FF FF 
1479   9B14 FF FF FF FF 
1479   9B18 FF FF FF FF 
1479   9B1C FF FF FF FF 
1479   9B20 FF FF FF FF 
1479   9B24 FF FF FF FF 
1479   9B28 FF FF FF FF 
1479   9B2C FF FF FF FF 
1479   9B30 FF FF FF FF 
1479   9B34 FF FF FF FF 
1479   9B38 FF FF FF FF 
1479   9B3C FF FF FF FF 
1479   9B40 FF FF FF FF 
1479   9B44 FF FF FF FF 
1479   9B48 FF FF FF FF 
1479   9B4C FF FF FF FF 
1479   9B50 FF FF FF FF 
1479   9B54 FF FF FF FF 
1479   9B58 FF FF FF FF 
1479   9B5C FF FF FF FF 
1479   9B60 FF FF FF FF 
1479   9B64 FF FF FF FF 
1479   9B68 FF FF FF FF 
1479   9B6C FF FF FF FF 
1479   9B70 FF FF FF FF 
1479   9B74 FF FF FF FF 
1479   9B78 FF FF FF FF 
1479   9B7C FF FF FF FF 
1479   9B80 FF FF FF FF 
1479   9B84 FF FF FF FF 
1479   9B88 FF FF FF FF 
1479   9B8C FF FF FF FF 
1479   9B90 FF FF FF FF 
1479   9B94 FF FF FF FF 
1479   9B98 FF FF FF FF 
1479   9B9C FF FF FF FF 
1479   9BA0 FF FF FF FF 
1479   9BA4 FF FF FF FF 
1479   9BA8 FF FF FF FF 
1479   9BAC FF FF FF FF 
1479   9BB0 FF FF FF FF 
1479   9BB4 FF FF FF FF 
1479   9BB8 FF FF FF FF 
1479   9BBC FF FF FF FF 
1479   9BC0 FF FF FF FF 
1479   9BC4 FF FF FF FF 
1479   9BC8 FF FF FF FF 
1479   9BCC FF FF FF FF 
1479   9BD0 FF FF FF FF 
1479   9BD4 FF FF FF FF 
1479   9BD8 FF FF FF FF 
1479   9BDC FF FF FF FF 
1479   9BE0 FF FF FF FF 
1479   9BE4 FF FF FF FF 
1479   9BE8 FF FF FF FF 
1479   9BEC FF FF FF FF 
1479   9BF0 FF FF FF FF 
1479   9BF4 FF FF FF FF 
1479   9BF8 FF FF FF FF 
1479   9BFC FF FF FF FF 
1479   9C00 FF FF FF FF 
1479   9C04 FF FF FF FF 
1479   9C08 FF FF FF FF 
1479   9C0C FF FF FF FF 
1479   9C10 FF FF FF FF 
1479   9C14 FF FF FF FF 
1479   9C18 FF FF FF FF 
1479   9C1C FF FF FF FF 
1479   9C20 FF FF FF FF 
1479   9C24 FF FF FF FF 
1479   9C28 FF FF FF FF 
1479   9C2C FF FF FF FF 
1479   9C30 FF FF FF FF 
1479   9C34 FF FF FF FF 
1479   9C38 FF FF FF FF 
1479   9C3C FF FF FF FF 
1479   9C40 FF FF FF FF 
1479   9C44 FF FF FF FF 
1479   9C48 FF FF FF FF 
1479   9C4C FF FF FF FF 
1479   9C50 FF FF FF FF 
1479   9C54 FF FF FF FF 
1479   9C58 FF FF FF FF 
1479   9C5C FF FF FF FF 
1479   9C60 FF FF FF FF 
1479   9C64 FF FF FF FF 
1479   9C68 FF FF FF FF 
1479   9C6C FF FF FF FF 
1479   9C70 FF FF FF FF 
1479   9C74 FF FF FF FF 
1479   9C78 FF FF FF FF 
1479   9C7C FF FF FF FF 
1479   9C80 FF FF FF FF 
1479   9C84 FF FF FF FF 
1479   9C88 FF FF FF FF 
1479   9C8C FF FF FF FF 
1479   9C90 FF FF FF FF 
1479   9C94 FF FF FF FF 
1479   9C98 FF FF FF FF 
1479   9C9C FF FF FF FF 
1479   9CA0 FF FF FF FF 
1479   9CA4 FF FF FF FF 
1479   9CA8 FF FF FF FF 
1479   9CAC FF FF FF FF 
1479   9CB0 FF FF FF FF 
1479   9CB4 FF FF FF FF 
1479   9CB8 FF FF FF FF 
1479   9CBC FF FF FF FF 
1479   9CC0 FF FF FF FF 
1479   9CC4 FF FF FF FF 
1479   9CC8 FF FF FF FF 
1479   9CCC FF FF FF FF 
1479   9CD0 FF FF FF FF 
1479   9CD4 FF FF FF FF 
1479   9CD8 FF FF FF FF 
1479   9CDC FF FF FF FF 
1479   9CE0 FF FF FF FF 
1479   9CE4 FF FF FF FF 
1479   9CE8 FF FF FF FF 
1479   9CEC FF FF FF FF 
1479   9CF0 FF FF FF FF 
1479   9CF4 FF FF FF FF 
1479   9CF8 FF FF FF FF 
1479   9CFC FF FF FF FF 
1479   9D00 FF FF FF FF 
1479   9D04 FF FF FF FF 
1479   9D08 FF FF FF FF 
1479   9D0C FF FF FF FF 
1479   9D10 FF FF FF FF 
1479   9D14 FF FF FF FF 
1479   9D18 FF FF FF FF 
1479   9D1C FF FF FF FF 
1479   9D20 FF FF FF FF 
1479   9D24 FF FF FF FF 
1479   9D28 FF FF FF FF 
1479   9D2C FF FF FF FF 
1479   9D30 FF FF FF FF 
1479   9D34 FF FF FF FF 
1479   9D38 FF FF FF FF 
1479   9D3C FF FF FF FF 
1479   9D40 FF FF FF FF 
1479   9D44 FF FF FF FF 
1479   9D48 FF FF FF FF 
1479   9D4C FF FF FF FF 
1479   9D50 FF FF FF FF 
1479   9D54 FF FF FF FF 
1479   9D58 FF FF FF FF 
1479   9D5C FF FF FF FF 
1479   9D60 FF FF FF FF 
1479   9D64 FF FF FF FF 
1479   9D68 FF FF FF FF 
1479   9D6C FF FF FF FF 
1479   9D70 FF FF FF FF 
1479   9D74 FF FF FF FF 
1479   9D78 FF FF FF FF 
1479   9D7C FF FF FF FF 
1479   9D80 FF FF FF FF 
1479   9D84 FF FF FF FF 
1479   9D88 FF FF FF FF 
1479   9D8C FF FF FF FF 
1479   9D90 FF FF FF FF 
1479   9D94 FF FF FF FF 
1479   9D98 FF FF FF FF 
1479   9D9C FF FF FF FF 
1479   9DA0 FF FF FF FF 
1479   9DA4 FF FF FF FF 
1479   9DA8 FF FF FF FF 
1479   9DAC FF FF FF FF 
1479   9DB0 FF FF FF FF 
1479   9DB4 FF FF FF FF 
1479   9DB8 FF FF FF FF 
1479   9DBC FF FF FF FF 
1479   9DC0 FF FF FF FF 
1479   9DC4 FF FF FF FF 
1479   9DC8 FF FF FF FF 
1479   9DCC FF FF FF FF 
1479   9DD0 FF FF FF FF 
1479   9DD4 FF FF FF FF 
1479   9DD8 FF FF FF FF 
1479   9DDC FF FF FF FF 
1479   9DE0 FF FF FF FF 
1479   9DE4 FF FF FF FF 
1479   9DE8 FF FF FF FF 
1479   9DEC FF FF FF FF 
1479   9DF0 FF FF FF FF 
1479   9DF4 FF FF FF FF 
1479   9DF8 FF FF FF FF 
1479   9DFC FF FF FF FF 
1479   9E00 FF FF FF FF 
1479   9E04 FF FF FF FF 
1479   9E08 FF FF FF FF 
1479   9E0C FF FF FF FF 
1479   9E10 FF FF FF FF 
1479   9E14 FF FF FF FF 
1479   9E18 FF FF FF FF 
1479   9E1C FF FF FF FF 
1479   9E20 FF FF FF FF 
1479   9E24 FF FF FF FF 
1479   9E28 FF FF FF FF 
1479   9E2C FF FF FF FF 
1479   9E30 FF FF FF FF 
1479   9E34 FF FF FF FF 
1479   9E38 FF FF FF FF 
1479   9E3C FF FF FF FF 
1479   9E40 FF FF FF FF 
1479   9E44 FF FF FF FF 
1479   9E48 FF FF FF FF 
1479   9E4C FF FF FF FF 
1479   9E50 FF FF FF FF 
1479   9E54 FF FF FF FF 
1479   9E58 FF FF FF FF 
1479   9E5C FF FF FF FF 
1479   9E60 FF FF FF FF 
1479   9E64 FF FF FF FF 
1479   9E68 FF FF FF FF 
1479   9E6C FF FF FF FF 
1479   9E70 FF FF FF FF 
1479   9E74 FF FF FF FF 
1479   9E78 FF FF FF FF 
1479   9E7C FF FF FF FF 
1479   9E80 FF FF FF FF 
1479   9E84 FF FF FF FF 
1479   9E88 FF FF FF FF 
1479   9E8C FF FF FF FF 
1479   9E90 FF FF FF FF 
1479   9E94 FF FF FF FF 
1479   9E98 FF FF FF FF 
1479   9E9C FF FF FF FF 
1479   9EA0 FF FF FF FF 
1479   9EA4 FF FF FF FF 
1479   9EA8 FF FF FF FF 
1479   9EAC FF FF FF FF 
1479   9EB0 FF FF FF FF 
1479   9EB4 FF FF FF FF 
1479   9EB8 FF FF FF FF 
1479   9EBC FF FF FF FF 
1479   9EC0 FF FF FF FF 
1479   9EC4 FF FF FF FF 
1479   9EC8 FF FF FF FF 
1479   9ECC FF FF FF FF 
1479   9ED0 FF FF FF FF 
1479   9ED4 FF FF FF FF 
1479   9ED8 FF FF FF FF 
1479   9EDC FF FF FF FF 
1479   9EE0 FF FF FF FF 
1479   9EE4 FF FF FF FF 
1479   9EE8 FF FF FF FF 
1479   9EEC FF FF FF FF 
1479   9EF0 FF FF FF FF 
1479   9EF4 FF FF FF FF 
1479   9EF8 FF FF FF FF 
1479   9EFC FF FF FF FF 
1479   9F00 FF FF FF FF 
1479   9F04 FF FF FF FF 
1479   9F08 FF FF FF FF 
1479   9F0C FF FF FF FF 
1479   9F10 FF FF FF FF 
1479   9F14 FF FF FF FF 
1479   9F18 FF FF FF FF 
1479   9F1C FF FF FF FF 
1479   9F20 FF FF FF FF 
1479   9F24 FF FF FF FF 
1479   9F28 FF FF FF FF 
1479   9F2C FF FF FF FF 
1479   9F30 FF FF FF FF 
1479   9F34 FF FF FF FF 
1479   9F38 FF FF FF FF 
1479   9F3C FF FF FF FF 
1479   9F40 FF FF FF FF 
1479   9F44 FF FF FF FF 
1479   9F48 FF FF FF FF 
1479   9F4C FF FF FF FF 
1479   9F50 FF FF FF FF 
1479   9F54 FF FF FF FF 
1479   9F58 FF FF FF FF 
1479   9F5C FF FF FF FF 
1479   9F60 FF FF FF FF 
1479   9F64 FF FF FF FF 
1479   9F68 FF FF FF FF 
1479   9F6C FF FF FF FF 
1479   9F70 FF FF FF FF 
1479   9F74 FF FF FF FF 
1479   9F78 FF FF FF FF 
1479   9F7C FF FF FF FF 
1479   9F80 FF FF FF FF 
1479   9F84 FF FF FF FF 
1479   9F88 FF FF FF FF 
1479   9F8C FF FF FF FF 
1479   9F90 FF FF FF FF 
1479   9F94 FF FF FF FF 
1479   9F98 FF FF FF FF 
1479   9F9C FF FF FF FF 
1479   9FA0 FF FF FF FF 
1479   9FA4 FF FF FF FF 
1479   9FA8 FF FF FF FF 
1479   9FAC FF FF FF FF 
1479   9FB0 FF FF FF FF 
1479   9FB4 FF FF FF FF 
1479   9FB8 FF FF FF FF 
1479   9FBC FF FF FF FF 
1479   9FC0 FF FF FF FF 
1479   9FC4 FF FF FF FF 
1479   9FC8 FF FF FF FF 
1479   9FCC FF FF FF FF 
1479   9FD0 FF FF FF FF 
1479   9FD4 FF FF FF FF 
1479   9FD8 FF FF FF FF 
1479   9FDC FF FF FF FF 
1479   9FE0 FF FF FF FF 
1479   9FE4 FF FF FF FF 
1479   9FE8 FF FF FF FF 
1479   9FEC FF FF FF FF 
1479   9FF0 FF FF FF FF 
1479   9FF4 FF FF FF FF 
1479   9FF8 FF FF FF FF 
1479   9FFC FF FF FF FF 
1479   A000 FF FF FF FF 
1479   A004 FF FF FF FF 
1479   A008 FF FF FF FF 
1479   A00C FF FF FF FF 
1479   A010 FF FF FF FF 
1479   A014 FF FF FF FF 
1479   A018 FF FF FF FF 
1479   A01C FF FF FF FF 
1479   A020 FF FF FF FF 
1479   A024 FF FF FF FF 
1479   A028 FF FF FF FF 
1479   A02C FF FF FF FF 
1479   A030 FF FF FF FF 
1479   A034 FF FF FF FF 
1479   A038 FF FF FF FF 
1479   A03C FF FF FF FF 
1479   A040 FF FF FF FF 
1479   A044 FF FF FF FF 
1479   A048 FF FF FF FF 
1479   A04C FF FF FF FF 
1479   A050 FF FF FF FF 
1479   A054 FF FF FF FF 
1479   A058 FF FF FF FF 
1479   A05C FF FF FF FF 
1479   A060 FF FF FF FF 
1479   A064 FF FF FF FF 
1479   A068 FF FF FF FF 
1479   A06C FF FF FF FF 
1479   A070 FF FF FF FF 
1479   A074 FF FF FF FF 
1479   A078 FF FF FF FF 
1479   A07C FF FF FF FF 
1479   A080 FF FF FF FF 
1479   A084 FF FF FF FF 
1479   A088 FF FF FF FF 
1479   A08C FF FF FF FF 
1479   A090 FF FF FF FF 
1479   A094 FF FF FF FF 
1479   A098 FF FF FF FF 
1479   A09C FF FF FF FF 
1479   A0A0 FF FF FF FF 
1479   A0A4 FF FF FF FF 
1479   A0A8 FF FF FF FF 
1479   A0AC FF FF FF FF 
1479   A0B0 FF FF FF FF 
1479   A0B4 FF FF FF FF 
1479   A0B8 FF FF FF FF 
1479   A0BC FF FF FF FF 
1479   A0C0 FF FF FF FF 
1479   A0C4 FF FF FF FF 
1479   A0C8 FF FF FF FF 
1479   A0CC FF FF FF FF 
1479   A0D0 FF FF FF FF 
1479   A0D4 FF FF FF FF 
1479   A0D8 FF FF FF FF 
1479   A0DC FF FF FF FF 
1479   A0E0 FF FF FF FF 
1479   A0E4 FF FF FF FF 
1479   A0E8 FF FF FF FF 
1479   A0EC FF FF FF FF 
1479   A0F0 FF FF FF FF 
1479   A0F4 FF FF FF FF 
1479   A0F8 FF FF FF FF 
1479   A0FC FF FF FF FF 
1479   A100 FF FF FF FF 
1479   A104 FF FF FF FF 
1479   A108 FF FF FF FF 
1479   A10C FF FF FF FF 
1479   A110 FF FF FF FF 
1479   A114 FF FF FF FF 
1479   A118 FF FF FF FF 
1479   A11C FF FF FF FF 
1479   A120 FF FF FF FF 
1479   A124 FF FF FF FF 
1479   A128 FF FF FF FF 
1479   A12C FF FF FF FF 
1479   A130 FF FF FF FF 
1479   A134 FF FF FF FF 
1479   A138 FF FF FF FF 
1479   A13C FF FF FF FF 
1479   A140 FF FF FF FF 
1479   A144 FF FF FF FF 
1479   A148 FF FF FF FF 
1479   A14C FF FF FF FF 
1479   A150 FF FF FF FF 
1479   A154 FF FF FF FF 
1479   A158 FF FF FF FF 
1479   A15C FF FF FF FF 
1479   A160 FF FF FF FF 
1479   A164 FF FF FF FF 
1479   A168 FF FF FF FF 
1479   A16C FF FF FF FF 
1479   A170 FF FF FF FF 
1479   A174 FF FF FF FF 
1479   A178 FF FF FF FF 
1479   A17C FF FF FF FF 
1479   A180 FF FF FF FF 
1479   A184 FF FF FF FF 
1479   A188 FF FF FF FF 
1479   A18C FF FF FF FF 
1479   A190 FF FF FF FF 
1479   A194 FF FF FF FF 
1479   A198 FF FF FF FF 
1479   A19C FF FF FF FF 
1479   A1A0 FF FF FF FF 
1479   A1A4 FF FF FF FF 
1479   A1A8 FF FF FF FF 
1479   A1AC FF FF FF FF 
1479   A1B0 FF FF FF FF 
1479   A1B4 FF FF FF FF 
1479   A1B8 FF FF FF FF 
1479   A1BC FF FF FF FF 
1479   A1C0 FF FF FF FF 
1479   A1C4 FF FF FF FF 
1479   A1C8 FF FF FF FF 
1479   A1CC FF FF FF FF 
1479   A1D0 FF FF FF FF 
1479   A1D4 FF FF FF FF 
1479   A1D8 FF FF FF FF 
1479   A1DC FF FF FF FF 
1479   A1E0 FF FF FF FF 
1479   A1E4 FF FF FF FF 
1479   A1E8 FF FF FF FF 
1479   A1EC FF FF FF FF 
1479   A1F0 FF FF FF FF 
1479   A1F4 FF FF FF FF 
1479   A1F8 FF FF FF FF 
1479   A1FC FF FF FF FF 
1479   A200 FF FF FF FF 
1479   A204 FF FF FF FF 
1479   A208 FF FF FF FF 
1479   A20C FF FF FF FF 
1479   A210 FF FF FF FF 
1479   A214 FF FF FF FF 
1479   A218 FF FF FF FF 
1479   A21C FF FF FF FF 
1479   A220 FF FF FF FF 
1479   A224 FF FF FF FF 
1479   A228 FF FF FF FF 
1479   A22C FF FF FF FF 
1479   A230 FF FF FF FF 
1479   A234 FF FF FF FF 
1479   A238 FF FF FF FF 
1479   A23C FF FF FF FF 
1479   A240 FF FF FF FF 
1479   A244 FF FF FF FF 
1479   A248 FF FF FF FF 
1479   A24C FF FF FF FF 
1479   A250 FF FF FF FF 
1479   A254 FF FF FF FF 
1479   A258 FF FF FF FF 
1479   A25C FF FF FF FF 
1479   A260 FF FF FF FF 
1479   A264 FF FF FF FF 
1479   A268 FF FF FF FF 
1479   A26C FF FF FF FF 
1479   A270 FF FF FF FF 
1479   A274 FF FF FF FF 
1479   A278 FF FF FF FF 
1479   A27C FF FF FF FF 
1479   A280 FF FF FF FF 
1479   A284 FF FF FF FF 
1479   A288 FF FF FF FF 
1479   A28C FF FF FF FF 
1479   A290 FF FF FF FF 
1479   A294 FF FF FF FF 
1479   A298 FF FF FF FF 
1479   A29C FF FF FF FF 
1479   A2A0 FF FF FF FF 
1479   A2A4 FF FF FF FF 
1479   A2A8 FF FF FF FF 
1479   A2AC FF FF FF FF 
1479   A2B0 FF FF FF FF 
1479   A2B4 FF FF FF FF 
1479   A2B8 FF FF FF FF 
1479   A2BC FF FF FF FF 
1479   A2C0 FF FF FF FF 
1479   A2C4 FF FF FF FF 
1479   A2C8 FF FF FF FF 
1479   A2CC FF FF FF FF 
1479   A2D0 FF FF FF FF 
1479   A2D4 FF FF FF FF 
1479   A2D8 FF FF FF FF 
1479   A2DC FF FF FF FF 
1479   A2E0 FF FF FF FF 
1479   A2E4 FF FF FF FF 
1479   A2E8 FF FF FF FF 
1479   A2EC FF FF FF FF 
1479   A2F0 FF FF FF FF 
1479   A2F4 FF FF FF FF 
1479   A2F8 FF FF FF FF 
1479   A2FC FF FF FF FF 
1479   A300 FF FF FF FF 
1479   A304 FF FF FF FF 
1479   A308 FF FF FF FF 
1479   A30C FF FF FF FF 
1479   A310 FF FF FF FF 
1479   A314 FF FF FF FF 
1479   A318 FF FF FF FF 
1479   A31C FF FF FF FF 
1479   A320 FF FF FF FF 
1479   A324 FF FF FF FF 
1479   A328 FF FF FF FF 
1479   A32C FF FF FF FF 
1479   A330 FF FF FF FF 
1479   A334 FF FF FF FF 
1479   A338 FF FF FF FF 
1479   A33C FF FF FF FF 
1479   A340 FF FF FF FF 
1479   A344 FF FF FF FF 
1479   A348 FF FF FF FF 
1479   A34C FF FF FF FF 
1479   A350 FF FF FF FF 
1479   A354 FF FF FF FF 
1479   A358 FF FF FF FF 
1479   A35C FF FF FF FF 
1479   A360 FF FF FF FF 
1479   A364 FF FF FF FF 
1479   A368 FF FF FF FF 
1479   A36C FF FF FF FF 
1479   A370 FF FF FF FF 
1479   A374 FF FF FF FF 
1479   A378 FF FF FF FF 
1479   A37C FF FF FF FF 
1479   A380 FF FF FF FF 
1479   A384 FF FF FF FF 
1479   A388 FF FF FF FF 
1479   A38C FF FF FF FF 
1479   A390 FF FF FF FF 
1479   A394 FF FF FF FF 
1479   A398 FF FF FF FF 
1479   A39C FF FF FF FF 
1479   A3A0 FF FF FF FF 
1479   A3A4 FF FF FF FF 
1479   A3A8 FF FF FF FF 
1479   A3AC FF FF FF FF 
1479   A3B0 FF FF FF FF 
1479   A3B4 FF FF FF FF 
1479   A3B8 FF FF FF FF 
1479   A3BC FF FF FF FF 
1479   A3C0 FF FF FF FF 
1479   A3C4 FF FF FF FF 
1479   A3C8 FF FF FF FF 
1479   A3CC FF FF FF FF 
1479   A3D0 FF FF FF FF 
1479   A3D4 FF FF FF FF 
1479   A3D8 FF FF FF FF 
1479   A3DC FF FF FF FF 
1479   A3E0 FF FF FF FF 
1479   A3E4 FF FF FF FF 
1479   A3E8 FF FF FF FF 
1479   A3EC FF FF FF FF 
1479   A3F0 FF FF FF FF 
1479   A3F4 FF FF FF FF 
1479   A3F8 FF FF FF FF 
1479   A3FC FF FF FF FF 
1479   A400 FF FF FF FF 
1479   A404 FF FF FF FF 
1479   A408 FF FF FF FF 
1479   A40C FF FF FF FF 
1479   A410 FF FF FF FF 
1479   A414 FF FF FF FF 
1479   A418 FF FF FF FF 
1479   A41C FF FF FF FF 
1479   A420 FF FF FF FF 
1479   A424 FF FF FF FF 
1479   A428 FF FF FF FF 
1479   A42C FF FF FF FF 
1479   A430 FF FF FF FF 
1479   A434 FF FF FF FF 
1479   A438 FF FF FF FF 
1479   A43C FF FF FF FF 
1479   A440 FF FF FF FF 
1479   A444 FF FF FF FF 
1479   A448 FF FF FF FF 
1479   A44C FF FF FF FF 
1479   A450 FF FF FF FF 
1479   A454 FF FF FF FF 
1479   A458 FF FF FF FF 
1479   A45C FF FF FF FF 
1479   A460 FF FF FF FF 
1479   A464 FF FF FF FF 
1479   A468 FF FF FF FF 
1479   A46C FF FF FF FF 
1479   A470 FF FF FF FF 
1479   A474 FF FF FF FF 
1479   A478 FF FF FF FF 
1479   A47C FF FF FF FF 
1479   A480 FF FF FF FF 
1479   A484 FF FF FF FF 
1479   A488 FF FF FF FF 
1479   A48C FF FF FF FF 
1479   A490 FF FF FF FF 
1479   A494 FF FF FF FF 
1479   A498 FF FF FF FF 
1479   A49C FF FF FF FF 
1479   A4A0 FF FF FF FF 
1479   A4A4 FF FF FF FF 
1479   A4A8 FF FF FF FF 
1479   A4AC FF FF FF FF 
1479   A4B0 FF FF FF FF 
1479   A4B4 FF FF FF FF 
1479   A4B8 FF FF FF FF 
1479   A4BC FF FF FF FF 
1479   A4C0 FF FF FF FF 
1479   A4C4 FF FF FF FF 
1479   A4C8 FF FF FF FF 
1479   A4CC FF FF FF FF 
1479   A4D0 FF FF FF FF 
1479   A4D4 FF FF FF FF 
1479   A4D8 FF FF FF FF 
1479   A4DC FF FF FF FF 
1479   A4E0 FF FF FF FF 
1479   A4E4 FF FF FF FF 
1479   A4E8 FF FF FF FF 
1479   A4EC FF FF FF FF 
1479   A4F0 FF FF FF FF 
1479   A4F4 FF FF FF FF 
1479   A4F8 FF FF FF FF 
1479   A4FC FF FF FF FF 
1479   A500 FF FF FF FF 
1479   A504 FF FF FF FF 
1479   A508 FF FF FF FF 
1479   A50C FF FF FF FF 
1479   A510 FF FF FF FF 
1479   A514 FF FF FF FF 
1479   A518 FF FF FF FF 
1479   A51C FF FF FF FF 
1479   A520 FF FF FF FF 
1479   A524 FF FF FF FF 
1479   A528 FF FF FF FF 
1479   A52C FF FF FF FF 
1479   A530 FF FF FF FF 
1479   A534 FF FF FF FF 
1479   A538 FF FF FF FF 
1479   A53C FF FF FF FF 
1479   A540 FF FF FF FF 
1479   A544 FF FF FF FF 
1479   A548 FF FF FF FF 
1479   A54C FF FF FF FF 
1479   A550 FF FF FF FF 
1479   A554 FF FF FF FF 
1479   A558 FF FF FF FF 
1479   A55C FF FF FF FF 
1479   A560 FF FF FF FF 
1479   A564 FF FF FF FF 
1479   A568 FF FF FF FF 
1479   A56C FF FF FF FF 
1479   A570 FF FF FF FF 
1479   A574 FF FF FF FF 
1479   A578 FF FF FF FF 
1479   A57C FF FF FF FF 
1479   A580 FF FF FF FF 
1479   A584 FF FF FF FF 
1479   A588 FF FF FF FF 
1479   A58C FF FF FF FF 
1479   A590 FF FF FF FF 
1479   A594 FF FF FF FF 
1479   A598 FF FF FF FF 
1479   A59C FF FF FF FF 
1479   A5A0 FF FF FF FF 
1479   A5A4 FF FF FF FF 
1479   A5A8 FF FF FF FF 
1479   A5AC FF FF FF FF 
1479   A5B0 FF FF FF FF 
1479   A5B4 FF FF FF FF 
1479   A5B8 FF FF FF FF 
1479   A5BC FF FF FF FF 
1479   A5C0 FF FF FF FF 
1479   A5C4 FF FF FF FF 
1479   A5C8 FF FF FF FF 
1479   A5CC FF FF FF FF 
1479   A5D0 FF FF FF FF 
1479   A5D4 FF FF FF FF 
1479   A5D8 FF FF FF FF 
1479   A5DC FF FF FF FF 
1479   A5E0 FF FF FF FF 
1479   A5E4 FF FF FF FF 
1479   A5E8 FF FF FF FF 
1479   A5EC FF FF FF FF 
1479   A5F0 FF FF FF FF 
1479   A5F4 FF FF FF FF 
1479   A5F8 FF FF FF FF 
1479   A5FC FF FF FF FF 
1479   A600 FF FF FF FF 
1479   A604 FF FF FF FF 
1479   A608 FF FF FF FF 
1479   A60C FF FF FF FF 
1479   A610 FF FF FF FF 
1479   A614 FF FF FF FF 
1479   A618 FF FF FF FF 
1479   A61C FF FF FF FF 
1479   A620 FF FF FF FF 
1479   A624 FF FF FF FF 
1479   A628 FF FF FF FF 
1479   A62C FF FF FF FF 
1479   A630 FF FF FF FF 
1479   A634 FF FF FF FF 
1479   A638 FF FF FF FF 
1479   A63C FF FF FF FF 
1479   A640 FF FF FF FF 
1479   A644 FF FF FF FF 
1479   A648 FF FF FF FF 
1479   A64C FF FF FF FF 
1479   A650 FF FF FF FF 
1479   A654 FF FF FF FF 
1479   A658 FF FF FF FF 
1479   A65C FF FF FF FF 
1479   A660 FF FF FF FF 
1479   A664 FF FF FF FF 
1479   A668 FF FF FF FF 
1479   A66C FF FF FF FF 
1479   A670 FF FF FF FF 
1479   A674 FF FF FF FF 
1479   A678 FF FF FF FF 
1479   A67C FF FF FF FF 
1479   A680 FF FF FF FF 
1479   A684 FF FF FF FF 
1479   A688 FF FF FF FF 
1479   A68C FF FF FF FF 
1479   A690 FF FF FF FF 
1479   A694 FF FF FF FF 
1479   A698 FF FF FF FF 
1479   A69C FF FF FF FF 
1479   A6A0 FF FF FF FF 
1479   A6A4 FF FF FF FF 
1479   A6A8 FF FF FF FF 
1479   A6AC FF FF FF FF 
1479   A6B0 FF FF FF FF 
1479   A6B4 FF FF FF FF 
1479   A6B8 FF FF FF FF 
1479   A6BC FF FF FF FF 
1479   A6C0 FF FF FF FF 
1479   A6C4 FF FF FF FF 
1479   A6C8 FF FF FF FF 
1479   A6CC FF FF FF FF 
1479   A6D0 FF FF FF FF 
1479   A6D4 FF FF FF FF 
1479   A6D8 FF FF FF FF 
1479   A6DC FF FF FF FF 
1479   A6E0 FF FF FF FF 
1479   A6E4 FF FF FF FF 
1479   A6E8 FF FF FF FF 
1479   A6EC FF FF FF FF 
1479   A6F0 FF FF FF FF 
1479   A6F4 FF FF FF FF 
1479   A6F8 FF FF FF FF 
1479   A6FC FF FF FF FF 
1479   A700 FF FF FF FF 
1479   A704 FF FF FF FF 
1479   A708 FF FF FF FF 
1479   A70C FF FF FF FF 
1479   A710 FF FF FF FF 
1479   A714 FF FF FF FF 
1479   A718 FF FF FF FF 
1479   A71C FF FF FF FF 
1479   A720 FF FF FF FF 
1479   A724 FF FF FF FF 
1479   A728 FF FF FF FF 
1479   A72C FF FF FF FF 
1479   A730 FF FF FF FF 
1479   A734 FF FF FF FF 
1479   A738 FF FF FF FF 
1479   A73C FF FF FF FF 
1479   A740 FF FF FF FF 
1479   A744 FF FF FF FF 
1479   A748 FF FF FF FF 
1479   A74C FF FF FF FF 
1479   A750 FF FF FF FF 
1479   A754 FF FF FF FF 
1479   A758 FF FF FF FF 
1479   A75C FF FF FF FF 
1479   A760 FF FF FF FF 
1479   A764 FF FF FF FF 
1479   A768 FF FF FF FF 
1479   A76C FF FF FF FF 
1479   A770 FF FF FF FF 
1479   A774 FF FF FF FF 
1479   A778 FF FF FF FF 
1479   A77C FF FF FF FF 
1479   A780 FF FF FF FF 
1479   A784 FF FF FF FF 
1479   A788 FF FF FF FF 
1479   A78C FF FF FF FF 
1479   A790 FF FF FF FF 
1479   A794 FF FF FF FF 
1479   A798 FF FF FF FF 
1479   A79C FF FF FF FF 
1479   A7A0 FF FF FF FF 
1479   A7A4 FF FF FF FF 
1479   A7A8 FF FF FF FF 
1479   A7AC FF FF FF FF 
1479   A7B0 FF FF FF FF 
1479   A7B4 FF FF FF FF 
1479   A7B8 FF FF FF FF 
1479   A7BC FF FF FF FF 
1479   A7C0 FF FF FF FF 
1479   A7C4 FF FF FF FF 
1479   A7C8 FF FF FF FF 
1479   A7CC FF FF FF FF 
1479   A7D0 FF FF FF FF 
1479   A7D4 FF FF FF FF 
1479   A7D8 FF FF FF FF 
1479   A7DC FF FF FF FF 
1479   A7E0 FF FF FF FF 
1479   A7E4 FF FF FF FF 
1479   A7E8 FF FF FF FF 
1479   A7EC FF FF FF FF 
1479   A7F0 FF FF FF FF 
1479   A7F4 FF FF FF FF 
1479   A7F8 FF FF FF FF 
1479   A7FC FF FF FF FF 
1479   A800 FF FF FF FF 
1479   A804 FF FF FF FF 
1479   A808 FF FF FF FF 
1479   A80C FF FF FF FF 
1479   A810 FF FF FF FF 
1479   A814 FF FF FF FF 
1479   A818 FF FF FF FF 
1479   A81C FF FF FF FF 
1479   A820 FF FF FF FF 
1479   A824 FF FF FF FF 
1479   A828 FF FF FF FF 
1479   A82C FF FF FF FF 
1479   A830 FF FF FF FF 
1479   A834 FF FF FF FF 
1479   A838 FF FF FF FF 
1479   A83C FF FF FF FF 
1479   A840 FF FF FF FF 
1479   A844 FF FF FF FF 
1479   A848 FF FF FF FF 
1479   A84C FF FF FF FF 
1479   A850 FF FF FF FF 
1479   A854 FF FF FF FF 
1479   A858 FF FF FF FF 
1479   A85C FF FF FF FF 
1479   A860 FF FF FF FF 
1479   A864 FF FF FF FF 
1479   A868 FF FF FF FF 
1479   A86C FF FF FF FF 
1479   A870 FF FF FF FF 
1479   A874 FF FF FF FF 
1479   A878 FF FF FF FF 
1479   A87C FF FF FF FF 
1479   A880 FF FF FF FF 
1479   A884 FF FF FF FF 
1479   A888 FF FF FF FF 
1479   A88C FF FF FF FF 
1479   A890 FF FF FF FF 
1479   A894 FF FF FF FF 
1479   A898 FF FF FF FF 
1479   A89C FF FF FF FF 
1479   A8A0 FF FF FF FF 
1479   A8A4 FF FF FF FF 
1479   A8A8 FF FF FF FF 
1479   A8AC FF FF FF FF 
1479   A8B0 FF FF FF FF 
1479   A8B4 FF FF FF FF 
1479   A8B8 FF FF FF FF 
1479   A8BC FF FF FF FF 
1479   A8C0 FF FF FF FF 
1479   A8C4 FF FF FF FF 
1479   A8C8 FF FF FF FF 
1479   A8CC FF FF FF FF 
1479   A8D0 FF FF FF FF 
1479   A8D4 FF FF FF FF 
1479   A8D8 FF FF FF FF 
1479   A8DC FF FF FF FF 
1479   A8E0 FF FF FF FF 
1479   A8E4 FF FF FF FF 
1479   A8E8 FF FF FF FF 
1479   A8EC FF FF FF FF 
1479   A8F0 FF FF FF FF 
1479   A8F4 FF FF FF FF 
1479   A8F8 FF FF FF FF 
1479   A8FC FF FF FF FF 
1479   A900 FF FF FF FF 
1479   A904 FF FF FF FF 
1479   A908 FF FF FF FF 
1479   A90C FF FF FF FF 
1479   A910 FF FF FF FF 
1479   A914 FF FF FF FF 
1479   A918 FF FF FF FF 
1479   A91C FF FF FF FF 
1479   A920 FF FF FF FF 
1479   A924 FF FF FF FF 
1479   A928 FF FF FF FF 
1479   A92C FF FF FF FF 
1479   A930 FF FF FF FF 
1479   A934 FF FF FF FF 
1479   A938 FF FF FF FF 
1479   A93C FF FF FF FF 
1479   A940 FF FF FF FF 
1479   A944 FF FF FF FF 
1479   A948 FF FF FF FF 
1479   A94C FF FF FF FF 
1479   A950 FF FF FF FF 
1479   A954 FF FF FF FF 
1479   A958 FF FF FF FF 
1479   A95C FF FF FF FF 
1479   A960 FF FF FF FF 
1479   A964 FF FF FF FF 
1479   A968 FF FF FF FF 
1479   A96C FF FF FF FF 
1479   A970 FF FF FF FF 
1479   A974 FF FF FF FF 
1479   A978 FF FF FF FF 
1479   A97C FF FF FF FF 
1479   A980 FF FF FF FF 
1479   A984 FF FF FF FF 
1479   A988 FF FF FF FF 
1479   A98C FF FF FF FF 
1479   A990 FF FF FF FF 
1479   A994 FF FF FF FF 
1479   A998 FF FF FF FF 
1479   A99C FF FF FF FF 
1479   A9A0 FF FF FF FF 
1479   A9A4 FF FF FF FF 
1479   A9A8 FF FF FF FF 
1479   A9AC FF FF FF FF 
1479   A9B0 FF FF FF FF 
1479   A9B4 FF FF FF FF 
1479   A9B8 FF FF FF FF 
1479   A9BC FF FF FF FF 
1479   A9C0 FF FF FF FF 
1479   A9C4 FF FF FF FF 
1479   A9C8 FF FF FF FF 
1479   A9CC FF FF FF FF 
1479   A9D0 FF FF FF FF 
1479   A9D4 FF FF FF FF 
1479   A9D8 FF FF FF FF 
1479   A9DC FF FF FF FF 
1479   A9E0 FF FF FF FF 
1479   A9E4 FF FF FF FF 
1479   A9E8 FF FF FF FF 
1479   A9EC FF FF FF FF 
1479   A9F0 FF FF FF FF 
1479   A9F4 FF FF FF FF 
1479   A9F8 FF FF FF FF 
1479   A9FC FF FF FF FF 
1479   AA00 FF FF FF FF 
1479   AA04 FF FF FF FF 
1479   AA08 FF FF FF FF 
1479   AA0C FF FF FF FF 
1479   AA10 FF FF FF FF 
1479   AA14 FF FF FF FF 
1479   AA18 FF FF FF FF 
1479   AA1C FF FF FF FF 
1479   AA20 FF FF FF FF 
1479   AA24 FF FF FF FF 
1479   AA28 FF FF FF FF 
1479   AA2C FF FF FF FF 
1479   AA30 FF FF FF FF 
1479   AA34 FF FF FF FF 
1479   AA38 FF FF FF FF 
1479   AA3C FF FF FF FF 
1479   AA40 FF FF FF FF 
1479   AA44 FF FF FF FF 
1479   AA48 FF FF FF FF 
1479   AA4C FF FF FF FF 
1479   AA50 FF FF FF FF 
1479   AA54 FF FF FF FF 
1479   AA58 FF FF FF FF 
1479   AA5C FF FF FF FF 
1479   AA60 FF FF FF FF 
1479   AA64 FF FF FF FF 
1479   AA68 FF FF FF FF 
1479   AA6C FF FF FF FF 
1479   AA70 FF FF FF FF 
1479   AA74 FF FF FF FF 
1479   AA78 FF FF FF FF 
1479   AA7C FF FF FF FF 
1479   AA80 FF FF FF FF 
1479   AA84 FF FF FF FF 
1479   AA88 FF FF FF FF 
1479   AA8C FF FF FF FF 
1479   AA90 FF FF FF FF 
1479   AA94 FF FF FF FF 
1479   AA98 FF FF FF FF 
1479   AA9C FF FF FF FF 
1479   AAA0 FF FF FF FF 
1479   AAA4 FF FF FF FF 
1479   AAA8 FF FF FF FF 
1479   AAAC FF FF FF FF 
1479   AAB0 FF FF FF FF 
1479   AAB4 FF FF FF FF 
1479   AAB8 FF FF FF FF 
1479   AABC FF FF FF FF 
1479   AAC0 FF FF FF FF 
1479   AAC4 FF FF FF FF 
1479   AAC8 FF FF FF FF 
1479   AACC FF FF FF FF 
1479   AAD0 FF FF FF FF 
1479   AAD4 FF FF FF FF 
1479   AAD8 FF FF FF FF 
1479   AADC FF FF FF FF 
1479   AAE0 FF FF FF FF 
1479   AAE4 FF FF FF FF 
1479   AAE8 FF FF FF FF 
1479   AAEC FF FF FF FF 
1479   AAF0 FF FF FF FF 
1479   AAF4 FF FF FF FF 
1479   AAF8 FF FF FF FF 
1479   AAFC FF FF FF FF 
1479   AB00 FF FF FF FF 
1479   AB04 FF FF FF FF 
1479   AB08 FF FF FF FF 
1479   AB0C FF FF FF FF 
1479   AB10 FF FF FF FF 
1479   AB14 FF FF FF FF 
1479   AB18 FF FF FF FF 
1479   AB1C FF FF FF FF 
1479   AB20 FF FF FF FF 
1479   AB24 FF FF FF FF 
1479   AB28 FF FF FF FF 
1479   AB2C FF FF FF FF 
1479   AB30 FF FF FF FF 
1479   AB34 FF FF FF FF 
1479   AB38 FF FF FF FF 
1479   AB3C FF FF FF FF 
1479   AB40 FF FF FF FF 
1479   AB44 FF FF FF FF 
1479   AB48 FF FF FF FF 
1479   AB4C FF FF FF FF 
1479   AB50 FF FF FF FF 
1479   AB54 FF FF FF FF 
1479   AB58 FF FF FF FF 
1479   AB5C FF FF FF FF 
1479   AB60 FF FF FF FF 
1479   AB64 FF FF FF FF 
1479   AB68 FF FF FF FF 
1479   AB6C FF FF FF FF 
1479   AB70 FF FF FF FF 
1479   AB74 FF FF FF FF 
1479   AB78 FF FF FF FF 
1479   AB7C FF FF FF FF 
1479   AB80 FF FF FF FF 
1479   AB84 FF FF FF FF 
1479   AB88 FF FF FF FF 
1479   AB8C FF FF FF FF 
1479   AB90 FF FF FF FF 
1479   AB94 FF FF FF FF 
1479   AB98 FF FF FF FF 
1479   AB9C FF FF FF FF 
1479   ABA0 FF FF FF FF 
1479   ABA4 FF FF FF FF 
1479   ABA8 FF FF FF FF 
1479   ABAC FF FF FF FF 
1479   ABB0 FF FF FF FF 
1479   ABB4 FF FF FF FF 
1479   ABB8 FF FF FF FF 
1479   ABBC FF FF FF FF 
1479   ABC0 FF FF FF FF 
1479   ABC4 FF FF FF FF 
1479   ABC8 FF FF FF FF 
1479   ABCC FF FF FF FF 
1479   ABD0 FF FF FF FF 
1479   ABD4 FF FF FF FF 
1479   ABD8 FF FF FF FF 
1479   ABDC FF FF FF FF 
1479   ABE0 FF FF FF FF 
1479   ABE4 FF FF FF FF 
1479   ABE8 FF FF FF FF 
1479   ABEC FF FF FF FF 
1479   ABF0 FF FF FF FF 
1479   ABF4 FF FF FF FF 
1479   ABF8 FF FF FF FF 
1479   ABFC FF FF FF FF 
1479   AC00 FF FF FF FF 
1479   AC04 FF FF FF FF 
1479   AC08 FF FF FF FF 
1479   AC0C FF FF FF FF 
1479   AC10 FF FF FF FF 
1479   AC14 FF FF FF FF 
1479   AC18 FF FF FF FF 
1479   AC1C FF FF FF FF 
1479   AC20 FF FF FF FF 
1479   AC24 FF FF FF FF 
1479   AC28 FF FF FF FF 
1479   AC2C FF FF FF FF 
1479   AC30 FF FF FF FF 
1479   AC34 FF FF FF FF 
1479   AC38 FF FF FF FF 
1479   AC3C FF FF FF FF 
1479   AC40 FF FF FF FF 
1479   AC44 FF FF FF FF 
1479   AC48 FF FF FF FF 
1479   AC4C FF FF FF FF 
1479   AC50 FF FF FF FF 
1479   AC54 FF FF FF FF 
1479   AC58 FF FF FF FF 
1479   AC5C FF FF FF FF 
1479   AC60 FF FF FF FF 
1479   AC64 FF FF FF FF 
1479   AC68 FF FF FF FF 
1479   AC6C FF FF FF FF 
1479   AC70 FF FF FF FF 
1479   AC74 FF FF FF FF 
1479   AC78 FF FF FF FF 
1479   AC7C FF FF FF FF 
1479   AC80 FF FF FF FF 
1479   AC84 FF FF FF FF 
1479   AC88 FF FF FF FF 
1479   AC8C FF FF FF FF 
1479   AC90 FF FF FF FF 
1479   AC94 FF FF FF FF 
1479   AC98 FF FF FF FF 
1479   AC9C FF FF FF FF 
1479   ACA0 FF FF FF FF 
1479   ACA4 FF FF FF FF 
1479   ACA8 FF FF FF FF 
1479   ACAC FF FF FF FF 
1479   ACB0 FF FF FF FF 
1479   ACB4 FF FF FF FF 
1479   ACB8 FF FF FF FF 
1479   ACBC FF FF FF FF 
1479   ACC0 FF FF FF FF 
1479   ACC4 FF FF FF FF 
1479   ACC8 FF FF FF FF 
1479   ACCC FF FF FF FF 
1479   ACD0 FF FF FF FF 
1479   ACD4 FF FF FF FF 
1479   ACD8 FF FF FF FF 
1479   ACDC FF FF FF FF 
1479   ACE0 FF FF FF FF 
1479   ACE4 FF FF FF FF 
1479   ACE8 FF FF FF FF 
1479   ACEC FF FF FF FF 
1479   ACF0 FF FF FF FF 
1479   ACF4 FF FF FF FF 
1479   ACF8 FF FF FF FF 
1479   ACFC FF FF FF FF 
1479   AD00 FF FF FF FF 
1479   AD04 FF FF FF FF 
1479   AD08 FF FF FF FF 
1479   AD0C FF FF FF FF 
1479   AD10 FF FF FF FF 
1479   AD14 FF FF FF FF 
1479   AD18 FF FF FF FF 
1479   AD1C FF FF FF FF 
1479   AD20 FF FF FF FF 
1479   AD24 FF FF FF FF 
1479   AD28 FF FF FF FF 
1479   AD2C FF FF FF FF 
1479   AD30 FF FF FF FF 
1479   AD34 FF FF FF FF 
1479   AD38 FF FF FF FF 
1479   AD3C FF FF FF FF 
1479   AD40 FF FF FF FF 
1479   AD44 FF FF FF FF 
1479   AD48 FF FF FF FF 
1479   AD4C FF FF FF FF 
1479   AD50 FF FF FF FF 
1479   AD54 FF FF FF FF 
1479   AD58 FF FF FF FF 
1479   AD5C FF FF FF FF 
1479   AD60 FF FF FF FF 
1479   AD64 FF FF FF FF 
1479   AD68 FF FF FF FF 
1479   AD6C FF FF FF FF 
1479   AD70 FF FF FF FF 
1479   AD74 FF FF FF FF 
1479   AD78 FF FF FF FF 
1479   AD7C FF FF FF FF 
1479   AD80 FF FF FF FF 
1479   AD84 FF FF FF FF 
1479   AD88 FF FF FF FF 
1479   AD8C FF FF FF FF 
1479   AD90 FF FF FF FF 
1479   AD94 FF FF FF FF 
1479   AD98 FF FF FF FF 
1479   AD9C FF FF FF FF 
1479   ADA0 FF FF FF FF 
1479   ADA4 FF FF FF FF 
1479   ADA8 FF FF FF FF 
1479   ADAC FF FF FF FF 
1479   ADB0 FF FF FF FF 
1479   ADB4 FF FF FF FF 
1479   ADB8 FF FF FF FF 
1479   ADBC FF FF FF FF 
1479   ADC0 FF FF FF FF 
1479   ADC4 FF FF FF FF 
1479   ADC8 FF FF FF FF 
1479   ADCC FF FF FF FF 
1479   ADD0 FF FF FF FF 
1479   ADD4 FF FF FF FF 
1479   ADD8 FF FF FF FF 
1479   ADDC FF FF FF FF 
1479   ADE0 FF FF FF FF 
1479   ADE4 FF FF FF FF 
1479   ADE8 FF FF FF FF 
1479   ADEC FF FF FF FF 
1479   ADF0 FF FF FF FF 
1479   ADF4 FF FF FF FF 
1479   ADF8 FF FF FF FF 
1479   ADFC FF FF FF FF 
1479   AE00 FF FF FF FF 
1479   AE04 FF FF FF FF 
1479   AE08 FF FF FF FF 
1479   AE0C FF FF FF FF 
1479   AE10 FF FF FF FF 
1479   AE14 FF FF FF FF 
1479   AE18 FF FF FF FF 
1479   AE1C FF FF FF FF 
1479   AE20 FF FF FF FF 
1479   AE24 FF FF FF FF 
1479   AE28 FF FF FF FF 
1479   AE2C FF FF FF FF 
1479   AE30 FF FF FF FF 
1479   AE34 FF FF FF FF 
1479   AE38 FF FF FF FF 
1479   AE3C FF FF FF FF 
1479   AE40 FF FF FF FF 
1479   AE44 FF FF FF FF 
1479   AE48 FF FF FF FF 
1479   AE4C FF FF FF FF 
1479   AE50 FF FF FF FF 
1479   AE54 FF FF FF FF 
1479   AE58 FF FF FF FF 
1479   AE5C FF FF FF FF 
1479   AE60 FF FF FF FF 
1479   AE64 FF FF FF FF 
1479   AE68 FF FF FF FF 
1479   AE6C FF FF FF FF 
1479   AE70 FF FF FF FF 
1479   AE74 FF FF FF FF 
1479   AE78 FF FF FF FF 
1479   AE7C FF FF FF FF 
1479   AE80 FF FF FF FF 
1479   AE84 FF FF FF FF 
1479   AE88 FF FF FF FF 
1479   AE8C FF FF FF FF 
1479   AE90 FF FF FF FF 
1479   AE94 FF FF FF FF 
1479   AE98 FF FF FF FF 
1479   AE9C FF FF FF FF 
1479   AEA0 FF FF FF FF 
1479   AEA4 FF FF FF FF 
1479   AEA8 FF FF FF FF 
1479   AEAC FF FF FF FF 
1479   AEB0 FF FF FF FF 
1479   AEB4 FF FF FF FF 
1479   AEB8 FF FF FF FF 
1479   AEBC FF FF FF FF 
1479   AEC0 FF FF FF FF 
1479   AEC4 FF FF FF FF 
1479   AEC8 FF FF FF FF 
1479   AECC FF FF FF FF 
1479   AED0 FF FF FF FF 
1479   AED4 FF FF FF FF 
1479   AED8 FF FF FF FF 
1479   AEDC FF FF FF FF 
1479   AEE0 FF FF FF FF 
1479   AEE4 FF FF FF FF 
1479   AEE8 FF FF FF FF 
1479   AEEC FF FF FF FF 
1479   AEF0 FF FF FF FF 
1479   AEF4 FF FF FF FF 
1479   AEF8 FF FF FF FF 
1479   AEFC FF FF FF FF 
1479   AF00 FF FF FF FF 
1479   AF04 FF FF FF FF 
1479   AF08 FF FF FF FF 
1479   AF0C FF FF FF FF 
1479   AF10 FF FF FF FF 
1479   AF14 FF FF FF FF 
1479   AF18 FF FF FF FF 
1479   AF1C FF FF FF FF 
1479   AF20 FF FF FF FF 
1479   AF24 FF FF FF FF 
1479   AF28 FF FF FF FF 
1479   AF2C FF FF FF FF 
1479   AF30 FF FF FF FF 
1479   AF34 FF FF FF FF 
1479   AF38 FF FF FF FF 
1479   AF3C FF FF FF FF 
1479   AF40 FF FF FF FF 
1479   AF44 FF FF FF FF 
1479   AF48 FF FF FF FF 
1479   AF4C FF FF FF FF 
1479   AF50 FF FF FF FF 
1479   AF54 FF FF FF FF 
1479   AF58 FF FF FF FF 
1479   AF5C FF FF FF FF 
1479   AF60 FF FF FF FF 
1479   AF64 FF FF FF FF 
1479   AF68 FF FF FF FF 
1479   AF6C FF FF FF FF 
1479   AF70 FF FF FF FF 
1479   AF74 FF FF FF FF 
1479   AF78 FF FF FF FF 
1479   AF7C FF FF FF FF 
1479   AF80 FF FF FF FF 
1479   AF84 FF FF FF FF 
1479   AF88 FF FF FF FF 
1479   AF8C FF FF FF FF 
1479   AF90 FF FF FF FF 
1479   AF94 FF FF FF FF 
1479   AF98 FF FF FF FF 
1479   AF9C FF FF FF FF 
1479   AFA0 FF FF FF FF 
1479   AFA4 FF FF FF FF 
1479   AFA8 FF FF FF FF 
1479   AFAC FF FF FF FF 
1479   AFB0 FF FF FF FF 
1479   AFB4 FF FF FF FF 
1479   AFB8 FF FF FF FF 
1479   AFBC FF FF FF FF 
1479   AFC0 FF FF FF FF 
1479   AFC4 FF FF FF FF 
1479   AFC8 FF FF FF FF 
1479   AFCC FF FF FF FF 
1479   AFD0 FF FF FF FF 
1479   AFD4 FF FF FF FF 
1479   AFD8 FF FF FF FF 
1479   AFDC FF FF FF FF 
1479   AFE0 FF FF FF FF 
1479   AFE4 FF FF FF FF 
1479   AFE8 FF FF FF FF 
1479   AFEC FF FF FF FF 
1479   AFF0 FF FF FF FF 
1479   AFF4 FF FF FF FF 
1479   AFF8 FF FF FF FF 
1479   AFFC FF FF FF FF 
1479   B000 FF FF FF FF 
1479   B004 FF FF FF FF 
1479   B008 FF FF FF FF 
1479   B00C FF FF FF FF 
1479   B010 FF FF FF FF 
1479   B014 FF FF FF FF 
1479   B018 FF FF FF FF 
1479   B01C FF FF FF FF 
1479   B020 FF FF FF FF 
1479   B024 FF FF FF FF 
1479   B028 FF FF FF FF 
1479   B02C FF FF FF FF 
1479   B030 FF FF FF FF 
1479   B034 FF FF FF FF 
1479   B038 FF FF FF FF 
1479   B03C FF FF FF FF 
1479   B040 FF FF FF FF 
1479   B044 FF FF FF FF 
1479   B048 FF FF FF FF 
1479   B04C FF FF FF FF 
1479   B050 FF FF FF FF 
1479   B054 FF FF FF FF 
1479   B058 FF FF FF FF 
1479   B05C FF FF FF FF 
1479   B060 FF FF FF FF 
1479   B064 FF FF FF FF 
1479   B068 FF FF FF FF 
1479   B06C FF FF FF FF 
1479   B070 FF FF FF FF 
1479   B074 FF FF FF FF 
1479   B078 FF FF FF FF 
1479   B07C FF FF FF FF 
1479   B080 FF FF FF FF 
1479   B084 FF FF FF FF 
1479   B088 FF FF FF FF 
1479   B08C FF FF FF FF 
1479   B090 FF FF FF FF 
1479   B094 FF FF FF FF 
1479   B098 FF FF FF FF 
1479   B09C FF FF FF FF 
1479   B0A0 FF FF FF FF 
1479   B0A4 FF FF FF FF 
1479   B0A8 FF FF FF FF 
1479   B0AC FF FF FF FF 
1479   B0B0 FF FF FF FF 
1479   B0B4 FF FF FF FF 
1479   B0B8 FF FF FF FF 
1479   B0BC FF FF FF FF 
1479   B0C0 FF FF FF FF 
1479   B0C4 FF FF FF FF 
1479   B0C8 FF FF FF FF 
1479   B0CC FF FF FF FF 
1479   B0D0 FF FF FF FF 
1479   B0D4 FF FF FF FF 
1479   B0D8 FF FF FF FF 
1479   B0DC FF FF FF FF 
1479   B0E0 FF FF FF FF 
1479   B0E4 FF FF FF FF 
1479   B0E8 FF FF FF FF 
1479   B0EC FF FF FF FF 
1479   B0F0 FF FF FF FF 
1479   B0F4 FF FF FF FF 
1479   B0F8 FF FF FF FF 
1479   B0FC FF FF FF FF 
1479   B100 FF FF FF FF 
1479   B104 FF FF FF FF 
1479   B108 FF FF FF FF 
1479   B10C FF FF FF FF 
1479   B110 FF FF FF FF 
1479   B114 FF FF FF FF 
1479   B118 FF FF FF FF 
1479   B11C FF FF FF FF 
1479   B120 FF FF FF FF 
1479   B124 FF FF FF FF 
1479   B128 FF FF FF FF 
1479   B12C FF FF FF FF 
1479   B130 FF FF FF FF 
1479   B134 FF FF FF FF 
1479   B138 FF FF FF FF 
1479   B13C FF FF FF FF 
1479   B140 FF FF FF FF 
1479   B144 FF FF FF FF 
1479   B148 FF FF FF FF 
1479   B14C FF FF FF FF 
1479   B150 FF FF FF FF 
1479   B154 FF FF FF FF 
1479   B158 FF FF FF FF 
1479   B15C FF FF FF FF 
1479   B160 FF FF FF FF 
1479   B164 FF FF FF FF 
1479   B168 FF FF FF FF 
1479   B16C FF FF FF FF 
1479   B170 FF FF FF FF 
1479   B174 FF FF FF FF 
1479   B178 FF FF FF FF 
1479   B17C FF FF FF FF 
1479   B180 FF FF FF FF 
1479   B184 FF FF FF FF 
1479   B188 FF FF FF FF 
1479   B18C FF FF FF FF 
1479   B190 FF FF FF FF 
1479   B194 FF FF FF FF 
1479   B198 FF FF FF FF 
1479   B19C FF FF FF FF 
1479   B1A0 FF FF FF FF 
1479   B1A4 FF FF FF FF 
1479   B1A8 FF FF FF FF 
1479   B1AC FF FF FF FF 
1479   B1B0 FF FF FF FF 
1479   B1B4 FF FF FF FF 
1479   B1B8 FF FF FF FF 
1479   B1BC FF FF FF FF 
1479   B1C0 FF FF FF FF 
1479   B1C4 FF FF FF FF 
1479   B1C8 FF FF FF FF 
1479   B1CC FF FF FF FF 
1479   B1D0 FF FF FF FF 
1479   B1D4 FF FF FF FF 
1479   B1D8 FF FF FF FF 
1479   B1DC FF FF FF FF 
1479   B1E0 FF FF FF FF 
1479   B1E4 FF FF FF FF 
1479   B1E8 FF FF FF FF 
1479   B1EC FF FF FF FF 
1479   B1F0 FF FF FF FF 
1479   B1F4 FF FF FF FF 
1479   B1F8 FF FF FF FF 
1479   B1FC FF FF FF FF 
1479   B200 FF FF FF FF 
1479   B204 FF FF FF FF 
1479   B208 FF FF FF FF 
1479   B20C FF FF FF FF 
1479   B210 FF FF FF FF 
1479   B214 FF FF FF FF 
1479   B218 FF FF FF FF 
1479   B21C FF FF FF FF 
1479   B220 FF FF FF FF 
1479   B224 FF FF FF FF 
1479   B228 FF FF FF FF 
1479   B22C FF FF FF FF 
1479   B230 FF FF FF FF 
1479   B234 FF FF FF FF 
1479   B238 FF FF FF FF 
1479   B23C FF FF FF FF 
1479   B240 FF FF FF FF 
1479   B244 FF FF FF FF 
1479   B248 FF FF FF FF 
1479   B24C FF FF FF FF 
1479   B250 FF FF FF FF 
1479   B254 FF FF FF FF 
1479   B258 FF FF FF FF 
1479   B25C FF FF FF FF 
1479   B260 FF FF FF FF 
1479   B264 FF FF FF FF 
1479   B268 FF FF FF FF 
1479   B26C FF FF FF FF 
1479   B270 FF FF FF FF 
1479   B274 FF FF FF FF 
1479   B278 FF FF FF FF 
1479   B27C FF FF FF FF 
1479   B280 FF FF FF FF 
1479   B284 FF FF FF FF 
1479   B288 FF FF FF FF 
1479   B28C FF FF FF FF 
1479   B290 FF FF FF FF 
1479   B294 FF FF FF FF 
1479   B298 FF FF FF FF 
1479   B29C FF FF FF FF 
1479   B2A0 FF FF FF FF 
1479   B2A4 FF FF FF FF 
1479   B2A8 FF FF FF FF 
1479   B2AC FF FF FF FF 
1479   B2B0 FF FF FF FF 
1479   B2B4 FF FF FF FF 
1479   B2B8 FF FF FF FF 
1479   B2BC FF FF FF FF 
1479   B2C0 FF FF FF FF 
1479   B2C4 FF FF FF FF 
1479   B2C8 FF FF FF FF 
1479   B2CC FF FF FF FF 
1479   B2D0 FF FF FF FF 
1479   B2D4 FF FF FF FF 
1479   B2D8 FF FF FF FF 
1479   B2DC FF FF FF FF 
1479   B2E0 FF FF FF FF 
1479   B2E4 FF FF FF FF 
1479   B2E8 FF FF FF FF 
1479   B2EC FF FF FF FF 
1479   B2F0 FF FF FF FF 
1479   B2F4 FF FF FF FF 
1479   B2F8 FF FF FF FF 
1479   B2FC FF FF FF FF 
1479   B300 FF FF FF FF 
1479   B304 FF FF FF FF 
1479   B308 FF FF FF FF 
1479   B30C FF FF FF FF 
1479   B310 FF FF FF FF 
1479   B314 FF FF FF FF 
1479   B318 FF FF FF FF 
1479   B31C FF FF FF FF 
1479   B320 FF FF FF FF 
1479   B324 FF FF FF FF 
1479   B328 FF FF FF FF 
1479   B32C FF FF FF FF 
1479   B330 FF FF FF FF 
1479   B334 FF FF FF FF 
1479   B338 FF FF FF FF 
1479   B33C FF FF FF FF 
1479   B340 FF FF FF FF 
1479   B344 FF FF FF FF 
1479   B348 FF FF FF FF 
1479   B34C FF FF FF FF 
1479   B350 FF FF FF FF 
1479   B354 FF FF FF FF 
1479   B358 FF FF FF FF 
1479   B35C FF FF FF FF 
1479   B360 FF FF FF FF 
1479   B364 FF FF FF FF 
1479   B368 FF FF FF FF 
1479   B36C FF FF FF FF 
1479   B370 FF FF FF FF 
1479   B374 FF FF FF FF 
1479   B378 FF FF FF FF 
1479   B37C FF FF FF FF 
1479   B380 FF FF FF FF 
1479   B384 FF FF FF FF 
1479   B388 FF FF FF FF 
1479   B38C FF FF FF FF 
1479   B390 FF FF FF FF 
1479   B394 FF FF FF FF 
1479   B398 FF FF FF FF 
1479   B39C FF FF FF FF 
1479   B3A0 FF FF FF FF 
1479   B3A4 FF FF FF FF 
1479   B3A8 FF FF FF FF 
1479   B3AC FF FF FF FF 
1479   B3B0 FF FF FF FF 
1479   B3B4 FF FF FF FF 
1479   B3B8 FF FF FF FF 
1479   B3BC FF FF FF FF 
1479   B3C0 FF FF FF FF 
1479   B3C4 FF FF FF FF 
1479   B3C8 FF FF FF FF 
1479   B3CC FF FF FF FF 
1479   B3D0 FF FF FF FF 
1479   B3D4 FF FF FF FF 
1479   B3D8 FF FF FF FF 
1479   B3DC FF FF FF FF 
1479   B3E0 FF FF FF FF 
1479   B3E4 FF FF FF FF 
1479   B3E8 FF FF FF FF 
1479   B3EC FF FF FF FF 
1479   B3F0 FF FF FF FF 
1479   B3F4 FF FF FF FF 
1479   B3F8 FF FF FF FF 
1479   B3FC FF FF FF FF 
1479   B400 FF FF FF FF 
1479   B404 FF FF FF FF 
1479   B408 FF FF FF FF 
1479   B40C FF FF FF FF 
1479   B410 FF FF FF FF 
1479   B414 FF FF FF FF 
1479   B418 FF FF FF FF 
1479   B41C FF FF FF FF 
1479   B420 FF FF FF FF 
1479   B424 FF FF FF FF 
1479   B428 FF FF FF FF 
1479   B42C FF FF FF FF 
1479   B430 FF FF FF FF 
1479   B434 FF FF FF FF 
1479   B438 FF FF FF FF 
1479   B43C FF FF FF FF 
1479   B440 FF FF FF FF 
1479   B444 FF FF FF FF 
1479   B448 FF FF FF FF 
1479   B44C FF FF FF FF 
1479   B450 FF FF FF FF 
1479   B454 FF FF FF FF 
1479   B458 FF FF FF FF 
1479   B45C FF FF FF FF 
1479   B460 FF FF FF FF 
1479   B464 FF FF FF FF 
1479   B468 FF FF FF FF 
1479   B46C FF FF FF FF 
1479   B470 FF FF FF FF 
1479   B474 FF FF FF FF 
1479   B478 FF FF FF FF 
1479   B47C FF FF FF FF 
1479   B480 FF FF FF FF 
1479   B484 FF FF FF FF 
1479   B488 FF FF FF FF 
1479   B48C FF FF FF FF 
1479   B490 FF FF FF FF 
1479   B494 FF FF FF FF 
1479   B498 FF FF FF FF 
1479   B49C FF FF FF FF 
1479   B4A0 FF FF FF FF 
1479   B4A4 FF FF FF FF 
1479   B4A8 FF FF FF FF 
1479   B4AC FF FF FF FF 
1479   B4B0 FF FF FF FF 
1479   B4B4 FF FF FF FF 
1479   B4B8 FF FF FF FF 
1479   B4BC FF FF FF FF 
1479   B4C0 FF FF FF FF 
1479   B4C4 FF FF FF FF 
1479   B4C8 FF FF FF FF 
1479   B4CC FF FF FF FF 
1479   B4D0 FF FF FF FF 
1479   B4D4 FF FF FF FF 
1479   B4D8 FF FF FF FF 
1479   B4DC FF FF FF FF 
1479   B4E0 FF FF FF FF 
1479   B4E4 FF FF FF FF 
1479   B4E8 FF FF FF FF 
1479   B4EC FF FF FF FF 
1479   B4F0 FF FF FF FF 
1479   B4F4 FF FF FF FF 
1479   B4F8 FF FF FF FF 
1479   B4FC FF FF FF FF 
1479   B500 FF FF FF FF 
1479   B504 FF FF FF FF 
1479   B508 FF FF FF FF 
1479   B50C FF FF FF FF 
1479   B510 FF FF FF FF 
1479   B514 FF FF FF FF 
1479   B518 FF FF FF FF 
1479   B51C FF FF FF FF 
1479   B520 FF FF FF FF 
1479   B524 FF FF FF FF 
1479   B528 FF FF FF FF 
1479   B52C FF FF FF FF 
1479   B530 FF FF FF FF 
1479   B534 FF FF FF FF 
1479   B538 FF FF FF FF 
1479   B53C FF FF FF FF 
1479   B540 FF FF FF FF 
1479   B544 FF FF FF FF 
1479   B548 FF FF FF FF 
1479   B54C FF FF FF FF 
1479   B550 FF FF FF FF 
1479   B554 FF FF FF FF 
1479   B558 FF FF FF FF 
1479   B55C FF FF FF FF 
1479   B560 FF FF FF FF 
1479   B564 FF FF FF FF 
1479   B568 FF FF FF FF 
1479   B56C FF FF FF FF 
1479   B570 FF FF FF FF 
1479   B574 FF FF FF FF 
1479   B578 FF FF FF FF 
1479   B57C FF FF FF FF 
1479   B580 FF FF FF FF 
1479   B584 FF FF FF FF 
1479   B588 FF FF FF FF 
1479   B58C FF FF FF FF 
1479   B590 FF FF FF FF 
1479   B594 FF FF FF FF 
1479   B598 FF FF FF FF 
1479   B59C FF FF FF FF 
1479   B5A0 FF FF FF FF 
1479   B5A4 FF FF FF FF 
1479   B5A8 FF FF FF FF 
1479   B5AC FF FF FF FF 
1479   B5B0 FF FF FF FF 
1479   B5B4 FF FF FF FF 
1479   B5B8 FF FF FF FF 
1479   B5BC FF FF FF FF 
1479   B5C0 FF FF FF FF 
1479   B5C4 FF FF FF FF 
1479   B5C8 FF FF FF FF 
1479   B5CC FF FF FF FF 
1479   B5D0 FF FF FF FF 
1479   B5D4 FF FF FF FF 
1479   B5D8 FF FF FF FF 
1479   B5DC FF FF FF FF 
1479   B5E0 FF FF FF FF 
1479   B5E4 FF FF FF FF 
1479   B5E8 FF FF FF FF 
1479   B5EC FF FF FF FF 
1479   B5F0 FF FF FF FF 
1479   B5F4 FF FF FF FF 
1479   B5F8 FF FF FF FF 
1479   B5FC FF FF FF FF 
1479   B600 FF FF FF FF 
1479   B604 FF FF FF FF 
1479   B608 FF FF FF FF 
1479   B60C FF FF FF FF 
1479   B610 FF FF FF FF 
1479   B614 FF FF FF FF 
1479   B618 FF FF FF FF 
1479   B61C FF FF FF FF 
1479   B620 FF FF FF FF 
1479   B624 FF FF FF FF 
1479   B628 FF FF FF FF 
1479   B62C FF FF FF FF 
1479   B630 FF FF FF FF 
1479   B634 FF FF FF FF 
1479   B638 FF FF FF FF 
1479   B63C FF FF FF FF 
1479   B640 FF FF FF FF 
1479   B644 FF FF FF FF 
1479   B648 FF FF FF FF 
1479   B64C FF FF FF FF 
1479   B650 FF FF FF FF 
1479   B654 FF FF FF FF 
1479   B658 FF FF FF FF 
1479   B65C FF FF FF FF 
1479   B660 FF FF FF FF 
1479   B664 FF FF FF FF 
1479   B668 FF FF FF FF 
1479   B66C FF FF FF FF 
1479   B670 FF FF FF FF 
1479   B674 FF FF FF FF 
1479   B678 FF FF FF FF 
1479   B67C FF FF FF FF 
1479   B680 FF FF FF FF 
1479   B684 FF FF FF FF 
1479   B688 FF FF FF FF 
1479   B68C FF FF FF FF 
1479   B690 FF FF FF FF 
1479   B694 FF FF FF FF 
1479   B698 FF FF FF FF 
1479   B69C FF FF FF FF 
1479   B6A0 FF FF FF FF 
1479   B6A4 FF FF FF FF 
1479   B6A8 FF FF FF FF 
1479   B6AC FF FF FF FF 
1479   B6B0 FF FF FF FF 
1479   B6B4 FF FF FF FF 
1479   B6B8 FF FF FF FF 
1479   B6BC FF FF FF FF 
1479   B6C0 FF FF FF FF 
1479   B6C4 FF FF FF FF 
1479   B6C8 FF FF FF FF 
1479   B6CC FF FF FF FF 
1479   B6D0 FF FF FF FF 
1479   B6D4 FF FF FF FF 
1479   B6D8 FF FF FF FF 
1479   B6DC FF FF FF FF 
1479   B6E0 FF FF FF FF 
1479   B6E4 FF FF FF FF 
1479   B6E8 FF FF FF FF 
1479   B6EC FF FF FF FF 
1479   B6F0 FF FF FF FF 
1479   B6F4 FF FF FF FF 
1479   B6F8 FF FF FF FF 
1479   B6FC FF FF FF FF 
1479   B700 FF FF FF FF 
1479   B704 FF FF FF FF 
1479   B708 FF FF FF FF 
1479   B70C FF FF FF FF 
1479   B710 FF FF FF FF 
1479   B714 FF FF FF FF 
1479   B718 FF FF FF FF 
1479   B71C FF FF FF FF 
1479   B720 FF FF FF FF 
1479   B724 FF FF FF FF 
1479   B728 FF FF FF FF 
1479   B72C FF FF FF FF 
1479   B730 FF FF FF FF 
1479   B734 FF FF FF FF 
1479   B738 FF FF FF FF 
1479   B73C FF FF FF FF 
1479   B740 FF FF FF FF 
1479   B744 FF FF FF FF 
1479   B748 FF FF FF FF 
1479   B74C FF FF FF FF 
1479   B750 FF FF FF FF 
1479   B754 FF FF FF FF 
1479   B758 FF FF FF FF 
1479   B75C FF FF FF FF 
1479   B760 FF FF FF FF 
1479   B764 FF FF FF FF 
1479   B768 FF FF FF FF 
1479   B76C FF FF FF FF 
1479   B770 FF FF FF FF 
1479   B774 FF FF FF FF 
1479   B778 FF FF FF FF 
1479   B77C FF FF FF FF 
1479   B780 FF FF FF FF 
1479   B784 FF FF FF FF 
1479   B788 FF FF FF FF 
1479   B78C FF FF FF FF 
1479   B790 FF FF FF FF 
1479   B794 FF FF FF FF 
1479   B798 FF FF FF FF 
1479   B79C FF FF FF FF 
1479   B7A0 FF FF FF FF 
1479   B7A4 FF FF FF FF 
1479   B7A8 FF FF FF FF 
1479   B7AC FF FF FF FF 
1479   B7B0 FF FF FF FF 
1479   B7B4 FF FF FF FF 
1479   B7B8 FF FF FF FF 
1479   B7BC FF FF FF FF 
1479   B7C0 FF FF FF FF 
1479   B7C4 FF FF FF FF 
1479   B7C8 FF FF FF FF 
1479   B7CC FF FF FF FF 
1479   B7D0 FF FF FF FF 
1479   B7D4 FF FF FF FF 
1479   B7D8 FF FF FF FF 
1479   B7DC FF FF FF FF 
1479   B7E0 FF FF FF FF 
1479   B7E4 FF FF FF FF 
1479   B7E8 FF FF FF FF 
1479   B7EC FF FF FF FF 
1479   B7F0 FF FF FF FF 
1479   B7F4 FF FF FF FF 
1479   B7F8 FF FF FF FF 
1479   B7FC FF FF FF FF 
1479   B800 FF FF FF FF 
1479   B804 FF FF FF FF 
1479   B808 FF FF FF FF 
1479   B80C FF FF FF FF 
1479   B810 FF FF FF FF 
1479   B814 FF FF FF FF 
1479   B818 FF FF FF FF 
1479   B81C FF FF FF FF 
1479   B820 FF FF FF FF 
1479   B824 FF FF FF FF 
1479   B828 FF FF FF FF 
1479   B82C FF FF FF FF 
1479   B830 FF FF FF FF 
1479   B834 FF FF FF FF 
1479   B838 FF FF FF FF 
1479   B83C FF FF FF FF 
1479   B840 FF FF FF FF 
1479   B844 FF FF FF FF 
1479   B848 FF FF FF FF 
1479   B84C FF FF FF FF 
1479   B850 FF FF FF FF 
1479   B854 FF FF FF FF 
1479   B858 FF FF FF FF 
1479   B85C FF FF FF FF 
1479   B860 FF FF FF FF 
1479   B864 FF FF FF FF 
1479   B868 FF FF FF FF 
1479   B86C FF FF FF FF 
1479   B870 FF FF FF FF 
1479   B874 FF FF FF FF 
1479   B878 FF FF FF FF 
1479   B87C FF FF FF FF 
1479   B880 FF FF FF FF 
1479   B884 FF FF FF FF 
1479   B888 FF FF FF FF 
1479   B88C FF FF FF FF 
1479   B890 FF FF FF FF 
1479   B894 FF FF FF FF 
1479   B898 FF FF FF FF 
1479   B89C FF FF FF FF 
1479   B8A0 FF FF FF FF 
1479   B8A4 FF FF FF FF 
1479   B8A8 FF FF FF FF 
1479   B8AC FF FF FF FF 
1479   B8B0 FF FF FF FF 
1479   B8B4 FF FF FF FF 
1479   B8B8 FF FF FF FF 
1479   B8BC FF FF FF FF 
1479   B8C0 FF FF FF FF 
1479   B8C4 FF FF FF FF 
1479   B8C8 FF FF FF FF 
1479   B8CC FF FF FF FF 
1479   B8D0 FF FF FF FF 
1479   B8D4 FF FF FF FF 
1479   B8D8 FF FF FF FF 
1479   B8DC FF FF FF FF 
1479   B8E0 FF FF FF FF 
1479   B8E4 FF FF FF FF 
1479   B8E8 FF FF FF FF 
1479   B8EC FF FF FF FF 
1479   B8F0 FF FF FF FF 
1479   B8F4 FF FF FF FF 
1479   B8F8 FF FF FF FF 
1479   B8FC FF FF FF FF 
1479   B900 FF FF FF FF 
1479   B904 FF FF FF FF 
1479   B908 FF FF FF FF 
1479   B90C FF FF FF FF 
1479   B910 FF FF FF FF 
1479   B914 FF FF FF FF 
1479   B918 FF FF FF FF 
1479   B91C FF FF FF FF 
1479   B920 FF FF FF FF 
1479   B924 FF FF FF FF 
1479   B928 FF FF FF FF 
1479   B92C FF FF FF FF 
1479   B930 FF FF FF FF 
1479   B934 FF FF FF FF 
1479   B938 FF FF FF FF 
1479   B93C FF FF FF FF 
1479   B940 FF FF FF FF 
1479   B944 FF FF FF FF 
1479   B948 FF FF FF FF 
1479   B94C FF FF FF FF 
1479   B950 FF FF FF FF 
1479   B954 FF FF FF FF 
1479   B958 FF FF FF FF 
1479   B95C FF FF FF FF 
1479   B960 FF FF FF FF 
1479   B964 FF FF FF FF 
1479   B968 FF FF FF FF 
1479   B96C FF FF FF FF 
1479   B970 FF FF FF FF 
1479   B974 FF FF FF FF 
1479   B978 FF FF FF FF 
1479   B97C FF FF FF FF 
1479   B980 FF FF FF FF 
1479   B984 FF FF FF FF 
1479   B988 FF FF FF FF 
1479   B98C FF FF FF FF 
1479   B990 FF FF FF FF 
1479   B994 FF FF FF FF 
1479   B998 FF FF FF FF 
1479   B99C FF FF FF FF 
1479   B9A0 FF FF FF FF 
1479   B9A4 FF FF FF FF 
1479   B9A8 FF FF FF FF 
1479   B9AC FF FF FF FF 
1479   B9B0 FF FF FF FF 
1479   B9B4 FF FF FF FF 
1479   B9B8 FF FF FF FF 
1479   B9BC FF FF FF FF 
1479   B9C0 FF FF FF FF 
1479   B9C4 FF FF FF FF 
1479   B9C8 FF FF FF FF 
1479   B9CC FF FF FF FF 
1479   B9D0 FF FF FF FF 
1479   B9D4 FF FF FF FF 
1479   B9D8 FF FF FF FF 
1479   B9DC FF FF FF FF 
1479   B9E0 FF FF FF FF 
1479   B9E4 FF FF FF FF 
1479   B9E8 FF FF FF FF 
1479   B9EC FF FF FF FF 
1479   B9F0 FF FF FF FF 
1479   B9F4 FF FF FF FF 
1479   B9F8 FF FF FF FF 
1479   B9FC FF FF FF FF 
1479   BA00 FF FF FF FF 
1479   BA04 FF FF FF FF 
1479   BA08 FF FF FF FF 
1479   BA0C FF FF FF FF 
1479   BA10 FF FF FF FF 
1479   BA14 FF FF FF FF 
1479   BA18 FF FF FF FF 
1479   BA1C FF FF FF FF 
1479   BA20 FF FF FF FF 
1479   BA24 FF FF FF FF 
1479   BA28 FF FF FF FF 
1479   BA2C FF FF FF FF 
1479   BA30 FF FF FF FF 
1479   BA34 FF FF FF FF 
1479   BA38 FF FF FF FF 
1479   BA3C FF FF FF FF 
1479   BA40 FF FF FF FF 
1479   BA44 FF FF FF FF 
1479   BA48 FF FF FF FF 
1479   BA4C FF FF FF FF 
1479   BA50 FF FF FF FF 
1479   BA54 FF FF FF FF 
1479   BA58 FF FF FF FF 
1479   BA5C FF FF FF FF 
1479   BA60 FF FF FF FF 
1479   BA64 FF FF FF FF 
1479   BA68 FF FF FF FF 
1479   BA6C FF FF FF FF 
1479   BA70 FF FF FF FF 
1479   BA74 FF FF FF FF 
1479   BA78 FF FF FF FF 
1479   BA7C FF FF FF FF 
1479   BA80 FF FF FF FF 
1479   BA84 FF FF FF FF 
1479   BA88 FF FF FF FF 
1479   BA8C FF FF FF FF 
1479   BA90 FF FF FF FF 
1479   BA94 FF FF FF FF 
1479   BA98 FF FF FF FF 
1479   BA9C FF FF FF FF 
1479   BAA0 FF FF FF FF 
1479   BAA4 FF FF FF FF 
1479   BAA8 FF FF FF FF 
1479   BAAC FF FF FF FF 
1479   BAB0 FF FF FF FF 
1479   BAB4 FF FF FF FF 
1479   BAB8 FF FF FF FF 
1479   BABC FF FF FF FF 
1479   BAC0 FF FF FF FF 
1479   BAC4 FF FF FF FF 
1479   BAC8 FF FF FF FF 
1479   BACC FF FF FF FF 
1479   BAD0 FF FF FF FF 
1479   BAD4 FF FF FF FF 
1479   BAD8 FF FF FF FF 
1479   BADC FF FF FF FF 
1479   BAE0 FF FF FF FF 
1479   BAE4 FF FF FF FF 
1479   BAE8 FF FF FF FF 
1479   BAEC FF FF FF FF 
1479   BAF0 FF FF FF FF 
1479   BAF4 FF FF FF FF 
1479   BAF8 FF FF FF FF 
1479   BAFC FF FF FF FF 
1479   BB00 FF FF FF FF 
1479   BB04 FF FF FF FF 
1479   BB08 FF FF FF FF 
1479   BB0C FF FF FF FF 
1479   BB10 FF FF FF FF 
1479   BB14 FF FF FF FF 
1479   BB18 FF FF FF FF 
1479   BB1C FF FF FF FF 
1479   BB20 FF FF FF FF 
1479   BB24 FF FF FF FF 
1479   BB28 FF FF FF FF 
1479   BB2C FF FF FF FF 
1479   BB30 FF FF FF FF 
1479   BB34 FF FF FF FF 
1479   BB38 FF FF FF FF 
1479   BB3C FF FF FF FF 
1479   BB40 FF FF FF FF 
1479   BB44 FF FF FF FF 
1479   BB48 FF FF FF FF 
1479   BB4C FF FF FF FF 
1479   BB50 FF FF FF FF 
1479   BB54 FF FF FF FF 
1479   BB58 FF FF FF FF 
1479   BB5C FF FF FF FF 
1479   BB60 FF FF FF FF 
1479   BB64 FF FF FF FF 
1479   BB68 FF FF FF FF 
1479   BB6C FF FF FF FF 
1479   BB70 FF FF FF FF 
1479   BB74 FF FF FF FF 
1479   BB78 FF FF FF FF 
1479   BB7C FF FF FF FF 
1479   BB80 FF FF FF FF 
1479   BB84 FF FF FF FF 
1479   BB88 FF FF FF FF 
1479   BB8C FF FF FF FF 
1479   BB90 FF FF FF FF 
1479   BB94 FF FF FF FF 
1479   BB98 FF FF FF FF 
1479   BB9C FF FF FF FF 
1479   BBA0 FF FF FF FF 
1479   BBA4 FF FF FF FF 
1479   BBA8 FF FF FF FF 
1479   BBAC FF FF FF FF 
1479   BBB0 FF FF FF FF 
1479   BBB4 FF FF FF FF 
1479   BBB8 FF FF FF FF 
1479   BBBC FF FF FF FF 
1479   BBC0 FF FF FF FF 
1479   BBC4 FF FF FF FF 
1479   BBC8 FF FF FF FF 
1479   BBCC FF FF FF FF 
1479   BBD0 FF FF FF FF 
1479   BBD4 FF FF FF FF 
1479   BBD8 FF FF FF FF 
1479   BBDC FF FF FF FF 
1479   BBE0 FF FF FF FF 
1479   BBE4 FF FF FF FF 
1479   BBE8 FF FF FF FF 
1479   BBEC FF FF FF FF 
1479   BBF0 FF FF FF FF 
1479   BBF4 FF FF FF FF 
1479   BBF8 FF FF FF FF 
1479   BBFC FF FF FF FF 
1479   BC00 FF FF FF FF 
1479   BC04 FF FF FF FF 
1479   BC08 FF FF FF FF 
1479   BC0C FF FF FF FF 
1479   BC10 FF FF FF FF 
1479   BC14 FF FF FF FF 
1479   BC18 FF FF FF FF 
1479   BC1C FF FF FF FF 
1479   BC20 FF FF FF FF 
1479   BC24 FF FF FF FF 
1479   BC28 FF FF FF FF 
1479   BC2C FF FF FF FF 
1479   BC30 FF FF FF FF 
1479   BC34 FF FF FF FF 
1479   BC38 FF FF FF FF 
1479   BC3C FF FF FF FF 
1479   BC40 FF FF FF FF 
1479   BC44 FF FF FF FF 
1479   BC48 FF FF FF FF 
1479   BC4C FF FF FF FF 
1479   BC50 FF FF FF FF 
1479   BC54 FF FF FF FF 
1479   BC58 FF FF FF FF 
1479   BC5C FF FF FF FF 
1479   BC60 FF FF FF FF 
1479   BC64 FF FF FF FF 
1479   BC68 FF FF FF FF 
1479   BC6C FF FF FF FF 
1479   BC70 FF FF FF FF 
1479   BC74 FF FF FF FF 
1479   BC78 FF FF FF FF 
1479   BC7C FF FF FF FF 
1479   BC80 FF FF FF FF 
1479   BC84 FF FF FF FF 
1479   BC88 FF FF FF FF 
1479   BC8C FF FF FF FF 
1479   BC90 FF FF FF FF 
1479   BC94 FF FF FF FF 
1479   BC98 FF FF FF FF 
1479   BC9C FF FF FF FF 
1479   BCA0 FF FF FF FF 
1479   BCA4 FF FF FF FF 
1479   BCA8 FF FF FF FF 
1479   BCAC FF FF FF FF 
1479   BCB0 FF FF FF FF 
1479   BCB4 FF FF FF FF 
1479   BCB8 FF FF FF FF 
1479   BCBC FF FF FF FF 
1479   BCC0 FF FF FF FF 
1479   BCC4 FF FF FF FF 
1479   BCC8 FF FF FF FF 
1479   BCCC FF FF FF FF 
1479   BCD0 FF FF FF FF 
1479   BCD4 FF FF FF FF 
1479   BCD8 FF FF FF FF 
1479   BCDC FF FF FF FF 
1479   BCE0 FF FF FF FF 
1479   BCE4 FF FF FF FF 
1479   BCE8 FF FF FF FF 
1479   BCEC FF FF FF FF 
1479   BCF0 FF FF FF FF 
1479   BCF4 FF FF FF FF 
1479   BCF8 FF FF FF FF 
1479   BCFC FF FF FF FF 
1479   BD00 FF FF FF FF 
1479   BD04 FF FF FF FF 
1479   BD08 FF FF FF FF 
1479   BD0C FF FF FF FF 
1479   BD10 FF FF FF FF 
1479   BD14 FF FF FF FF 
1479   BD18 FF FF FF FF 
1479   BD1C FF FF FF FF 
1479   BD20 FF FF FF FF 
1479   BD24 FF FF FF FF 
1479   BD28 FF FF FF FF 
1479   BD2C FF FF FF FF 
1479   BD30 FF FF FF FF 
1479   BD34 FF FF FF FF 
1479   BD38 FF FF FF FF 
1479   BD3C FF FF FF FF 
1479   BD40 FF FF FF FF 
1479   BD44 FF FF FF FF 
1479   BD48 FF FF FF FF 
1479   BD4C FF FF FF FF 
1479   BD50 FF FF FF FF 
1479   BD54 FF FF FF FF 
1479   BD58 FF FF FF FF 
1479   BD5C FF FF FF FF 
1479   BD60 FF FF FF FF 
1479   BD64 FF FF FF FF 
1479   BD68 FF FF FF FF 
1479   BD6C FF FF FF FF 
1479   BD70 FF FF FF FF 
1479   BD74 FF FF FF FF 
1479   BD78 FF FF FF FF 
1479   BD7C FF FF FF FF 
1479   BD80 FF FF FF FF 
1479   BD84 FF FF FF FF 
1479   BD88 FF FF FF FF 
1479   BD8C FF FF FF FF 
1479   BD90 FF FF FF FF 
1479   BD94 FF FF FF FF 
1479   BD98 FF FF FF FF 
1479   BD9C FF FF FF FF 
1479   BDA0 FF FF FF FF 
1479   BDA4 FF FF FF FF 
1479   BDA8 FF FF FF FF 
1479   BDAC FF FF FF FF 
1479   BDB0 FF FF FF FF 
1479   BDB4 FF FF FF FF 
1479   BDB8 FF FF FF FF 
1479   BDBC FF FF FF FF 
1479   BDC0 FF FF FF FF 
1479   BDC4 FF FF FF FF 
1479   BDC8 FF FF FF FF 
1479   BDCC FF FF FF FF 
1479   BDD0 FF FF FF FF 
1479   BDD4 FF FF FF FF 
1479   BDD8 FF FF FF FF 
1479   BDDC FF FF FF FF 
1479   BDE0 FF FF FF FF 
1479   BDE4 FF FF FF FF 
1479   BDE8 FF FF FF FF 
1479   BDEC FF FF FF FF 
1479   BDF0 FF FF FF FF 
1479   BDF4 FF FF FF FF 
1479   BDF8 FF FF FF FF 
1479   BDFC FF FF FF FF 
1479   BE00 FF FF FF FF 
1479   BE04 FF FF FF FF 
1479   BE08 FF FF FF FF 
1479   BE0C FF FF FF FF 
1479   BE10 FF FF FF FF 
1479   BE14 FF FF FF FF 
1479   BE18 FF FF FF FF 
1479   BE1C FF FF FF FF 
1479   BE20 FF FF FF FF 
1479   BE24 FF FF FF FF 
1479   BE28 FF FF FF FF 
1479   BE2C FF FF FF FF 
1479   BE30 FF FF FF FF 
1479   BE34 FF FF FF FF 
1479   BE38 FF FF FF FF 
1479   BE3C FF FF FF FF 
1479   BE40 FF FF FF FF 
1479   BE44 FF FF FF FF 
1479   BE48 FF FF FF FF 
1479   BE4C FF FF FF FF 
1479   BE50 FF FF FF FF 
1479   BE54 FF FF FF FF 
1479   BE58 FF FF FF FF 
1479   BE5C FF FF FF FF 
1479   BE60 FF FF FF FF 
1479   BE64 FF FF FF FF 
1479   BE68 FF FF FF FF 
1479   BE6C FF FF FF FF 
1479   BE70 FF FF FF FF 
1479   BE74 FF FF FF FF 
1479   BE78 FF FF FF FF 
1479   BE7C FF FF FF FF 
1479   BE80 FF FF FF FF 
1479   BE84 FF FF FF FF 
1479   BE88 FF FF FF FF 
1479   BE8C FF FF FF FF 
1479   BE90 FF FF FF FF 
1479   BE94 FF FF FF FF 
1479   BE98 FF FF FF FF 
1479   BE9C FF FF FF FF 
1479   BEA0 FF FF FF FF 
1479   BEA4 FF FF FF FF 
1479   BEA8 FF FF FF FF 
1479   BEAC FF FF FF FF 
1479   BEB0 FF FF FF FF 
1479   BEB4 FF FF FF FF 
1479   BEB8 FF FF FF FF 
1479   BEBC FF FF FF FF 
1479   BEC0 FF FF FF FF 
1479   BEC4 FF FF FF FF 
1479   BEC8 FF FF FF FF 
1479   BECC FF FF FF FF 
1479   BED0 FF FF FF FF 
1479   BED4 FF FF FF FF 
1479   BED8 FF FF FF FF 
1479   BEDC FF FF FF FF 
1479   BEE0 FF FF FF FF 
1479   BEE4 FF FF FF FF 
1479   BEE8 FF FF FF FF 
1479   BEEC FF FF FF FF 
1479   BEF0 FF FF FF FF 
1479   BEF4 FF FF FF FF 
1479   BEF8 FF FF FF FF 
1479   BEFC FF FF FF FF 
1479   BF00 FF FF FF FF 
1479   BF04 FF FF FF FF 
1479   BF08 FF FF FF FF 
1479   BF0C FF FF FF FF 
1479   BF10 FF FF FF FF 
1479   BF14 FF FF FF FF 
1479   BF18 FF FF FF FF 
1479   BF1C FF FF FF FF 
1479   BF20 FF FF FF FF 
1479   BF24 FF FF FF FF 
1479   BF28 FF FF FF FF 
1479   BF2C FF FF FF FF 
1479   BF30 FF FF FF FF 
1479   BF34 FF FF FF FF 
1479   BF38 FF FF FF FF 
1479   BF3C FF FF FF FF 
1479   BF40 FF FF FF FF 
1479   BF44 FF FF FF FF 
1479   BF48 FF FF FF FF 
1479   BF4C FF FF FF FF 
1479   BF50 FF FF FF FF 
1479   BF54 FF FF FF FF 
1479   BF58 FF FF FF FF 
1479   BF5C FF FF FF FF 
1479   BF60 FF FF FF FF 
1479   BF64 FF FF FF FF 
1479   BF68 FF FF FF FF 
1479   BF6C FF FF FF FF 
1479   BF70 FF FF FF FF 
1479   BF74 FF FF FF FF 
1479   BF78 FF FF FF FF 
1479   BF7C FF FF FF FF 
1479   BF80 FF FF FF FF 
1479   BF84 FF FF FF FF 
1479   BF88 FF FF FF FF 
1479   BF8C FF FF FF FF 
1479   BF90 FF FF FF FF 
1479   BF94 FF FF FF FF 
1479   BF98 FF FF FF FF 
1479   BF9C FF FF FF FF 
1479   BFA0 FF FF FF FF 
1479   BFA4 FF FF FF FF 
1479   BFA8 FF FF FF FF 
1479   BFAC FF FF FF FF 
1479   BFB0 FF FF FF FF 
1479   BFB4 FF FF FF FF 
1479   BFB8 FF FF FF FF 
1479   BFBC FF FF FF FF 
1479   BFC0 FF FF FF FF 
1479   BFC4 FF FF FF FF 
1479   BFC8 FF FF FF FF 
1479   BFCC FF FF FF FF 
1479   BFD0 FF FF FF FF 
1479   BFD4 FF FF FF FF 
1479   BFD8 FF FF FF FF 
1479   BFDC FF FF FF FF 
1479   BFE0 FF FF FF FF 
1479   BFE4 FF FF FF FF 
1479   BFE8 FF FF FF FF 
1479   BFEC FF FF FF FF 
1479   BFF0 FF FF FF FF 
1479   BFF4 FF FF FF FF 
1479   BFF8 FF FF FF FF 
1479   BFFC FF FF FF FF 
1479   C000 FF FF FF FF 
1479   C004 FF FF FF FF 
1479   C008 FF FF FF FF 
1479   C00C FF FF FF FF 
1479   C010 FF FF FF FF 
1479   C014 FF FF FF FF 
1479   C018 FF FF FF FF 
1479   C01C FF FF FF FF 
1479   C020 FF FF FF FF 
1479   C024 FF FF FF FF 
1479   C028 FF FF FF FF 
1479   C02C FF FF FF FF 
1479   C030 FF FF FF FF 
1479   C034 FF FF FF FF 
1479   C038 FF FF FF FF 
1479   C03C FF FF FF FF 
1479   C040 FF FF FF FF 
1479   C044 FF FF FF FF 
1479   C048 FF FF FF FF 
1479   C04C FF FF FF FF 
1479   C050 FF FF FF FF 
1479   C054 FF FF FF FF 
1479   C058 FF FF FF FF 
1479   C05C FF FF FF FF 
1479   C060 FF FF FF FF 
1479   C064 FF FF FF FF 
1479   C068 FF FF FF FF 
1479   C06C FF FF FF FF 
1479   C070 FF FF FF FF 
1479   C074 FF FF FF FF 
1479   C078 FF FF FF FF 
1479   C07C FF FF FF FF 
1479   C080 FF FF FF FF 
1479   C084 FF FF FF FF 
1479   C088 FF FF FF FF 
1479   C08C FF FF FF FF 
1479   C090 FF FF FF FF 
1479   C094 FF FF FF FF 
1479   C098 FF FF FF FF 
1479   C09C FF FF FF FF 
1479   C0A0 FF FF FF FF 
1479   C0A4 FF FF FF FF 
1479   C0A8 FF FF FF FF 
1479   C0AC FF FF FF FF 
1479   C0B0 FF FF FF FF 
1479   C0B4 FF FF FF FF 
1479   C0B8 FF FF FF FF 
1479   C0BC FF FF FF FF 
1479   C0C0 FF FF FF FF 
1479   C0C4 FF FF FF FF 
1479   C0C8 FF FF FF FF 
1479   C0CC FF FF FF FF 
1479   C0D0 FF FF FF FF 
1479   C0D4 FF FF FF FF 
1479   C0D8 FF FF FF FF 
1479   C0DC FF FF FF FF 
1479   C0E0 FF FF FF FF 
1479   C0E4 FF FF FF FF 
1479   C0E8 FF FF FF FF 
1479   C0EC FF FF FF FF 
1479   C0F0 FF FF FF FF 
1479   C0F4 FF FF FF FF 
1479   C0F8 FF FF FF FF 
1479   C0FC FF FF FF FF 
1479   C100 FF FF FF FF 
1479   C104 FF FF FF FF 
1479   C108 FF FF FF FF 
1479   C10C FF FF FF FF 
1479   C110 FF FF FF FF 
1479   C114 FF FF FF FF 
1479   C118 FF FF FF FF 
1479   C11C FF FF FF FF 
1479   C120 FF FF FF FF 
1479   C124 FF FF FF FF 
1479   C128 FF FF FF FF 
1479   C12C FF FF FF FF 
1479   C130 FF FF FF FF 
1479   C134 FF FF FF FF 
1479   C138 FF FF FF FF 
1479   C13C FF FF FF FF 
1479   C140 FF FF FF FF 
1479   C144 FF FF FF FF 
1479   C148 FF FF FF FF 
1479   C14C FF FF FF FF 
1479   C150 FF FF FF FF 
1479   C154 FF FF FF FF 
1479   C158 FF FF FF FF 
1479   C15C FF FF FF FF 
1479   C160 FF FF FF FF 
1479   C164 FF FF FF FF 
1479   C168 FF FF FF FF 
1479   C16C FF FF FF FF 
1479   C170 FF FF FF FF 
1479   C174 FF FF FF FF 
1479   C178 FF FF FF FF 
1479   C17C FF FF FF FF 
1479   C180 FF FF FF FF 
1479   C184 FF FF FF FF 
1479   C188 FF FF FF FF 
1479   C18C FF FF FF FF 
1479   C190 FF FF FF FF 
1479   C194 FF FF FF FF 
1479   C198 FF FF FF FF 
1479   C19C FF FF FF FF 
1479   C1A0 FF FF FF FF 
1479   C1A4 FF FF FF FF 
1479   C1A8 FF FF FF FF 
1479   C1AC FF FF FF FF 
1479   C1B0 FF FF FF FF 
1479   C1B4 FF FF FF FF 
1479   C1B8 FF FF FF FF 
1479   C1BC FF FF FF FF 
1479   C1C0 FF FF FF FF 
1479   C1C4 FF FF FF FF 
1479   C1C8 FF FF FF FF 
1479   C1CC FF FF FF FF 
1479   C1D0 FF FF FF FF 
1479   C1D4 FF FF FF FF 
1479   C1D8 FF FF FF FF 
1479   C1DC FF FF FF FF 
1479   C1E0 FF FF FF FF 
1479   C1E4 FF FF FF FF 
1479   C1E8 FF FF FF FF 
1479   C1EC FF FF FF FF 
1479   C1F0 FF FF FF FF 
1479   C1F4 FF FF FF FF 
1479   C1F8 FF FF FF FF 
1479   C1FC FF FF FF FF 
1479   C200 FF FF FF FF 
1479   C204 FF FF FF FF 
1479   C208 FF FF FF FF 
1479   C20C FF FF FF FF 
1479   C210 FF FF FF FF 
1479   C214 FF FF FF FF 
1479   C218 FF FF FF FF 
1479   C21C FF FF FF FF 
1479   C220 FF FF FF FF 
1479   C224 FF FF FF FF 
1479   C228 FF FF FF FF 
1479   C22C FF FF FF FF 
1479   C230 FF FF FF FF 
1479   C234 FF FF FF FF 
1479   C238 FF FF FF FF 
1479   C23C FF FF FF FF 
1479   C240 FF FF FF FF 
1479   C244 FF FF FF FF 
1479   C248 FF FF FF FF 
1479   C24C FF FF FF FF 
1479   C250 FF FF FF FF 
1479   C254 FF FF FF FF 
1479   C258 FF FF FF FF 
1479   C25C FF FF FF FF 
1479   C260 FF FF FF FF 
1479   C264 FF FF FF FF 
1479   C268 FF FF FF FF 
1479   C26C FF FF FF FF 
1479   C270 FF FF FF FF 
1479   C274 FF FF FF FF 
1479   C278 FF FF FF FF 
1479   C27C FF FF FF FF 
1479   C280 FF FF FF FF 
1479   C284 FF FF FF FF 
1479   C288 FF FF FF FF 
1479   C28C FF FF FF FF 
1479   C290 FF FF FF FF 
1479   C294 FF FF FF FF 
1479   C298 FF FF FF FF 
1479   C29C FF FF FF FF 
1479   C2A0 FF FF FF FF 
1479   C2A4 FF FF FF FF 
1479   C2A8 FF FF FF FF 
1479   C2AC FF FF FF FF 
1479   C2B0 FF FF FF FF 
1479   C2B4 FF FF FF FF 
1479   C2B8 FF FF FF FF 
1479   C2BC FF FF FF FF 
1479   C2C0 FF FF FF FF 
1479   C2C4 FF FF FF FF 
1479   C2C8 FF FF FF FF 
1479   C2CC FF FF FF FF 
1479   C2D0 FF FF FF FF 
1479   C2D4 FF FF FF FF 
1479   C2D8 FF FF FF FF 
1479   C2DC FF FF FF FF 
1479   C2E0 FF FF FF FF 
1479   C2E4 FF FF FF FF 
1479   C2E8 FF FF FF FF 
1479   C2EC FF FF FF FF 
1479   C2F0 FF FF FF FF 
1479   C2F4 FF FF FF FF 
1479   C2F8 FF FF FF FF 
1479   C2FC FF FF FF FF 
1479   C300 FF FF FF FF 
1479   C304 FF FF FF FF 
1479   C308 FF FF FF FF 
1479   C30C FF FF FF FF 
1479   C310 FF FF FF FF 
1479   C314 FF FF FF FF 
1479   C318 FF FF FF FF 
1479   C31C FF FF FF FF 
1479   C320 FF FF FF FF 
1479   C324 FF FF FF FF 
1479   C328 FF FF FF FF 
1479   C32C FF FF FF FF 
1479   C330 FF FF FF FF 
1479   C334 FF FF FF FF 
1479   C338 FF FF FF FF 
1479   C33C FF FF FF FF 
1479   C340 FF FF FF FF 
1479   C344 FF FF FF FF 
1479   C348 FF FF FF FF 
1479   C34C FF FF FF FF 
1479   C350 FF FF FF FF 
1479   C354 FF FF FF FF 
1479   C358 FF FF FF FF 
1479   C35C FF FF FF FF 
1479   C360 FF FF FF FF 
1479   C364 FF FF FF FF 
1479   C368 FF FF FF FF 
1479   C36C FF FF FF FF 
1479   C370 FF FF FF FF 
1479   C374 FF FF FF FF 
1479   C378 FF FF FF FF 
1479   C37C FF FF FF FF 
1479   C380 FF FF FF FF 
1479   C384 FF FF FF FF 
1479   C388 FF FF FF FF 
1479   C38C FF FF FF FF 
1479   C390 FF FF FF FF 
1479   C394 FF FF FF FF 
1479   C398 FF FF FF FF 
1479   C39C FF FF FF FF 
1479   C3A0 FF FF FF FF 
1479   C3A4 FF FF FF FF 
1479   C3A8 FF FF FF FF 
1479   C3AC FF FF FF FF 
1479   C3B0 FF FF FF FF 
1479   C3B4 FF FF FF FF 
1479   C3B8 FF FF FF FF 
1479   C3BC FF FF FF FF 
1479   C3C0 FF FF FF FF 
1479   C3C4 FF FF FF FF 
1479   C3C8 FF FF FF FF 
1479   C3CC FF FF FF FF 
1479   C3D0 FF FF FF FF 
1479   C3D4 FF FF FF FF 
1479   C3D8 FF FF FF FF 
1479   C3DC FF FF FF FF 
1479   C3E0 FF FF FF FF 
1479   C3E4 FF FF FF FF 
1479   C3E8 FF FF FF FF 
1479   C3EC FF FF FF FF 
1479   C3F0 FF FF FF FF 
1479   C3F4 FF FF FF FF 
1479   C3F8 FF FF FF FF 
1479   C3FC FF FF FF FF 
1479   C400 FF FF FF FF 
1479   C404 FF FF FF FF 
1479   C408 FF FF FF FF 
1479   C40C FF FF FF FF 
1479   C410 FF FF FF FF 
1479   C414 FF FF FF FF 
1479   C418 FF FF FF FF 
1479   C41C FF FF FF FF 
1479   C420 FF FF FF FF 
1479   C424 FF FF FF FF 
1479   C428 FF FF FF FF 
1479   C42C FF FF FF FF 
1479   C430 FF FF FF FF 
1479   C434 FF FF FF FF 
1479   C438 FF FF FF FF 
1479   C43C FF FF FF FF 
1479   C440 FF FF FF FF 
1479   C444 FF FF FF FF 
1479   C448 FF FF FF FF 
1479   C44C FF FF FF FF 
1479   C450 FF FF FF FF 
1479   C454 FF FF FF FF 
1479   C458 FF FF FF FF 
1479   C45C FF FF FF FF 
1479   C460 FF FF FF FF 
1479   C464 FF FF FF FF 
1479   C468 FF FF FF FF 
1479   C46C FF FF FF FF 
1479   C470 FF FF FF FF 
1479   C474 FF FF FF FF 
1479   C478 FF FF FF FF 
1479   C47C FF FF FF FF 
1479   C480 FF FF FF FF 
1479   C484 FF FF FF FF 
1479   C488 FF FF FF FF 
1479   C48C FF FF FF FF 
1479   C490 FF FF FF FF 
1479   C494 FF FF FF FF 
1479   C498 FF FF FF FF 
1479   C49C FF FF FF FF 
1479   C4A0 FF FF FF FF 
1479   C4A4 FF FF FF FF 
1479   C4A8 FF FF FF FF 
1479   C4AC FF FF FF FF 
1479   C4B0 FF FF FF FF 
1479   C4B4 FF FF FF FF 
1479   C4B8 FF FF FF FF 
1479   C4BC FF FF FF FF 
1479   C4C0 FF FF FF FF 
1479   C4C4 FF FF FF FF 
1479   C4C8 FF FF FF FF 
1479   C4CC FF FF FF FF 
1479   C4D0 FF FF FF FF 
1479   C4D4 FF FF FF FF 
1479   C4D8 FF FF FF FF 
1479   C4DC FF FF FF FF 
1479   C4E0 FF FF FF FF 
1479   C4E4 FF FF FF FF 
1479   C4E8 FF FF FF FF 
1479   C4EC FF FF FF FF 
1479   C4F0 FF FF FF FF 
1479   C4F4 FF FF FF FF 
1479   C4F8 FF FF FF FF 
1479   C4FC FF FF FF FF 
1479   C500 FF FF FF FF 
1479   C504 FF FF FF FF 
1479   C508 FF FF FF FF 
1479   C50C FF FF FF FF 
1479   C510 FF FF FF FF 
1479   C514 FF FF FF FF 
1479   C518 FF FF FF FF 
1479   C51C FF FF FF FF 
1479   C520 FF FF FF FF 
1479   C524 FF FF FF FF 
1479   C528 FF FF FF FF 
1479   C52C FF FF FF FF 
1479   C530 FF FF FF FF 
1479   C534 FF FF FF FF 
1479   C538 FF FF FF FF 
1479   C53C FF FF FF FF 
1479   C540 FF FF FF FF 
1479   C544 FF FF FF FF 
1479   C548 FF FF FF FF 
1479   C54C FF FF FF FF 
1479   C550 FF FF FF FF 
1479   C554 FF FF FF FF 
1479   C558 FF FF FF FF 
1479   C55C FF FF FF FF 
1479   C560 FF FF FF FF 
1479   C564 FF FF FF FF 
1479   C568 FF FF FF FF 
1479   C56C FF FF FF FF 
1479   C570 FF FF FF FF 
1479   C574 FF FF FF FF 
1479   C578 FF FF FF FF 
1479   C57C FF FF FF FF 
1479   C580 FF FF FF FF 
1479   C584 FF FF FF FF 
1479   C588 FF FF FF FF 
1479   C58C FF FF FF FF 
1479   C590 FF FF FF FF 
1479   C594 FF FF FF FF 
1479   C598 FF FF FF FF 
1479   C59C FF FF FF FF 
1479   C5A0 FF FF FF FF 
1479   C5A4 FF FF FF FF 
1479   C5A8 FF FF FF FF 
1479   C5AC FF FF FF FF 
1479   C5B0 FF FF FF FF 
1479   C5B4 FF FF FF FF 
1479   C5B8 FF FF FF FF 
1479   C5BC FF FF FF FF 
1479   C5C0 FF FF FF FF 
1479   C5C4 FF FF FF FF 
1479   C5C8 FF FF FF FF 
1479   C5CC FF FF FF FF 
1479   C5D0 FF FF FF FF 
1479   C5D4 FF FF FF FF 
1479   C5D8 FF FF FF FF 
1479   C5DC FF FF FF FF 
1479   C5E0 FF FF FF FF 
1479   C5E4 FF FF FF FF 
1479   C5E8 FF FF FF FF 
1479   C5EC FF FF FF FF 
1479   C5F0 FF FF FF FF 
1479   C5F4 FF FF FF FF 
1479   C5F8 FF FF FF FF 
1479   C5FC FF FF FF FF 
1479   C600 FF FF FF FF 
1479   C604 FF FF FF FF 
1479   C608 FF FF FF FF 
1479   C60C FF FF FF FF 
1479   C610 FF FF FF FF 
1479   C614 FF FF FF FF 
1479   C618 FF FF FF FF 
1479   C61C FF FF FF FF 
1479   C620 FF FF FF FF 
1479   C624 FF FF FF FF 
1479   C628 FF FF FF FF 
1479   C62C FF FF FF FF 
1479   C630 FF FF FF FF 
1479   C634 FF FF FF FF 
1479   C638 FF FF FF FF 
1479   C63C FF FF FF FF 
1479   C640 FF FF FF FF 
1479   C644 FF FF FF FF 
1479   C648 FF FF FF FF 
1479   C64C FF FF FF FF 
1479   C650 FF FF FF FF 
1479   C654 FF FF FF FF 
1479   C658 FF FF FF FF 
1479   C65C FF FF FF FF 
1479   C660 FF FF FF FF 
1479   C664 FF FF FF FF 
1479   C668 FF FF FF FF 
1479   C66C FF FF FF FF 
1479   C670 FF FF FF FF 
1479   C674 FF FF FF FF 
1479   C678 FF FF FF FF 
1479   C67C FF FF FF FF 
1479   C680 FF FF FF FF 
1479   C684 FF FF FF FF 
1479   C688 FF FF FF FF 
1479   C68C FF FF FF FF 
1479   C690 FF FF FF FF 
1479   C694 FF FF FF FF 
1479   C698 FF FF FF FF 
1479   C69C FF FF FF FF 
1479   C6A0 FF FF FF FF 
1479   C6A4 FF FF FF FF 
1479   C6A8 FF FF FF FF 
1479   C6AC FF FF FF FF 
1479   C6B0 FF FF FF FF 
1479   C6B4 FF FF FF FF 
1479   C6B8 FF FF FF FF 
1479   C6BC FF FF FF FF 
1479   C6C0 FF FF FF FF 
1479   C6C4 FF FF FF FF 
1479   C6C8 FF FF FF FF 
1479   C6CC FF FF FF FF 
1479   C6D0 FF FF FF FF 
1479   C6D4 FF FF FF FF 
1479   C6D8 FF FF FF FF 
1479   C6DC FF FF FF FF 
1479   C6E0 FF FF FF FF 
1479   C6E4 FF FF FF FF 
1479   C6E8 FF FF FF FF 
1479   C6EC FF FF FF FF 
1479   C6F0 FF FF FF FF 
1479   C6F4 FF FF FF FF 
1479   C6F8 FF FF FF FF 
1479   C6FC FF FF FF FF 
1479   C700 FF FF FF FF 
1479   C704 FF FF FF FF 
1479   C708 FF FF FF FF 
1479   C70C FF FF FF FF 
1479   C710 FF FF FF FF 
1479   C714 FF FF FF FF 
1479   C718 FF FF FF FF 
1479   C71C FF FF FF FF 
1479   C720 FF FF FF FF 
1479   C724 FF FF FF FF 
1479   C728 FF FF FF FF 
1479   C72C FF FF FF FF 
1479   C730 FF FF FF FF 
1479   C734 FF FF FF FF 
1479   C738 FF FF FF FF 
1479   C73C FF FF FF FF 
1479   C740 FF FF FF FF 
1479   C744 FF FF FF FF 
1479   C748 FF FF FF FF 
1479   C74C FF FF FF FF 
1479   C750 FF FF FF FF 
1479   C754 FF FF FF FF 
1479   C758 FF FF FF FF 
1479   C75C FF FF FF FF 
1479   C760 FF FF FF FF 
1479   C764 FF FF FF FF 
1479   C768 FF FF FF FF 
1479   C76C FF FF FF FF 
1479   C770 FF FF FF FF 
1479   C774 FF FF FF FF 
1479   C778 FF FF FF FF 
1479   C77C FF FF FF FF 
1479   C780 FF FF FF FF 
1479   C784 FF FF FF FF 
1479   C788 FF FF FF FF 
1479   C78C FF FF FF FF 
1479   C790 FF FF FF FF 
1479   C794 FF FF FF FF 
1479   C798 FF FF FF FF 
1479   C79C FF FF FF FF 
1479   C7A0 FF FF FF FF 
1479   C7A4 FF FF FF FF 
1479   C7A8 FF FF FF FF 
1479   C7AC FF FF FF FF 
1479   C7B0 FF FF FF FF 
1479   C7B4 FF FF FF FF 
1479   C7B8 FF FF FF FF 
1479   C7BC FF FF FF FF 
1479   C7C0 FF FF FF FF 
1479   C7C4 FF FF FF FF 
1479   C7C8 FF FF FF FF 
1479   C7CC FF FF FF FF 
1479   C7D0 FF FF FF FF 
1479   C7D4 FF FF FF FF 
1479   C7D8 FF FF FF FF 
1479   C7DC FF FF FF FF 
1479   C7E0 FF FF FF FF 
1479   C7E4 FF FF FF FF 
1479   C7E8 FF FF FF FF 
1479   C7EC FF FF FF FF 
1479   C7F0 FF FF FF FF 
1479   C7F4 FF FF FF FF 
1479   C7F8 FF FF FF FF 
1479   C7FC FF FF FF FF 
1479   C800 FF FF FF FF 
1479   C804 FF FF FF FF 
1479   C808 FF FF FF FF 
1479   C80C FF FF FF FF 
1479   C810 FF FF FF FF 
1479   C814 FF FF FF FF 
1479   C818 FF FF FF FF 
1479   C81C FF FF FF FF 
1479   C820 FF FF FF FF 
1479   C824 FF FF FF FF 
1479   C828 FF FF FF FF 
1479   C82C FF FF FF FF 
1479   C830 FF FF FF FF 
1479   C834 FF FF FF FF 
1479   C838 FF FF FF FF 
1479   C83C FF FF FF FF 
1479   C840 FF FF FF FF 
1479   C844 FF FF FF FF 
1479   C848 FF FF FF FF 
1479   C84C FF FF FF FF 
1479   C850 FF FF FF FF 
1479   C854 FF FF FF FF 
1479   C858 FF FF FF FF 
1479   C85C FF FF FF FF 
1479   C860 FF FF FF FF 
1479   C864 FF FF FF FF 
1479   C868 FF FF FF FF 
1479   C86C FF FF FF FF 
1479   C870 FF FF FF FF 
1479   C874 FF FF FF FF 
1479   C878 FF FF FF FF 
1479   C87C FF FF FF FF 
1479   C880 FF FF FF FF 
1479   C884 FF FF FF FF 
1479   C888 FF FF FF FF 
1479   C88C FF FF FF FF 
1479   C890 FF FF FF FF 
1479   C894 FF FF FF FF 
1479   C898 FF FF FF FF 
1479   C89C FF FF FF FF 
1479   C8A0 FF FF FF FF 
1479   C8A4 FF FF FF FF 
1479   C8A8 FF FF FF FF 
1479   C8AC FF FF FF FF 
1479   C8B0 FF FF FF FF 
1479   C8B4 FF FF FF FF 
1479   C8B8 FF FF FF FF 
1479   C8BC FF FF FF FF 
1479   C8C0 FF FF FF FF 
1479   C8C4 FF FF FF FF 
1479   C8C8 FF FF FF FF 
1479   C8CC FF FF FF FF 
1479   C8D0 FF FF FF FF 
1479   C8D4 FF FF FF FF 
1479   C8D8 FF FF FF FF 
1479   C8DC FF FF FF FF 
1479   C8E0 FF FF FF FF 
1479   C8E4 FF FF FF FF 
1479   C8E8 FF FF FF FF 
1479   C8EC FF FF FF FF 
1479   C8F0 FF FF FF FF 
1479   C8F4 FF FF FF FF 
1479   C8F8 FF FF FF FF 
1479   C8FC FF FF FF FF 
1479   C900 FF FF FF FF 
1479   C904 FF FF FF FF 
1479   C908 FF FF FF FF 
1479   C90C FF FF FF FF 
1479   C910 FF FF FF FF 
1479   C914 FF FF FF FF 
1479   C918 FF FF FF FF 
1479   C91C FF FF FF FF 
1479   C920 FF FF FF FF 
1479   C924 FF FF FF FF 
1479   C928 FF FF FF FF 
1479   C92C FF FF FF FF 
1479   C930 FF FF FF FF 
1479   C934 FF FF FF FF 
1479   C938 FF FF FF FF 
1479   C93C FF FF FF FF 
1479   C940 FF FF FF FF 
1479   C944 FF FF FF FF 
1479   C948 FF FF FF FF 
1479   C94C FF FF FF FF 
1479   C950 FF FF FF FF 
1479   C954 FF FF FF FF 
1479   C958 FF FF FF FF 
1479   C95C FF FF FF FF 
1479   C960 FF FF FF FF 
1479   C964 FF FF FF FF 
1479   C968 FF FF FF FF 
1479   C96C FF FF FF FF 
1479   C970 FF FF FF FF 
1479   C974 FF FF FF FF 
1479   C978 FF FF FF FF 
1479   C97C FF FF FF FF 
1479   C980 FF FF FF FF 
1479   C984 FF FF FF FF 
1479   C988 FF FF FF FF 
1479   C98C FF FF FF FF 
1479   C990 FF FF FF FF 
1479   C994 FF FF FF FF 
1479   C998 FF FF FF FF 
1479   C99C FF FF FF FF 
1479   C9A0 FF FF FF FF 
1479   C9A4 FF FF FF FF 
1479   C9A8 FF FF FF FF 
1479   C9AC FF FF FF FF 
1479   C9B0 FF FF FF FF 
1479   C9B4 FF FF FF FF 
1479   C9B8 FF FF FF FF 
1479   C9BC FF FF FF FF 
1479   C9C0 FF FF FF FF 
1479   C9C4 FF FF FF FF 
1479   C9C8 FF FF FF FF 
1479   C9CC FF FF FF FF 
1479   C9D0 FF FF FF FF 
1479   C9D4 FF FF FF FF 
1479   C9D8 FF FF FF FF 
1479   C9DC FF FF FF FF 
1479   C9E0 FF FF FF FF 
1479   C9E4 FF FF FF FF 
1479   C9E8 FF FF FF FF 
1479   C9EC FF FF FF FF 
1479   C9F0 FF FF FF FF 
1479   C9F4 FF FF FF FF 
1479   C9F8 FF FF FF FF 
1479   C9FC FF FF FF FF 
1479   CA00 FF FF FF FF 
1479   CA04 FF FF FF FF 
1479   CA08 FF FF FF FF 
1479   CA0C FF FF FF FF 
1479   CA10 FF FF FF FF 
1479   CA14 FF FF FF FF 
1479   CA18 FF FF FF FF 
1479   CA1C FF FF FF FF 
1479   CA20 FF FF FF FF 
1479   CA24 FF FF FF FF 
1479   CA28 FF FF FF FF 
1479   CA2C FF FF FF FF 
1479   CA30 FF FF FF FF 
1479   CA34 FF FF FF FF 
1479   CA38 FF FF FF FF 
1479   CA3C FF FF FF FF 
1479   CA40 FF FF FF FF 
1479   CA44 FF FF FF FF 
1479   CA48 FF FF FF FF 
1479   CA4C FF FF FF FF 
1479   CA50 FF FF FF FF 
1479   CA54 FF FF FF FF 
1479   CA58 FF FF FF FF 
1479   CA5C FF FF FF FF 
1479   CA60 FF FF FF FF 
1479   CA64 FF FF FF FF 
1479   CA68 FF FF FF FF 
1479   CA6C FF FF FF FF 
1479   CA70 FF FF FF FF 
1479   CA74 FF FF FF FF 
1479   CA78 FF FF FF FF 
1479   CA7C FF FF FF FF 
1479   CA80 FF FF FF FF 
1479   CA84 FF FF FF FF 
1479   CA88 FF FF FF FF 
1479   CA8C FF FF FF FF 
1479   CA90 FF FF FF FF 
1479   CA94 FF FF FF FF 
1479   CA98 FF FF FF FF 
1479   CA9C FF FF FF FF 
1479   CAA0 FF FF FF FF 
1479   CAA4 FF FF FF FF 
1479   CAA8 FF FF FF FF 
1479   CAAC FF FF FF FF 
1479   CAB0 FF FF FF FF 
1479   CAB4 FF FF FF FF 
1479   CAB8 FF FF FF FF 
1479   CABC FF FF FF FF 
1479   CAC0 FF FF FF FF 
1479   CAC4 FF FF FF FF 
1479   CAC8 FF FF FF FF 
1479   CACC FF FF FF FF 
1479   CAD0 FF FF FF FF 
1479   CAD4 FF FF FF FF 
1479   CAD8 FF FF FF FF 
1479   CADC FF FF FF FF 
1479   CAE0 FF FF FF FF 
1479   CAE4 FF FF FF FF 
1479   CAE8 FF FF FF FF 
1479   CAEC FF FF FF FF 
1479   CAF0 FF FF FF FF 
1479   CAF4 FF FF FF FF 
1479   CAF8 FF FF FF FF 
1479   CAFC FF FF FF FF 
1480   CB00             newCode     .org    $CB00
1481   CB00~            #ifdef batteryGauge
1482   CB00~            battGauge   ldab    battRaw                   ; b=battery voltage
1483   CB00~                        subb    #$8C                      ; remove 10.262V
1484   CB00~                        lsrb                              ;
1485   CB00~                        lsrb                              ;
1486   CB00~                        tba                               ;
1487   CB00~                        lsrb                              ;
1488   CB00~                        aba                               ;
1489   CB00~                        tab                               ; b = 3/8*(Vbatt-10.262v), gives a effective range of 10.262V to 14.95V (0 to 24 in boost gauge range)
1490   CB00~                        rts
1491   CB00             #endif
1492   CB00             
1493   CB00             
1494   CB00             
1495   CB00             ;******************************************************************
1496   CB00             ;
1497   CB00             ;
1498   CB00             ; Empty space
1499   CB00             ;
1500   CB00             ;
1501   CB00             ;******************************************************************
1502   CB00 FF FF FF FF             .fill   codeStart-$, $ff
1502   CB04 FF FF FF FF 
1502   CB08 FF FF FF FF 
1502   CB0C FF FF FF FF 
1502   CB10 FF FF FF FF 
1502   CB14 FF FF FF FF 
1502   CB18 FF FF FF FF 
1502   CB1C FF FF FF FF 
1502   CB20 FF FF FF FF 
1502   CB24 FF FF FF FF 
1502   CB28 FF FF FF FF 
1502   CB2C FF FF FF FF 
1502   CB30 FF FF FF FF 
1502   CB34 FF FF FF FF 
1502   CB38 FF FF FF FF 
1502   CB3C FF FF FF FF 
1502   CB40 FF FF FF FF 
1502   CB44 FF FF FF FF 
1502   CB48 FF FF FF FF 
1502   CB4C FF FF FF FF 
1502   CB50 FF FF FF FF 
1502   CB54 FF FF FF FF 
1502   CB58 FF FF FF FF 
1502   CB5C FF FF FF FF 
1502   CB60 FF FF FF FF 
1502   CB64 FF FF FF FF 
1502   CB68 FF FF FF FF 
1502   CB6C FF FF FF FF 
1502   CB70 FF FF FF FF 
1502   CB74 FF FF FF FF 
1502   CB78 FF FF FF FF 
1502   CB7C FF FF FF FF 
1502   CB80 FF FF FF FF 
1502   CB84 FF FF FF FF 
1502   CB88 FF FF FF FF 
1502   CB8C FF FF FF FF 
1502   CB90 FF FF FF FF 
1502   CB94 FF FF FF FF 
1502   CB98 FF FF FF FF 
1502   CB9C FF FF FF FF 
1502   CBA0 FF FF FF FF 
1502   CBA4 FF FF FF FF 
1502   CBA8 FF FF FF FF 
1502   CBAC FF FF FF FF 
1502   CBB0 FF FF FF FF 
1502   CBB4 FF FF FF FF 
1502   CBB8 FF FF FF FF 
1502   CBBC FF FF FF FF 
1502   CBC0 FF FF FF FF 
1502   CBC4 FF FF FF FF 
1502   CBC8 FF FF FF FF 
1502   CBCC FF FF FF FF 
1502   CBD0 FF FF FF FF 
1502   CBD4 FF FF FF FF 
1502   CBD8 FF FF FF FF 
1502   CBDC FF FF FF FF 
1502   CBE0 FF FF FF FF 
1502   CBE4 FF FF FF FF 
1502   CBE8 FF FF FF FF 
1502   CBEC FF FF FF FF 
1502   CBF0 FF FF FF FF 
1502   CBF4 FF FF FF FF 
1502   CBF8 FF FF FF FF 
1502   CBFC FF FF FF FF 
1502   CC00 FF FF FF FF 
1502   CC04 FF FF FF FF 
1502   CC08 FF FF FF FF 
1502   CC0C FF FF FF FF 
1502   CC10 FF FF FF FF 
1502   CC14 FF FF FF FF 
1502   CC18 FF FF FF FF 
1502   CC1C FF FF FF FF 
1502   CC20 FF FF FF FF 
1502   CC24 FF FF FF FF 
1502   CC28 FF FF FF FF 
1502   CC2C FF FF FF FF 
1502   CC30 FF FF FF FF 
1502   CC34 FF FF FF FF 
1502   CC38 FF FF FF FF 
1502   CC3C FF FF FF FF 
1502   CC40 FF FF FF FF 
1502   CC44 FF FF FF FF 
1502   CC48 FF FF FF FF 
1502   CC4C FF FF FF FF 
1502   CC50 FF FF FF FF 
1502   CC54 FF FF FF FF 
1502   CC58 FF FF FF FF 
1502   CC5C FF FF FF FF 
1502   CC60 FF FF FF FF 
1502   CC64 FF FF FF FF 
1502   CC68 FF FF FF FF 
1502   CC6C FF FF FF FF 
1502   CC70 FF FF FF FF 
1502   CC74 FF FF FF FF 
1502   CC78 FF FF FF FF 
1502   CC7C FF FF FF FF 
1502   CC80 FF FF FF FF 
1502   CC84 FF FF FF FF 
1502   CC88 FF FF FF FF 
1502   CC8C FF FF FF FF 
1502   CC90 FF FF FF FF 
1502   CC94 FF FF FF FF 
1502   CC98 FF FF FF FF 
1502   CC9C FF FF FF FF 
1502   CCA0 FF FF FF FF 
1502   CCA4 FF FF FF FF 
1502   CCA8 FF FF FF FF 
1502   CCAC FF FF FF FF 
1502   CCB0 FF FF FF FF 
1502   CCB4 FF FF FF FF 
1502   CCB8 FF FF FF FF 
1502   CCBC FF FF FF FF 
1502   CCC0 FF FF FF FF 
1502   CCC4 FF FF FF FF 
1502   CCC8 FF FF FF FF 
1502   CCCC FF FF FF FF 
1502   CCD0 FF FF FF FF 
1502   CCD4 FF FF FF FF 
1502   CCD8 FF FF FF FF 
1502   CCDC FF FF FF FF 
1502   CCE0 FF FF FF FF 
1502   CCE4 FF FF FF FF 
1502   CCE8 FF FF FF FF 
1502   CCEC FF FF FF FF 
1502   CCF0 FF FF FF FF 
1502   CCF4 FF FF FF FF 
1502   CCF8 FF FF FF FF 
1502   CCFC FF FF FF FF 
1502   CD00 FF FF FF FF 
1502   CD04 FF FF FF FF 
1502   CD08 FF FF FF FF 
1502   CD0C FF FF FF FF 
1502   CD10 FF FF FF FF 
1502   CD14 FF FF FF FF 
1502   CD18 FF FF FF FF 
1502   CD1C FF FF FF FF 
1502   CD20 FF FF FF FF 
1502   CD24 FF FF FF FF 
1502   CD28 FF FF FF FF 
1502   CD2C FF FF FF FF 
1502   CD30 FF FF FF FF 
1502   CD34 FF FF FF FF 
1502   CD38 FF FF FF FF 
1502   CD3C FF FF FF FF 
1502   CD40 FF FF FF FF 
1502   CD44 FF FF FF FF 
1502   CD48 FF FF FF FF 
1502   CD4C FF FF FF FF 
1502   CD50 FF FF FF FF 
1502   CD54 FF FF FF FF 
1502   CD58 FF FF FF FF 
1502   CD5C FF FF FF FF 
1502   CD60 FF FF FF FF 
1502   CD64 FF FF FF FF 
1502   CD68 FF FF FF FF 
1502   CD6C FF FF FF FF 
1502   CD70 FF FF FF FF 
1502   CD74 FF FF FF FF 
1502   CD78 FF FF FF FF 
1502   CD7C FF FF FF FF 
1502   CD80 FF FF FF FF 
1502   CD84 FF FF FF FF 
1502   CD88 FF FF FF FF 
1502   CD8C FF FF FF FF 
1502   CD90 FF FF FF FF 
1502   CD94 FF FF FF FF 
1502   CD98 FF FF FF FF 
1502   CD9C FF FF FF FF 
1502   CDA0 FF FF FF FF 
1502   CDA4 FF FF FF FF 
1502   CDA8 FF FF FF FF 
1502   CDAC FF FF FF FF 
1502   CDB0 FF FF FF FF 
1502   CDB4 FF FF FF FF 
1502   CDB8 FF FF FF FF 
1502   CDBC FF FF FF FF 
1502   CDC0 FF FF FF FF 
1502   CDC4 FF FF FF FF 
1502   CDC8 FF FF FF FF 
1502   CDCC FF FF FF FF 
1502   CDD0 FF FF FF FF 
1502   CDD4 FF FF FF FF 
1502   CDD8 FF FF FF FF 
1502   CDDC FF FF FF FF 
1502   CDE0 FF FF FF FF 
1502   CDE4 FF FF FF FF 
1502   CDE8 FF FF FF FF 
1502   CDEC FF FF FF FF 
1502   CDF0 FF FF FF FF 
1502   CDF4 FF FF FF FF 
1502   CDF8 FF FF FF FF 
1502   CDFC FF FF FF FF 
1502   CE00 FF FF FF FF 
1502   CE04 FF FF FF FF 
1502   CE08 FF FF FF FF 
1502   CE0C FF FF FF FF 
1502   CE10 FF FF FF FF 
1502   CE14 FF FF FF FF 
1502   CE18 FF FF FF FF 
1502   CE1C FF FF FF FF 
1502   CE20 FF FF FF FF 
1502   CE24 FF FF FF FF 
1502   CE28 FF FF FF FF 
1502   CE2C FF FF FF FF 
1502   CE30 FF FF FF FF 
1502   CE34 FF FF FF FF 
1502   CE38 FF FF FF FF 
1502   CE3C FF FF FF FF 
1502   CE40 FF FF FF FF 
1502   CE44 FF FF FF FF 
1502   CE48 FF FF FF FF 
1502   CE4C FF FF FF FF 
1502   CE50 FF FF FF FF 
1502   CE54 FF FF FF FF 
1502   CE58 FF FF FF FF 
1502   CE5C FF FF FF FF 
1502   CE60 FF FF FF FF 
1502   CE64 FF FF FF FF 
1502   CE68 FF FF FF FF 
1502   CE6C FF FF FF FF 
1502   CE70 FF FF FF FF 
1502   CE74 FF FF FF FF 
1502   CE78 FF FF FF FF 
1502   CE7C FF FF FF FF 
1502   CE80 FF FF FF FF 
1502   CE84 FF FF FF FF 
1502   CE88 FF FF FF FF 
1502   CE8C FF FF FF FF 
1502   CE90 FF FF FF FF 
1502   CE94 FF FF FF FF 
1502   CE98 FF FF FF FF 
1502   CE9C FF FF FF FF 
1502   CEA0 FF FF FF FF 
1502   CEA4 FF FF FF FF 
1502   CEA8 FF FF FF FF 
1502   CEAC FF FF FF FF 
1502   CEB0 FF FF FF FF 
1502   CEB4 FF FF FF FF 
1502   CEB8 FF FF FF FF 
1502   CEBC FF FF FF FF 
1502   CEC0 FF FF FF FF 
1502   CEC4 FF FF FF FF 
1502   CEC8 FF FF FF FF 
1502   CECC FF FF FF FF 
1502   CED0 FF FF FF FF 
1502   CED4 FF FF FF FF 
1502   CED8 FF FF FF FF 
1502   CEDC FF FF FF FF 
1502   CEE0 FF FF FF FF 
1502   CEE4 FF FF FF FF 
1502   CEE8 FF FF FF FF 
1502   CEEC FF FF FF FF 
1502   CEF0 FF FF FF FF 
1502   CEF4 FF FF FF FF 
1502   CEF8 FF FF FF FF 
1502   CEFC FF FF FF 
1503   CEFF             
1504   CEFF             
1505   CEFF             
1506   CEFF             ;******************************************************************
1507   CEFF             ;
1508   CEFF             ;
1509   CEFF             ; Start of code after reset
1510   CEFF             ;
1511   CEFF             ;
1512   CEFF             ;******************************************************************
1513   CEFF             codeStart   .ORG    $ceff-codeOffset
1514   CEFF 7E D0 3E                jmp     reset
1515   CF02             
1516   CF02             
1517   CF02             ;******************************************************************
1518   CF02             ;
1519   CF02             ;
1520   CF02             ; Empty space
1521   CF02             ;
1522   CF02             ;
1523   CF02             ;******************************************************************
1524   CF02 FF FF FF FF empty2      .fill   obdTable-empty2, $ff
1524   CF06 FF FF FF FF 
1524   CF0A FF FF FF FF 
1524   CF0E FF FF FF FF 
1524   CF12 FF FF FF FF 
1524   CF16 FF FF FF FF 
1524   CF1A FF FF FF FF 
1524   CF1E FF FF FF FF 
1524   CF22 FF FF FF FF 
1524   CF26 FF FF FF FF 
1524   CF2A FF FF FF FF 
1524   CF2E FF FF FF FF 
1524   CF32 FF FF FF FF 
1524   CF36 FF FF FF FF 
1524   CF3A FF FF FF FF 
1524   CF3E FF FF FF FF 
1524   CF42 FF FF FF FF 
1524   CF46 FF FF FF FF 
1524   CF4A FF FF FF FF 
1524   CF4E FF FF FF FF 
1524   CF52 FF FF FF FF 
1524   CF56 FF FF FF FF 
1524   CF5A FF FF FF FF 
1524   CF5E FF FF FF FF 
1524   CF62 FF FF FF FF 
1524   CF66 FF FF FF FF 
1524   CF6A FF FF FF FF 
1524   CF6E FF FF FF FF 
1524   CF72 FF FF FF FF 
1524   CF76 FF FF FF FF 
1524   CF7A FF FF FF FF 
1524   CF7E FF FF FF FF 
1524   CF82 FF FF FF FF 
1524   CF86 FF FF FF FF 
1524   CF8A FF FF FF FF 
1524   CF8E FF FF FF FF 
1524   CF92 FF FF FF FF 
1524   CF96 FF FF FF FF 
1524   CF9A FF FF FF FF 
1524   CF9E FF FF FF FF 
1524   CFA2 FF FF FF FF 
1524   CFA6 FF FF FF FF 
1524   CFAA FF FF FF FF 
1524   CFAE FF FF FF FF 
1524   CFB2 FF FF FF FF 
1524   CFB6 FF FF FF FF 
1524   CFBA FF FF FF FF 
1524   CFBE FF FF FF FF 
1524   CFC2 FF FF FF FF 
1524   CFC6 FF FF FF FF 
1524   CFCA FF FF FF FF 
1524   CFCE FF FF FF FF 
1524   CFD2 FF FF FF FF 
1524   CFD6 FF FF FF FF 
1524   CFDA FF FF FF FF 
1524   CFDE FF FF FF FF 
1524   CFE2 FF FF FF FF 
1524   CFE6 FF FF FF FF 
1524   CFEA FF FF FF FF 
1524   CFEE FF FF FF FF 
1524   CFF2 FF FF FF FF 
1524   CFF6 FF FF FF FF 
1524   CFFA FF FF FF FF 
1524   CFFE FF FF 
1525   D000             
1526   D000             
1527   D000             
1528   D000             ;******************************************************************
1529   D000             ;*
1530   D000             ;* OBD interface queries, commands
1531   D000             ;*
1532   D000             ;*   Codes from $00 to $3d: Regular queries, return the value of the
1533   D000             ;*                variables showed in obdTable located below, 
1534   D000             ;*                see each variable definition... First value in table 
1535   D000             ;*                correspond to obd query code $00, increases by 1 
1536   D000             ;*                for each table value
1537   D000             ;*     
1538   D000             ;*   Codes from $3e to $3f: Converted to $3d, see that obd code
1539   D000             ;*
1540   D000             ;*   Codes from $40 to $c9: Returns what is stored in that ram address
1541   D000             ;*
1542   D000             ;*   Codes from $ca to $ca:: Erase all fault codes and returns $00 if
1543   D000             ;*                           engine not rotating. If engine is rotating, all 
1544   D000             ;*                           actuators/injector commands are reset and $ff
1545   D000             ;*                           is returned.
1546   D000             ;* 
1547   D000             ;*   Codes from $cb to $f0: Returns what is stored in that ram address
1548   D000             ;*
1549   D000             ;*   Codes from $f1 to $fc: Injector/actuators commands, returns $ff if 
1550   D000             ;*                          successfull
1551   D000             ;*         
1552   D000             ;*         $f1: Activate boost control solenoid
1553   D000             ;*         $f2: Unused in code        
1554   D000             ;*         $f3: Activate egr solemoid          
1555   D000             ;*         $f4: Activate fuel pressure solenoid
1556   D000             ;*         $f5: Activate purge solenoid       
1557   D000             ;*         $f6: Turn on fuel pump     
1558   D000             ;*         $f7: Disable injector #6 (inoperative in code)  
1559   D000             ;*         $f8: Disable injector #5 (inoperative in code)  
1560   D000             ;*         $f9: Disable injector #4 
1561   D000             ;*         $fa: Disable injector #3 
1562   D000             ;*         $fb: Disable injector #2 
1563   D000             ;*         $fc: Disable injector #1 
1564   D000             ;*
1565   D000             ;*   Codes from $f1 to $ff: Special queries
1566   D000             ;*
1567   D000             ;*         $fd: Serial link test, returns $b5 (E931) or $b7 (E932)
1568   D000             ;*         $fe: resistor strapping low word from t_strap3
1569   D000             ;*         $ff: resistor strapping high word from t_strap3
1570   D000             ;*     
1571   D000             ;******************************************************************
1572   D000                         .org $d000-codeOffset
1573   D000 02 03 06 07 obdTable    .byte   port1,         port2,       port3,       port4            ; obd $00 to $03 
1574   D004 16 2F 8A CB             .byte   port5,         port6,       timingAdv,   ectRaw           ; obd $04 to $07
1575   D008 44 ED 46 EE             .byte   isc0,          iscY0,       isc1,        iscY1            ; obd $08 to $0b
1576   D00C 40 41 42 E9             .byte   ftrim_low,     ftrim_mid,   ftrim_hi,    o2Fbk            ; obd $0c to $0f
1577   D010 D3 D4 CF CE             .byte   ectFiltered,   iatChecked,  egrtRaw,     o2Raw            ; obd $10 to $13
1578   D014 D0 CD 49 D2             .byte   battRaw,       baroRaw,     iscStepCurr, tpsRaw           ; obd $14 to $17
1579   D018 E8 E5 E4 40             .byte   closedLpFlags, ftrimFlags,  mafRaw,      ftrim_low        ; obd $18 to $1b
1580   D01C E0 A1 E6 40             .byte   airVol,        accEnr,      state1,      ftrim_low        ; obd $1c to $1f
1581   D020 DC DD F1 F3             .byte   rpm8,          rpm31,       port3Snap1,  iscLrnFlags      ; obd $20 to $23
1582   D024 FE FD 8B D7             .byte   idleSpdTarg,   iscStepTarg, knockSum,    port3Snap0       ; obd $24 to $27
1583   D028 D8 A7 A8 89             .byte   port4Snap,     injPw,       injPw+1,     enerLen          ; obd $28 to $2b
1584   D02C 8D 8E A3 A4             .byte   airCnt0,       airCnt1,     injFactor,   injFactor+1      ; obd $2c to $2f
1585   D030 4B 57 58 59             .byte   iscFlags0,     temp1,       temp2,       temp3            ; obd $30 to $33
1586   D034 5A 5B 50 51             .byte   temp4,         temp5,       o2BadCnt,    egrtBadCnt       ; obd $34 to $37
1587   D038 4E 4F CC 4C             .byte   faultHi,       faultLo,     iatRaw,      stFaultHi        ; obd $38 to $3b
1588   D03C 4D 40                   .byte   stFaultLo,     ftrim_low                                  ; obd $3c to $3d
1589   D03E             
1590   D03E             
1591   D03E             
1592   D03E             ;******************************************************************
1593   D03E             ;
1594   D03E             ;
1595   D03E             ; Code executed after reset
1596   D03E             ;
1597   D03E             ;
1598   D03E             ;******************************************************************
1599   D03E 8E 01 BF    reset       lds     #stack                    ; Set the stack pointer                                       
1600   D041 8D 0F                   bsr     ecuInit                   ; Initialization branch                                       
1601   D043                                                                                        
1602   D043                         ;---------------------------------------------                                                       
1603   D043                         ; Main ECU loop executed in low priority
1604   D043                         ; (compared to interrupt code). Loop will
1605   D043                         ; execute slower when the computing load
1606   D043                         ; increases...A minimum of 20Hz is monitored
1607   D043                         ; by the COP function? 
1608   D043                         ;---------------------------------------------                                                       
1609   D043 BD D1 7D    L1001       jsr     subroutine1                ; 
1610   D046 BD DF 0D                jsr     subroutine2                ; 
1611   D049 BD DD 16                jsr     subroutine3                ; 
1612   D04C BD E5 62                jsr     subroutine4                ; 
1613   D04F 7E D0 43                jmp     L1001                      ; 
1614   D052             
1615   D052             
1616   D052             
1617   D052             ;******************************************************************
1618   D052             ;
1619   D052             ;
1620   D052             ; Initialization subroutine
1621   D052             ;
1622   D052             ;
1623   D052             ;******************************************************************
1624   D052                         ;------------------------------------------------------------------                       
1625   D052                         ; Init all outputs  (port1, port2 port5 and port6) to known states
1626   D052                         ;------------------------------------------------------------------                       
1627   D052 CC BF 0F    ecuInit     ldd     #$bf0f                    ;                               
1628   D055 DD 02                   std     port1                     ; port1 = 1011 1111, port2 = 0000 ffff                             
1629   D057 03 16 FF                orm     port5, #$ff               ; port5 = 1111 1111
1630   D05A 02 2F 00                andm    port6, #$00               ; port6 = 0000 0000
1631   D05D             
1632   D05D                         ;-------------------------------------------------------------                       
1633   D05D                         ; Init port1 through port5 data direction registers
1634   D05D                         ; Init real time interrupt frequency
1635   D05D                         ; Init L000f, L0017 and L0024 to 0 (never used in the code???)
1636   D05D                         ;-------------------------------------------------------------                       
1637   D05D BD EA 25                jsr     initFunc1                 ;                                  
1638   D060 CC 1B 3D                ldd     #$1b3d                    ;                               
1639   D063 97 08                   staa    t1_csr                    ; t1_csr = 0001 1011, enable injectors and cas interrupts, disable injectors, set cas detection edge polarity?
1640   D065 D7 18                   stab    t2_csr                    ;                               
1641   D067 CC 5E 0A                ldd     #$5e0a                    ;                               
1642   D06A DD 19                   std     t3_csr0                   ; t3_csr0 = 0101 1110, t3_csr1 = 0000 1010, both coils not energized                             
1643   D06C BD D1 62                jsr     init_t1_t2                ;                                   
1644   D06F                                                                                    
1645   D06F                         ;-----------------------------------------------------------                       
1646   D06F                         ; Clear RAM from ramClearStart to ramClearEnd inclusively   
1647   D06F                         ;-----------------------------------------------------------                       
1648   D06F             #ifndef noRamReset
1649   D06F CD CE 00 57             ldy     #ramClearStart            ;                             
1650   D073 4F                      clra                              ;                             
1651   D074 5F                      clrb                              ;                             
1652   D075 ED 80       L1003       std     $00,y                     ; Operation does y = y + 2                                               
1653   D077 CD 8C 01 91             cmpy    #ramClearEnd+1            ;                                             
1654   D07B 25 F8                   bcs     L1003                     ;                              
1655   D07D             #endif
1656   D07D                                                                                    
1657   D07D                         ;------------------------------------------------
1658   D07D                         ; Read all 8 ADC ports values and store in ram
1659   D07D                         ;------------------------------------------------
1660   D07D CD CE 00 CB             ldy     #ectRaw                   ;                                
1661   D081 86 08                   ldaa    #$08                      ; start with port 0 and start bit set ($08)                          
1662   D083 36          L1004       psha                              ;                           
1663   D084 BD EC 0C                jsr     readAdc2                  ;                              
1664   D087 E7 80                   stab    $00,y                     ; y = y + 1                          
1665   D089 32                      pula                              ;                           
1666   D08A 4C                      inca                              ;                           
1667   D08B 81 10                   cmpa    #$10                      ;                           
1668   D08D 25 F4                   bcs     L1004                     ;                           
1669   D08F             
1670   D08F                         ;-------------------------------------------------------
1671   D08F                         ; Check if all ISC variables are initialized properly
1672   D08F                         ; If not then re-initialize ECU from scratch
1673   D08F                         ;-------------------------------------------------------
1674   D08F CE B0 00                ldx     #$b000                    ;                           
1675   D092 9C 44                   cpx     isc0                      ;                          
1676   D094 25 20                   bcs     L1005                     ; Branch to re-initialize ECU from scratch 
1677   D096 9C 46                   cpx     isc1                      ;                             
1678   D098 25 1C                   bcs     L1005                     ; Branch to re-initialize ECU from scratch                             
1679   D09A CE 6C 00                ldx     #$6c00                    ;                               
1680   D09D 9C 44                   cpx     isc0                      ;                             
1681   D09F 22 15                   bhi     L1005                     ; Branch to re-initialize ECU from scratch                              
1682   D0A1 9C 46                   cpx     isc1                      ;                             
1683   D0A3 22 11                   bhi     L1005                     ; Branch to re-initialize ECU from scratch                             
1684   D0A5 96 49                   ldaa    iscStepCurr               ;                                    
1685   D0A7 81 87                   cmpa    #$87                      ;                             
1686   D0A9 22 0B                   bhi     L1005                     ; Branch to re-initialize ECU from scratch                             
1687   D0AB 43                      coma                              ;                             
1688   D0AC 84 7F                   anda    #$7f                      ;                             
1689   D0AE 91 48                   cmpa    iscStepCom                ;                                   
1690   D0B0 26 04                   bne     L1005                     ; Branch to re-initialize ECU from scratch                             
1691   D0B2             
1692   D0B2                         ;-----------------------------------------------------------
1693   D0B2                         ; All ISC variables look OK
1694   D0B2                         ; Check if ram control register was erased (loss of power)
1695   D0B2                         ;-----------------------------------------------------------
1696   D0B2 D6 14                   ldab    ramControl                ;                              
1697   D0B4~            #ifdef octaneReset                            ;
1698   D0B4~                        bmi     L1006a                    ;
1699   D0B4             #else                                         
1700   D0B4 2B 2C                   bmi     L1006                     ; Branch if ramControl.7 set, i.e. we already did a fresh reset and power was not lost
1701   D0B6             #endif
1702   D0B6                                                                         
1703   D0B6                         ;------------------------------------------------------
1704   D0B6                         ; Perform a fresh reset, i.e. init ECU from scratch
1705   D0B6                         ;------------------------------------------------------
1706   D0B6                         ;---------------------------------------
1707   D0B6                         ; Reset all faults and fault counters
1708   D0B6                         ;---------------------------------------
1709   D0B6 4F          L1005       clra                              ;                             
1710   D0B7 5F                      clrb                              ;                             
1711   D0B8 DD 4C                   std     stFaultHi                 ;                                  
1712   D0BA DD 4E                   std     faultHi                   ;                                
1713   D0BC DD 50                   std     o2BadCnt                  ;                                 
1714   D0BE             
1715   D0BE                         ;--------------------
1716   D0BE                         ; Init ISC variables
1717   D0BE                         ;--------------------
1718   D0BE 86 80                   ldaa    #$80                      ;                             
1719   D0C0 97 4B                   staa    iscFlags0                 ; iscFlags0 = $80, isc max calibration is requested                                 
1720   D0C2 4F                      clra                              ;                             
1721   D0C3 BD E4 A4                jsr     iscStepComp               ; iscStepCurr = $0, iscStepCom = (~$0 & 7F)                                    
1722   D0C6 CC 8C 00                ldd     #$8c00                    ;                               
1723   D0C9 DD 44                   std     isc0                      ; isc0 = $8c                            
1724   D0CB DD 46                   std     isc1                      ; isc1 = $00
1725   D0CD             
1726   D0CD                         ;-------------------------------------------------------------                                      
1727   D0CD                         ; Set isc coil pattern and pattern index to t_iscPattern(0)
1728   D0CD                         ;-------------------------------------------------------------                                      
1729   D0CD C6 04                   ldab    #$04                      ;                             
1730   D0CF D7 4A                   stab    iscPatrnIdx               ; iscPatrnIdx = $04 (lower two bits = 00b)                              
1731   D0D1 03 16 80                orm     port5, #$80               ; ISC coil pattern bit 6 and 7 = 10b = t_iscPattern(0)                               
1732   D0D4 02 16 BF                andm    port5, #$bf               ; ISC coil pattern bit 6 and 7 = 10b = t_iscPattern(0)                               
1733   D0D7             
1734   D0D7                         ;-------------------------------------------------------------                                      
1735   D0D7                         ; Init fuel trim to 100% and ftrimCntr to $80 
1736   D0D7                         ;-------------------------------------------------------------                                      
1737   D0D7 86 80                   ldaa    #$80                                                 
1738   D0D9 16                      tab                                                          
1739   D0DA DD 40                   std     ftrim_low                                                 
1740   D0DC DD 42                   std     ftrim_hi                                                 
1741   D0DE             
1742   D0DE                         ;------------------------------------
1743   D0DE                         ; Init octane to max, i.e. good fuel
1744   D0DE                         ;------------------------------------
1745   D0DE 86 FF       L1006a      ldaa    #$ff                    ; Reset octane value to max value (good fuel, no knock)
1746   D0E0 97 52                   staa    octane                                                 
1747   D0E2             
1748   D0E2                         ;-------------------------------------------------
1749   D0E2                         ; Set the ramControl flag bits since 
1750   D0E2                         ; fresh reset steps are (or were already) done
1751   D0E2                         ;-------------------------------------------------
1752   D0E2 86 C0       L1006       ldaa    #$c0                    ;                             
1753   D0E4 97 14                   staa    ramControl              ;              
1754   D0E6                                              
1755   D0E6                         ;-----------------------------------------
1756   D0E6                         ; Init timing/knock variables to defaults
1757   D0E6                         ;-----------------------------------------
1758   D0E6 CC FF A0                ldd     #$ffa0                  ;                               
1759   D0E9 97 64                   staa    TcasLast0               ;                                  
1760   D0EB B7 01 77                staa    knockTimer              ;                                   
1761   D0EE D7 88                   stab    tim61Tot0               ;                                  
1762   D0F0 B6 FE 90                ldaa    t_enerLen               ;                                  
1763   D0F3 97 89                   staa    enerLen                 ;                                
1764   D0F5             
1765   D0F5                         ;-----------------------------------------
1766   D0F5                         ; Init air count variables to default 
1767   D0F5                         ;-----------------------------------------
1768   D0F5 F6 FB 8E                ldab    t_airCntMax             ; b = t_airCntMax(0)                              
1769   D0F8 D7 A0                   stab    airCntMax               ;                                  
1770   D0FA 86 08                   ldaa    #$08                    ;                             
1771   D0FC 3D                      mul                             ; d = 8 * airCntMax                            
1772   D0FD DD 8D                   std     airCnt0                 ;                                
1773   D0FF DD 92                   std     oldAirCnt0              ;                                   
1774   D101             
1775   D101                         ;-----------------------------------------
1776   D101                         ; Init engine state flags to notRotating
1777   D101                         ;-----------------------------------------
1778   D101 86 10                   ldaa    #$10                    ;                             
1779   D103 97 A2                   staa    state3                  ; engine notRotating                               
1780   D105 97 E6                   staa    state1                  ; engine notRotating 
1781   D107             
1782   D107                         ;---------------------------------------------
1783   D107                         ; Init cas flags, current cylinder to default
1784   D107                         ;---------------------------------------------
1785   D107 CC 05 03                ldd     #$0503                  ;                               
1786   D10A 97 B3                   staa    tdcCasFlags             ; Why not use std??? I guess it is not obvious taht they are not contiguous just by looking at variable names...                             
1787   D10C D7 B4                   stab    casCylIndex             ;                              
1788   D10E             
1789   D10E                         ;----------------------
1790   D10E                         ; More init to default
1791   D10E                         ;----------------------
1792   D10E 86 FF                   ldaa    #$ff                    ;                             
1793   D110 97 BA                   staa    obdInjCmd               ; No obd injector command                                  
1794   D112 B7 01 74                staa    coilChkCnt              ;                                   
1795   D115 B7 01 35                staa    T2_EcuPower             ;                                    
1796   D118 97 C6                   staa    vss                     ; speed = 0                           
1797   D11A             
1798   D11A                         ;-----------------------------------------------------
1799   D11A                         ; Init reed switch flag to current reed switch value
1800   D11A                         ; and init 40Hz bit to 1
1801   D11A                         ;-----------------------------------------------------
1802   D11A 96 02                   ldaa    port1                   ;                              
1803   D11C 84 80                   anda    #$80                    ; Keep only reed switch bit                             
1804   D11E 4C                      inca                            ;                             
1805   D11F 97 BD                   staa    rtiReedFlags            ; Store latest Reed switch in bit 7 and set bit 1 for 40Hz based events
1806   D121             
1807   D121                         ;---------------------------------------------
1808   D121                         ; More init to default
1809   D121                         ;---------------------------------------------
1810   D121 86 06                   ldaa    #$06                    ; 30ms                             
1811   D123 97 C2                   staa    T200_cop                ;                                  
1812   D125 97 BE                   staa    T200_40Hz               ;                                  
1813   D127 97 CA                   staa    L00ca                   ; Never used in the code??????????????                             
1814   D129             
1815   D129                         ;---------------------------------------------
1816   D129                         ; More init to default
1817   D129                         ;---------------------------------------------
1818   D129 96 D2                   ldaa    tpsRaw                  ;                               
1819   D12B 97 C7                   staa    oldTps2                 ;                              
1820   D12D 86 0E                   ldaa    #$0e                    ;                             
1821   D12F B7 01 1B                staa    T40_baro                ;                              
1822   D132 CC 14 50                ldd     #$1450                  ;                               
1823   D135 B7 01 17                staa    T40_2hz                 ;                              
1824   D138 F7 01 18                stab    T40_0p5hz               ;                              
1825   D13B             
1826   D13B                         ;--------------------------------------------------
1827   D13B                         ; Reset all iscFlags0 and 
1828   D13B                         ; If either min or max isc calibration flag was set
1829   D13B                         ; set iscStepCurr = 0 and request max calibration
1830   D13B                         ; else set flag indicating max calibration is done???
1831   D13B                         ;--------------------------------------------------
1832   D13B 86 40                   ldaa    #$40                    ; Assume max calibration flag is set                             
1833   D13D 8F 4B A0 06             brclr   iscFlags0, #$a0, L1007  ; branch if both max and min calibration flags are clear (1010 0000)
1834   D141 4F                      clra                            ;                             
1835   D142 BD E4 A4                jsr     iscStepComp             ; iscStepCurr = $00, iscStepCom = (~$00 & 7F) 
1836   D145 86 80                   ldaa    #$80                    ;                             
1837   D147 97 4B       L1007       staa    iscFlags0               ; iscFlags0 = $40 or $80
1838   D149             
1839   D149                         ;--------------
1840   D149                         ; Init timer
1841   D149                         ;--------------
1842   D149 86 05                   ldaa    #$05                    ;                             
1843   D14B B7 01 24                staa    T40_noPower             ;                                    
1844   D14E             
1845   D14E                         ;------------------------------------------
1846   D14E                         ; Init TDC and injector testing valriables
1847   D14E                         ;------------------------------------------
1848   D14E C6 08                   ldab    #$08                    ; b = 0000 1000                            
1849   D150 D7 B6                   stab    tdcCheck                ; tdcCheck = 0000 1000                            
1850   D152 D7 B8                   stab    injToTest               ; injToTest = 0000 1000                              
1851   D154             
1852   D154                         ;----------------------------------------------------------------------
1853   D154                         ; Load the ECU configuration variables according to resistor strapping
1854   D154                         ;----------------------------------------------------------------------
1855   D154 BD EA 16                jsr     loadConfig              ;                              
1856   D157             
1857   D157                         ;----------------------
1858   D157                         ; re-enable interrupts
1859   D157                         ;----------------------
1860   D157 0E                      cli                             ;
1861   D158                                                   
1862   D158                         ;-----------------------
1863   D158                         ; More init to defaults
1864   D158                         ;-----------------------
1865   D158 5F                      clrb                            ;                             
1866   D159 F7 01 21                stab    T40_mas                 ;                                 
1867   D15C F7 01 20                stab    T40_engRot              ;                                   
1868   D15F             
1869   D15F                         ;-------------------------------------
1870   D15F                         ; Init Tcas and TcasOld to max value 
1871   D15F                         ; since engine is not rotating
1872   D15F                         ;-------------------------------------
1873   D15F 8D 11                   bsr     init_Tcas               ;                              
1874   D161 39                      rts                                                          
1875   D162                         
1876   D162                         
1877   D162             
1878   D162             ;******************************************************************
1879   D162             ;
1880   D162             ; Initialize timer 1 and 2
1881   D162             ;
1882   D162             ;
1883   D162             ;
1884   D162             ;******************************************************************
1885   D162 03 08 09    init_t1_t2  orm     t1_csr, #$09             ; Deactivate injector 1 and enable injector 1 output compare interrupts
1886   D165 03 18 3D                orm     t2_csr, #$3d             ; Deactivate injector 3,2,4 and enable injector 3,2,4 output compare interrupts
1887   D168             
1888   D168                         ;---------------------------------------------------
1889   D168                         ; Schedule interrupt in 11us for t1 and t2
1890   D168                         ; i.e. Make sure injectors are actually deactivated
1891   D168                         ;---------------------------------------------------
1892   D168 DC 09                   ldd     t1t2_clk                                                 
1893   D16A C3 00 0B                addd    #$000b                                                 
1894   D16D DD 0B                   std     t1_outCmpWr                                                 
1895   D16F DD 1B                   std     t2_outCmpWr                                                 
1896   D171 39                      rts                                                          
1897   D172             
1898   D172             
1899   D172             
1900   D172             ;******************************************************************
1901   D172             ;
1902   D172             ; Initialize Tcas and TcasOld to $7fff (infinite, not rotating...)
1903   D172             ;
1904   D172             ;
1905   D172             ;
1906   D172             ;******************************************************************
1907   D172 CE 01 45    init_Tcas   ldx     #Tcas                                                 
1908   D175 CC 7F FF                ldd     #$7fff                                                 
1909   D178 ED 00                   std     $00,x                                                 
1910   D17A ED 02                   std     $02,x                                                 
1911   D17C 39                      rts                                                          
1912   D17D             
1913   D17D             
1914   D17D             
1915   D17D             ;******************************************************************
1916   D17D             ;
1917   D17D             ;
1918   D17D             ; First subroutine
1919   D17D             ;
1920   D17D             ;
1921   D17D             ;******************************************************************
1922   D17D                         ;----------------------------------------------
1923   D17D                         ; Clear counter state flag and check if 40Hz
1924   D17D                         ; flag was set by real time interrupt
1925   D17D                         ;----------------------------------------------
1926   D17D 4F          subroutine1 clra                              ; a=0, used to accumulate various conditions in code below                             
1927   D17E 8F BD 01 3B             brclr   rtiReedFlags, #$01, L1013 ; Branch if 40Hz flag is not yet set (flag is set at ~40Hz in RT interrupt)
1928   D182 02 BD FE                andm    rtiReedFlags, #$fe        ; Reset bit
1929   D185                         
1930   D185                         ;---------------------------------------------------------------
1931   D185                         ; 40Hz flag is set, process it (code executed 40 times a second,
1932   D185                         ; at the most...)
1933   D185                         ;---------------------------------------------------------------
1934   D185                         ;---------------------------------------------------------------
1935   D185                         ; Decrement all 40Hz timers (min of 0) from $0117 to $0132
1936   D185                         ;---------------------------------------------------------------
1937   D185 CE 01 17                ldx     #T40_2hz                ;                               
1938   D188 C6 1C                   ldab    #$1c                    ;                             
1939   D18A BD EB F7                jsr     decTable                ;                                 
1940   D18D 4C                      inca                            ; a.0=1, set at 40Hz 
1941   D18E             
1942   D18E                         ;------------------------------------------
1943   D18E                         ; Update 10Hz flag based on T40_2hz 
1944   D18E                         ;------------------------------------------
1945   D18E F6 01 17                ldab    T40_2hz                 ; 
1946   D191 C5 03                   bitb    #$03                    ;                              
1947   D193 26 02                   bne     L1011                   ; Branch 3 times out of 4???
1948   D195 8A 02                   oraa    #$02                    ; a.1=1, set at ~10Hz
1949   D197             
1950   D197                         ;----------------------------------------------------------
1951   D197                         ; Check T40_2hz, loops at $14 (20d), which produces 2Hz
1952   D197                         ;----------------------------------------------------------
1953   D197 5D          L1011       tstb                            ;                             
1954   D198 26 0F                   bne     L1012                   ; Branch if T40_2hz is not null yet (takes ~0.5sec)
1955   D19A             
1956   D19A                         ;----------------------------------------------------------------------
1957   D19A                         ; Decrement all 2Hz timers (min of 0) from $0134 to $13f
1958   D19A                         ;----------------------------------------------------------------------
1959   D19A CE 01 34                ldx     #T2_crank               ;                                  
1960   D19D C6 0C                   ldab    #$0c                    ;                             
1961   D19F BD EB F7                jsr     decTable                ;                                 
1962   D1A2 8A 04                   oraa    #$04                    ; a.2=1, set at 2Hz 
1963   D1A4             
1964   D1A4                         ;-----------------
1965   D1A4                         ; Re-init counter
1966   D1A4                         ;-----------------
1967   D1A4 C6 14                   ldab    #$14                    ;                             
1968   D1A6 F7 01 17                stab    T40_2hz                 ;
1969   D1A9                                                         ;                 
1970   D1A9                         ;---------------------------------------------------------
1971   D1A9                         ; Check T40_0p5hz, loops at $50 (80d), which produces 0.5Hz
1972   D1A9                         ;---------------------------------------------------------
1973   D1A9 F6 01 18    L1012       ldab    T40_0p5hz               ;                              
1974   D1AC 26 0F                   bne     L1013                   ; Branch if T40_0p5hz is not null yet (takes ~2sec)                           
1975   D1AE             
1976   D1AE                         ;----------------------------------------------------------------
1977   D1AE                         ; Decrement all 0.5Hz timers (stop at 0) from $140 to $145
1978   D1AE                         ;----------------------------------------------------------------
1979   D1AE CE 01 40                ldx     #T0p5_crank1            ;                                
1980   D1B1 C6 05                   ldab    #$05                    ;                             
1981   D1B3 BD EB F7                jsr     decTable                ;                                 
1982   D1B6 8A 08                   oraa    #$08                    ; a.3=1
1983   D1B8             
1984   D1B8                         ;-----------------
1985   D1B8                         ; Re-init counter
1986   D1B8                         ;-----------------
1987   D1B8 C6 50                   ldab    #$50                    ;                             
1988   D1BA F7 01 18                stab    T40_0p5hz               ; Re-init T40_0p5hz with $50 (2sec)
1989   D1BD                         
1990   D1BD                         ;--------------------------------------------------------
1991   D1BD                         ; At this point, accum. A contains state of counters updated
1992   D1BD                         ; in the above code, store it in Tclocks                               
1993   D1BD                         ;--------------------------------------------------------
1994   D1BD 97 D9       L1013       staa    Tclocks                                                 
1995   D1BF             
1996   D1BF                         ;----------------------------------------------------------------------
1997   D1BF                         ; Re-init T40_crank, T2_crank, T0p5_crank1 to max if startingToCrank  
1998   D1BF                         ;----------------------------------------------------------------------
1999   D1BF 86 FF                   ldaa    #$ff                    ; a = $ff                             
2000   D1C1 8F E6 01 09             brclr   state1, #$01, L1014     ; Branch if startingToCrank is clear
2001   D1C5 B7 01 1A                staa    T40_crank               ; Engine startingToCrank, reset a few timers
2002   D1C8 B7 01 34                staa    T2_crank                ; 
2003   D1CB B7 01 40                staa    T0p5_crank1             ;                               
2004   D1CE             
2005   D1CE                         ;----------------------------------
2006   D1CE                         ; Re-init T40_start if key is in start
2007   D1CE                         ;----------------------------------
2008   D1CE 87 D7 40 03 L1014       brset   port3Snap0, #$40, L1015 ; Branch if key is not in start
2009   D1D2 B7 01 19                staa    T40_start               ; Key in start, re-init counter                             
2010   D1D5             
2011   D1D5                         ;-------------------------------------------------------------------
2012   D1D5                         ; Load config1 and config2 memories depending on config resistors
2013   D1D5                         ;-------------------------------------------------------------------
2014   D1D5 BD EA 16    L1015       jsr     loadConfig                   
2015   D1D8             
2016   D1D8                         ;-------------------------------------------------------
2017   D1D8                         ; Reset counter T200_cop to $0a (on every loop,
2018   D1D8                         ; will reach 0 only if main loop takes more
2019   D1D8                         ; than 50ms=10/200Hz, i.e. main loop slower than 20Hz)
2020   D1D8                         ; Could be used as a COP monitor to reset ECU???
2021   D1D8                         ;-------------------------------------------------------
2022   D1D8 86 0A                   ldaa    #$0a                    ; 50ms or 20Hz                             
2023   D1DA 97 C2                   staa    T200_cop                ; Re-init counter                               
2024   D1DC BD EA 25                jsr     initFunc1               ; Re-init ports and other stuff on every loop???, maybe used in conjunction with T200_cop timer...??? 
2025   D1DF             
2026   D1DF                         ;----------------------------------------
2027   D1DF                         ; Re-init timer 1 and 2 and t3_csr0 
2028   D1DF                         ;----------------------------------------
2029   D1DF 0F                      sei                             ;                             
2030   D1E0 02 08 1B                andm    t1_csr, #$1b            ;                                 
2031   D1E3 03 08 18                orm     t1_csr, #$18            ;                                 
2032   D1E6 03 18 18                orm     t2_csr, #$18            ;                                 
2033   D1E9 02 19 5E                andm    t3_csr0, #$5e           ;                                
2034   D1EC 03 19 42                orm     t3_csr0, #$42           ;                                
2035   D1EF 0E                      cli
2036   D1F0             
2037   D1F0                         ;---------------------------------------------------------
2038   D1F0                         ; Re-init some stuff in case the engine is not rotating
2039   D1F0                         ;---------------------------------------------------------
2040   D1F0 0F                      sei                             ;                             
2041   D1F1 F6 01 20                ldab    T40_engRot              ;                                     
2042   D1F4 26 0D                   bne     L1016                   ; Branch if T40_engRot not expired                             
2043   D1F6 CC 05 03                ldd     #$0503                  ; T40_engRot reached 0, re-init stuff since engine not rotating
2044   D1F9 97 B3                   staa    tdcCasFlags             ;                              
2045   D1FB D7 B4                   stab    casCylIndex             ; Why not std?                             
2046   D1FD 7F 00 A7                clr     injPw                   ;                              
2047   D200 BD D1 62                jsr     init_t1_t2              ;                         
2048   D203                              
2049   D203                         ;---------------------------------------------------------
2050   D203                         ; Re-init cas related controls if T40s_casInt is expired 
2051   D203                         ; i.e. no CAS interrupts received for over 1.275sec
2052   D203                         ;---------------------------------------------------------
2053   D203 87 84 FF 0C L1016       brset   T40s_casInt, #$ff, L1017 ; Branch if T40s_casInt not expired (not 0)                               
2054   D207 7F 00 83                clr     tdcCasCount              ; tdcCasCount = 0                                    
2055   D20A 03 19 0C                orm     t3_csr0, #$0c            ; set 0000 1111, disable both power transistor coils and ???
2056   D20D 03 1A 0A                orm     t3_csr1, #$0a            ; set 0000 1010,                                                                   
2057   D210 4F                      clra                             ;                                                                   
2058   D211 97 63                   staa    enerFlags                ;                                                                    
2059   D213 0E          L1017       cli                              ;                                                                 
2060   D214             
2061   D214                         ;------------------------------
2062   D214                         ; Check if ECU is in test mode
2063   D214                         ;------------------------------
2064   D214 87 07 08 12             brset   port4, #$08, L1018       ; Branch if ECU test mode terminal is grounded
2065   D218             
2066   D218                         ;--------------------------------------
2067   D218                         ; Not in test mode, Reset serial comm.
2068   D218                         ;--------------------------------------
2069   D218 DC 11                   ldd     sci_scr                          ; Read serial port at address 0011 (status) and 0012 (data) (clears it)?       
2070   D21A CC 06 00                ldd     #($0400 |((baudRate & $03)<<8))  ; A=06, B=00                                                                    
2071   D21D DD 10                   std     sci_baud                         ; set serial port mode, sci_rate=06, sci_cr=00                                                          
2072   D21F 03 BA 3F                orm     obdInjCmd, #$3f                  ; Reset all injector off commands                                                                         
2073   D222 7F 00 FB                clr     obdActCmd                        ; Reset all actuator on commands
2074   D225 02 FA 3C                andm    obdFlags, #$3c                   ; Reset stored serial port state to 00xxxx00?, FA.0 and FA.1 are reset to 0                                  
2075   D228 20 26                   bra     L1022                                                      
2076   D22A                         
2077   D22A                         ;------------------------------------
2078   D22A                         ; At this point, we are in test mode
2079   D22A                         ;------------------------------------
2080   D22A 87 FA 02 06 L1018       brset   obdFlags, #$02, L1019     ; Check if port2.4 initialized to 1 (output to serial connector)?                                                 
2081   D22E 03 03 10                orm     port2, #$10               ; Set output to serial port to 1 (heart beat level on diagnostic port if TE not enabled)                          
2082   D231 03 FA 02                orm     obdFlags, #$02            ; Set $FA.1 indicating we initialized default serial port output                                                   
2083   D234 87 FA 01 0F L1019       brset   obdFlags, #$01, L1020     ; branch if FA.0 is 1? (FA.0 seems to be toggled on every loop)                                                   
2084   D238             
2085   D238                         ;---------------------------------------------------------------------------------
2086   D238                         ; At this point serial tx was previously enabled, reset all parameters anyway
2087   D238                         ; Code is executed only after tx is enabled on first loop at (preamble is sent, 
2088   D238                         ; we don't want to receive the echo...) and then at 1/2 loop frequency
2089   D238                         ;---------------------------------------------------------------------------------
2090   D238 86 06                   ldaa    #($04 | (baudRate & $03)) ;
2091   D23A D6 11                   ldab    sci_scr                   ;                              
2092   D23C C4 FA                   andb    #$fa                      ;                           
2093   D23E CA 18                   orab    #$18                      ;                           
2094   D240 DD 10                   std     sci_baud                  ; Set baud rate and serial port mode                               
2095   D242 03 FA 01                orm     obdFlags, #$01            ;                                 
2096   D245 20 06                   bra     L1021                     ;                            
2097   D247 03 11 02    L1020       orm     sci_scr, #$02             ;                                
2098   D24A 02 FA FE                andm    obdFlags, #$fe            ;                                 
2099   D24D 7F 01 7C    L1021       clr     errCodeProc               ; Reset code (no code...) being output to test connector (heart beat mode)                                    
2100   D250             
2101   D250                         ;------------------------------------------------
2102   D250                         ; Build port3Snap0 from port3
2103   D250                         ;------------------------------------------------
2104   D250 96 06       L1022       ldaa    port3                   ; a = port3                              
2105   D252 84 FB                   anda    #$fb                    ; Reset 0000 0100
2106   D254             #ifdef E932
2107   D254 F6 01 19                ldab    T40_start               ;                              
2108   D257 CB 3C                   addb    #$3c                    ; add 1.5s                            
2109   D259 24 02                   bcc     L1023                   ; branch if key was out of start for more than than 1.5s                            
2110   D25B             #endif
2111   D25B 8A 20                   oraa    #$20                    ; force setting of park/neutral flag                             
2112   D25D F6 01 1A    L1023       ldab    T40_crank               ;                                   
2113   D260 CB AC                   addb    #$ac                    ; 4.3s                             
2114   D262 24 02                   bcc     L1024                   ; branch if engine stopped "startingToCrank" more than 4.3s ago                              
2115   D264 8A 10                   oraa    #$10                    ; Force setting of A/C switch flag                             
2116   D266 8F E6 11 02 L1024       brclr   state1, #$11, L1025     ; Branch if both notRotating and startingToCrank clear
2117   D26A 8A 30                   oraa    #$30                    ; engine is either notRotating or startingToCrank, force setting of both A/C switch  and park/neutral flags                              
2118   D26C D6 D3       L1025       ldab    ectFiltered             ;                              
2119   D26E C1 9B                   cmpb    #$9b                    ; 10.2degC                              
2120   D270 25 02                   bcs     L1026                   ; Branch if ECT temperature lower than threshold                             
2121   D272 84 F7                   anda    #$f7                    ; Reset $08, power steering flag                            
2122   D274 97 D7       L1026       staa    port3Snap0               ;                              
2123   D276             
2124   D276                         ;----------------------------
2125   D276                         ; Build port4Snap from port4
2126   D276                         ;----------------------------
2127   D276 96 07                   ldaa    port4                   ;                              
2128   D278 84 78                   anda    #$78                    ; Only keep 01111000                             
2129   D27A 97 D8                   staa    port4Snap               ;                              
2130   D27C             
2131   D27C                         ;------------------------------------------
2132   D27C                         ; Read some ADC inputs 
2133   D27C                         ;     ECT (engine coolant temp)
2134   D27C                         ;     IAT (intake air temp)
2135   D27C                         ;     BARO
2136   D27C                         ;     O2
2137   D27C                         ;     EGRT
2138   D27C                         ;------------------------------------------
2139   D27C CD CE 00 CB             ldy     #$00cb                  ;                               
2140   D280 86 08                   ldaa    #$08                    ;                             
2141   D282 36          L1027       psha                            ;                             
2142   D283 BD EC 0B                jsr     readAdc1                ;                                 
2143   D286 0E                      cli                             ;                             
2144   D287 E7 80                   stab    $00,y                   ; y = y + 1                              
2145   D289 32                      pula                            ;                             
2146   D28A 4C                      inca                            ;                             
2147   D28B 81 0D                   cmpa    #$0d                    ;                             
2148   D28D 25 F3                   bcs     L1027                   ;       
2149   D28F                                                
2150   D28F                         ;------------------------------------------------------
2151   D28F                         ; Validate and condition raw engine coolant temperature
2152   D28F                         ;------------------------------------------------------
2153   D28F 02 D6 F0                andm    state2, #$f0            ; Reset error flags before update below                                 
2154   D292 D6 CB                   ldab    ectRaw                  ; b = ectRaw                              
2155   D294 C1 05                   cmpb    #$05                    ; 141degC                            
2156   D296 25 04                   bcs     L1028                   ;                              
2157   D298 C1 EC                   cmpb    #$ec                    ; -52degC                             
2158   D29A 23 05                   bls     L1029                   ;                              
2159   D29C C6 1E       L1028       ldab    #$1e                    ; Use default of 83degC
2160   D29E 03 D6 01                orm     state2, #$01            ; Set error flag                                
2161   D2A1             
2162   D2A1                         ;-------------------------------------------------
2163   D2A1                         ; Check some conditions for filtered ECT update
2164   D2A1                         ;-------------------------------------------------
2165   D2A1 8F D6 10 02 L1029       brclr   state2, #$10, L1030     ;                                
2166   D2A5 C6 1E                   ldab    #$1e                    ; Use default of 83degC
2167   D2A7 87 E6 10 1C L1030       brset   state1, #$10, L1033     ; Branch if notRotating                                
2168   D2AB 8F D9 04 1F             brclr   Tclocks, #$04, L1035    ; Branch if 2Hz signal not set
2169   D2AF             
2170   D2AF                         ;----------------------------------------------------
2171   D2AF                         ; At this point 2 Hz signal is set and  b = validated ECT
2172   D2AF                         ;
2173   D2AF                         ; Filter the validated ECT
2174   D2AF                         ;
2175   D2AF                         ; This section of code computes ectFiltered which
2176   D2AF                         ; is basically the same as validated ECT except
2177   D2AF                         ; that it can only increase by 3 units every 0.5s...
2178   D2AF                         ; or decrease by 1 unit every 0.5s
2179   D2AF                         ;----------------------------------------------------
2180   D2AF 96 D3                   ldaa    ectFiltered             ; a = ectFiltered
2181   D2B1 10                      sba                             ; a = a-b = ectFiltered - validated ECT = ECTdiff
2182   D2B2 24 09                   bcc     L1031                   ; Branch if ectFiltered >= validated ECT (new temp is higher than old one, which is normal case when warming...)
2183   D2B4 D6 D3                   ldab    ectFiltered             ; ectFiltered < validated ECT (temperatured lowered...)                             
2184   D2B6 C1 54                   cmpb    #$54                    ; 41degC                             
2185   D2B8 27 12                   beq     L1034                   ; branch if equal to this temp????                            
2186   D2BA 5C                      incb                            ; else increment validated ECT (decrease temp) by 1 at a time (slowly change it to reflect sensor value...)
2187   D2BB 20 0A                   bra     L1033                   ;
2188   D2BD             
2189   D2BD 81 03       L1031       cmpa    #$03                    ; Check ECT difference
2190   D2BF 23 02                   bls     L1032                   ; Branch if ECT difference <= 3  (5F)                             
2191   D2C1 86 03                   ldaa    #$03                    ; Difference higher than 3, use 3                            
2192   D2C3 90 D3       L1032       suba    ectFiltered             ;                              
2193   D2C5 40                      nega                            ; a = ectFiltered-min(ECTdiff,3) =  ectFiltered - min(ectFiltered-validatedECT, 3) = validatedECT if difference smaller than 3, else it lags behind... 
2194   D2C6 16                      tab                             ; b = ectFiltered-min(ECTdiff,3)
2195   D2C7             
2196   D2C7 86 96       L1033       ldaa    #$96                    ; 300s (5 minutes!!!)                              
2197   D2C9 B7 01 44                staa    T0p5_ect                ; Reset counter                               
2198   D2CC D7 D3       L1034       stab    ectFiltered             ; ectFiltered = filtered and validated ECT
2199   D2CE             
2200   D2CE                         ;----------------------------------------------------------
2201   D2CE                         ; Compute ectCond which is used for table interpolation
2202   D2CE                         ; Limit max value to $e0 (min temp of -29degC) 
2203   D2CE                         ; Scale by 8 below $20 (temp above 80degC) 
2204   D2CE                         ;
2205   D2CE                         ;     ectFiltered          ectFiltered        ectCond
2206   D2CE                         ;  -31degC to -59degC          $e1-$ff   ->   $e0        
2207   D2CE                         ;   80degC to -29degC          $20-$e0   ->   $20-$e0    
2208   D2CE                         ;   81.3degC                       $1f   ->   $18        
2209   D2CE                         ;   82.8degC                       $1e   ->   $10        
2210   D2CE                         ;   84.3degC                       $1d   ->   $08        
2211   D2CE                         ;   158degC to 85.9degC        $00-$1c   ->   $00        
2212   D2CE                         ;----------------------------------------------------------
2213   D2CE D6 D3       L1035       ldab    ectFiltered             ;                                    
2214   D2D0 C1 E0                   cmpb    #$e0                    ; -29degC                            
2215   D2D2 23 02                   bls     L1036                   ; Branch if ectFiltered <= $e0
2216   D2D4 C6 E0                   ldab    #$e0                    ; Use max of $e0
2217   D2D6 C1 20       L1036       cmpb    #$20                    ; 80degC  
2218   D2D8 24 08                   bcc     L1038                   ; Branch if ectFiltered >= $20
2219   D2DA C0 1C                   subb    #$1c                    ; b = ectFiltered - $1c
2220   D2DC 24 01                   bcc     L1037                   ; Branch if no underflow
2221   D2DE 5F                      clrb                            ; underflow, use 0 
2222   D2DF 58          L1037       aslb                            ;                             
2223   D2E0 58                      aslb                            ;                             
2224   D2E1 58                      aslb                            ; b = (ectFiltered-$1c)*8 
2225   D2E2 F7 01 4E    L1038       stab    ectCond                 ; Store conditionned ect          
2226   D2E5                                  
2227   D2E5                         ;-------------------------------------------------
2228   D2E5                         ; Validate/condition raw intake air temperature
2229   D2E5                         ;-------------------------------------------------
2230   D2E5 D6 CC                   ldab    iatRaw                  ;                               
2231   D2E7 C1 0E                   cmpb    #$0e                    ; 122degC
2232   D2E9 25 04                   bcs     L1039                   ; Branch if temp > 122degC
2233   D2EB C1 EA                   cmpb    #$ea                    ; -49degC                            
2234   D2ED 23 05                   bls     L1040                   ; Branch if temp > -49degC                              
2235   D2EF 03 D6 02    L1039       orm     state2, #$02            ; Set fault code                                
2236   D2F2 C6 7B                   ldab    #$7b                    ; Use 25degC
2237   D2F4 D7 D4       L1040       stab    iatChecked              ;                 
2238   D2F6                          
2239   D2F6                         ;-----------------------------------------------------------
2240   D2F6                         ; Compute conditionned IAT for later table interpolation
2241   D2F6                         ;-----------------------------------------------------------
2242   D2F6 CE E0 20                ldx     #$e020                  ; Load x with max/offset (max=$e0)                              
2243   D2F9 BD EB B9                jsr     clipOffset              ; b = max(min(b,$e0)-$20,0)-> offset and clip temp, returns b=$00 to $c0
2244   D2FC F7 01 4F                stab    iatCond                 ; Conditionned IAT
2245   D2FF                                                      
2246   D2FF                         ;-------------------------------------------------
2247   D2FF                         ; Compute air density factor based on air temperature
2248   D2FF                         ;-------------------------------------------------
2249   D2FF CE FC 05                ldx     #t_airDens              ;                               
2250   D302 BD EB 39                jsr     iatCInterp              ;                              
2251   D305 F7 01 5F                stab    iatCompFact             ; Air density factor                             
2252   D308             
2253   D308                         ;---------------------------------------------------
2254   D308                         ; Check battery voltage for baro sensor validation
2255   D308                         ;---------------------------------------------------
2256   D308 96 D0                   ldaa    battRaw                   ;                                 
2257   D30A 81 6D                   cmpa    #$6d                      ; 8V
2258   D30C 24 05                   bcc     L1042                     ; Branch if more than 8V                             
2259   D30E 86 0E                   ldaa    #$0e                      ; battery voltage too low, start timer??? (0.35sec)                            
2260   D310 B7 01 1B                staa    T40_baro                  ;                              
2261   D313             
2262   D313                         ;------------------------------------------------------------
2263   D313                         ; Validate baro range, T40_baro is used to ignore baroRaw
2264   D313                         ; When battery<8v (and 0.35s after it is >8V)
2265   D313                         ;------------------------------------------------------------
2266   D313 D6 CD       L1042       ldab    baroRaw                   ; 
2267   D315 B6 01 1B                ldaa    T40_baro                  ;                                                                 
2268   D318 26 0B                   bne     L1044                     ; Branch if battery voltage was too low                                                                
2269   D31A C1 E4                   cmpb    #$e4                      ; 1.1 bar                                                       
2270   D31C 24 04                   bcc     L1043                     ; branch if baroRaw > 1.1
2271   D31E C1 64                   cmpb    #$64                      ; .49 bar                                                       
2272   D320 24 05                   bcc     L1045                     ; branch if baroRaw > .49
2273   D322 03 D6 04    L1043       orm     state2, #$04              ; Set error flag
2274   D325 C6 CD       L1044       ldab    #$cd                      ; Use 1.0 bar                                           
2275   D327 D7 D5       L1045       stab    baroChecked               ;                                                                
2276   D329             
2277   D329                         ;-----------------------------------------------------
2278   D329                         ; Compute conditionned baro for table interpolation
2279   D329                         ;-----------------------------------------------------
2280   D329 CE BD 5D                ldx     #$bd5d                    ;                                                                  
2281   D32C BD EB B9                jsr     clipOffset                ; b = max(min(b,$bd)-$5d,0)-> offset and clip baro, returns b = $00 to $60  (0.45bar to 0.92bar???)                                           
2282   D32F C1 40                   cmpb    #$40                      ;                                                                
2283   D331 25 03                   bcs     L1046                     ; branch if b < $40 
2284   D333 58                      aslb                              ; else mult by 2                                                
2285   D334 C0 40                   subb    #$40                      ; and sub 40 -> 1:1 scale for $00 to $40 and 2:1 scale for $40 to $60, new max is $80, not $60                                                   
2286   D336 F7 01 52    L1046       stab    baroCond                  ; Conditionned baro used in table lookup
2287   D339             
2288   D339                         ;----------------------------------------------------
2289   D339                         ; Compute barometric pressure factor for fuel inj.
2290   D339                         ;----------------------------------------------------
2291   D339 D6 D5                   ldab    baroChecked               ;                                                 
2292   D33B 86 A0                   ldaa    #$a0                      ;                                                                
2293   D33D 3D                      mul                               ; baroChecked*160                                                              
2294   D33E 58                      aslb                              ;                                                                
2295   D33F 89 00                   adca    #$00                      ; round-up                                                              
2296   D341 B7 01 60                staa    baroFact                  ; barometric pressure factor = rounded baroChecked*160/256 -> pressure is (baroFact/128) bar, i.e. $80 = 1 bar                                                    
2297   D344             
2298   D344                         ;-------------------------------------------------------------
2299   D344                         ; Transfer tpsDiffMax1 to tpsDiffMax2 and reset tpsDiffMax1 
2300   D344                         ;-------------------------------------------------------------
2301   D344 0F                      sei                               ;                                                              
2302   D345 96 C8                   ldaa    tpsDiffMax1               ;                                  
2303   D347 7F 00 C8                clr     tpsDiffMax1               ;                                  
2304   D34A 0E                      cli                               ;                           
2305   D34B B7 01 4D                staa    tpsDiffMax2               ;     
2306   D34E                                                      
2307   D34E                         ;-----------------------------------------------------------
2308   D34E                         ; If engine is not rotating, re-init Tcas and use rpm = 0
2309   D34E                         ;-----------------------------------------------------------
2310   D34E 8F E6 10 07             brclr   state1, #$10, L1047       ; Branch if notRotating clear
2311   D352 BD D1 72                jsr     init_Tcas                 ; engine is notRotating, re-init Tcas
2312   D355 4F                      clra                              ;                              
2313   D356 5F                      clrb                              ; use d = rpm = 0 for below                             
2314   D357 20 06                   bra     L1048                     ;                              
2315   D359             
2316   D359                         ;------------------------------------------------------------------------
2317   D359                         ; Update rpm variables from Tcas (Tcas is obtained from CAS interrupt)
2318   D359                         ;------------------------------------------------------------------------
2319   D359 FC 01 45    L1047       ldd     Tcas                      ;                               
2320   D35C BD EA 45                jsr     calcFreq                  ; D = $EA600/Tcas = 960000/Tcas = 960000/(125000/2/(rpm/60)) = 0.256*rpm                                
2321   D35F DD DA       L1048       std     rpm4                      ; RPM4 = #$EA600/Tcas = 0.256*rpm                                                                    
2322   D361 BD EB AE                jsr     scale2m                   ; scale D by 2                                                                                           
2323   D364 D7 DC                   stab    rpm8                      ; rpm8 = #$EA600/Tcas/2 = rpm/7.8125                                                              
2324   D366 DC DA                   ldd     rpm4                      ; D = #$EA600/Tcas                                                                                     
2325   D368 BD EB AC                jsr     scale8m                   ; D = #$EA600/Tcas/8 = rpm/31.25                                                                       
2326   D36B D7 DD                   stab    rpm31                     ; rpm31 = #$EA600/Tcas/8 = #$EA600 / (125000/2/(rpm/60)) / 8 = rpm/31.25.                              
2327   D36D             
2328   D36D                         ;------------------------------------------------------
2329   D36D                         ; Compute rpmIndex1 for eventual map interpolation 
2330   D36D                         ;------------------------------------------------------
2331   D36D 86 90                   ldaa    #$90                      ; a=$90 (4500rpm)                            
2332   D36F BD EC 1C                jsr     rpmRange                  ; get rpm for map interpolation, b = min(max(RPM31p25-#$10, 0), $90) = min(max(RPM31p25-500rpm,0),4500rpm)  
2333   D372 F7 01 51                stab    rpmIndex1                 ; rpmIndex1
2334   D375                                                      
2335   D375                         ;-------------------------------------------------------------
2336   D375                         ; if notRotating or startingToCrank. Use rpmX4Filt = 16*rpm4
2337   D375                         ;-------------------------------------------------------------
2338   D375 8F E6 11 0B             brclr   state1, #$11, L1049       ; branch if notRotating and startingToCrank clear 
2339   D379 DC DA                   ldd     rpm4                      ; engine is either notRotating or startingToCrank                               
2340   D37B 05                      asld                              ;                             
2341   D37C 05                      asld                              ;                             
2342   D37D 05                      asld                              ;                             
2343   D37E 05                      asld                              ; d = 16*rpm4                              
2344   D37F 02 9E FE                andm    masCasFlags, #$fe         ; reset masCasFlags.1                                
2345   D382 20 32                   bra     L1050                     ; 
2346   D384                                                      
2347   D384                         ;-----------------------------------------------------------------
2348   D384                         ; Engine is running, Use rpmX4Filt = filtered(16*rpm4)
2349   D384                         ; Update only when masCasFlags.1 was set by interrupt 
2350   D384                         ;
2351   D384                         ; rpmX4Filt is basically the filtered version of rpm4 where 
2352   D384                         ; an exponential averaging filter is used
2353   D384                         ;
2354   D384                         ; rpmX4Filt = $e8/256 * oldrpmX4Filt + $18/256   * 16*rpm4
2355   D384                         ;              alpha * oldrpmX4Filt + (1-alpha) * 16*rpm4
2356   D384                         ;
2357   D384                         ; where alpha = 0.90625
2358   D384                         ;-----------------------------------------------------------------
2359   D384 8F 9E 01 31 L1049       brclr   masCasFlags, #$01, L1051  ; Branch if flag not set                              
2360   D388 02 9E FE                andm    masCasFlags, #$fe         ; Reset the flag
2361   D38B FE 01 84                ldx     rpmX4Filt                 ; x = rpmX4Filt                             
2362   D38E C6 E8                   ldab    #$e8                      ; b = $e8                            
2363   D390 BD EA 72                jsr     mul816b                   ; d = $e8/256 * rpmX4Filt, temp3 = lower 8 bits of result                                 
2364   D393 FD 01 84                std     rpmX4Filt                 ; rpmX4Filt = $e8/256 * rpmX4Filt                             
2365   D396 96 59                   ldaa    temp3                     ; 
2366   D398 97 5A                   staa    temp4                     ; temp4 = temp3 = lower 8 bits of ($e8/256 * old rpmX4Filt)                              
2367   D39A DC DA                   ldd     rpm4                      ;                             
2368   D39C 05                      asld                              ;                             
2369   D39D 05                      asld                              ;                             
2370   D39E 05                      asld                              ;                             
2371   D39F 05                      asld                              ; d = 16 * rpm4                            
2372   D3A0 1A                      xgdx                              ; x = 16 * rpm4                             
2373   D3A1 C6 E8                   ldab    #$e8                      ; b = $e8                            
2374   D3A3 50                      negb                              ; b = -$e8 = $18 (why not load it directly, maybe mitsu compiler stuff...?)                            
2375   D3A4 BD EA 72                jsr     mul816b                   ; d = $18/256 * 16 * rpm4                                
2376   D3A7 1A                      xgdx                              ; x = $18/256 * 16 * rpm4                             
2377   D3A8 5F                      clrb                              ; b = 0                            
2378   D3A9 96 59                   ldaa    temp3                     ; a = lower 8 bits of ($18/256 * 16 * rpm4)                              
2379   D3AB 9B 5A                   adda    temp4                     ; a = lower 8 bits of ($18/256 * 16 * rpm4) + lower 8 bits of ($e8/256 * old rpmX4Filt)                             
2380   D3AD 59                      rolb                              ; b = carry bit (if a carry was generated) from that addition                             
2381   D3AE 49                      rola                              ; a = a*2 (shift upper bit for roundoff purposes)                           
2382   D3AF C9 00                   adcb    #$00                      ; Round off. At this point, b contains the rounded-up highest bit of the addition of the lowest 8 bits
2383   D3B1 3A                      abx                               ; x = $18/256 * 16 * rpm4 + rounded lower 1 bit                                                                               
2384   D3B2 1A                      xgdx                              ; d = $18/256 * 16 * rpm4 + rounded lower 1 bit                                                                                 
2385   D3B3 F3 01 84                addd    rpmX4Filt                 ; d = $18/256 * 16 * rpm4 + $e8/256 * old rpmX4Filt                                                                                   
2386   D3B6 FD 01 84    L1050       std     rpmX4Filt                 ; Store new value                            
2387   D3B9                                                                
2388   D3B9                         ;-------------------------------------------------------------
2389   D3B9                         ; Restart T40_mas if engine notRotating or startingToCrank 
2390   D3B9                         ;-------------------------------------------------------------
2391   D3B9 8F E6 11 05 L1051       brclr   state1, #$11, L1052       ; branch if notRotating and startingToCrank clear
2392   D3BD 86 0C                   ldaa    #$0c                      ; Engine is either notRotating or startingToCrank                                                                              
2393   D3BF B7 01 21                staa    T40_mas                   ; Restart timer at 0.3s 
2394   D3C2             
2395   D3C2                         ;-----------------------------------------
2396   D3C2                         ; Set state2 mas flag if T40_mas expired
2397   D3C2                         ;-----------------------------------------
2398   D3C2 B6 01 21    L1052       ldaa    T40_mas                   ; 
2399   D3C5 26 03                   bne     L1053                     ; Branch if counter not yet 0                                                                               
2400   D3C7 03 D6 08                orm     state2, #$08              ; Set bit indicating timer expired
2401   D3CA             
2402   D3CA                         ;---------------------------------------------------------------------------
2403   D3CA                         ; Compute mafRaw16 and mafRaw from airCnt0:airCnt1 
2404   D3CA                         ;
2405   D3CA                         ; Since airCnt0:airCnt1 is filtered airCntNew0:airCntNew1, we have
2406   D3CA                         ;
2407   D3CA                         ;   mafRaw = $200d * airCnt0 / Tcas / 64  
2408   D3CA                         ;          = 8205 * airCntNew0 / Tcas / 64          
2409   D3CA                         ;          = 8205 * (N+r) * $9c / Tcas / 64        (see airCntNew0 definition)
2410   D3CA                         ;          = 8205 * (N+r) * $9c / (125000*TcasInSeconds) / 64
2411   D3CA                         ;          = (N+r)/TcasInSeconds/6.25
2412   D3CA                         ;          = "number of airflow sensor pulse per sec" / 6.25
2413   D3CA                         ;
2414   D3CA                         ; Where:
2415   D3CA                         ; 
2416   D3CA                         ;     -Tcas is the time required for 1 cas interrupt (there are 4 cas 
2417   D3CA                         ;      interrupts for every 2 rotations which basically means 1 cas 
2418   D3CA                         ;      interrupt for every complete cycle of one cylinder)
2419   D3CA                         ;     -(N+r) is the number of air sensor pulses received during
2420   D3CA                         ;            one cas interrupt, r<1 is the fractional part. See
2421   D3CA                         ;            the mas interrupt for assumptions...
2422   D3CA                         ;     -Tcas is the cas interrupt period measured at 125KHz 
2423   D3CA                         ;
2424   D3CA                         ;---------------------------------------------------------------------------
2425   D3CA FC 01 45    L1053       ldd     Tcas                      ; d = Tcas                                                                                        
2426   D3CD DD 5A                   std     temp4                     ;                                                                                       
2427   D3CF CC 20 0D                ldd     #$200d                    ; d = $200d = 8205d                                                                                      
2428   D3D2 DE 8D                   ldx     airCnt0                   ;                                                                                          
2429   D3D4 DF 5C                   stx     temp6                     ;                                                                                       
2430   D3D6 BD EA 85                jsr     mul1616                   ; d = d * temp6:temp7 = ($200d * airCnt0)/65536 = 0.125198*airCnt0
2431   D3D9 BD EA B3                jsr     div3216                   ; d = 65536*0.125198*airCnt0/Tcas = 8205 * airCnt0/Tcas                                                                  
2432   D3DC FD 01 4B                std     mafRaw16                  ; 16 bit mafRaw                                                                                      
2433   D3DF~            #ifdef masLog2X                               ;                        
2434   D3DF~                        jsr     scale128m                 ;                                              
2435   D3DF             #else                                         ;            
2436   D3DF BD EB A9                jsr     scale64m                  ; d = 8205*airCnt0/Tcas/64, result is in B...                                 
2437   D3E2             #endif                                        
2438   D3E2 87 E6 10 04             brset   state1, #$10, L1054       ; Branch if engine notRotating
2439   D3E6 8F D6 08 01             brclr   state2, #$08, L1055       ; Branch if pulse accumulator interrupts received
2440   D3EA 5F          L1054       clrb                              ; No interrupts or notRotating, use 0 air flow                            
2441   D3EB D7 E4       L1055       stab    mafRaw                    ; Store 8 bit mafRaw =  8205*airCnt0/Tcas/64
2442   D3ED             
2443   D3ED                         ;----------------------------------------------------------------------
2444   D3ED                         ; Compute airCntMax (max air count as a function of rpm, ect and iat)
2445   D3ED                         ;----------------------------------------------------------------------
2446   D3ED DC DA                   ldd     rpm4                      ; d = rpm4                                                                       
2447   D3EF 81 03                   cmpa    #$03                      ; compare high part to 3 -> compare D to 768                                       
2448   D3F1 25 03                   bcs     L1057                     ; Branch if RPM < 3000                                                              
2449   D3F3 CC 03 00                ldd     #$0300                    ; RPM >=3000 -> use 3000                                                             
2450   D3F6 05          L1057       asld                              ;                                                                                  
2451   D3F7 05                      asld                              ; scale rpm
2452   D3F8 CE FB 8E                ldx     #t_airCntMax              ;                                                                                   
2453   D3FB BD EB 47                jsr     interp1                   ; b = t_airCntMax[rpm]
2454   D3FE 4F                      clra                              ;                                                                                  
2455   D3FF DD 5C                   std     temp6                     ; temp6:temp7 = t_airCntMax[rpm]
2456   D401 CE FB 9B                ldx     #L1990                    ;                               
2457   D404 B6 01 4E                ldaa    ectCond                   ;                                
2458   D407 BD EB 5D                jsr     interp32mul               ; D = t_airCntMax[rpm] * L1990[ectCond]
2459   D40A CE FB A3                ldx     #L1991                    ;                               
2460   D40D B6 01 4F                ldaa    iatCond                   ;                                
2461   D410 BD EB 5D                jsr     interp32mul               ; D = t_airCntMax[rpm] * L1990[ectCond] * L1991[iatCond]
2462   D413 BD EB B3                jsr     ovfCheck                  ; Check for overflow                              
2463   D416 D7 A0                   stab    airCntMax                 ; airCntMax = t_airCntMax[rpm] * L1990[ectCond] * L1991[iatCond]
2464   D418                                                       
2465   D418                         ;------------------------------------------------
2466   D418                         ; Store airCntMax in airCnt0 and oldAirCnt0 
2467   D418                         ; when engine is notRotating or startingToCrank
2468   D418                         ;------------------------------------------------
2469   D418 8F E6 11 08             brclr   state1, #$11, L1060       ; branch if notRotating and startingToCrank clear   
2470   D41C 4F                      clra                              ; engine is either notRotating or startingToCrank                                
2471   D41D 05                      asld                              ;                           
2472   D41E 05                      asld                              ;                           
2473   D41F 05                      asld                              ; d = airCntMax*8                             
2474   D420 DD 8D                   std     airCnt0                   ; airCnt0:airCnt1 = airCntMax*8                                 
2475   D422 DD 92                   std     oldAirCnt0                ; oldAirCnt0 = airCntMax*8                              
2476   D424             
2477   D424                         ;----------------------------------------------
2478   D424                         ; Compute airCntDef, default airCnt0 value 
2479   D424                         ; when no mas interrupts are being received 
2480   D424                         ;----------------------------------------------
2481   D424 CD CE FF CB L1060       ldy     #L2053                    ;                               
2482   D428 BD EB E9                jsr     rpmPwise                  ; b = F(rpm4), see L2053 table                                
2483   D42B 37                      pshb                              ;                             
2484   D42C CE FE FC                ldx     #L2036                    ;                               
2485   D42F BD EB 2F                jsr     interpEct                 ;                                  
2486   D432 DB D2                   addb    tpsRaw                    ; b = tpsRaw + L2036[ect]                            
2487   D434 24 02                   bcc     L1062                     ; overflow check                              
2488   D436 C6 FF                   ldab    #$ff                      ; Use max                            
2489   D438 CE BA 1A    L1062       ldx     #$ba1a                    ;                               
2490   D43B BD EB B9                jsr     clipOffset                ; offset and clip b, b = max(min(tpsRaw + L2036[ect],$ba)-$1a,0)
2491   D43E 54                      lsrb                              ; b = b/2                           
2492   D43F 32                      pula                              ; a = F(rpm4)                            
2493   D440 CE FB 37                ldx     #L1986                    ;                               
2494   D443 CD CE 05 00             ldy     #$0500                    ;                               
2495   D447 BD EA D8                jsr     lookup2D2                 ; b = L1986[a,b], 2D interpolated air count since stored in airCntDef which is stored in airCnt0 under some cases??? 
2496   D44A 86 57                   ldaa    #$57                      ;                             
2497   D44C 3D                      mul                               ; b = $57*L1986[a,b]                            
2498   D44D BD EB A8                jsr     scale128m                 ; b = $57*L1986[a,b]/128                                 
2499   D450 D7 FF                   stab    airCntDef                 ; airCntDef = $57*L1986[a,b]/128                             
2500   D452                         
2501   D452                         ;------------------------------------------------------
2502   D452                         ; Re-init airFiltFact (airflow filtering factor)
2503   D452                         ;
2504   D452                         ; Filtering factor depends on current conditions???
2505   D452                         ;------------------------------------------------------
2506   D452~            #ifdef E931
2507   D452~                        ldaa    #$b3                       ; Value to use if timer T40_ftrim2 is expired                             
2508   D452~                        ldab    T40_ftrim2                 ;                               
2509   D452~                        beq     L1064                      ;                               
2510   D452             #endif                                         
2511   D452 86 D1                   ldaa    #$d1                       ;                             
2512   D454 87 F3 10 02             brset   iscLrnFlags, #$10, L1064   ; Branch if conditions are good to update isc variables                              
2513   D458 86 E4                   ldaa    #$e4                       ;                             
2514   D45A 97 9F       L1064       staa    airFiltFact             
2515   D45C             
2516   D45C                         ;-------------------------------------------------------------
2517   D45C                         ; Transfer airDiffPos:airDiffNeg to airDiffPos1:airDiffNeg1
2518   D45C                         ; and re-init airDiffPos:airDiffNeg to 0                                    
2519   D45C                         ;-------------------------------------------------------------
2520   D45C 4F                      clra                              ;                             
2521   D45D 5F                      clrb                              ;                             
2522   D45E 0F                      sei                               ;
2523   D45F DE 94                   ldx     airDiffPos                ;                                   
2524   D461 DD 94                   std     airDiffPos                ;                                   
2525   D463 0E                      cli                               ;                             
2526   D464 FF 01 49                stx     airDiffPos1               ;                              
2527   D467             
2528   D467                         ;-----------------------------------------------------------------------------------------
2529   D467                         ; Compute airCntMin0 (minimum value of airCntNew0 before it is used for airCnt0 calc)
2530   D467                         ;-----------------------------------------------------------------------------------------
2531   D467 4F                      clra                            ;                             
2532   D468 5F                      clrb                            ; d = 0                            
2533   D469 87 E6 11 23             brset   state1, #$11, L1065     ; branch if engine notRotating or startingToCrank (use minimum of 0)
2534   D46D 86 10                   ldaa    #$10                    ;                               
2535   D46F~            #ifdef E931
2536   D46F~                        ldab    #$81                                                 
2537   D46F             #else
2538   D46F C6 91                   ldab    #$91                                                 
2539   D471             #endif
2540   D471 3D                      mul                             ;                            
2541   D472 FE 01 45                ldx     Tcas                    ;                               
2542   D475 DF 5C                   stx     temp6                   ;                              
2543   D477 BD EA 85                jsr     mul1616                 ;                                
2544   D47A CE 40 00                ldx     #$4000                  ;                               
2545   D47D DF 5C                   stx     temp6                   ;                              
2546   D47F BD EA 85                jsr     mul1616                 ;                                
2547   D482 1A                      xgdx                            ;
2548   D483~            #ifdef E931
2549   D483~                        ldab    baroFact                ;                                 
2550   D483             #else
2551   D483 C6 80                   ldab    #$80                    ; Use 1.0 bar
2552   D485 01                      nop                                                          
2553   D486             #endif
2554   D486 B6 01 5F                ldaa    iatCompFact             ;                                    
2555   D489 3D                      mul                             ;                             
2556   D48A DD 5A                   std     temp4                   ;                              
2557   D48C 1A                      xgdx                            ;                             
2558   D48D BD EA B3                jsr     div3216                 ;                                
2559   D490 FD 01 87    L1065       std     airCntMin0              ; Store "min" used in air count calc                              
2560   D493             
2561   D493                         ;---------------------------------------------------------------
2562   D493                         ; Compute airVol16 and airVol from [airCnt0:airCnt1]*masScalar
2563   D493                         ;---------------------------------------------------------------
2564   D493 4F                      clra                            ;                             
2565   D494 5F                      clrb                            ;                             
2566   D495 87 E6 10 0A             brset   state1, #$10, L1066     ; Branch if engine notRotating                                
2567   D499 CC 5E 86                ldd     #masScalar              ; 16 bit MAS scalar ($5e86 for 1G, $7A03 for 2g), seem to correspond to (masComp+t_mascomp(72Hz))/512*65536   
2568   D49C DD 5C                   std     temp6                   ; Store for 16 multi.                                               
2569   D49E DC 8D                   ldd     airCnt0                 ; MAS air count                                                          
2570   D4A0 BD EA 85                jsr     mul1616                 ; d = masScalar/65536 * [airCnt0:airCnt1]
2571   D4A3 DD 5C       L1066       std     temp6                   ; temp6:temp7 = masScalar/65536 * [airCnt0:airCnt1]
2572   D4A5 DD DE                   std     airVol16                ; airVol16 = masScalar/65536 * [airCnt0:airCnt1]
2573   D4A7 BD EB AE                jsr     scale2m                 ; b = masScalar/65536 * airCnt0 / 2 with overflow check
2574   D4AA D7 E0                   stab    airVol                  ; airVol = masScalar/65536*[airCnt0:airCnt1]/2 (8 bit airflow)                                                     
2575   D4AC             
2576   D4AC                         ;--------------------
2577   D4AC                         ; Compute airVolCond 
2578   D4AC                         ;--------------------
2579   D4AC 17                      tba                             ; a = airVol                             
2580   D4AD BD EC 31                jsr     L1647                   ; b = Apply offset and scaling to airVol???                              
2581   D4B0 F7 01 50                stab    airVolCond              ;                              
2582   D4B3             
2583   D4B3                         ;----------------------------------------
2584   D4B3                         ; At this point [temp6:temp7] = airVol16  
2585   D4B3                         ;
2586   D4B3                         ; Compute airVolT, airVolTB and airVolB
2587   D4B3                         ;----------------------------------------
2588   D4B3 F6 01 5F                ldab    iatCompFact             ;                                    
2589   D4B6 BD EA 54                jsr     mul816_256              ; b = airVol16/2 * iatCompFact/128; [temp6:temp7] = airVol16 * iatCompFact/128
2590   D4B9 D7 E1                   stab    airVolT                 ; airVolT =  airVol16/2 * iatCompFact/128
2591   D4BB BD EA 51                jsr     mul816_baro             ;  
2592   D4BE D7 E2                   stab    airVolTB                ; airVolTB = airVol16/2 * iatCompFact/128 * baroFact/128; 
2593   D4C0 DC DE                   ldd     airVol16                ; d = airVol16                                 
2594   D4C2 DD 5C                   std     temp6                   ;                              
2595   D4C4 BD EA 51                jsr     mul816_baro             ;                              
2596   D4C7 D7 E3                   stab    airVolB                 ; airVolB = airVol16/2 * baroFact/128                               
2597   D4C9                         
2598   D4C9~            #ifdef E931       
2599   D4C9~                        ;---------------------------------------------------                          
2600   D4C9~                        ; Set ftrimFlags.3 if speed exceed threshold (with
2601   D4C9~                        ; hysteresis) and port3.0 is set?????????
2602   D4C9~                        ;---------------------------------------------------                          
2603   D4C9~                        andm    ftrimFlags, #$f7         ; Assume we reset flag $08, updated below                                 
2604   D4C9~                        ldaa    #$18                     ; speed threshold = $18                            
2605   D4C9~                        brclr    ftrimFlags, #$04, Md4d4 ; branch is flag not yet set                                
2606   D4C9~                        ldaa    #$1c                     ; Flag already set, use higher threshold (lower speed threshold)                             
2607   D4C9~            Md4d4       andm    ftrimFlags, #$fb         ; Assume we reset $04                                 
2608   D4C9~                        cmpa    vss                      ; 
2609   D4C9~                        bcs     L1067                    ; Bail if speed < 24km/h (vss=1/speed...)
2610   D4C9~                        orm     ftrimFlags, #$04         ; speed > 24km/h, set "threshold exceeded" bit
2611   D4C9~                        ldaa    port3Snap0               ; Get stored port3                                  
2612   D4C9~                        anda    port3                    ; Confirm bit is still set with current value                              
2613   D4C9~                        lsra                             ; Get confirmed bit 0 in carry                              
2614   D4C9~                        bcc     L1067                    ; Branch if bit was not set                              
2615   D4C9~                        orm     ftrimFlags, #$08         ; Bit was still set, set flag bit                                 
2616   D4C9             #endif
2617   D4C9             
2618   D4C9                         ;-----------------------------------------------
2619   D4C9                         ; Set ftrimFlags.4 if rpm exceeds 
2620   D4C9                         ; threshold (around 1000rpm), with hysteresis
2621   D4C9                         ;-----------------------------------------------
2622   D4C9 CE FB 23    L1067       ldx     #L1983                  ; x points to initial threshold                               
2623   D4CC 8F E5 10 01             brclr   ftrimFlags, #$10, L1068 ; Branch if flag not yet set                              
2624   D4D0 08                      inx                             ; Flag is set, go to next value (hysteresis)
2625   D4D1             L1068       .equ    $
2626   D4D1             #ifdef E932
2627   D4D1 87 D7 20 02             brset   port3Snap0, #$20, L1069 ; branch if Park/neutral                               
2628   D4D5 08                      inx                             ; even more threshold hysteresis...                            
2629   D4D6 08                      inx                             ; even more threshold hysteresis...                            
2630   D4D7             #endif        
2631   D4D7 96 DD       L1069       ldaa    rpm31                   ;                              
2632   D4D9 02 E5 EF                andm    ftrimFlags, #$ef        ; Assume we reset $10                               
2633   D4DC A1 00                   cmpa    $00,x                   ; Compare rpm to treshold
2634   D4DE 25 03                   bcs     L1070                   ; branch if rpm31 < L1983(flags...)                              
2635   D4E0 03 E5 10                orm     ftrimFlags, #$10        ; set flag indicating we are above rpm threshold                                
2636   D4E3             
2637   D4E3                         ;----------------------------------------------------------------------------------------
2638   D4E3                         ; Update the fuel trim range (low, mid, high)  according to mafRaw16. Table 
2639   D4E3                         ; t_ftrimRg provides the 2 thresholds with some hysteresis (+/-6Hz)
2640   D4E3                         ; The trim range is stored in L00e3.0.1 (lowest 2 bits)
2641   D4E3                         ;
2642   D4E3                         ; old L00e3.0.1    resulting X       new L00e3.0.1
2643   D4E3                         ;   00              t_ftrimRg        00 if maf < t_ftrimRg(00) otherwise 01
2644   D4E3                         ;   01              t_ftrimRg        00 if maf < t_ftrimRg(01) otherwise 01 if maf < t_ftrimRg(02) otherwise 10
2645   D4E3                         ;   10              t_ftrimRg+1      01 if maf < t_ftrimRg(03) otherwise 10 
2646   D4E3                         ;   11              t_ftrimRg+1      01 if maf < t_ftrimRg(03) otherwise 10 
2647   D4E3                         ;
2648   D4E3                         ;  L00e3.0.1        meaning
2649   D4E3                         ;     00        low trim (below first threshold)
2650   D4E3                         ;     01        mid trim (between first and second threshold)
2651   D4E3                         ;     10        high trim (above second threshold)
2652   D4E3                         ;     11        Never used I think
2653   D4E3                         ;----------------------------------------------------------------------------------------
2654   D4E3 CE FB 1F    L1070       ldx     #t_ftrimRg              ; X pointx to t_ftrimRg min1                                  
2655   D4E6 FC 01 4B                ldd     mafRaw16                ; d = mafRaw16                                
2656   D4E9 BD EB A9                jsr     scale64m                ; d = mafRaw16/64 (thats equal to mafRaw...?)                                
2657   D4EC 17                      tba                             ; a = mafRaw16/64 = mafRaw (6.25x)Hz                            
2658   D4ED 5F                      clrb                            ; b=0                            
2659   D4EE 8F E5 03 11             brclr   ftrimFlags, #$03, L1074 ;                               
2660   D4F2 8F E5 02 03             brclr   ftrimFlags, #$02, L1071 ;                               
2661   D4F6 08                      inx                             ; X pointx to t_ftrimRg+1
2662   D4F7 20 04                   bra     L1073                   ;                              
2663   D4F9 A1 01       L1071       cmpa    $01,x                   ;                              
2664   D4FB 25 0E                   bcs     L1077                   ; Branch if mafRaw16/64 < t_ftrimRg                              
2665   D4FD A1 02       L1073       cmpa    $02,x                   ;                             
2666   D4FF 25 09                   bcs     L1076                   ; Branch if mafRaw16/64 < t_ftrimRg                             
2667   D501 20 06                   bra     L1075                   ;                              
2668   D503 A1 00       L1074       cmpa    $00,x                   ;                              
2669   D505 25 04                   bcs     L1077                   ; Branch if mafRaw16/64 < t_ftrimRg                             
2670   D507 20 01                   bra     L1076                   ;                               
2671   D509 5C          L1075       incb                            ;                             
2672   D50A 5C          L1076       incb    
2673   D50B 96 E5       L1077       ldaa    ftrimFlags              ; a = ftrimFlags
2674   D50D 84 FC                   anda    #$fc                    ; Reset trim range 
2675   D50F 1B                      aba                             ; Add new trim range                            
2676   D510 97 E5                   staa    ftrimFlags              ; Update ftrimFlags
2677   D512                     
2678   D512                         ;---------------------------------------------------
2679   D512                         ; Restart timer T40_ftrim2 on E931 if 
2680   D512                         ;
2681   D512                         ;     rpm > 1953rpm 
2682   D512                         ;  or speed > 15 km/h    
2683   D512                         ;  or speed < 2.5 km/h    
2684   D512                         ;  or vss*rpm/15.625 < $cd8   (note speed ~ 1/vss)
2685   D512                         ;  or airVol > $38 
2686   D512                         ;  or tpsDiffMax2 > $04
2687   D512                         ;---------------------------------------------------
2688   D512~            #ifdef E931
2689   D512~                        ldd     rpm4                    ;                              
2690   D512~                        jsr     scale4m                 ;                                 
2691   D512~                        cmpb    #$7d                    ; 1953rpm                             
2692   D512~                        bcc     Md551                   ; Branch if rpm>1953rpm                              
2693   D512~                        ldaa    vss                     ;                             
2694   D512~                        cmpa    #$26                    ; ~15km/h                                
2695   D512~                        bcs     Md551                   ; Branch if speed>15km/h                                           
2696   D512~                        cmpa    #$e2                    ; ~2.5km/h                                 
2697   D512~                        bcc     Md551                   ; Branch if speed<2.5km/h                             
2698   D512~                        mul                             ;                              
2699   D512~                        cmpd    #$0cd8                  ; d = vss*rpm/15.625                               
2700   D512~                        bcs     Md551                   ; branch if vss*rpm/15.625 < $cd8                              
2701   D512~                        ldaa    airVol                  ;                                
2702   D512~                        cmpa    #$38                    ;                              
2703   D512~                        bcc     Md551                   ; Branch if airVol > $38                              
2704   D512~                        ldaa    tpsDiffMax2             ;                                     
2705   D512~                        cmpa    #$04                    ;                              
2706   D512~                        bcs     L1078                   ; Branch if tpsDiffMax2 < $04                              
2707   D512~            Md551       ldaa    #$78                    ; 3 sec                              
2708   D512~                        staa    T40_ftrim2              ;                               
2709   D512             #endif        
2710   D512             
2711   D512                         ;---------------------------------------------------
2712   D512                         ; Reload T40s_Idle as long as idle switch is off
2713   D512                         ;---------------------------------------------------
2714   D512 87 D7 80 05 L1078       brset   port3Snap0, #$80, L1079 ; Branch if idle position switch on                                
2715   D516 86 1E                   ldaa    #$1e                    ;                             
2716   D518 B7 01 33                staa    T40s_Idle               ; Reload down counter (~0.75sec)                             
2717   D51B             
2718   D51B                         ;---------------------------------------------------------------------
2719   D51B                         ; Check for airVolT threshold with hysteresis and update T2_airVolT
2720   D51B                         ; ftrimFlags is set when airVolT > 24 and is reset when airVolT <= 15
2721   D51B                         ;---------------------------------------------------------------------
2722   D51B 86 0F       L1079       ldaa    #$0f                    ; Threshold min                            
2723   D51D 87 E5 80 02             brset   ftrimFlags, #$80, L1080 ;                                
2724   D521 86 18                   ldaa    #$18                    ; Threshold max
2725   D523 02 E5 7F    L1080       andm    ftrimFlags, #$7f        ; 
2726   D526 91 E1                   cmpa    airVolT                 ; Compare current air volume                                
2727   D528 24 08                   bcc     L1081                   ; Branch if airVolT <= threshold                              
2728   D52A 03 E5 80                orm     ftrimFlags, #$80        ; airVolT > threshold, set bit
2729   D52D 86 0A                   ldaa    #$0a                    ; reset timer to 5 seconds                            
2730   D52F B7 01 39                staa    T2_airVolT              ;                            
2731   D532 87 D6 08 23 L1081       brset   state2, #$08, L1083     ; Branch if no pulse accumulator interrupts received
2732   D536 87 E6 10 1F             brset   state1, #$10, L1083     ; Branch if engine notRotating                               
2733   D53A             
2734   D53A                         ;-----------------------------------------------------------
2735   D53A                         ; Compute air volume used in fuel cut comparison
2736   D53A                         ; it uses 16 bits since 8 bit air volume saturate at ~1g of air/cas
2737   D53A                         ;-----------------------------------------------------------
2738   D53A DC DE                   ldd     airVol16                ; d = airVol16
2739   D53C BD EB AD                jsr     scale4m                 ; b = airVol16/4 (makes sure it fits in b only...)
2740   D53F~            #ifdef extLoadRange                         ;
2741   D53F~                        stab    L0054                   ;                              
2742   D53F             #else                                       ;
2743   D53F D7 57                   stab    temp1                   ; temp1 = airVol16/4
2744   D541             #endif                                      ;
2745   D541 B6 01 5F                ldaa    iatCompFact             ; Correct for air temp                              
2746   D544 3D                      mul                             ;                             
2747   D545 BD EB A8                jsr     scale128m               ; d = airVol16/4 * iatCompFact/128 
2748   D548 B6 01 60                ldaa    baroFact                ; a = baroFact
2749   D54B 3D                      mul                             ;                             
2750   D54C BD EB A8                jsr     scale128m               ; d = airVol16/4 * iatCompFact/128 * baroFact/128 (fits in b only)
2751   D54F             
2752   D54F                         ;---------------------------------------------------------------------------------------
2753   D54F                         ; Keep the minimum of airVol16/4 and airVol16/4 * iatCompFact/128 * baroFact/128 
2754   D54F                         ;---------------------------------------------------------------------------------------
2755   D54F~            #ifdef extLoadRange
2756   D54F~                        cmpb    L0054                   ;
2757   D54F~                        bcs     L1082                   ;                              
2758   D54F~                        ldab    L0054                   ;
2759   D54F             #else
2760   D54F D1 57                   cmpb    temp1                   ;                               
2761   D551 25 02                   bcs     L1082                   ; Branch if airVol16/4 * iatCompFact/128 * baroFact/128 <= airVol16/4 
2762   D553 D6 57                   ldab    temp1                   ; Use max of airVol16/4
2763   D555             #endif
2764   D555             
2765   D555                         ;------------------------------------------------------------------------------
2766   D555                         ; Check air volume for eventual fuel cut 
2767   D555                         ; When air volume exceeds a threshold, Timer T40_fuelCut 
2768   D555                         ; is not re-initialized on every loop (to 1s) and therefore starts 
2769   D555                         ; counting down. when it reaches 0, fuel cut is applied, see L1090 below
2770   D555                         ;------------------------------------------------------------------------------
2771   D555 C1 A0       L1082       cmpb    #fuelCutVal             ; Air volume based fuel cut value    $a0 = 1.25g/cas
2772   D557~            #ifdef noFuelCut
2773   D557~                        brn     L1084                   ;
2774   D557             #else
2775   D557 24 05                   bcc     L1084                   ; Branch if air volume>=threshold                
2776   D559             #endif
2777   D559 C6 28       L1083       ldab    #$28                    ; 1 sec
2778   D55B F7 01 22                stab    T40_fuelCut             ; Re-init counter to 1 sec (Apply fuel cut only after threshold is exceeded for more than 1s)
2779   D55E             
2780   D55E                         ;-----------------------------------------------------------------
2781   D55E                         ; Section to update the state1 flags from various conditions 
2782   D55E                         ;
2783   D55E                         ; Bits in b are used to accumulate various loads and states
2784   D55E                         ; In this section, b is only set in case we have 
2785   D55E                         ; to bail to the state1 flag setting section
2786   D55E                         ;-----------------------------------------------------------------
2787   D55E C6 30       L1084       ldab    #$30                    ; Starting "state1" value, b=00110000 (not rotating)                          
2788   D560 8F E6 20 0A             brclr   state1, #$20, L1085     ; Bail if this is the first time we compute state1??                               
2789   D564 B6 01 20                ldaa    T40_engRot              ;                                     
2790   D567 27 05                   beq     L1085                   ; Bail if engine not rotating                             
2791   D569 B6 01 24                ldaa    T40_noPower             ;                               
2792   D56C 26 03                   bne     L1086                   ; Don't bail if timer not expired???                             
2793   D56E 7E D5 F9    L1085       jmp     L1100                   ; bail
2794   D571                                                  
2795   D571                         ;----------------------------------------------------
2796   D571                         ; Engine rotating, check if key is in "start"
2797   D571                         ; In this section, b is only set in case we have 
2798   D571                         ; to bail to the state1 flag setting section
2799   D571                         ;----------------------------------------------------
2800   D571 C6 21       L1086       ldab    #$21                     ; pre-load new state1 in case we have to bail, b=00100001 (startingToCrank)                           
2801   D573 87 D7 40 12             brset   port3Snap0, #$40, L1089  ; branch to next state if key not in start???
2802   D577             
2803   D577                         ;----------------------------------------------------
2804   D577                         ; Key is in "start", check if rpm is higher than
2805   D577                         ; threshold (engine running?)
2806   D577                         ;----------------------------------------------------
2807   D577 86 0E                   ldaa    #$0e                    ; starting rpm value (RPM/31.25) $0e = 437.25
2808   D579 87 E6 01 02             brset   state1, #$01, L1087     ; Branch if engine rotating bit was previously set
2809   D57D 86 0B                   ldaa    #$0b                    ; $0b = 343.75RPM                             
2810   D57F 8F E7 20 02 L1087       brclr   injFlags0, #$20, L1088  ; Branch if temperature(ectFiltered) >= -8degC
2811   D583 8B 02                   adda    #$02                    ; temperature(ectFiltered) < -8degC, add 62.5 RPM                             
2812   D585 91 DD       L1088       cmpa    rpm31                   ; compare threshold to current engine speed                              
2813   D587 22 E5                   bhi     L1085                   ; Bail if engine rpm lower than calculated value                             
2814   D589             
2815   D589                         ;---------------------------------------------------------------------
2816   D589                         ; At this point, 
2817   D589                         ; key is in "start" or engine rpm is higher than minimum threshold, 
2818   D589                         ; minimum conditions are therefore met for the engine to start or be started?
2819   D589                         ; 
2820   D589                         ; Use this state to check if we should get fuel injection. If we get stuck in
2821   D589                         ; this state it means engine is rotating but something is wrong...
2822   D589                         ;---------------------------------------------------------------------
2823   D589                         ;---------------------------------------------------------------------
2824   D589                         ; If enough time has elapsed, check if CAS is working normally
2825   D589                         ;---------------------------------------------------------------------
2826   D589 C6 28       L1089       ldab    #$28                    ; pre-load new state1 in case we have to bail, b=00101000  (trying to start but something is wrong...)                          
2827   D58B B6 01 19                ldaa    T40_start               ;                              
2828   D58E 8B 50                   adda    #$50                    ; add 2s                            
2829   D590 25 0A                   bcs     L1090                   ; Branch if key was out of start for less than 2s (when engine was upgraded from startingToCrank),                             
2830   D592 8F 4E 80 06             brclr   faultHi, #$80, L1090    ; Its been more than ~2s since key was out of start, ECU has had enough time to check if CAS was working, check it, branch if no fault on CAS
2831   D596 96 83                   ldaa    tdcCasCount             ; Fault code set...                             
2832   D598 81 04                   cmpa    #$04                    ;                             
2833   D59A 25 D2                   bcs     L1085                   ; Bail if tdcCasCount<4, this should not have happened at this time since engine has been rotating for a while                           
2834   D59C             
2835   D59C                         ;----------------------------------------------------------------------
2836   D59C                         ; Bail if fuel cut is active (T40_fuelCut=0)
2837   D59C                         ;----------------------------------------------------------------------
2838   D59C B6 01 22    L1090       ldaa    T40_fuelCut             ; Fuel cut timer                              
2839   D59F 27 CD                   beq     L1085                   ; Bail if timer 0 (fuel cut is active)                             
2840   D5A1             
2841   D5A1                         ;-----------------------------------------------
2842   D5A1                         ; Bail if ECU is about to be shutoff????
2843   D5A1                         ;-----------------------------------------------
2844   D5A1 87 06 02 C9             brset   port3, #$02, L1085      ; Bail if IG1 at 0V, ECU is about to turn off after delay...?
2845   D5A5             
2846   D5A5                         ;-------------------------------------------------------------------------
2847   D5A5                         ; At this point, minimum conditions are met for the engine 
2848   D5A5                         ; to start or run (rpm>thresh or start switch on), CAS is working,
2849   D5A5                         ; there is no fuel cut and the ECU is not being turned off
2850   D5A5                         ;
2851   D5A5                         ; Basically we know that we should be injecting fuel, do a little more check below...
2852   D5A5                         ;
2853   D5A5                         ;
2854   D5A5                         ; Calculate a maximum rpm that we should have based on maxRpm = baseRpm + rpmOffset
2855   D5A5                         ; where rpmOffset is additional loads that we calculate below
2856   D5A5                         ;
2857   D5A5                         ; Below, a will contain baseRpm and b will be used to accumulate the additional loads as flags...
2858   D5A5                         ;-------------------------------------------------------------------------
2859   D5A5                         ;-----------------------------------------------
2860   D5A5                         ; Get Initial RPM from ECT interpolated table
2861   D5A5                         ;-----------------------------------------------
2862   D5A5 CE FB 27                ldx     #t_rpmEct               ;                                 
2863   D5A8 BD EB 2F                jsr     interpEct               ;                                    
2864   D5AB 17                      tba                             ; a = initial rpm idle speed, will be changed below (L1095)                               
2865   D5AC 5F                      clrb                            ; b = 00000000, no additionnal loads yet
2866   D5AD             
2867   D5AD                         ;-----------------------------------------------------------------
2868   D5AD                         ; Check if T40s_Idle timer expired
2869   D5AD                         ; (when idle position switch has been on for more than 0.75s)
2870   D5AD                         ;-----------------------------------------------------------------
2871   D5AD 7D 01 33                tst     T40s_Idle               ;                                
2872   D5B0 27 0D                   beq     L1091                   ; Branch if T40s_Idle already at zero (idle position switch on for more than 0.75s)                               
2873   D5B2             
2874   D5B2                         ;----------------------------------------------------------------
2875   D5B2                         ; Timer not expired, decrement it at 40Hz
2876   D5B2                         ;----------------------------------------------------------------
2877   D5B2 8F D9 01 09             brclr   Tclocks, #$01, L1091    ; Branch if basic 40Hz signal not set
2878   D5B6 7A 01 33                dec     T40s_Idle               ; Decrement timer       
2879   D5B9 87 D7 20 02             brset   port3Snap0, #$20, L1091  ; Ignore timer if in Park or Neutral (no transmission load)                                
2880   D5BD 27 04                   beq     L1092                   ; Branch if T40s_Idle reached 0 this time 
2881   D5BF             
2882   D5BF                         ;-------------------------
2883   D5BF                         ; Add a load when ???
2884   D5BF                         ;-------------------------
2885   D5BF 8F E6 04 01 L1091       brclr   state1, #$04, L1093     ; Branch if state1.2 (idle too fast) was not previously set
2886   D5C3 5C          L1092       incb                            ; Add load
2887   D5C4             L1093       .equ    $
2888   D5C4             
2889   D5C4                         ;--------------------------
2890   D5C4                         ; Add "transmission" load
2891   D5C4                         ;--------------------------
2892   D5C4             #ifdef E932
2893   D5C4 87 D7 20 02             brset   port3Snap0, #$20, L1094  ; Branch if in Park or Neutral                              
2894   D5C8 CB 02                   addb    #$02                    ; Set flag indicating "transmission load"
2895   D5CA             #endif
2896   D5CA                         ;--------------------------
2897   D5CA                         ; Add "A/C" load
2898   D5CA                         ;--------------------------
2899   D5CA 87 D7 10 02 L1094       brset   port3Snap0, #$10, L1095  ; Branch if air conditioning switch is off (reverse logic)                            
2900   D5CE CB 04                   addb    #$04                    ; A/C on, set flag b += 00000100                                
2901   D5D0             
2902   D5D0                         ;---------------------------------------------------------
2903   D5D0                         ; Compute total rpm threshold from  baseRpm+rpmOffset
2904   D5D0                         ;---------------------------------------------------------
2905   D5D0 CE FB 2F    L1095       ldx     #t_rpmEctOff            ; x points to table of offsets                              
2906   D5D3 3A                      abx                             ; c points to desired offset
2907   D5D4 AB 00                   adda    $00,x                   ; a = baseRpm+rpmOffset
2908   D5D6             
2909   D5D6                         ;---------------------------------------------------------------------
2910   D5D6                         ; Based on that threshold, compute which state we will end-up with
2911   D5D6                         ;---------------------------------------------------------------------
2912   D5D6                         ;--------------------------------------------------------
2913   D5D6                         ; If current rpm<threshold, use state1=00100000 (normal)
2914   D5D6                         ;--------------------------------------------------------
2915   D5D6 91 DD                   cmpa    rpm31                   ; compare to current rpm
2916   D5D8 22 1D                   bhi     L1099                   ; Branch if current rpm lower than calculated value (engine is running normally?)
2917   D5DA~            #ifdef E931
2918   D5DA~                        brset   ftrimFlags, #$08, L1099 ; RPM is higher than threshold, branch anyway if speed>24km/h and IG2 related signal is set on E931??????
2919   D5DA             #endif
2920   D5DA             
2921   D5DA                         ;-----------------------------------------------------
2922   D5DA                         ; rpm > threshold 
2923   D5DA                         ; if air volume low, use state1=00101100 
2924   D5DA                         ; i.e. runningFast and rotatingStopInj
2925   D5DA                         ;-----------------------------------------------------
2926   D5DA 87 D6 08 05             brset   state2, #$08, L1096     ; Skip airVolT check / branch if no pulse accumulator interrupts received (mas broken, skip airFlow check?)
2927   D5DE B6 01 39                ldaa    T2_airVolT              ;                             
2928   D5E1 27 10                   beq     L1098                   ; Branch if airVolT below threshold for more than 5s 
2929   D5E3             
2930   D5E3                         ;-----------------------------------------------------
2931   D5E3                         ; rpm > threshold and air volume high
2932   D5E3                         ; If engine was started less than 5s ago, use state1=00100000 (normal)
2933   D5E3                         ; i.e. high rev upon startup is normal
2934   D5E3                         ;-----------------------------------------------------
2935   D5E3 B6 01 34    L1096       ldaa    T2_crank                 ;                             
2936   D5E6 8B 0A                   adda    #$0a                     ;                              
2937   D5E8 25 0D                   bcs     L1099                    ; branch if engine stopped "startingToCrank" less than 5s ago...
2938   D5EA 87 F3 20 09             brset   iscLrnFlags, #$20, L1099 ; branch if iscStStall has been updated
2939   D5EE             
2940   D5EE                         ;------------------------------------------------------------------------------
2941   D5EE                         ; rpm > threshold and air volume high and engine started more than 10s ago
2942   D5EE                         ; If idle switch is off, use state1=00100000 (normal)
2943   D5EE                         ; i.e. we are stepping on the gas...
2944   D5EE                         ;------------------------------------------------------------------------------
2945   D5EE B6 01 33                ldaa    T40s_Idle               ;                              
2946   D5F1 26 04                   bne     L1099                   ; Branch if timer not yet 0, idle switch not on for more than 0.75s
2947   D5F3             
2948   D5F3                         ;---------------------------------------------------------------------------------
2949   D5F3                         ; rpm > threshold and air volume high and engine started more than 10s ago 
2950   D5F3                         ; and idle switch has been on for more than 0.75s
2951   D5F3                         ; use state1 = 00101100
2952   D5F3                         ; i.e. runningFast and rotatingStopInj
2953   D5F3                         ;---------------------------------------------------------------------------------
2954   D5F3 C6 2C       L1098       ldab    #$2c                    ; b=00101100, this means the engine is running too fast                              
2955   D5F5 20 02                   bra     L1100                   ;                              
2956   D5F7 C6 20       L1099       ldab    #$20                    ; use b=00100000 (normal)
2957   D5F9             
2958   D5F9                         ;-------------------------------------------------------------
2959   D5F9                         ; Set state1 flag if we are not receiving mas interrupts
2960   D5F9                         ;-------------------------------------------------------------
2961   D5F9 8F D6 08 02 L1100       brclr   state2, #$08, L1101     ; Branch if pulse accumulator interrupts received
2962   D5FD CA 02                   orab    #$02                    ; Set flag indicating we are not receiving pulse accumulator interrupts received
2963   D5FF             
2964   D5FF                         ;------------------------------------------------
2965   D5FF                         ; At this point b has been set in preceeding 
2966   D5FF                         ; code to indicate current state, update state1
2967   D5FF                         ;------------------------------------------------
2968   D5FF 96 E6       L1101       ldaa    state1                  ;                               
2969   D601 84 80                   anda    #$80                    ; Reset all except closed loop mode flag
2970   D603 1B                      aba                             ; Tranfser other flags set in code above                            
2971   D604 97 E6                   staa    state1                  ; Store new state                               
2972   D606             
2973   D606                         ;------------------------------------------------------
2974   D606                         ; Compute index into maf compensation table t_masComp
2975   D606                         ; since the values it contains are not equally spaced.
2976   D606                         ; Basically remaps mafRaw16...
2977   D606                         ;
2978   D606                         ; Note that this mapping is the same for 1G and 2G
2979   D606                         ; maf such that it doesn't need to be changed in case
2980   D606                         ; 2G maf is used in 1G...
2981   D606                         ;------------------------------------------------------
2982   D606 FC 01 4B                ldd     mafRaw16                ; d = 16 bit mafRaw (a=mafRaw16/256)                                
2983   D609 CD CE FF D3             ldy     #L2054                  ;                               
2984   D60D BD EB C7                jsr     pwiseLin                ; d = T(L2054, mafRaw16) (a=T(L2054, mafRaw16/256))                                  
2985   D610 DD 58                   std     temp2                   ; temp2:temp3 = T(L2054, mafRaw16)                              
2986   D612 BD EB AB                jsr     scale16m                ; d = T(L2054, mafRaw16)/16 (b=16*T(L2054, mafRaw16/256))                               
2987   D615 C1 80                   cmpb    #$80                    ; Check for max of $80. Since max(T(L2054, mafRaw16/256))=20=1600Hz, we trim at $80/16=8=200Hz! 
2988   D617 25 02                   bcs     L1103                   ;                              
2989   D619 C6 80                   ldab    #$80                    ; Use max of $80       
2990   D61B                         
2991   D61B                         ;------------------------------------------------------------
2992   D61B                         ; Compute total maf compensation = masComp + t_masComp(Hz)
2993   D61B                         ;------------------------------------------------------------
2994   D61B D7 5B       L1103       stab    temp5                   ; temp5 = T(L2054, mafRaw16)/16 with max of $80                              
2995   D61D CE FB 55                ldx     #t_masComp              ; x point to masCompensation table                                   
2996   D620 DC 58                   ldd     temp2                   ; d = T(L2054, mafRaw16)                              
2997   D622 BD EB 47                jsr     interp1                 ;                                
2998   D625 4F                      clra                            ; d = t_masComp(T(L2054, mafRaw16))
2999   D626 CB 64                   addb    #masComp                ; b = masComp + t_masComp(T(L2054, mafRaw16))                                 
3000   D628 49                      rola                            ; propagate carry bit in a,
3001   D629 DD 5C                   std     temp6                   ; temp6:temp7 = d = t_masComp(T(L2054, mafRaw16)) = total MAS compensation                              
3002   D62B             
3003   D62B                         ;-------------------------------------------------------------------------
3004   D62B                         ; Compute conditioned L1992(iat) and compensate for barometric pressure
3005   D62B                         ;-------------------------------------------------------------------------
3006   D62B CE FB AA                ldx     #L1992                  ;                               
3007   D62E BD EB 39                jsr     iatCInterp              ; b = L1992(iat)                                  
3008   D631 86 CD                   ldaa    #$cd                    ; $cd is 1 bar for baroChecked                            
3009   D633 3D                      mul                             ; d = $cd*L1992(iat)                           
3010   D634 05                      asld                            ; d = 2*$cd*L1992(iat)                            
3011   D635 15 D5                   div     baroChecked             ; d = 2*$cd*L1992(iat)/baroChecked                                   
3012   D637 54                      lsrb                            ; b = $cd*L1992(iat)/baroChecked = L1992(iat) * $cd/baroChecked = L1992(iat)*baroFactor where baroFactor=$cd/baroChecked equals 1.0 if baroChecked=1bar                              
3013   D638 C9 00                   adcb    #$00                    ; Round up result
3014   D63A CE 52 22                ldx     #$5222                  ;                               
3015   D63D BD EB B9                jsr     clipOffset              ; b = max(min(L1992(iat)*baroFactor,$52)-$22,0)                                   
3016   D640             
3017   D640                         ;-----------------------------------------------------------------------
3018   D640                         ; Compute airflow sensor linearity compensation factor from 2D table t_masLin 
3019   D640                         ; using max(min(L1992(iat)*baroFactor,$52)-$22,0)/16 for rows 
3020   D640                         ; and T(L2054, mafRaw16)/16 for columns, see t_masLin description
3021   D640                         ;-----------------------------------------------------------------------
3022   D640 CE FB 6A                ldx     #t_masLin               ;                                     
3023   D643 CD CE 09 00             ldy     #$0900                  ;                               
3024   D647 96 5B                   ldaa    temp5                   ;                              
3025   D649 BD EA D8                jsr     lookup2D2               ; a = b = 2D interpolated t_masLin                                  
3026   D64C F7 01 57                stab    masLinComp              ; 
3027   D64F BD EB 5F                jsr     mul816_128              ; d = masLinComp * (masComp+t_masComp(xx))/128
3028   D652 FD 01 55                std     totMasComp              ; totMasComp =(masComp+t_masComp(xx)) *  t_masLin(xx)/128
3029   D655             
3030   D655                         ;-------------------------------------------------------------
3031   D655                         ; Section to check if the o2 sensor is operating normally
3032   D655                         ;-------------------------------------------------------------
3033   D655                         ;-------------------------------------------------------------
3034   D655                         ; If engine is notRotating, init rich/lean flag 
3035   D655                         ; and o2 sensor bad flag to default values 
3036   D655                         ;-------------------------------------------------------------
3037   D655 8F E6 10 0E             brclr   state1, #$10, L1106     ; Branch if notRotating clear 
3038   D659 03 E8 C0                orm     closedLpFlags, #$c0     ; Assume o2Raw is rich and o2 sensor bad
3039   D65C 96 CE                   ldaa    o2Raw                   ; a = o2Raw                              
3040   D65E 81 1F                   cmpa    #$1f                    ;                             
3041   D660 24 03                   bcc     L1105                   ; Branch if o2Raw >= 0.6v (rich)                            
3042   D662 02 E8 7F                andm    closedLpFlags, #$7f     ; o2Raw is lean, reset bit                                
3043   D665 20 39       L1105       bra     L1114                   ; Bail                              
3044   D667             
3045   D667                         ;-------------------------------------------------------
3046   D667                         ; Choose how long to wait to check o2 sensor voltage 
3047   D667                         ; depending on ect (o2 sensor warm-up time...)
3048   D667                         ;-------------------------------------------------------
3049   D667 B6 01 34    L1106       ldaa    T2_crank                ; a = T2_crank                                 
3050   D66A D6 D3                   ldab    ectFiltered             ;                                    
3051   D66C C1 54                   cmpb    #$54                    ; 41degC                             
3052   D66E 25 04                   bcs     L1108                   ; Branch if temperature(ectFiltered) > 41degC                              
3053   D670 8B 58                   adda    #$58                    ; a = T2_crank + $58  (44sec)                           
3054   D672 20 02                   bra     L1109                   ;                              
3055   D674 8B 1E       L1108       adda    #$1e                    ; a = T2_crank + $1e  (15sec)                          
3056   D676             
3057   D676                         ;---------------------------------------------------------------------------------------
3058   D676                         ; Update the rich/lean flag if sufficient time has elapsed since car was started 
3059   D676                         ;---------------------------------------------------------------------------------------
3060   D676 25 28       L1109       bcs     L1114                   ; bail if engine stopped "startingToCrank" less than 44 or 15 sec ago (depending en ect).                               
3061   D678 96 E8                   ldaa    closedLpFlags           ; a = old closedLpFlags                               
3062   D67A 03 E8 80                orm     closedLpFlags, #$80     ; Assume result will be rich
3063   D67D D6 CE                   ldab    o2Raw                   ; b = o2Raw                              
3064   D67F C1 1F                   cmpb    #$1f                    ;                              
3065   D681 24 03                   bcc     L1111                   ; Branch if o2Raw >= 0.6v (rich)                              
3066   D683 02 E8 7F                andm    closedLpFlags, #$7f     ; o2Raw is lean, Reset flag                                 
3067   D686             
3068   D686                         ;--------------------------------------------------------
3069   D686                         ; Check if flag value changed compared to the last time
3070   D686                         ;--------------------------------------------------------
3071   D686 98 E8       L1111       eora    closedLpFlags           ; Compare old closedLpFlags t new one                              
3072   D688 2B 0E                   bmi     L1112                   ; Branch if rich/lean flag changed (reset o2 bad flag)                             
3073   D68A             
3074   D68A                         ;-----------------------------------
3075   D68A                         ; Rich/lean flag did not change
3076   D68A                         ;-----------------------------------
3077   D68A 8F E6 80 0D             brclr   state1, #$80, L1113     ; Reset timer and bail if open loop mode
3078   D68E             
3079   D68E                         ;----------------------------------------------
3080   D68E                         ; Closed loop mode and flag did not change yet
3081   D68E                         ; Check if timer is expired which would mean that
3082   D68E                         ; something is wrong (in closed loop mode, o2 sensor
3083   D68E                         ; voltage should have changed by now...)
3084   D68E                         ;----------------------------------------------
3085   D68E B6 01 37                ldaa    T2_o2Sensor             ;                             
3086   D691 26 0D                   bne     L1114                   ; Bail if timer not yet expired                             
3087   D693 03 E8 40                orm     closedLpFlags, #$40     ; Timer expired, set o2 bad flag                               
3088   D696 20 08                   bra     L1114                   ; Bail
3089   D698                                                      
3090   D698                         ;------------------------------
3091   D698                         ; Reset flag and restart timer
3092   D698                         ;------------------------------
3093   D698 02 E8 BF    L1112       andm    closedLpFlags, #$bf     ; reset o2 bad flag                               
3094   D69B 86 28       L1113       ldaa    #$28                    ; 20sec                            
3095   D69D B7 01 37                staa    T2_o2Sensor             ; re-init timer to 20sec                             
3096   D6A0             
3097   D6A0                         ;--------------------------------------------------------------
3098   D6A0                         ; Re-init T40_stInj0 to 1 sec if engine is not rotatingStopInj
3099   D6A0                         ; This means that T40_stInj0 starts counting when state 
3100   D6A0                         ; changes to rotatingStopInj
3101   D6A0                         ;--------------------------------------------------------------
3102   D6A0 87 E6 08 07 L1114       brset   state1, #$08, L1115     ; Branch if engine rotatingStopInj?                                
3103   D6A4 86 28                   ldaa    #$28                    ; 1 sec                            
3104   D6A6 B7 01 1C                staa    T40_stInj0              ;                              
3105   D6A9 20 0A                   bra     L1116                   ;                              
3106   D6AB             
3107   D6AB                         ;----------------------------------------------------------------
3108   D6AB                         ; Re-init timer T40_stInj1 to 2 sec if engine 
3109   D6AB                         ; is rotatingStopInj and T40_stInj0 expired
3110   D6AB                         ; This means that T40_stInj1 is only init when rotatingStopInj
3111   D6AB                         ; has been active for more than 1 sec and will start counting
3112   D6AB                         ; when rotatingStopInj is no more active. Will expire 2sec later.
3113   D6AB                         ;----------------------------------------------------------------
3114   D6AB B6 01 1C    L1115       ldaa    T40_stInj0                ;                              
3115   D6AE 26 05                   bne     L1116                     ; Branch if timer not expired                             
3116   D6B0 86 50                   ldaa    #$50                      ;                             
3117   D6B2 B7 01 1D                staa    T40_stInj1                ;
3118   D6B5                                                       
3119   D6B5                         ;-------------------------------------------------------------
3120   D6B5                         ; Section to decide between closed loop and open loop mode
3121   D6B5                         ; (set/reset state1.7)
3122   D6B5                         ;-------------------------------------------------------------
3123   D6B5                         ;-------------------------------------------------------------
3124   D6B5                         ; Have y point to airVol or airVolTB depending on baroChecked 
3125   D6B5                         ;-------------------------------------------------------------
3126   D6B5 CD CE 00 E0 L1116       ldy     #airVol                   ;                               
3127   D6B9 96 D5                   ldaa    baroChecked               ;                                    
3128   D6BB 81 9C                   cmpa    #$9c                      ;                             
3129   D6BD 25 04                   bcs     L1117                     ; Branch if baroChecked<0.76bar (I think??)                               
3130   D6BF CD CE 00 E2             ldy     #airVolTB                 ;                               
3131   D6C3             
3132   D6C3                         ;--------------------------------------------------------
3133   D6C3                         ; Check airVolTB for first threshold (with hysteresis)
3134   D6C3                         ;--------------------------------------------------------
3135   D6C3 CE FB B1    L1117       ldx     #t_closedLp1               ;
3136   D6C6 BD EB 34                jsr     interp16rpm                ; b = t_closedLp1(rpm)                                    
3137   D6C9 8F E8 01 05             brclr   closedLpFlags, #$01, L1118 ; Branch if we were not above the threshold the last time we checked                              
3138   D6CD C0 06                   subb    #$06                       ; b =  t_closedLp1(rpm)-6 (hysteresis)                              
3139   D6CF 24 01                   bcc     L1118                      ; Branch if no underflow                             
3140   D6D1 5F                      clrb                               ; Use min of 0                            
3141   D6D2 02 E8 FC    L1118       andm    closedLpFlags, #$fc        ; Reset 000000011                               
3142   D6D5 E1 80                   cmpb    $00,y                      ; Notice implicit y = y + 1 here!!!!!!!!!!!
3143   D6D7 23 07                   bls     L1119                      ; Branch if t_closedLp1(rpm) <= airVol or airVolTB                              
3144   D6D9                                                           
3145   D6D9                         ;---------------------------------------------------------
3146   D6D9                         ; airVolTB smaller than threshold, closed loop is 
3147   D6D9                         ; therefore an option. Re-init timer T2_closedLp to 20sec 
3148   D6D9                         ; or 12sec and then continue trying to go to closed loop
3149   D6D9                         ;---------------------------------------------------------
3150   D6D9~            #ifdef E931
3151   D6D9~                        ldaa    #$28                      ; 20 sec                            
3152   D6D9             #else                                        
3153   D6D9 86 18                   ldaa    #$18                      ; 12 sec                           
3154   D6DB             #endif                                       
3155   D6DB B7 01 36                staa    T2_closedLp                                                   
3156   D6DE 20 1D                   bra     L1122                     ; Branch to continue closed loop checking                              
3157   D6E0             
3158   D6E0                         ;--------------------------------------------------------------------------------
3159   D6E0                         ; At this point airVolTB is higher than first threshold. Normally, 
3160   D6E0                         ; the airflow is too high to be in closed loop mode but in order to account
3161   D6E0                         ; for variations, we will remain in closed loop for a certain time
3162   D6E0                         ; (T2_closedLp) as long as we are below a second threshold t_closedLp2(rpm). If 
3163   D6E0                         ; we go over that second threshold, we go to open loop immediatly. This is 
3164   D6E0                         ; implementing aiflow hysteresis under specific rpm conditions
3165   D6E0                         ;
3166   D6E0                         ; Check if airVolTB higher than second threshold (with an hysteresis of 6)
3167   D6E0                         ;--------------------------------------------------------------------------------
3168   D6E0 03 E8 01    L1119       orm     closedLpFlags, #$01       ; Set flag indicating we are above the first threshold                               
3169   D6E3~            #ifdef E931                                   
3170   D6E3~                        ldx     #t_closedLp2              ;                                     
3171   D6E3~                        jsr     interp16rpm               ; b = t_closedLp2(rpm)
3172   D6E3             #else                                         
3173   D6E3 7E FA F2                jmp     L1978                     ; Jump to code patch for E932 rpm calculation..., jumps back here afterwards...                             
3174   D6E6 BD EB 3E    L1120       jsr     interp16b                 ;                                  
3175   D6E9             #endif                                        
3176   D6E9 87 E6 80 05             brset   state1, #$80, L1121       ; Branch if closed loop mode
3177   D6ED C0 06                   subb    #$06                      ; b = t_closedLp2(rpm)-6 (threshold hysteresis)
3178   D6EF 24 01                   bcc     L1121                     ; Branch if underflow                             
3179   D6F1 5F                      clrb                              ; Use min of 0                            
3180   D6F2 CD 09       L1121       decy                              ; y points back to airVol or airVolTB (implicit y=y+1 above...)                             
3181   D6F4 E1 80                   cmpb    $00,y                     ; Notice implicit y = y+1 here!!!!!!!!!!!
3182   D6F6 23 3B                   bls     L1126                     ; Use open loop if airVolTB higher than second threshold
3183   D6F8             
3184   D6F8                         ;---------------------------------------------------------
3185   D6F8                         ; airVolTB smaller than second threshold, we could 
3186   D6F8                         ; therefore remain in closed loop if timer not expired
3187   D6F8                         ;
3188   D6F8                         ; Check if T2_closedLp timer is expired
3189   D6F8                         ;---------------------------------------------------------
3190   D6F8 B6 01 36                ldaa    T2_closedLp               ;                             
3191   D6FB 27 36                   beq     L1126                     ; Use open loop mode if T2_closedLp expired                             
3192   D6FD             
3193   D6FD                         ;----------------------------------------------------
3194   D6FD                         ; Check tspRaw threshold with hysteresis to know 
3195   D6FD                         ; if closed loop is an option
3196   D6FD                         ;
3197   D6FD                         ; Go to open loop if 
3198   D6FD                         ;       tpsRaw >= t_closedLp3(rpm)
3199   D6FD                         ; Closed loop is possible if 
3200   D6FD                         ;       tpsRaw < t_closedLp3(rpm)-$0d (hysteresis)
3201   D6FD                         ;
3202   D6FD                         ;----------------------------------------------------
3203   D6FD CE FB C5    L1122       ldx     #t_closedLp3              ; x = t_closedLp3                                    
3204   D700 BD EB 34                jsr     interp16rpm               ; b = t_closedLp3(rpm)                                   
3205   D703 87 E6 80 05             brset   state1, #$80, L1124       ; Branch if closed loop mode
3206   D707 C0 0D                   subb    #$0d                      ; b = t_closedLp3(rpm) - $0d                            
3207   D709 24 01                   bcc     L1124                     ; Branch if no underflow                             
3208   D70B 5F                      clrb                              ; Use min of 0
3209   D70C D1 D2       L1124       cmpb    tpsRaw                    ;                               
3210   D70E 23 23                   bls     L1126                     ; Branch to use open loop if  t_closedLp3(rpm)<= tpsRaw                             
3211   D710             
3212   D710                         ;-----------------------------------------------------
3213   D710                         ; We could use closed loop, check a few more things
3214   D710                         ;-----------------------------------------------------
3215   D710 87 E6 1B 1F             brset   state1, #$1b, L1126        ; Use open loop if engine is either notRotating or rotatingStopInj or runningFast
3216   D714 87 85 80 1B             brset   coilChkFlags, #$80, L1126  ; Use open loop if ignition problem is detected                               
3217   D718 8F E5 80 17             brclr   ftrimFlags, #$80, L1126    ; Use open loop if airVolT < threshold (15 or 24, used for fTrim...). Means airflow is too low???                               
3218   D71C 03 E8 02                orm     closedLpFlags, #$02        ; Set flag indicating we should be using closed loop mode????                                
3219   D71F B6 01 1D                ldaa    T40_stInj1                 ;                                     
3220   D722 26 0F                   bne     L1126                      ; Use open loop if rotatingStopInj has been active for more than 1 sec (and 2 sec after)                             
3221   D724 87 E8 40 0B             brset   closedLpFlags, #$40, L1126 ; Use open loop if o2 sensor is bad                                
3222   D728 96 D3                   ldaa    ectFiltered                ;                                  
3223   D72A~            #ifdef E931
3224   D72A~                        cmpa    #$6a                       ; 31degC                             
3225   D72A             #else
3226   D72A 81 70                   cmpa    #$70                       ; 28degC                             
3227   D72C             #endif
3228   D72C             
3229   D72C~            #ifdef noClosedLoop
3230   D72C~                        bra     L1126                      ; 
3231   D72C             #else
3232   D72C 22 05                   bhi     L1126                      ; Use open loop if temperature(ectFiltered) < 31degC                              
3233   D72E             #endif
3234   D72E             
3235   D72E                         ;-----------------------------------------------------
3236   D72E                         ; Use closed loop mode, set flag
3237   D72E                         ;-----------------------------------------------------
3238   D72E 03 E6 80                orm     state1, #$80              ; Go into closed loop mode
3239   D731 20 03                   bra     L1127                     ; Bail                             
3240   D733             
3241   D733                         ;---------------------------------
3242   D733                         ; Use open loop mode, reset flag
3243   D733                         ;---------------------------------
3244   D733 02 E6 7F    L1126       andm    state1, #$7f              ; Go into open loop mode
3245   D736             
3246   D736                         ;-----------------------------------
3247   D736                         ; Reset o2Fbk in some cases
3248   D736                         ; open loop for instance...
3249   D736                         ;-----------------------------------
3250   D736 87 F9 04 08 L1127       brset   fpsBcsFlags, #$04, L1129  ; Branch to reset if the fuel pressure solenoid was just deactivated                               
3251   D73A 87 F8 02 09             brset   varFlags0, #$02, L1130    ; Bail if hot start flag is set                              
3252   D73E 87 E6 80 05             brset   state1, #$80, L1130       ; Bail if closed loop mode
3253   D742 CC 80 80    L1129       ldd     #$8080                    ;                               
3254   D745 DD E9                   std     o2Fbk                     ;                              
3255   D747             
3256   D747                         ;--------------------------------------------------
3257   D747                         ; Re-init timer T40_o2Fbk to 4 sec if 
3258   D747                         ; currentTrimRange!=low (or high speed, E931 only)
3259   D747                         ;
3260   D747                         ; T40_o2Fbk will be 0 when the low trim range will 
3261   D747                         ; will have been used for more than 4 sec
3262   D747                         ;--------------------------------------------------
3263   D747 8F E5 13 05 L1130       brclr   ftrimFlags, #$13, L1131   ; Branch if currentTrimRange=low and rpm<threshold
3264   D74B 86 A0                   ldaa    #$a0                      ; 4sec                            
3265   D74D B7 01 1E                staa    T40_o2Fbk                 ; T40_o2Fbk = 4sec                             
3266   D750             
3267   D750                         ;--------------------------------------------------------------------
3268   D750                         ; Find which table we should be using depending on config resistors
3269   D750                         ; (one of L1999, L2000, L2001, L2002)
3270   D750                         ;--------------------------------------------------------------------
3271   D750 CE FB 0F    L1131       ldx     #t_strap2                 ;                                  
3272   D753 BD EC 02                jsr     cfgLookup16               ; x =  t_strap2(2*(config2 & $03)) = tableAddress
3273   D756             
3274   D756                         ;----------------------------------------------------------
3275   D756                         ; Use o2Fbk_dec:o2Fbk_inc = t_o2Fbk1 if timer expired 
3276   D756                         ; i.e. we have been in low trim range for more than 4sec
3277   D756                         ;----------------------------------------------------------
3278   D756 B6 01 1E                ldaa    T40_o2Fbk                 ;                                
3279   D759 26 05                   bne     L1132                     ; Branch if timer not expired                             
3280   D75B FC FB D3                ldd     t_o2Fbk1                  ; Timer expired, use t_o2Fbk1                              
3281   D75E 20 2D                   bra     L1138                     ; Bail to store                             
3282   D760             
3283   D760                         ;--------------------------------------------------------------------------
3284   D760                         ; Timer not expired, compute values for o2Fbk_dec:o2Fbk_inc
3285   D760                         ; from table pointed by x (see above, one of L1999, L2000, L2001, L2002)
3286   D760                         ; Use b as index into table. Start with b = 0
3287   D760                         ;--------------------------------------------------------------------------
3288   D760 5F          L1132       clrb                              ; b = 0                            
3289   D761             
3290   D761                         ;-------------------------------------------------------------
3291   D761                         ; b = b+1 if airVolTB >= threshold
3292   D761                         ; Threshold based on config resistors (AWD vs FWD???)
3293   D761                         ;-------------------------------------------------------------
3294   D761 96 E2                   ldaa    airVolTB                  ; a = airVolTB                                
3295   D763~            #ifdef E931                                   
3296   D763~                        cmpa    #$40                      ;                             
3297   D763~                        brclr   config2, #$80, L1133      ; Branch if ??? (same as branching if FWD)                                
3298   D763~                        cmpa    #$40                      ;                             
3299   D763             #else                                         
3300   D763 81 48                   cmpa    #$48                      ;                             
3301   D765 8F 56 80 02             brclr   config2, #$80, L1133      ;                                 
3302   D769 81 50                   cmpa    #$50                      ;                             
3303   D76B             #endif                                        
3304   D76B 25 01       L1133       bcs     L1134                     ; Branch if airVolTB < threshold                             
3305   D76D 5C                      incb                              ; airVolTB > threshold, b +=1 (go to next value)                            
3306   D76E             
3307   D76E                         ;-------------------------------------------------------------
3308   D76E                         ; b = b+2 if rpm31 >= (1500rpm or 1406rpm)
3309   D76E                         ;     b+4 if rpm31 >= (2094rpm or 2313rpm)
3310   D76E                         ;-------------------------------------------------------------
3311   D76E 96 DD       L1134       ldaa    rpm31                     ;                              
3312   D770 81 2D                   cmpa    #$2d                      ;                             
3313   D772 8F 56 80 02             brclr   config2, #$80, L1135      ;  Branch if ??? (same as branching if FWD)
3314   D776~            #ifdef E931                                   
3315   D776~                        cmpa    #$30                      ;                             
3316   D776             #else                                         
3317   D776 81 2D                   cmpa    #$2d                      ;                             
3318   D778             #endif                                        
3319   D778 25 0E       L1135       bcs     L1137                     ; Branch if rpm31 < threshold (1500rpm or 1406rpm)                              
3320   D77A CB 02                   addb    #$02                      ; rpm31 > (1500rpm or 1406rpm, b += 2
3321   D77C 81 43                   cmpa    #$43                      ; 2094rpm                            
3322   D77E 8F 56 80 02             brclr   config2, #$80, L1136      ; Branch if ??? (same as branching if FWD)
3323   D782~            #ifdef E931                                   
3324   D782~                        cmpa    #$4a                      ; 2313rpm                             
3325   D782             #else                                         
3326   D782 81 43                   cmpa    #$43                      ; 2094rpm                            
3327   D784             #endif                                        
3328   D784 25 02       L1136       bcs     L1137                     ;                              
3329   D786 CB 02                   addb    #$02                      ; rpm31 > (2313rpm or 2094rpm, b += 2
3330   D788             
3331   D788                         ;---------------------------------------------
3332   D788                         ; interpolate table from x+b
3333   D788                         ; (x is one of L1999, L2000, L2001, L2002)
3334   D788                         ;---------------------------------------------
3335   D788 3A          L1137       abx                               ;                             
3336   D789 A6 00                   ldaa    $00,x                     ;                              
3337   D78B E6 06                   ldab    $06,x                     ; ???????????                             
3338   D78D                                                           
3339   D78D                         ;------------------------------------------------
3340   D78D                         ; Update o2Fbk_dec and o2Fbk_inc with new values
3341   D78D                         ;------------------------------------------------
3342   D78D DD EB       L1138       std     o2Fbk_dec                                                 
3343   D78F             
3344   D78F                         ;-------------------------------------------------------------
3345   D78F                         ; If we are in closed loop mode, limit the range of o2Fbk
3346   D78F                         ; depending on ect and then compute o2FuelAdj (how much 
3347   D78F                         ; fuel to add/remove based on o2 sensor in closed loop....)
3348   D78F                         ;
3349   D78F                         ; Notice that part of the code has been located somewhere 
3350   D78F                         ; else... (L1973)
3351   D78F                         ;-------------------------------------------------------------
3352   D78F 86 80                   ldaa    #$80                    ; pre-load default value of $80 (no fuel adjustment)                            
3353   D791 8F E6 80 37             brclr   state1, #$80, L1148     ; Branch if open loop mode
3354   D795             
3355   D795                         ;----------------------------------------------------
3356   D795                         ; We are in closed loop mode, limit the range
3357   D795                         ; of o2Fbk to $4d-$d6 or $2a-$d6 depending on ect 
3358   D795                         ;----------------------------------------------------
3359   D795 7E FA CF                jmp     L1973                   ; Jump to code snipet for closed loop mode, will jump back to main code as appropriate                             
3360   D798 01                      nop                                                          
3361   D799             
3362   D799                         ;------------------------------------------------
3363   D799                         ; Continuation of code...
3364   D799                         ;------------------------------------------------
3365   D799                         ;---------------------------------------
3366   D799                         ; temperature(ectFiltered) > 86degC
3367   D799                         ; Check for min and max of $2a and $d6
3368   D799                         ;---------------------------------------
3369   D799 24 04       L1140       bcc     L1141                   ; Branch if o2Fbk >= $2a
3370   D79B 86 2A                   ldaa    #$2a                    ; Use min of $2a                            
3371   D79D 20 06                   bra     L1142                   ;                              
3372   D79F 81 D6       L1141       cmpa    #$d6                    ;                             
3373   D7A1 25 05                   bcs     L1143                   ; Branch if o2Fbk < $d6
3374   D7A3 86 D6                   ldaa    #$d6                    ; Use max of $d6                            
3375   D7A5             
3376   D7A5                         ;--------------------------
3377   D7A5                         ; Store new value of o2Fbk  
3378   D7A5                         ;--------------------------
3379   D7A5 5F          L1142       clrb                            ; Set lower 8 bit of o2Fbk                             
3380   D7A6 DD E9                   std     o2Fbk                   ;                              
3381   D7A8             
3382   D7A8                         ;-----------------------------------------------------------------------------
3383   D7A8                         ; Compute o2FuelAdj = o2Fbk +/-  t_closedLpV1(xx) or t_closedLpV2(xx) or $02
3384   D7A8                         ; where +/- depends on o2Raw (lean or rich). 
3385   D7A8                         ;-----------------------------------------------------------------------------
3386   D7A8 36          L1143       psha                            ; st0 = o2Fbk high byte
3387   D7A9~            #ifdef E931                                 ;
3388   D7A9~                        ldab    #$02                    ; b = $02                              
3389   D7A9~                        ldaa    T40_ftrim2              ; a = T40_ftrim2                                   
3390   D7A9~                        beq     L1146                   ; Branch if timer expired, use $02 instead of table values if conditions are stable on E931                             
3391   D7A9             #else                                       ;
3392   D7A9 CE FB CF                ldx     #t_closedLpV2           ; x = t_closedLpV2                              
3393   D7AC 87 D7 20 03             brset   port3Snap0, #$20, L1144 ; branch if Park/neutral                               
3394   D7B0             #endif
3395   D7B0 CE FB D1                ldx     #t_closedLpV1           ; x = t_closedLpV1                                
3396   D7B3 8F E5 13 01 L1144       brclr   ftrimFlags, #$13, L1145 ; branch if trim range is low and rpm<threshold???
3397   D7B7 08                      inx                             ; go to next value in table                             
3398   D7B8 E6 00       L1145       ldab    $00,x                   ; b = = t_closedLpV1(xx) or t_closedLpV2(xx)                               
3399   D7BA 96 CE       L1146       ldaa    o2Raw                   ; a = o2Raw
3400   D7BC 81 1A                   cmpa    #$1a                    ; 0.5V
3401   D7BE 32                      pula                            ; a = o2Fbk                             
3402   D7BF 24 07                   bcc     L1147                   ; Branch if o2Raw > 0.5V
3403   D7C1 1B                      aba                             ; o2 lean, a = o2Fbk + t_closedLpV1(xx) or t_closedLpV2(xx)
3404   D7C2 24 08                   bcc     L1148                   ; branch if no overflow                              
3405   D7C4 86 FF                   ldaa    #$ff                    ; Use max in case of overflow                            
3406   D7C6 20 04                   bra     L1148                   ; Branch to store o2FuelAdj
3407   D7C8                                                      
3408   D7C8 10          L1147       sba                             ; o2 rich, a = o2Fbk -  t_closedLpV1(xx) or t_closedLpV2(xx)
3409   D7C9 24 01                   bcc     L1148                   ; branch if no underflow
3410   D7CB 4F                      clra                            ; Use min value of 0
3411   D7CC             
3412   D7CC                         ;---------------------
3413   D7CC                         ; Store new o2FuelAdj
3414   D7CC                         ;---------------------
3415   D7CC B7 01 5A    L1148       staa    o2FuelAdj               ; o2Fbk +/- table value for fuel compensation in closed loop                              
3416   D7CF             
3417   D7CF                         ;-------------------------------------------------------------
3418   D7CF                         ; Transfer ftrimFlags to oldFtrimFlg, a = old oldFtrimFlg
3419   D7CF                         ;-------------------------------------------------------------
3420   D7CF B6 01 02                ldaa    oldFtrimFlg             ;                                    
3421   D7D2 D6 E5                   ldab    ftrimFlags              ;                                   
3422   D7D4 F7 01 02                stab    oldFtrimFlg             ;                                    
3423   D7D7             
3424   D7D7                         ;--------------------------------------------------------------
3425   D7D7                         ; Section to check whether conditions are sufficiently 
3426   D7D7                         ; stable to update fuel trims. Fuel trims are updated 
3427   D7D7                         ; only if T40_ftrim = 0
3428   D7D7                         ;
3429   D7D7                         ; Restart timer T40_ftrim at 5s under all the following conditions
3430   D7D7                         ;
3431   D7D7                         ;       if  fuel trim range changed
3432   D7D7                         ;       or  open loop mode
3433   D7D7                         ;       or  airVolTB too high
3434   D7D7                         ;       or  ectRaw malfunction
3435   D7D7                         ;       or  iatRaw malfunction
3436   D7D7                         ;       or  baroRaw malfunction
3437   D7D7                         ;       or  temperature(ectFiltered) < 86degC
3438   D7D7                         ;       or  temperature(iatChecked) >= 50degC
3439   D7D7                         ;       or  baroChecked < 0.76bar
3440   D7D7                         ;       or  baroChecked >= 1.05bar
3441   D7D7                         ;       or  accEnr not 0
3442   D7D7                         ;       or  airDiffNeg1 >= accEnrDiffT 
3443   D7D7                         ;       or  airVolT too small
3444   D7D7                         ;       or  purge solenoid activated
3445   D7D7                         ;       or  fuel pressure solenoid activated
3446   D7D7                         ;       or  T40_ftrim2 expired (E931)
3447   D7D7                         ;       or  T0p5_crCold not expired
3448   D7D7                         ;
3449   D7D7                         ;--------------------------------------------------------------
3450   D7D7 98 E5                   eora    ftrimFlags              ;                               
3451   D7D9 84 03                   anda    #$03                    ; a = (oldFtrimFlg eor ftrimFlags) & $03
3452   D7DB 26 41                   bne     L1150                   ; Branch if trim rancge changed                             
3453   D7DD 8F E6 80 3D             brclr   state1, #$80, L1150     ; Branch if open loop mode                                
3454   D7E1 87 E8 01 39             brset   closedLpFlags, #$01, L1150      ; Branch if airVolTB too high                              
3455   D7E5 87 D6 07 35             brset   state2, #$07, L1150     ; Branch if ectRaw, iatRaw or baroRaw in error                               
3456   D7E9 96 D3                   ldaa    ectFiltered             ;                                    
3457   D7EB~            #ifdef E931
3458   D7EB~                        cmpa    #$1c                    ; 86degC                             
3459   D7EB             #else
3460   D7EB 81 1B                   cmpa    #$1b                    ; 88degC                            
3461   D7ED             #endif
3462   D7ED 22 2F                   bhi     L1150                   ; Branch if temperature(ectFiltered) < 86degC                             
3463   D7EF 96 D4                   ldaa    iatChecked              ;                                   
3464   D7F1 81 49                   cmpa    #$49                    ;                             
3465   D7F3 23 29                   bls     L1150                   ; Branch if temperature(iatChecked) >= 50degC                              
3466   D7F5 96 D5                   ldaa    baroChecked             ;                                    
3467   D7F7 81 9C                   cmpa    #$9c                    ;                             
3468   D7F9 25 23                   bcs     L1150                   ; Branch if baroChecked < 0.76bar?                              
3469   D7FB 81 D8                   cmpa    #$d8                    ;                             
3470   D7FD 24 1F                   bcc     L1150                   ; Branch if baroChecked >= 1.05bar?                             
3471   D7FF 96 A1                   ldaa    accEnr                  ;                               
3472   D801 26 1B                   bne     L1150                   ; Branch if accEnr not 0 (we are applying enrichment during acceleration)                              
3473   D803 B6 01 4A                ldaa    airDiffNeg1             ;                                    
3474   D806 B1 01 0C                cmpa    accEnrDiffT             ;                                    
3475   D809 24 13                   bcc     L1150                   ; Branch if airDiffNeg1 >= accEnrDiffT (we will apply decceleration enrichment????)                             
3476   D80B 96 E1                   ldaa    airVolT                 ;                                
3477   D80D 81 18                   cmpa    #$18                    ;                             
3478   D80F 25 0D                   bcs     L1150                   ; Branch if airVolT < $18 (air volume too low)                             
3479   D811 8F 2F 10 09             brclr   port6, #$10, L1150      ; Branch if purge solenoid activated
3480   D815 8F 16 10 05             brclr   port5, #$10, L1150      ; Branch if fuel pressure solenoid activated                              
3481   D819~            #ifdef E931
3482   D819~                        ldaa    T40_ftrim2              ;                                    
3483   D819~                        beq     L1150                   ; Branch if timer T40_ftrim2 expired on E931???                               
3484   D819             #endif
3485   D819 B6 01 41                ldaa    T0p5_crCold             ;                               
3486   D81C 27 05                   beq     L1151                   ; Branch if T0p5_crCold expired, meaning its been more than 120sec since we started a cold engine (we can update trims...)
3487   D81E                                                       
3488   D81E                         ;-----------------------------------------------------
3489   D81E                         ; Conditions not stable, Re-init T40_ftrim at 5 sec
3490   D81E                         ;-----------------------------------------------------
3491   D81E 86 C8       L1150       ldaa    #$c8                    ; 5 sec                             
3492   D820 B7 01 23                staa    T40_ftrim               ;                               
3493   D823             
3494   D823                         ;------------------------------------------------------------------
3495   D823                         ; Get current fuel trim value according to current fuel trim range 
3496   D823                         ;------------------------------------------------------------------
3497   D823 CE 00 40    L1151       ldx     #ftrim_low              ;                               
3498   D826 D6 E5                   ldab    ftrimFlags              ;                              
3499   D828 C4 03                   andb    #$03                    ; Get current fuel trim range to update                            
3500   D82A 3A                      abx                             ; X point to fuel trim                             
3501   D82B A6 00                   ldaa    $00,x                   ; a = fuelTrim                             
3502   D82D C6 80                   ldab    #$80                    ; pre-load $80 in case we bail                     
3503   D82F                               
3504   D82F                         ;----------------------------------------------
3505   D82F                         ; Don't update trim if T40_ftrim not yet expired
3506   D82F                         ;----------------------------------------------
3507   D82F 7D 01 23                tst     T40_ftrim               ;                               
3508   D832 26 18                   bne     L1153                   ;                              
3509   D834             
3510   D834                         ;-------------------------------------------------------------------------------
3511   D834                         ; Update fuel trim at 40Hz
3512   D834                         ; fuel trim is actually increased/decreased by 1 at 40Hz/(256/5) = 0.78125Hz
3513   D834                         ;-------------------------------------------------------------------------------
3514   D834 8F D9 01 16             brclr   Tclocks, #$01, L1154    ; Branch if 40Hz signal not set                                   
3515   D838 D6 E9                   ldab    o2Fbk                   ; b = o2Fbk
3516   D83A C1 80                   cmpb    #$80                    ; 
3517   D83C 27 10                   beq     L1154                   ; branch if o2Fbk = 100% (no update)
3518   D83E D6 43                   ldab    ftrimCntr               ; b = ftrimCntr                             
3519   D840 25 06                   bcs     L1152                   ; branch if o2Fbk < 100%
3520   D842 CB 05                   addb    #$05                    ; b = ftrimCntr + 5
3521   D844 89 00                   adca    #$00                    ; a = fuelTrim+1 if ftrimCntr rolled over (o2Fbk + 5)>255
3522   D846 20 04                   bra     L1153                   ;
3523   D848 C0 05       L1152       subb    #$05                    ; b = ftrimCntr - 5
3524   D84A 82 00                   sbca    #$00                    ; a = fuelTrim-1 if ftrimCntr rolled under (o2Fbk - 5)<0
3525   D84C             
3526   D84C                         ;------------------------------
3527   D84C                         ; Update ftrimCntr with new value
3528   D84C                         ;------------------------------
3529   D84C D7 43       L1153       stab    ftrimCntr               ;                              
3530   D84E             
3531   D84E                         ;------------------------------------------------
3532   D84E                         ; Check a = updated trim value for min/max values
3533   D84E                         ;------------------------------------------------
3534   D84E 81 68       L1154       cmpa    #$68                    ; 
3535   D850 24 02                   bcc     L1155                   ; Branch if new fuelTrim > $68 (81%)
3536   D852 86 68                   ldaa    #$68                    ; use min
3537   D854 81 B0       L1155       cmpa    #ftrimMax               ;                                  
3538   D856 23 02                   bls     L1156                   ; Branch if new fuelTrim <= max (~140%)
3539   D858 86 B0                   ldaa    #ftrimMax               ; use max
3540   D85A             
3541   D85A                         ;---------------------------------------------------------------
3542   D85A                         ; Update the stored fuel trim with updated value (in a) and decide
3543   D85A                         ; whether we will apply the fuel trim to injector pulse width
3544   D85A                         ;---------------------------------------------------------------
3545   D85A A7 00       L1156       staa    $00,x                      ; Store new fuel trim value
3546   D85C 86 80                   ldaa    #$80                       ; Assume we won't apply fuel trim, a = $80 (100% fuel trim) 
3547   D85E 87 D6 08 06             brset   state2, #$08, L1157        ; Branch to use 100% if pulse accumulator interrupts are not being  received
3548   D862 87 E8 01 02             brset   closedLpFlags, #$01, L1157 ; Branch to use 100% if the "air volume (airVolTB) is too high to use closed loop mode (first threshold)"
3549   D866 A6 00                   ldaa    $00,x                      ; Load fuel trim from the current range                                                
3550   D868 B7 01 5B    L1157       staa    workFtrim                  ; Store working fuel trim
3551   D86B             
3552   D86B                         ;--------------------------------------------------------
3553   D86B                         ; Compute coldTempEnr, fuel enrichment factor when engine
3554   D86B                         ; is cold...Depends on ect and airflow 
3555   D86B                         ;
3556   D86B                         ; coldTempEnr/$80 = 1 + (f1-1)*f2 
3557   D86B                         ;                   1 + ectNetEnrichment*f2 
3558   D86B                         ;
3559   D86B                         ;       where f1 is t_ectEnr(ectCond)/$80, f1>=1.0
3560   D86B                         ;             f2 is t_airEnr(airVolCond)/$80, f2>=1.0
3561   D86B                         ;
3562   D86B                         ; Basically this factor adds fuel enrichment under 
3563   D86B                         ; cold temperature which is reduced down to no enrichement
3564   D86B                         ; (coldTempEnr/$80=1.0) as airVolCond increases, i.e. fuel
3565   D86B                         ; enrichement is only required under low temperature and 
3566   D86B                         ; low airflow
3567   D86B                         ;--------------------------------------------------------
3568   D86B CE FC 18                ldx     #t_ectEnr               ;                               
3569   D86E BD EB 2F                jsr     interpEct               ; b = t_ectEnr(ectCond)                                 
3570   D871 4F                      clra                            ;                             
3571   D872 C0 80                   subb    #$80                    ; d = t_ectEnr(ectCond)-$80                             
3572   D874 24 01                   bcc     L1158                   ; Branch if no overflow                             
3573   D876 5F                      clrb                            ; Use min of 0                            
3574   D877 DD 5C       L1158       std     temp6                   ; temp6:temp7 = t_ectEnr(ectCond)-$80  
3575   D879 CE FC 0C                ldx     #t_airEnr               ;                               
3576   D87C B6 01 50                ldaa    airVolCond              ;                                   
3577   D87F BD EB 3E                jsr     interp16b               ; b = t_airEnr(airVolCond)                                  
3578   D882 96 DD                   ldaa    rpm31                   ;                              
3579   D884 81 30                   cmpa    #$30                    ;                             
3580   D886 24 02                   bcc     L1159                   ;                              
3581   D888 C6 80                   ldab    #$80                    ; Use b=$80 if rpm<1500 
3582   D88A BD EB 5F    L1159       jsr     mul816_128              ; d = t_airEnr(airVolCond) * (t_ectEnr(ectCond)-$80)/$80 
3583   D88D CB 80                   addb    #$80                    ; b =  t_airEnr(airVolCond)*(t_ectEnr(ectCond)-$80)/$80 + $80                             
3584   D88F F7 01 5C                stab    coldTempEnr             ; coldTempEnr = t_airEnr(airVolCond) * (t_ectEnr(ectCond)-$80)/$80 + $80
3585   D892                                                         
3586   D892                                                      
3587   D892                         ;----------------------------------------------------------------
3588   D892                         ; Section to update openLoopEnr enrichment factor if in open loop
3589   D892                         ;----------------------------------------------------------------
3590   D892 C6 80                   ldab    #$80                    ; Assume an enrichement factor of 1.0                            
3591   D894 87 E6 80 58             brset   state1, #$80, L1167     ; Branch if closed loop mode     
3592   D898                         
3593   D898                         ;-------------------------------------------------------------
3594   D898                         ; Open loop
3595   D898                         ; Compute conditionned rpm and load for 2D map interpolation                           
3596   D898                         ;-------------------------------------------------------------
3597   D898 D6 DD                   ldab    rpm31                   ; b = rpm31
3598   D89A 86 D0                   ldaa    #$d0                    ; 6500 RPM                                                                
3599   D89C BD EC 1C                jsr     rpmRange                ; get rpm for map interpolation, b = min(max(RPM31p25-#$10, 0), $d0) = min(max(RPM31p25-500rpm,0),6500rpm)  
3600   D89F D7 5C                   stab    temp6                   ; temp6 = conditionned rpm
3601   D8A1 BD EC 26                jsr     getLoadForMaps          ; get the load value for map interpolation                                                      
3602   D8A4 D7 5D                   stab    temp7                   ; temp7 = conditionned load                              
3603   D8A6             
3604   D8A6                         ;----------------------------------------------
3605   D8A6                         ; Get basic fuel enrichement from 2D fuel map
3606   D8A6                         ;----------------------------------------------
3607   D8A6 CE FC 28                ldx     #t_fuelMap              ;                                   
3608   D8A9 CD CE 0E 00             ldy     #$0e00                  ;                               
3609   D8AD BD EA D6                jsr     lookup2D                ; a = b = 2D interpolated fuel map value from temp6 (rpm) and temp7 (load)                               
3610   D8B0             
3611   D8B0                         ;----------------------------------------
3612   D8B0                         ; Check airVol vs. RPM (deceleration???)
3613   D8B0                         ;----------------------------------------
3614   D8B0 96 E0                   ldaa    airVol                  ;                                
3615   D8B2 81 AF                   cmpa    #$af                    ;                             
3616   D8B4 25 0D                   bcs     L1162                   ; branch if airVol<$af                              
3617   D8B6 96 DD                   ldaa    rpm31                   ;                              
3618   D8B8~            #ifdef E931
3619   D8B8~                        cmpa    #$46                    ; 2187rpm                            
3620   D8B8             #else
3621   D8B8 81 53                   cmpa    #$53                    ; 2594rpm                            
3622   D8BA             #endif
3623   D8BA 25 07                   bcs     L1162                   ; branch if current rpm smaller than threshold                              
3624   D8BC B6 01 61                ldaa    timFuelEnr              ; a = timing/knock based fuel enrichement                              
3625   D8BF 1B                      aba                             ; a = basicFuelEnrichement + timingKnockFuelEnrichment
3626   D8C0 25 05                   bcs     L1163                   ; branch if overflow                             
3627   D8C2 16                      tab                             ; b = basicFuelEnrichement + timingKnockFuelEnrichment
3628   D8C3             
3629   D8C3                         ;-----------------------------------------------------------------------
3630   D8C3                         ; Check  fuel compensation + timing/knock based enrichment for max value
3631   D8C3                         ;-----------------------------------------------------------------------
3632   D8C3 C1 C0       L1162       cmpb    #fuelMapClip            ; 
3633   D8C5 23 02                   bls     L1164                   ; Branch if below max                              
3634   D8C7 C6 C0       L1163       ldab    #fuelMapClip            ; Use max                            
3635   D8C9 37          L1164       pshb                            ; Store  basicFuelEnrichement + timingKnockFuelEnrichment on stack
3636   D8CA                                         
3637   D8CA                         ;-----------------------------------
3638   D8CA                         ; Compute TPS based fuel enrichment
3639   D8CA                         ;-----------------------------------
3640   D8CA D6 D2                   ldab    tpsRaw                  ;
3641   D8CC CE B0 80                ldx     #$b080                  ;                                
3642   D8CF BD EB B9                jsr     clipOffset              ; b = max(min(tpsRaw,$b0)-$80,0)-> returns b = $00 to $30  (50% to 69%)                                           
3643   D8D2 17                      tba                             ; a = conditionned TPS for table interpolation                            
3644   D8D3 CE FF 04                ldx     #t_tpsEnr               ;                                
3645   D8D6 BD EB 3E                jsr     interp16b               ; a = t_tpsEnr(tpsRaw)                                 
3646   D8D9             
3647   D8D9                         ;-----------------------------------------------------------------------------------------
3648   D8D9                         ; Keep the highest of t_tpsEnr(tpsRaw) and  "basicFuelEnrichement + timingKnockFuelEnrichment"
3649   D8D9                         ;-----------------------------------------------------------------------------------------
3650   D8D9 33                      pulb                            ; b = basicFuelEnrichement + timingKnockFuelEnrichment
3651   D8DA 11                      cba                             ;                              
3652   D8DB 25 01                   bcs     L1165                   ; branch if basicFuelEnrichement + timingKnockFuelEnrichment
3653   D8DD 16                      tab                             ; b = max(t_tpsEnr(tpsRaw), basicFuelEnrichement + timingKnockFuelEnrichment)
3654   D8DE             
3655   D8DE                                                       
3656   D8DE                         ;-----------------------------------------------------------
3657   D8DE                         ; Compute timer T2_hotEnrich based fuel enrichement if required
3658   D8DE                         ;-----------------------------------------------------------
3659   D8DE 8F F8 02 0E L1165       brclr   varFlags0, #$02, L1167  ; Bail if "hot start" flag was not set                              
3660   D8E2 37                      pshb                            ; save on stack                             
3661   D8E3 C6 30                   ldab    #$30                    ; 
3662   D8E5 B6 01 38                ldaa    T2_hotEnrich            ;                             
3663   D8E8 3D                      mul                             ;                             
3664   D8E9 8B 80                   adda    #$80                    ; d = T2_hotEnrich*$30 + $80                            
3665   D8EB             
3666   D8EB                         ;---------------------
3667   D8EB                         ; Keep the highest
3668   D8EB                         ;---------------------
3669   D8EB 33                      pulb                            ; b = max(t_tpsEnr(tpsRaw), basicFuelEnrichement + timingKnockFuelEnrichment)
3670   D8EC 11                      cba                             ;                             
3671   D8ED 23 01                   bls     L1167                   ;                              
3672   D8EF 16                      tab                             ; max(T2_hotEnrich*$30 + $80, t_tpsEnr(tpsRaw), basicFuelEnrichement + timingKnockFuelEnrichment)
3673   D8F0                         
3674   D8F0                         ;-------------------------------------------
3675   D8F0                         ; Update openLoopEnr with the above result
3676   D8F0                         ;-------------------------------------------
3677   D8F0 F7 01 59    L1167       stab    openLoopEnr             ; Store final value                               
3678   D8F3             
3679   D8F3                         ;------------------------------------------------------------------
3680   D8F3                         ; Update T2_hotEnrich and varFlags0.1 (hot start) used in timer based enrichement above
3681   D8F3                         ;------------------------------------------------------------------
3682   D8F3 8F E6 90 06             brclr   state1, #$90, L1168     ; Branch if notRotating and closed loop clear
3683   D8F7 02 F8 FD                andm    varFlags0, #$fd         ; closedLoop or notRotating, reset flag and reset timer
3684   D8FA 4F                      clra                            ; a = 0                             
3685   D8FB 20 1B                   bra     L1169                   ; Update timer with 0
3686   D8FD             
3687   D8FD 8F E6 01 1A L1168       brclr   state1, #$01, L1171     ; open loop and at least rotating, Bail if startingToCrank clear
3688   D901 96 D4                   ldaa    iatChecked              ; Engine startingToCrank, a = iatChecked
3689   D903 81 3A                   cmpa    #$3a                    ;                             
3690   D905 22 14                   bhi     L1171                   ; Bail if temperature(iatChecked) < 60degC
3691   D907 96 D3                   ldaa    ectFiltered             ;                                    
3692   D909 81 18                   cmpa    #$18                    ; 93degC                            
3693   D90B 22 0E                   bhi     L1171                   ; Bail if temperature(ectFiltered) < 93degC                             
3694   D90D             
3695   D90D                         ;-----------------------------------------------------------------------------
3696   D90D                         ; At this point, engine is startingToCrank and we are in open loop 
3697   D90D                         ; and temperature(iatChecked) >= 60degC and  
3698   D90D                         ; temperature(ectFiltered) >= 93degC (hot start)                              
3699   D90D                         ;
3700   D90D                         ; Set hot start flag, init o2Fbk to lean(??) and re-init T2_hotEnrich timer to 120sec  
3701   D90D                         ;-----------------------------------------------------------------------------
3702   D90D 03 F8 02                orm     varFlags0, #$02         ; Set varFlags0.1 flag (hot start)
3703   D910 86 D6                   ldaa    #$d6                    ;                             
3704   D912 C6 80                   ldab    #$80                    ;                             
3705   D914 DD E9                   std     o2Fbk                   ; o2Fbk = $d680 (lean?)                             
3706   D916 86 F0                   ldaa    #$f0                    ; Re-init timer with 120sec                            
3707   D918 B7 01 38    L1169       staa    T2_hotEnrich            ;                             
3708   D91B             
3709   D91B                         ;----------------------------------------------
3710   D91B                         ; Update enrWarmup when engine startingToCrank
3711   D91B                         ; get enrWarmup timer value from table
3712   D91B                         ;----------------------------------------------
3713   D91B 5F          L1171       clrb                            ;                             
3714   D91C 87 E6 10 0A             brset   state1, #$10, L1172     ; Branch if notRotating
3715   D920 8F E6 01 0B             brclr   state1, #$01, L1173     ; Branch if startingToCrank clear
3716   D924 CE FC 20                ldx     #t_enrWarmup            ;                               
3717   D927 BD EB 2F                jsr     interpEct               ;                                  
3718   D92A F7 01 5D    L1172       stab    enrWarmup               ;                              
3719   D92D 20 11                   bra     L1174                   ;
3720   D92F                                                       
3721   D92F                         ;-----------------------------------------------------------------------------------------
3722   D92F                         ; Update enrWarmup at 40Hz
3723   D92F                         ;
3724   D92F                         ; T_enrWarm is decremented at 40Hz and loops at 2 if enrWarmup>$1a or loops 
3725   D92F                         ; at $18 otherwise decrement enrWarmup each time T_enrWarm reaches 0
3726   D92F                         ;
3727   D92F                         ; This allows to have rapid lowering of enrWarmup at first and then slow one
3728   D92F                         ; enrWarmup is decremented at 20Hz until it reached $1a (fuel enrichment factor of 141%) 
3729   D92F                         ; and then at 1.67Hz 
3730   D92F                         ;-----------------------------------------------------------------------------------------
3731   D92F 8F D9 01 1B L1173       brclr   Tclocks, #$01, L1176    ; Bail if 40Hz signal not set 
3732   D933 B6 01 5D                ldaa    enrWarmup               ;                              
3733   D936 27 16                   beq     L1176                   ;                              
3734   D938 7A 01 5E                dec     T_enrWarm               ;                              
3735   D93B 26 11                   bne     L1176                   ;                              
3736   D93D 7A 01 5D                dec     enrWarmup               ;                              
3737   D940             
3738   D940 86 02       L1174       ldaa    #$02                    ;                             
3739   D942 F6 01 5D                ldab    enrWarmup               ;                              
3740   D945 C1 1A                   cmpb    #$1a                    ;                             
3741   D947 22 02                   bhi     L1175                   ; Branch if enrWarmup>$1a                             
3742   D949 86 18                   ldaa    #$18                    ; Reset T_enrWarm counter to $18                            
3743   D94B B7 01 5E    L1175       staa    T_enrWarm               ;                              
3744   D94E             
3745   D94E             
3746   D94E                         ;------------------------------------------------
3747   D94E                         ; Section to compute injFactor 
3748   D94E                         ; start with basic value of totMasComp*16  
3749   D94E                         ;------------------------------------------------
3750   D94E FC 01 55    L1176       ldd     totMasComp              ; d = totMasComp                                   
3751   D951 05                      asld                            ;                             
3752   D952 05                      asld                            ;                             
3753   D953 05                      asld                            ;                             
3754   D954 05                      asld                            ;                             
3755   D955 DD 5C                   std     temp6                   ; temp6:temp7 = totMasComp*16
3756   D957             
3757   D957                         ;---------------------------------------
3758   D957                         ; Factor in injector size compensation
3759   D957                         ;---------------------------------------
3760   D957 C6 4E                   ldab    #injComp                ; Injector size compensation factor ($80 = 100% = no compensation, referenced at 260cc, 36psi)                                
3761   D959 BD EB 5F                jsr     mul816_128              ; d = [temp6:temp7] = totMasComp*16 * injComp /128                                   
3762   D95C FD 01 53                std     injMasComp              ; injMasComp = totMasComp*16 * injComp/128                              
3763   D95F             
3764   D95F                         ;-------------------------------------------------------
3765   D95F                         ; Factor in working fuel trim and 02 fuel adjustment
3766   D95F                         ; Done this way, total range is limited to [50%,150%]
3767   D95F                         ; when both workFtrim and o2FuelAdj are at $00 or $ff  
3768   D95F                         ;-------------------------------------------------------
3769   D95F 4F                      clra                              ; a=0                            
3770   D960 F6 01 5B                ldab    workFtrim                 ; d = working fuel trim ($80=100%)                             
3771   D963 C3 01 00                addd    #$0100                    ; d = workFtrim + 2*$80                               
3772   D966 FB 01 5A                addb    o2FuelAdj                 ; Add o2 adjustment (Add/remove fuel based on o2 sensor voltage/feedback, $80=100%->no fuel adjustment)                              
3773   D969 89 00                   adca    #$00                      ; propagate carry, d = workFtrim + o2FuelAdj + 2*$80                            
3774   D96B BD EB 79                jsr     mul1616_512               ; D = [temp6:temp7] = [workFtrim + o2FuelAdj + 2*$80]/512 * [temp6:temp7]
3775   D96E             
3776   D96E                         ;-----------------------------------
3777   D96E                         ; Factor-in air temp, baro, etc...
3778   D96E                         ;-----------------------------------
3779   D96E F6 01 5F                ldab    iatCompFact               ; Correct for air temperature (air density)                                    
3780   D971 BD EB 5F                jsr     mul816_128                ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
3781   D974 F6 01 60                ldab    baroFact                  ; Correct for barometric pressure (air density)                                 
3782   D977 BD EB 5F                jsr     mul816_128                ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
3783   D97A F6 01 59                ldab    openLoopEnr               ; Apply the open loop enrichment factor, based on timing/knock, tps and timer
3784   D97D BD EB 5F                jsr     mul816_128                ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
3785   D980 F6 01 5C                ldab    coldTempEnr               ; Add fuel enrichement under cold engine temperature and low airflow
3786   D983 BD EB 5F                jsr     mul816_128                ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
3787   D986 F6 01 5D                ldab    enrWarmup                 ; b = enrichment during warmup/startup, from t_enrWarmup(ECT), can reach 300% in very cold temp but is decreased to 140% very rapidly
3788   D989 4F                      clra                              ; a=0                            
3789   D98A 05                      asld                              ; d = 2*enrWarmup                            
3790   D98B C3 00 80                addd    #$0080                    ; d = 2*enrWarmup + $80 
3791   D98E BD EB 77                jsr     mul1616_128               ; Apply (2*enrWarmup+$80) enrichment factor
3792   D991 DD A3                   std     injFactor                 ; Store final result in injFactor (global injector factor)                            
3793   D993             
3794   D993                         ;----------------------------
3795   D993                         ; Compute injector deadTime
3796   D993                         ;----------------------------
3797   D993 CE FC CE                ldx     #t_deadtime-2                                            
3798   D996 96 D0                   ldaa    battRaw                                                 
3799   D998 BD EB 41                jsr     interp32                                                 
3800   D99B D7 A6                   stab    deadTime
3801   D99D                         
3802   D99D                         ;-----------------------------------------
3803   D99D                         ; Update injFlags0.2 (set but not reset???) 
3804   D99D                         ;-----------------------------------------
3805   D99D 96 DD                   ldaa    rpm31                                                 
3806   D99F 81 0E                   cmpa    #$0e                                                 
3807   D9A1 25 03                   bcs     L1178                     ; branch if rpm < 437.5                              
3808   D9A3 03 E7 04                orm     injFlags0, #$04           ; rpm >= 437.5, set bit                               
3809   D9A6             
3810   D9A6                         ;-----------------------------------------------
3811   D9A6                         ; Update injFlags0.1.3.5 if engine notRotating
3812   D9A6                         ;-----------------------------------------------
3813   D9A6 8F E6 10 13 L1178       brclr   state1, #$10, L1180       ; Branch if notRotating clear
3814   D9AA 02 E7 DF                andm    injFlags0, #$df           ; assume we reset 00100000, updated below
3815   D9AD 96 D3                   ldaa    ectFiltered               ;                                    
3816   D9AF 81 C2                   cmpa    #$c2                      ; -8degC                            
3817   D9B1 25 03                   bcs     L1179                     ; Branch if temperature(ectFiltered) > -8degC                              
3818   D9B3 03 E7 20                orm     injFlags0, #$20           ; temperature(ectFiltered) <= -8degC, set bit                                 
3819   D9B6 8F E7 04 03 L1179       brclr   injFlags0, #$04, L1180    ; Branch if rpm<437.5                                
3820   D9BA 02 E7 FA                andm    injFlags0, #$fa           ; Reset 0000 0101                                
3821   D9BD             
3822   D9BD                         ;------------------------------------------------------------------------------------
3823   D9BD                         ; Section to compute injPwStart, the injector pulsewidth when engine "startingToCrank" 
3824   D9BD                         ;
3825   D9BD                         ;  startingToCrank   "cold engine"   injPwStart       injFlags0.7 (startingToCrankColdEngine)
3826   D9BD                         ;          0             0               0                0
3827   D9BD                         ;          0             1               0                0
3828   D9BD                         ;          1             0            pulseWidth*4        0
3829   D9BD                         ;          1             1             pulseWidth         1
3830   D9BD                         ;------------------------------------------------------------------------------------
3831   D9BD                         ;--------------------------------
3832   D9BD                         ; Get starting value from L2008
3833   D9BD                         ;--------------------------------
3834   D9BD 4F          L1180       clra                                                         
3835   D9BE 8F E6 01 66             brclr   state1, #$01, L1191     ; Bail to end of section if startingToCrank clear
3836   D9C2 CE FC D7                ldx     #L2008                  ; Engine is startingToCrank                               
3837   D9C5 BD EB 1D                jsr     interpEct2              ; b = L2008(ectCond)                                   
3838   D9C8 86 80                   ldaa    #$80                    ; a = $80                            
3839   D9CA 3D                      mul                             ;                             
3840   D9CB 04                      lsrd                            ; d = $80*L2008(ectCond)                           
3841   D9CC DD 5C                   std     temp6                   ; [temp6:temp7] = $80*L2008(ectCond)                            
3842   D9CE             
3843   D9CE                         ;--------------------------------------------
3844   D9CE                         ; Factor-in some enrichement if injCount<5 
3845   D9CE                         ; This only adds more fuel when starting to 
3846   D9CE                         ; crank for the first time under very cold 
3847   D9CE                         ; temperature (-16degC). Not sure as to 
3848   D9CE                         ; exactly why but at -16degC, I guess 
3849   D9CE                         ; it just might help???
3850   D9CE                         ;--------------------------------------------
3851   D9CE B6 01 86                ldaa    injCount                  ;                              
3852   D9D1 81 05                   cmpa    #$05                      ;                              
3853   D9D3 24 0D                   bcc     L1182                     ; Branch if injCount>=5                              
3854   D9D5 CE FF 2E                ldx     #L2042                    ;                               
3855   D9D8 BD EB 1D                jsr     interpEct2                ; b=L2042(ectCond)                                  
3856   D9DB 4F                      clra                              ;                             
3857   D9DC C3 00 80                addd    #$0080                    ; d = L2042(ectCond) + $80                               
3858   D9DF BD EB 77                jsr     mul1616_128               ; [temp6:temp7] = [temp6:temp7] * (L2042(ectCond)+$80)/128
3859   D9E2             
3860   D9E2                         ;------------------------------------------------------------
3861   D9E2                         ; Factor in an rpm dependent correction factor if rpm >125???
3862   D9E2                         ;------------------------------------------------------------
3863   D9E2 96 DC       L1182       ldaa    rpm8                      ; a = rpm8                            
3864   D9E4 81 40                   cmpa    #$40                      ;                             
3865   D9E6 25 02                   bcs     L1183                     ; Branch if rpm < max of 500                              
3866   D9E8 86 40                   ldaa    #$40                      ; rpm>500, use max of 500rpm                            
3867   D9EA                                                           
3868   D9EA 80 10       L1183       suba    #$10                      ; a = rpm8-$10                             
3869   D9EC 25 10                   bcs     L1185                     ; Bail if rpm8<125rpm                             
3870   D9EE 48                      asla                              ; a = 2*(rpm8-$10)                             
3871   D9EF~            #ifdef E931                                   
3872   D9EF~                        ldab    #$56                      ;                             
3873   D9EF             #else                                         
3874   D9EF C6 57                   ldab    #$57                      ;                             
3875   D9F1             #endif                                        
3876   D9F1 3D                      mul                               ; d = $56*2*(rpm8-$10)                             
3877   D9F2 05                      asld                              ;                             
3878   D9F3 16                      tab                               ; b = 2*$56*2*(rpm8-$10)/256                            
3879   D9F4 86 80                   ldaa    #$80                      ; a = $80                            
3880   D9F6 10                      sba                               ; a = $80 - $56*2*(rpm8-$10)/128                             
3881   D9F7 24 01                   bcc     L1184                     ; Branch if no underflow                             
3882   D9F9 4F                      clra                              ; Use min of 0                            
3883   D9FA 16          L1184       tab                               ; b = $80 - $56*2*(rpm8-$10)/128                            
3884   D9FB BD EB 5F                jsr     mul816_128                ; [temp6:temp7] = [temp6:temp7] * ($80 - $56*2*(rpm8-$10)/128)/128
3885   D9FE                                                           
3886   D9FE             
3887   D9FE                         ;------------------------------------------------------------------
3888   D9FE                         ; Check current value for minimum, keep min
3889   D9FE                         ; minimum is L2008(0) -> starting value at 86degC (hot engine)
3890   D9FE                         ;------------------------------------------------------------------
3891   D9FE F6 FC D7    L1185       ldab    L2008                   ; b = L2008(0)                              
3892   DA01 86 80                   ldaa    #$80                    ; a = $80                            
3893   DA03 3D                      mul                             ; d = $80*L2008(0)                            
3894   DA04 04                      lsrd                            ; d = $80*L2008(0)/2                            
3895   DA05 1D 5C                   cmpd1   temp6                   ;                              
3896   DA07 25 02                   bcs     L1187                   ; branch if current value >                             
3897   DA09 DD 5C                   std     temp6                   ;  
3898   DA0B                                                     
3899   DA0B                         ;--------------------------------
3900   DA0B                         ; Factor-in barometric pressure
3901   DA0B                         ;--------------------------------
3902   DA0B F6 01 60    L1187       ldab    baroFact                ;                                 
3903   DA0E BD EB 5F                jsr     mul816_128              ; d = pulseWidth = [temp6:temp7] = [temp6:temp7] * baroFact/128
3904   DA11             
3905   DA11                         ;-----------------------------------------
3906   DA11                         ; Multiply by 2 and check for overflow
3907   DA11                         ;-----------------------------------------
3908   DA11 05                      asld                            ; pulseWidth = d = 2*[temp6:temp7]                            
3909   DA12 24 02                   bcc     L1188                   ; Branch if no overflow                              
3910   DA14 86 FF                   ldaa    #$ff                    ; Use max                             
3911   DA16             
3912   DA16                         ;--------------------------------------------------------------
3913   DA16                         ; At this point d = pulseWidth
3914   DA16                         ;
3915   DA16                         ; Set startingToCrankColdEngine flag if pulseWidth > threshold
3916   DA16                         ; or reset it (with hysteresis) 
3917   DA16                         ;
3918   DA16                         ; Note that pulseWidth will be larger when the engine is cold, also rpm dependent...
3919   DA16                         ;--------------------------------------------------------------
3920   DA16 37          L1188       pshb                            ; Put b on stack for temp calculation
3921   DA17 C6 35                   ldab    #$35                    ; b = $35 = 13.6ms =threshold
3922   DA19 8F E7 80 02             brclr   injFlags0, #$80, L1190  ; Branch if startingToCrankColdEngine was not previously set
3923   DA1D C6 30                   ldab    #$30                    ; Flag was set, use lower threshold (hysteresis) b=$30 = 12.3ms
3924   DA1F 03 E7 80    L1190       orm     injFlags0, #$80         ; By default, assume startingToCrankColdEngine flag set
3925   DA22 11                      cba                             ; 
3926   DA23 33                      pulb                            ; restore b (lower part of pulseWidth)                             
3927   DA24 24 05                   bcc     L1192                   ; Branch if pulseWidth/256 >= threshold (flag already set), we are startingToCrankColdEngine
3928   DA26             
3929   DA26                         ;-------------------------------------------------------------------------
3930   DA26                         ; pulseWidth < threshold, engine is therefore startingToCrank
3931   DA26                         ; but the engine is not cold 
3932   DA26                         ; Multiply pulseWidth by 4?????? and reset the flag
3933   DA26                         ;-------------------------------------------------------------------------
3934   DA26 05                      asld                            ;                               
3935   DA27 05                      asld                            ; d =  d * 4                              
3936   DA28 02 E7 7F    L1191       andm    injFlags0, #$7f         ; Reset startingToCrankColdEngine flag                                 
3937   DA2B 1A          L1192       xgdx                            ; x = pulseWidth
3938   DA2C                                                                      
3939   DA2C                         ;-----------------------------------------------------
3940   DA2C                         ; Store injPwStart and update state3.7 from injFlags0.7
3941   DA2C                         ; (done this way since used in interrupts)
3942   DA2C                         ;-----------------------------------------------------
3943   DA2C 96 E7                   ldaa    injFlags0               ;                               
3944   DA2E 84 80                   anda    #$80                    ; a = injFlags0 & $80, keep only that bit                             
3945   DA30 0F                      sei                             ;                              
3946   DA31 FF 01 00                stx     injPwStart              ; injPwStart = pulseWidth
3947   DA34 D6 A2                   ldab    state3                                                 
3948   DA36 C4 7F                   andb    #$7f                    ;                             
3949   DA38 1B                      aba                             ; b = b&$7f + injFlags0&$80                             
3950   DA39 97 A2                   staa    state3                  ; Update state3
3951   DA3B                              
3952   DA3B                         ;----------------------------------------                         
3953   DA3B                         ; Update state3 from state1
3954   DA3B                         ;----------------------------------------                         
3955   DA3B 96 E6                   ldaa    state1                  ;                               
3956   DA3D 84 1B                   anda    #$1b                    ; Keep 00011011
3957   DA3F 8F E6 08 06             brclr   state1, #$08, L1193     ; Branch if rotatingStopInj clear                                 
3958   DA43 87 E6 04 02             brset   state1, #$04, L1193     ; Engine rotatingStopInj, branch if runningFast                                 
3959   DA47 8A 20                   oraa    #$20                    ; Engine rotatingStopInj but not runningFast, set bit                              
3960   DA49 D6 A2       L1193       ldab    state3                  ;                              
3961   DA4B C4 C4                   andb    #$c4                    ; Keep 11000100                             
3962   DA4D 1B                      aba                             ;                             
3963   DA4E 97 A2                   staa    state3                  ;                               
3964   DA50             
3965   DA50                         ;--------------------------------------------------------------------------
3966   DA50                         ; If engine is just startingToCrank and this is the first time we are here
3967   DA50                         ; then compute sInjPw and schedule an interrupt to activate simultaneous 
3968   DA50                         ; injection (if no injector is currently active)
3969   DA50                         ;--------------------------------------------------------------------------
3970   DA50 0E                      cli                             ;                             
3971   DA51 8F E6 01 1A             brclr   state1, #$01, L1195     ; Bail if startingToCrank clear 
3972   DA55 87 E7 01 16             brset   injFlags0, #$01, L1195  ; Engine startingToCrank, bail if injFlags0.0 already set, meaning we were already here before and                               
3973   DA59 03 E7 01                orm     injFlags0, #$01         ; Set flag                                
3974   DA5C 86 0C                   ldaa    #$0c                    ; a = $0c                            
3975   DA5E 5F                      clrb                            ; d = $0c00                            
3976   DA5F 0F                      sei                             ;                             
3977   DA60 FD 01 14                std     sInjPw                  ; sInjPw = $0c00 = 3.072ms                              
3978   DA63 87 B2 0F 07             brset   injToAct, #$0f, L1194   ; Bail if any injector is active                                 
3979   DA67 DC 09                   ldd     t1t2_clk                ; No injector flag set, schedule interrupt
3980   DA69 C3 00 14                addd    #$0014                  ; 20us                              
3981   DA6C DD 0B                   std     t1_outCmpWr             ; schedule interrupt in 20us
3982   DA6E             
3983   DA6E                         ;----------------------
3984   DA6E                         ; Compute accEnrFact
3985   DA6E                         ;----------------------
3986   DA6E 0E          L1194       cli                             ;                             
3987   DA6F CE FF BB    L1195       ldx     #L2051                  ; x point to L2051                              
3988   DA72 BD EB 2F                jsr     interpEct               ; b = L2051(ect)                                 
3989   DA75 CE FC E8                ldx     #t_accEnr1              ; x point to t_accEnr1                               
3990   DA78 CD CE FC E0             ldy     #t_accEnr2a             ;                               
3991   DA7C FB 01 34                addb    T2_crank                ;                             
3992   DA7F 24 04                   bcc     L1196                   ; branch if engine stopped "startingToCrank" more than L2051(ect)/2 sec ago.
3993   DA81 CD CE FF AB             ldy     #t_accEnr2b             ;                               
3994   DA85 BD EA 5A    L1196       jsr     L1577                   ;                              
3995   DA88 FD 01 08                std     accEnrFact              ; [accEnrFact:accEnrFact+1] = 8 * injMasComp * t_accEnr1(rpm)/128 * [t_accEnr2a(ect) or t_accEnr2b(ect)]/128 * baroFact/128
3996   DA8B             
3997   DA8B                         ;-----------------------
3998   DA8B                         ; Compute accEnrDecay 
3999   DA8B                         ;-----------------------
4000   DA8B CE FC F2                ldx     #t_accEnrDecay          ;                               
4001   DA8E BD EB 2F                jsr     interpEct               ;                                  
4002   DA91 F7 01 03                stab    accEnrDecay             ; accEnrDecay = t_accEnrDecay(ect)
4003   DA94                                                                        
4004   DA94                         ;---------------------
4005   DA94                         ; Compute accEnrMinAf 
4006   DA94                         ;---------------------
4007   DA94 CE FF 12                ldx     #L2039                                                 
4008   DA97 BD EB 34                jsr     interp16rpm             ; a = L2039(rpm)                                    
4009   DA9A C6 57                   ldab    #$57                    ;                              
4010   DA9C 3D                      mul                             ; d = $57*L2039(rpm)                             
4011   DA9D BD EB 98                jsr     scale16                 ; d = $57*L2039(rpm)/16                               
4012   DAA0 FD 01 05                std     accEnrMinAf             ; accEnrMinAf:L0106 = $57*L2039(rpm)/16                            
4013   DAA3             
4014   DAA3                         ;---------------------
4015   DAA3                         ; Compute decEnrFact 
4016   DAA3                         ;---------------------          ;
4017   DAA3 B6 01 1A                ldaa    T40_crank               ;                              
4018   DAA6 8B 78                   adda    #$78                    ; 3s                            
4019   DAA8 24 04                   bcc     L1197                   ; branch if engine stopped "startingToCrank" more than 3s ago 
4020   DAAA 4F                      clra                            ;                             
4021   DAAB 5F                      clrb                            ;                             
4022   DAAC 20 0A                   bra     L1199                   ;                              
4023   DAAE CE FD 27    L1197       ldx     #t_decEnr1              ;                                   
4024   DAB1 CD CE FD 1F             ldy     #t_decEnr2              ;                                   
4025   DAB5 BD EA 5A                jsr     L1577                   ;                              
4026   DAB8 FD 01 0A    L1199       std     decEnrFact              ; [decEnrFact:decEnrFact+1] = 8 * injMasComp * t_decEnr1(rpm)/128 * t_decEnr2/128 * baroFact/128
4027   DABB             
4028   DABB                                                            
4029   DABB                         ;-------------------------------------------------------------------------
4030   DABB                         ; Compute sInjEnrInc   
4031   DABB                         ; Parameters related to adding fuel during simultaneous injection mode
4032   DABB                         ;-------------------------------------------------------------------------
4033   DABB CE FF BB                ldx     #L2051                  ; 
4034   DABE BD EB 2F                jsr     interpEct               ; b = L2051(ect)                                
4035   DAC1 CE FD 03                ldx     #L2013                  ;                              
4036   DAC4 FB 01 34                addb    T2_crank                ; b = L2051(ect) + T2_crank                            
4037   DAC7 24 03                   bcc     L1202                   ; branch if engine stopped "startingToCrank" more than L2051(ect)/2 sec ago
4038   DAC9 CE FF B3                ldx     #L2050                  ; Overflow, change table                             
4039   DACC BD EB 2F    L1202       jsr     interpEct               ; b = L2050(ect) or L2013(ect)                                
4040   DACF 37                      pshb                            ; st0 = L2050(ect) or L2013(ect)                            
4041   DAD0 CE FD 15                ldx     #L2015                  ;                              
4042   DAD3 BD EB 34                jsr     interp16rpm             ; b = L2015(rpm)                                   
4043   DAD6 32                      pula                            ; a = L2050(ect) or L2013(ect)                           
4044   DAD7 1B                      aba                             ; a = L2050(ect) or L2013(ect) +  L2015(rpm)                           
4045   DAD8 24 02                   bcc     L1205                   ; Branch if no overflow                            
4046   DADA 86 FF                   ldaa    #$ff                    ; Overflow, use max                      
4047   DADC B7 01 16    L1205       staa    sInjEnrInc              ; sInjEnrInc = L2050(ect) or L2013(ect) +  L2015(rpm)
4048   DADF             
4049   DADF                         ;-------------------------------------------------------------------------
4050   DADF                         ; Compute sInjEnrMax = sInjEnrInc/4   
4051   DADF                         ; Parameters related to adding fuel during simultaneous injection mode
4052   DADF                         ;-------------------------------------------------------------------------
4053   DADF C6 20                   ldab    #$20                    ; b = $20                           
4054   DAE1 3D                      mul                             ; d = $20 * sInjEnrInc
4055   DAE2 BD EB A8                jsr     scale128m               ; d = $20/128 * sInjEnrInc = 1/4 * sInjEnrInc, also check for max of 255...
4056   DAE5 F7 01 12                stab    sInjEnrMax              ; sInjEnrMax = 1/4 * sInjEnrInc = 1/4 * (L2051(ect) + T2_crank or L2050(ect) +  L2015(rpm))
4057   DAE8             
4058   DAE8                         ;---------------------------------------------------------------------------------
4059   DAE8                         ; Compute sInjTpsMax, threshold used to increase fuel in simulateneous injection
4060   DAE8                         ;---------------------------------------------------------------------------------
4061   DAE8 CE FD 0B                ldx     #t_sInjTpsMax           ;                              
4062   DAEB BD EB 34                jsr     interp16rpm             ;                                   
4063   DAEE F7 01 13                stab    sInjTpsMax              ; sInjTpsMax = t_sInjTpsMax(rpm)
4064   DAF1                                                                          
4065   DAF1                         ;---------------------------------
4066   DAF1                         ; Decrement T40s_casInt at 40Hz
4067   DAF1                         ;---------------------------------
4068   DAF1 CE 00 84                ldx     #T40s_casInt                                                 
4069   DAF4 BD EB F1                jsr     decX40Hz                ; Decrement T40s_casInt at 40Hz
4070   DAF7             
4071   DAF7                         ;-------------------------------------------------------------------------
4072   DAF7                         ; Set the timing adjustment flag (timAdjFlags.7) if the timing 
4073   DAF7                         ; adjustment terminal is grounded but the ECU test mode terminal is not
4074   DAF7                         ;-------------------------------------------------------------------------
4075   DAF7 8F D8 10 0D             brclr   port4Snap, #$10, L1209    ; Branch if stored timing terminal not grounded?                                   
4076   DAFB 8F 07 10 09             brclr   port4, #$10, L1209        ; Branch if timing terminal not grounded?                               
4077   DAFF 87 D8 08 05             brset   port4Snap, #$08, L1209    ; Branch if ECU test mode terminal grounded?                                   
4078   DB03 03 87 80                orm     timAdjFlags, #$80         ; Set flag, timing terminal grounded but ECU test mode terminal NOT grounded
4079   DB06 20 03                   bra     L1210                     ; Bail                             
4080   DB08 02 87 7F    L1209       andm    timAdjFlags, #$7f         ; Reset flag       
4081   DB0B                                     
4082   DB0B                         ;-----------------------------------------------------
4083   DB0B                         ; Re-init knockTimer to $ff if engine notRotating  
4084   DB0B                         ;-----------------------------------------------------
4085   DB0B 8F E6 10 05 L1210       brclr   state1, #$10, L1212       ; Branch if notRotating clear
4086   DB0F 86 FF                   ldaa    #$ff                      ; Engine notRotating                             
4087   DB11 B7 01 77                staa    knockTimer                                                 
4088   DB14             
4089   DB14                         ;-----------------------------------------------------
4090   DB14                         ; Update the "knock sensor bad" flag if 
4091   DB14                         ; engine was started more than 1 sec ago
4092   DB14                         ;-----------------------------------------------------
4093   DB14 87 E6 11 13 L1212       brset   state1, #$11, L1214       ; Branch if notRotating or startingToCrank
4094   DB18 B6 01 1A                ldaa    T40_crank                 ; Engine is running                              
4095   DB1B 8B 28                   adda    #$28                      ; 
4096   DB1D 25 0C                   bcs     L1214                     ; branch if engine stopped "startingToCrank" less than 1s ago (don't check knock sensor yet)
4097   DB1F 03 53 40                orm     knockFlags, #$40          ; Set flag indicating "engine running for more than 1 sec"???                               
4098   DB22 87 D8 20 08             brset   port4Snap, #$20, L1215    ; Branch if knock sensor is OK???                                   
4099   DB26 03 D6 20                orm     state2, #$20              ; Set flag indicating knock sensor is bad                                
4100   DB29 20 06                   bra     L1217                     ; Bail                             
4101   DB2B 02 53 BF    L1214       andm    knockFlags, #$bf          ; Reset flag indicating "engine running for more than 1 sec"???                                
4102   DB2E 02 D6 DF    L1215       andm    state2, #$df              ; Reset bad knock sensor flag                                
4103   DB31             
4104   DB31                         ;---------------------------------------------------------------------------------
4105   DB31                         ; Update  knockFlags.7 (airVol threshold flag) and T200s_knock if below threshold  
4106   DB31                         ;---------------------------------------------------------------------------------
4107   DB31 D6 E0       L1217       ldab    airVol                    ; b=airVol
4108   DB33 C1 49                   cmpb    #$49                      ; 
4109   DB35 24 08                   bcc     L1218                     ; branch if airVol>$49
4110   DB37 02 8C 03                andm    T200s_knock, #$03         ; airVol<$49, reset T200s_knock to a more reasonable value
4111   DB3A 02 53 7F                andm    knockFlags, #$7f          ; clear knockFlags.7                                                                 
4112   DB3D 20 03                   bra     L1219                     ; branch LDB89                                                             
4113   DB3F 03 53 80    L1218       orm     knockFlags, #$80          ; set knockFlags.7                                                                   
4114   DB42             
4115   DB42                         ;-----------------------------------------------------
4116   DB42                         ; Something activated at 4595rpm with hysteresis??????
4117   DB42                         ; Could be related to knock since we are in the area...
4118   DB42                         ; Maybe knock sensor filter parameter being changed???
4119   DB42                         ;-----------------------------------------------------
4120   DB42 86 96       L1219       ldaa    #$96                      ; 4688rpm                                                                          
4121   DB44 8F 2F 02 02             brclr   port6, #$02, L1220        ; branch if ??? not yet activated???                                 
4122   DB48 86 90                   ldaa    #$90                      ; 4500rpm                                                                          
4123   DB4A 91 DD       L1220       cmpa    rpm31                     ;                                                                           
4124   DB4C 22 05                   bhi     L1221                     ;  Branch if rpm lower than threshold                                                                           
4125   DB4E 03 2F 02                orm     port6, #$02               ; rpm higher than threshold, Activate ???
4126   DB51 20 03                   bra     L1222                     ;                                                                           
4127   DB53 02 2F FD    L1221       andm    port6, #$fd               ; De-activate ???
4128   DB56             
4129   DB56                         ;----------------------------
4130   DB56                         ; Section to update octane
4131   DB56                         ;----------------------------
4132   DB56                         ;--------------------------------------------------
4133   DB56                         ; Skip octane update if temp(ectFiltered) < 80degC
4134   DB56                         ;--------------------------------------------------
4135   DB56 96 D3       L1222       ldaa    ectFiltered                                                 
4136   DB58 81 20                   cmpa    #$20                    ; 80degC                            
4137   DB5A 22 50                   bhi     L1227                   ; Bail if temp(ectFiltered) < 80degC                               
4138   DB5C             
4139   DB5C                         ;-----------------------------------------
4140   DB5C                         ; temp(ectFiltered) >= 80degC
4141   DB5C                         ; Skip octane update under more cases... 
4142   DB5C                         ;-----------------------------------------
4143   DB5C 87 D6 28 4C             brset   state2, #$28, L1227     ; Bail if no pulse accumulator interrupts or if knock sensor not working?
4144   DB60 8F 53 40 48             brclr   knockFlags, #$40, L1227 ; Bail if engine has not been running for more than 1 sec                               
4145   DB64 CD CE FF C3             ldy     #L2052                  ; Engine has been running for more than 1 sec                               
4146   DB68 BD EB E9                jsr     rpmPwise                ; b = piecewise(rpm4) for table interpolation                                  
4147   DB6B 86 B0                   ldaa    #$b0                    ; a = $b0                             
4148   DB6D BD EC 21                jsr     abmin                   ; Apply max to b, b = min($b0,piecewise(rpm4))                             
4149   DB70 17                      tba                             ; a = min($b0,piecewise(rpm4))                            
4150   DB71 CE FF 22                ldx     #L2041                  ; x points to L2041                               
4151   DB74 BD EB 3E                jsr     interp16b               ; a = L2041(rpm4)                                  
4152   DB77 91 E0                   cmpa    airVol                  ;                                
4153   DB79 24 31                   bcc     L1227                   ; Bail if airVol <= L2041(rpm4)                              
4154   DB7B             
4155   DB7B                         ;---------------------------------------------
4156   DB7B                         ; airVol > L2041(rpm4), skip octane update 
4157   DB7B                         ; if 3<=knockSum<=5 (hysteresis zone...)
4158   DB7B                         ;---------------------------------------------
4159   DB7B 96 8B                   ldaa    knockSum                ;                                 
4160   DB7D 81 03                   cmpa    #$03                    ;                             
4161   DB7F 25 04                   bcs     L1223                   ; Branch if knockSum <3                             
4162   DB81 81 05                   cmpa    #$05                    ;                             
4163   DB83 23 27                   bls     L1227                   ; Bail if knockSum <=5                             
4164   DB85             
4165   DB85                         ;-------------------------------------------------------------
4166   DB85                         ; knockSum<3 or knockSum>5, we can update octane at 2.5Hz
4167   DB85                         ;-------------------------------------------------------------
4168   DB85 46          L1223       rora                            ; shift in carry bit, rest of a = knockSum/2                            
4169   DB86             
4170   DB86                         ;-----------------------------------------------------------
4171   DB86                         ; Decrement T40s_octane at 40Hz (loops at $10)
4172   DB86                         ; and update octane if timer is expired (at 2.5Hz)
4173   DB86                         ;-----------------------------------------------------------
4174   DB86 8F D9 01 22             brclr   Tclocks, #$01, L1227    ; Bail if 40Hz signal no set                                   
4175   DB8A F6 01 76                ldab    T40s_octane             ; b = T40s_octane                             
4176   DB8D 27 05                   beq     L1224                   ; Branch if timer expired                             
4177   DB8F 7A 01 76                dec     T40s_octane             ; Update timer                             
4178   DB92 26 18                   bne     L1227                   ; Bail if timer not yet expired
4179   DB94             
4180   DB94                         ;-------------------------------------
4181   DB94                         ; T40s_octane expired, update octane
4182   DB94                         ;-------------------------------------
4183   DB94 D6 52       L1224       ldab    octane                  ; b = octane                               
4184   DB96 4D                      tsta                            ;                             
4185   DB97 2A 08                   bpl     L1225                   ; Branch if knockSum >=3 (see carry bit shited-in above)
4186   DB99             
4187   DB99                         ;--------------------------------------------------
4188   DB99                         ; knockSum <3, increment octane by 1 (max 255)
4189   DB99                         ;--------------------------------------------------
4190   DB99 86 10                   ldaa    #$10                    ; pre-load timer value                             
4191   DB9B 5C                      incb                            ; b = octane+1                             
4192   DB9C 26 09                   bne     L1226                   ; Branf if no rollover                             
4193   DB9E 5A                      decb                            ; Rollover, use max of 255                             
4194   DB9F 20 06                   bra     L1226                   ; Bail to store                             
4195   DBA1             
4196   DBA1                         ;--------------------------------------------------
4197   DBA1                         ; knockSum >=3, decrement octane by 1 (min 0)
4198   DBA1                         ;--------------------------------------------------
4199   DBA1 86 10       L1225       ldaa    #$10                    ; pre-load timer value                             
4200   DBA3 5D                      tstb                            ;                             
4201   DBA4 27 01                   beq     L1226                   ; Branch if octane already 0                             
4202   DBA6 5A                      decb                            ; b = octane - 1                            
4203   DBA7 D7 52       L1226       stab    octane                  ; update octane
4204   DBA9 B7 01 76                staa    T40s_octane             ; Re-init T40s_octane with $10                              
4205   DBAC             
4206   DBAC                         ;-------------------------------------------------------------------------------------------------
4207   DBAC                         ; Section to compute timingOct, the timing interpolated from the 
4208   DBAC                         ; two timing maps (timing under high octane and low octane) according 
4209   DBAC                         ; to the current octane value
4210   DBAC                         ;
4211   DBAC                         ;       timingOct = alpha * t_timingHiOct(rpm, load) + (1-alpha) * t_timingLoOct(rpm, load)
4212   DBAC                         ;
4213   DBAC                         ; where alpha = octane/255, 0<= alpha <=1
4214   DBAC                         ;-------------------------------------------------------------------------------------------------
4215   DBAC                         ;-------------------------------------------------
4216   DBAC                         ; Compute rpm and load for 2D map interpolation                           
4217   DBAC                         ;-------------------------------------------------
4218   DBAC CD CE FF C3 L1227       ldy     #L2052                  ;
4219   DBB0 BD EB E9                jsr     rpmPwise                ; b = rpm                                
4220   DBB3 D7 5C                   stab    temp6                   ; temp6 = rpm                              
4221   DBB5 BD EC 26                jsr     getLoadForMaps          ; b = load                                      
4222   DBB8 D7 5D                   stab    temp7                   ; temp7 = load                             
4223   DBBA             
4224   DBBA                         ;--------------------------------------
4225   DBBA                         ; Get timing value from t_timingHiOct
4226   DBBA                         ;--------------------------------------
4227   DBBA CE FD 31                ldx     #t_timingHiOct          ; x points to t_timingHiOct                                  
4228   DBBD CD CE 10 00             ldy     #$1000                  ;                               
4229   DBC1 BD EA D6                jsr     lookup2D                ; b = t_timingHiOct(rpm,load)
4230   DBC4 F7 01 61                stab    timFuelEnr              ; timFuelEnr = t_timingHiOct(rpm,load)
4231   DBC7             
4232   DBC7                         ;------------------------------------------------------------------------------------
4233   DBC7                         ; Change load value for t_timingLoOct map interpolation (first three row missing)
4234   DBC7                         ;------------------------------------------------------------------------------------
4235   DBC7 96 5D                   ldaa    temp7                   ; a = load                             
4236   DBC9 80 30                   suba    #$30                    ; a = load - $30                            
4237   DBCB 25 22                   bcs     L1229                   ; branch if load <$30 (no interpolation,  use t_timingHiOct(rpm,load)
4238   DBCD 97 5D                   staa    temp7                   ; temp7 = load-$30                             
4239   DBCF             
4240   DBCF                         ;------------------------------------------------------
4241   DBCF                         ; Compute t_timingHiOct(rpm,load) * octane and put it on stack
4242   DBCF                         ;------------------------------------------------------
4243   DBCF BD DD 0E                jsr     getOctane               ; a = validated octane                                   
4244   DBD2 3D                      mul                             ; d = t_timingHiOct(rpm,load) * octane                             
4245   DBD3 36                      psha                            ; put on stack                             
4246   DBD4 37                      pshb                            ; put on stack
4247   DBD5                                                     
4248   DBD5                         ;-------------------------------------
4249   DBD5                         ; Get timing value from t_timingLoOct
4250   DBD5                         ;-------------------------------------
4251   DBD5 CE FD F1                ldx     #t_timingLoOct          ; x points to t_timingLoOct                                 
4252   DBD8 CD CE 10 00             ldy     #$1000                  ;                               
4253   DBDC BD EA D6                jsr     lookup2D                ; b = t_timingLoOct(rpm, load)
4254   DBDF             
4255   DBDF                         ;-----------------------------------------------------------------------------------------------------------
4256   DBDF                         ; Compute 
4257   DBDF                         ;       timingOct = octane/255 * t_timingHiOct(rpm,load) + (255 - octane)/255 * t_timingLoOct(rpm, load)
4258   DBDF                         ;                 = alpha * t_timingHiOct(rpm,load) + (1-alpha) * t_timingLoOct(rpm, load)
4259   DBDF                         ;-----------------------------------------------------------------------------------------------------------
4260   DBDF BD DD 0E                jsr     getOctane               ; a = octane                                   
4261   DBE2 43                      coma                            ; a = not(octane) = 255 - octane                             
4262   DBE3 3D                      mul                             ; d = (255 - octane) * t_timingLoOct(rpm, load)
4263   DBE4 DD 5C                   std     temp6                   ; temp6:temp7 = (255 - octane) * t_timingLoOct(rpm, load)
4264   DBE6 33                      pulb                            ;                             
4265   DBE7 32                      pula                            ; d = octane * t_timingHiOct(rpm,load) 
4266   DBE8 D3 5C                   addd    temp6                   ; d = octane * t_timingHiOct(rpm,load) + (255 - octane) *  t_timingLoOct(rpm, load)
4267   DBEA 14 FF                   div     #$ff                    ; a = remainder, b = octane/255 * t_timingHiOct(rpm,load) + (255 - octane)/255 *  t_timingLoOct(rpm, load)
4268   DBEC 49                      rola                            ; Put remainder high bit in carry
4269   DBED C9 00                   adcb    #$00                    ; roundup b with remainder
4270   DBEF F7 01 70    L1229       stab    timingOct               ; timingOct = octane/255 * t_timingHiOct(rpm,load) + (255 - octane)/255 *  t_timingLoOct(rpm, load)
4271   DBF2                                       
4272   DBF2                         ;--------------------------------------------------------------------------------------------------
4273   DBF2                         ; Compute timFuelEnr = $4b/256 * ($b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum - 5)
4274   DBF2                         ; timFuelEnr is a fuel enrichment based on timing, octane and knockSum
4275   DBF2                         ;--------------------------------------------------------------------------------------------------
4276   DBF2 B6 01 61                ldaa    timFuelEnr              ; a = t_timingHiOct(rpm,load)
4277   DBF5 B0 01 70                suba    timingOct               ; a = t_timingHiOct(rpm,load) - timingOct
4278   DBF8 24 01                   bcc     L1230                   ; Branch if result positive                              
4279   DBFA 4F                      clra                            ; Use min of 0                            
4280   DBFB C6 B6       L1230       ldab    #$b6                    ; b = $b6                            
4281   DBFD 3D                      mul                             ; d = $b6 * (t_timingHiOct(rpm,load) - timingOct)
4282   DBFE BD EB 96                jsr     scale64                 ; b = $b6/64 * (t_timingHiOct(rpm,load) - timingOct)
4283   DC01 DB 8B                   addb    knockSum                ; b = $b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum 
4284   DC03 24 02                   bcc     L1232                   ; Branch if no overflow                             
4285   DC05 C6 FF                   ldab    #$ff                    ; Overflow, use max of 255                            
4286   DC07 C0 05       L1232       subb    #$05                    ; b = $b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum - 5                            
4287   DC09 24 01                   bcc     L1233                   ; Branch if result positive                             
4288   DC0B 5F                      clrb                            ; Use min of 0                            
4289   DC0C~            #ifdef E931                                 
4290   DC0C~            L1233       ldaa    #$4b                    ; a = $4b                            
4291   DC0C             #else                                       
4292   DC0C 86 86       L1233       ldaa    #$86                    ; a = $86                            
4293   DC0E             #endif                                      
4294   DC0E 3D                      mul                             ; d =  $4b*($b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum - 5)                            
4295   DC0F B7 01 61                staa    timFuelEnr              ; timFuelEnr = $4b/256 * ($b6/64 * (t_timingHiOct(rpm,load) - timingOct) + knockSum - 5)                                 
4296   DC12             
4297   DC12                         ;---------------------------------------
4298   DC12                         ; Section to update maxAdv for E931
4299   DC12                         ;---------------------------------------
4300   DC12~            #ifdef E931
4301   DC12~                        brset   state1, #$04, Mdc7a     ; Branch if engine runningFast                                 
4302   DC12~                        brset   state1, #$10, Mdc76     ; Branch if notRotating
4303   DC12~                        ldaa    rpm8                    ; 
4304   DC12~                        cmpa    t_idleSpd               ;                                   
4305   DC12~                        bcs     Mdc76                   ; Branch if rpm8 < t_idleSpd (normal idle speed)                             
4306   DC12~                        ldaa    tpsDiffMax2             ; 
4307   DC12~                        cmpa    #$03                    ;                              
4308   DC12~                        bcc     Mdc76                   ; Branch if tpsDiffMax2 >= 3 (pedal is moving forward...)
4309   DC12~                        ldaa    airDiffPos1             ;                                     
4310   DC12~                        cmpa    #$0a                    ;                              
4311   DC12~                        bcs     L1234                   ; Bail (dont even update maxAdv) if airDiffPos1 < $0a (airflow decrease or small airflow increase)
4312   DC12~                                                                     
4313   DC12~                        ;----------------------------------------
4314   DC12~                        ; Use max of $80 (maxAdv=$80, no limit?)  
4315   DC12~                        ; if notRotating
4316   DC12~                        ;    or rpm8 < t_idleSpd
4317   DC12~                        ;    or tpsDiffMax2 >= 3
4318   DC12~                        ;    or airDiffPos1 >= $0a
4319   DC12~                        ;----------------------------------------
4320   DC12~            Mdc76       ldaa    #$80                    ; Use default of $80 (no limit)                              
4321   DC12~                        bra     Mdc90                   ; Branch to store
4322   DC12~                                                       
4323   DC12~                        ;--------------------------------------------------------------------
4324   DC12~                        ; Engine runningFast, compute maxAdv which will reduce the 
4325   DC12~                        ; timing advance by 13deg or limit it to 12deg
4326   DC12~                        ;---------------------------------------------------------------------
4327   DC12~            Mdc7a       ldaa    vssCnt1                 ;                                 
4328   DC12~                        beq     L1234                   ; Bail if car not moving                               
4329   DC12~                        ldaa    #$05                    ;                              
4330   DC12~                        staa    T_maxAdv                ; Init timer T_maxAdv = 5 ?
4331   DC12~                        ldaa    timingOct               ;                                   
4332   DC12~                        suba    #$0d                    ;                             
4333   DC12~                        bcc     Mdc8a                   ; Branch if timingOct - $0d positive                              
4334   DC12~                        clra                            ; Use min of 0                             
4335   DC12~            Mdc8a       ldab    #$12                    ; b = $12                             
4336   DC12~                        cba                             ;                              
4337   DC12~                        bcc     Mdc90                   ; Branch if timingOct-$0d >= $12                              
4338   DC12~                        tba                             ; Use max of $12 degrees                             
4339   DC12~            Mdc90       staa    maxAdv                  ; maxAdv = max(timingOct - $0d, 12)                                
4340   DC12             #endif
4341   DC12             
4342   DC12                         ;-------------------------------------------------
4343   DC12                         ; Set timAdjFlags.1 flag if rpm>2000rpm or reset it
4344   DC12                         ;-------------------------------------------------
4345   DC12 C6 40       L1234       ldab    #$40                     ; assume b = threshold = 2000rpm                           
4346   DC14 8F 87 01 02             brclr   timAdjFlags, #$01, L1235 ; Branch if flag clear                              
4347   DC18 C6 3A                   ldab    #$3a                     ; Flag was previously set, use a lower threshold of 1813rpm (hysteresis)                             
4348   DC1A 02 87 FE    L1235       andm    timAdjFlags, #$fe        ; Reset flag                               
4349   DC1D D1 DD                   cmpb    rpm31                    ;                              
4350   DC1F 24 03                   bcc     L1237                    ; Branch if rpm31 <= threshold (2000rpm or 1813rpm)
4351   DC21 03 87 01                orm     timAdjFlags, #$01        ; rpm31 > threshold, set flag                              
4352   DC24             
4353   DC24                         ;------------------------------------------------------------------------
4354   DC24                         ; Compute advRpm under some conditions (low rpm, idle switch off, etc.)
4355   DC24                         ; advRpm is an rpm based timing advance/retard with +/-8deg max
4356   DC24                         ;------------------------------------------------------------------------
4357   DC24 86 80       L1237       ldaa    #$80                     ; preload a = $80 = default value (no timing change)                             
4358   DC26 87 87 01 48             brset   timAdjFlags, #$01, L1243 ; Bail if rpm31 > 2000rpm (with hysteresis)                              
4359   DC2A 87 4B 04 44             brset   iscFlags0, #$04, L1243   ; Bail if basic idle speed adjustment mode is active (no timing change)                              
4360   DC2E 87 E6 19 40             brset   state1, #$19, L1243      ; Bail if notRotating or startingToCrank or rotatingStopInj
4361   DC32 8F D7 80 3C             brclr   port3Snap0, #$80, L1243  ; Bail if idle switch on                                   
4362   DC36 D6 C4                   ldab    vssCnt1                 ;                                
4363   DC38 21 38                   brn     L1243                   ; Branch never (?)                              
4364   DC3A CE 00 00                ldx     #$0000                  ; x = 0                              
4365   DC3D 5F                      clrb                            ; b = 0                            
4366   DC3E 96 FE                   ldaa    idleSpdTarg             ; d = 256*idleSpdTarg                             
4367   DC40~            #ifdef E931                                 ;
4368   DC40~                        suba    #$06                    ; d = 256*(idleSpdTarg - 6)      (-47rpm)                   
4369   DC40             #else                                       ;
4370   DC40 80 04                   suba    #$04                    ;                             
4371   DC42             #endif                                      ;
4372   DC42 24 01                   bcc     L1238                   ; Branch if no underflow                              
4373   DC44 4F                      clra                            ; Underflow, use min of 0                            
4374   DC45 BD EB 99    L1238       jsr     scale8                  ; a = 256/8 * (idleSpdTarg - 6) = 32*(idleSpdTarg - 6)                              
4375   DC48 1F 01 84                cmpd    rpmX4Filt               ;                                 
4376   DC4B 24 03                   bcc     L1239                   ; Branch if 32*(idleSpdTarg - 6) >= rpmX4Filt                             
4377   DC4D FC 01 84                ldd     rpmX4Filt               ; use min of rpmX4Filt                                 
4378   DC50 BD EB 98    L1239       jsr     scale16                 ; d = 2*(idleSpdTarg - 6)
4379   DC53 93 DA                   subd    rpm4                    ; d = 2*(idleSpdTarg - 6) - rpm4 
4380   DC55 24 06                   bcc     L1240                   ; Branch if positive                             
4381   DC57 08                      inx                             ; result negative, x = 1                            
4382   DC58 43                      coma                            ;                             
4383   DC59 53                      comb                            ;                             
4384   DC5A C3 00 01                addd    #$0001                  ; d =  rpm4 - 2*(idleSpdTarg - 6)
4385   DC5D BD EB B3    L1240       jsr     ovfCheck                ; b = result = abs(rpm4 - 2*(idleSpdTarg - 6))
4386   DC60 86 68                   ldaa    #$68                    ; a = $68                            
4387   DC62 3D                      mul                             ; d = $68 * abs(rpm4 - 2*(idleSpdTarg - 6))
4388   DC63 BD EB A1                jsr     round256                ; a = $68/256 * abs(rpm4 - 2*(idleSpdTarg - 6))
4389   DC66 81 08                   cmpa    #$08                    ;                             
4390   DC68 23 02                   bls     L1241                   ; Branch if a <= 8 (+/-8 degrees advance or retard)
4391   DC6A 86 08                   ldaa    #$08                    ; Use max of 8                            
4392   DC6C 09          L1241       dex                             ; x = x-1                            
4393   DC6D 26 01                   bne     L1242                   ; Branch if we did not have a negative result earlier                            
4394   DC6F 40                      nega                            ; Result was negative, negate again to restore it...                             
4395   DC70 8B 80       L1242       adda    #$80                    ; a =  $80 + $68/256 * (rpm4 - 2*(idleSpdTarg - 6))
4396   DC72 B7 01 73    L1243       staa    advRpm                  ; advRpm = $80 + $68/256 * (rpm4 - 2*(idleSpdTarg - 6))
4397   DC75             
4398   DC75                         ;--------------------------------------------------
4399   DC75                         ; Compute advEct, ect based timing advance/retard
4400   DC75                         ;--------------------------------------------------
4401   DC75 CE FE 81                ldx     #L2020                                                 
4402   DC78 BD EB 2F                jsr     interpEct                                                 
4403   DC7B F7 01 71                stab    advEct                  ; advEct = L2020(ect)                              
4404   DC7E             
4405   DC7E                         ;---------------------------------------------------------------
4406   DC7E                         ; Compute advIat iat based advance/retard under low load
4407   DC7E                         ;---------------------------------------------------------------
4408   DC7E CE FF 08                ldx     #L2038                  ;                               
4409   DC81 BD EB 34                jsr     interp16rpm             ; b = L2038(rpm)                                    
4410   DC84 91 E3                   cmpa    airVolB                 ;                                
4411   DC86 23 04                   bls     L1244                   ; Branch if L2038(rpm) <= airVolB                             
4412   DC88 86 80                   ldaa    #$80                    ; Use default value of $80 under high load                            
4413   DC8A 20 06                   bra     L1245                   ;                              
4414   DC8C CE FE 89    L1244       ldx     #L2021                  ; L2038(rpm) <= airVolB                              
4415   DC8F BD EB 39                jsr     iatCInterp              ;                                   
4416   DC92 B7 01 72    L1245       staa    advIat                  ; advIat = L2021(iat)
4417   DC95             
4418   DC95                         ;----------------------------------------------------------------------------------
4419   DC95                         ; Compute advTotal = min(timingOct, maxAdv) + advEct  + advIat + advRpm - $0180
4420   DC95                         ;                  = min(timingOct, maxAdv) + (advEct-$80)  + (advIat-$80) + (advRpm-$80)
4421   DC95                         ;----------------------------------------------------------------------------------
4422   DC95 CE 01 6F                ldx     #advTotal               ; x points to advTotal (table of timing related value)                             
4423   DC98 E6 01                   ldab    $01,x                   ; b = timingOct (timing corrected for current octane)                               
4424   DC9A~            #ifdef E931
4425   DC9A~                        cmpb    maxAdv                  ;                               
4426   DC9A~                        bls     L1246                   ; branch if timingOct<=maxAdv                               
4427   DC9A~                        ldab    maxAdv                  ; Use max of maxAdv                                
4428   DC9A             #endif
4429   DC9A 4F          L1246       clra                            ; d = min(timingOct, maxAdv) (a = 0...)                            
4430   DC9B CD 1A                   xgdy                            ; y =  min(timingOct, maxAdv)                            
4431   DC9D E6 02                   ldab    $02,x                   ; b = advEct                              
4432   DC9F CD 3A                   aby                             ; y = min(timingOct, maxAdv) + advEct                            
4433   DCA1 E6 03                   ldab    $03,x                   ; b = advIat                             
4434   DCA3 CD 3A                   aby                             ; y = min(timingOct, maxAdv) + advEct  + advIat                             
4435   DCA5 E6 04                   ldab    $04,x                   ; b = advRpm
4436   DCA7 CD 3A                   aby                             ; y = min(timingOct, maxAdv) + advEct  + advIat + advRpm
4437   DCA9 CD 1A                   xgdy                            ; d = min(timingOct, maxAdv) + advEct  + advIat + advRpm
4438   DCAB 1C 01 BC                cmpd    #$01bc                  ;                               
4439   DCAE 23 03                   bls     L1247                   ; Branch if min(timingOct, maxAdv) + advEct  + advIat + advRpm <= $01bc
4440   DCB0 CC 01 BC                ldd     #$01bc                  ; Use max of $01bc
4441   DCB3                                                       
4442   DCB3 1C 01 80    L1247       cmpd    #$0180                  ;                               
4443   DCB6 24 03                   bcc     L1248                   ; Branch if min(timingOct, maxAdv) + advEct  + advIat + advRpm >= $0180
4444   DCB8 CC 01 80                ldd     #$0180                  ; Use min of $0180
4445   DCBB                                                       
4446   DCBB 83 01 80    L1248       subd    #$0180                  ; d = min(timingOct, maxAdv) + advEct  + advIat + advRpm - $0180
4447   DCBE E7 00                   stab    $00,x                   ; advTotal = min(timingOct, maxAdv) + advEct  + advIat + advRpm - $0180
4448   DCC0             
4449   DCC0                         ;----------------------------------------------------------
4450   DCC0                         ; Compute tim61Tot0 = $e7 - $b6/64 * (advTotal + $0a) 
4451   DCC0                         ;                   = 256 * (61deg - (advTotal-10deg)) / 90
4452   DCC0                         ;
4453   DCC0                         ; This is timing referenced to -61deg BTDC
4454   DCC0                         ; -10deg is because advTotal is shifted by 10deg (timingOct 
4455   DCC0                         ; is from the timing maps which are shifted by 10 deg...)
4456   DCC0                         ;----------------------------------------------------------
4457   DCC0 CB 0A                   addb    #$0a                    ; b = advTotal + $0a
4458   DCC2 86 B6                   ldaa    #$b6                    ; a = $b6                             
4459   DCC4 3D                      mul                             ; d = $b6 * (advTotal + $0a)                            
4460   DCC5 BD EB 96                jsr     scale64                 ; d = $b6/64 *  (advTotal + $0a)
4461   DCC8 86 E7                   ldaa    #$e7                    ; a = $e7                            
4462   DCCA 10                      sba                             ; a = $e7 - $b6/64 *  (advTotal + $0a)
4463   DCCB 97 88                   staa    tim61Tot0               ; tim61Tot0 = $e7 - $b6/64 *  (advTotal + $0a)
4464   DCCD             
4465   DCCD                         ;-------------------------------
4466   DCCD                         ; Compute timingAdv from tim61
4467   DCCD                         ;-------------------------------
4468   DCCD 86 A0                   ldaa    #$a0                    ; a = $a0 (default when engine not running)                           
4469   DCCF 87 E6 11 02             brset   state1, #$11, L1249     ; Branch if notRotating or startingToCrank
4470   DCD3 96 7D                   ldaa    tim61                   ; a = tim61                             
4471   DCD5 C6 5A       L1249       ldab    #$5a                    ; b = $5a                            
4472   DCD7 3D                      mul                             ; d = $5a * tim61
4473   DCD8 BD EB A1                jsr     round256                ; a = $5a * tim61/256
4474   DCDB 40                      nega                            ; a = -($5a * tim61/256)
4475   DCDC 8B 47                   adda    #$47                    ; a = -($5a * tim61/256) + $47 = $47 - $5a * tim61/256 
4476   DCDE 97 8A                   staa    timingAdv               ; timingAdv = $147 - $5a * tim61/256
4477   DCE0             
4478   DCE0                         ;-------------------
4479   DCE0                         ; Compute enerLen
4480   DCE0                         ;-------------------
4481   DCE0 96 D0                   ldaa    battRaw                 ;                                
4482   DCE2 80 80                   suba    #$80                    ; a = battRaw - $80  (9.38v)                          
4483   DCE4 24 01                   bcc     L1250                   ; branch if underflow                              
4484   DCE6 4F                      clra                            ; Use min of 0                            
4485   DCE7 97 5B       L1250       staa    temp5                   ; temp5 = max(0,battRaw - $80)                             
4486   DCE9 CE FE 90                ldx     #t_enerLen              ; x points to t_enerLen                               
4487   DCEC BD EB 3E                jsr     interp16b               ; b = t_enerLen(battRaw)                                 
4488   DCEF D7 89                   stab    enerLen                 ; enerLen = t_enerLen(battRaw)                             
4489   DCF1             
4490   DCF1                         ;-------------------------------------------------
4491   DCF1                         ; Update coilChkFlags.5 flag, Set bit if engine 
4492   DCF1                         ; running and rpm<5000 and 8V<=battRaw<=18V
4493   DCF1                         ;-------------------------------------------------
4494   DCF1 87 E6 11 15             brset   state1, #$11, L1253     ; Branch if notRotating or startingToCrank 
4495   DCF5 96 DD                   ldaa    rpm31                   ; a = rpm31                              
4496   DCF7 81 A0                   cmpa    #$a0                    ;                             
4497   DCF9 24 0F                   bcc     L1253                   ; Branch if rpm31 >= 5000rpm                             
4498   DCFB 96 D0                   ldaa    battRaw                 ; a = battRaw                               
4499   DCFD 81 F5                   cmpa    #$f5                    ; 18V                             
4500   DCFF 22 09                   bhi     L1253                   ; Branch if battRaw > 18V                              
4501   DD01 81 6D                   cmpa    #$6d                    ; 8V                             
4502   DD03 25 05                   bcs     L1253                   ; Branch if battRaw < 8V                              
4503   DD05 03 85 20                orm     coilChkFlags, #$20      ; At this point voltage is between 8V and 18V, set bit
4504   DD08 20 03                   bra     L1255                   ;                              
4505   DD0A 02 85 DF    L1253       andm    coilChkFlags, #$df      ; Reset bit 
4506   DD0D             
4507   DD0D                         ;------
4508   DD0D                         ; Exit
4509   DD0D                         ;------
4510   DD0D 39          L1255       rts                             ;                             
4511   DD0E             
4512   DD0E             
4513   DD0E             
4514   DD0E             ;******************************************************************
4515   DD0E             ;
4516   DD0E             ; Return the octane value if sensors look ok, 0 otherwise 
4517   DD0E             ; (very low octane to be on the safe side)
4518   DD0E             ;
4519   DD0E             ;
4520   DD0E             ;
4521   DD0E             ;******************************************************************
4522   DD0E 4F          getOctane   clra                                                         
4523   DD0F 87 D6 28 02             brset   state2, #$28, L1257     ; Branch if no pulse accumulator interrupts or knock sensor not working 
4524   DD13 96 52                   ldaa    octane                                                 
4525   DD15 39          L1257       rts                                                          
4526   DD16             
4527   DD16             
4528   DD16             
4529   DD16             ;******************************************************************
4530   DD16             ;
4531   DD16             ;
4532   DD16             ; Third subroutine
4533   DD16             ;
4534   DD16             ;
4535   DD16             ;******************************************************************
4536   DD16                         ;-------------------------------------------
4537   DD16                         ; Update fuel pump activation/deactivation
4538   DD16                         ;-------------------------------------------
4539   DD16 8F E6 10 09 subroutine3 brclr   state1, #$10, L1259     ; Branch if notRotating clear
4540   DD1A 87 FB 02 05             brset   obdActCmd, #$02, L1259  ; Engine notRotating, branch if fuel pump is being actuated through OBD command
4541   DD1E 03 02 10                orm     port1, #$10             ; De-activate fuel pump relay
4542   DD21 20 03                   bra     L1260                   ; Bail                                                                                          
4543   DD23 02 02 EF    L1259       andm    port1, #$ef             ; activate fuel pump relay
4544   DD26             
4545   DD26                         ;------------------------------------------------------------------------
4546   DD26                         ; Re-init T40_acOn if A/C switch on is off
4547   DD26                         ; (implement a min delay before turning A/C on after button is pressed)
4548   DD26                         ;------------------------------------------------------------------------
4549   DD26 CE 01 2E    L1260       ldx     #T40_acOn                ; X points to 40Hz timer T40_acOn                                                                                           
4550   DD29 8F D7 10 04             brclr   port3Snap0, #$10, L1261  ; Branch if A/C switch flag off (switch is on?)                                                                                         
4551   DD2D 86 18                   ldaa    #$18                     ; Switch is off, init timer                                                                                        
4552   DD2F A7 00                   staa    $00,x                    ; Re-init T40_acOn with $18 (0.6s, min time before activating A/C)                                                                                         
4553   DD31             
4554   DD31                         ;---------------------------------------------------------------------------------
4555   DD31                         ; Re-init T40_acOnRpm if rpm<438
4556   DD31                         ; (implement a min delay before turning A/C on after RPM > 438 (after start-up)
4557   DD31                         ;---------------------------------------------------------------------------------
4558   DD31 96 DD       L1261       ldaa    rpm31                   ; a = rpm                                                                               
4559   DD33 81 0E                   cmpa    #$0e                    ; 438rpm                                                                                
4560   DD35 22 04                   bhi     L1262                   ; Branch if rpm > 438                                                                   
4561   DD37 86 20                   ldaa    #$20                    ; rpm lower than 438, init timer
4562   DD39 A7 01                   staa    $01,x                   ; rpm<438 -> Re-init timer #T40_acOnRpm with $20 (0.8s)
4563   DD3B                                           
4564   DD3B                         ;--------------------------------------------------------------
4565   DD3B                         ; For AT, decide if we will turn A/C on/off based on TPS...
4566   DD3B                         ;--------------------------------------------------------------
4567   DD3B             L1262       .equ    $                       ;
4568   DD3B             #ifdef E932    
4569   DD3B                         ;-----------------------------------------------------------------
4570   DD3B                         ; Load TPS value of 78% or 82% (80% target with +/-2% hysteresis) 
4571   DD3B                         ;-----------------------------------------------------------------
4572   DD3B 86 D2                   ldaa    #$d2                    ; Load 82% threshold                            
4573   DD3D 8F F8 01 02             brclr   varFlags0, #$01, L1263  ; Do not branch if TPS was higher than 82% the previous time we were here                             
4574   DD41 86 C7                   ldaa    #$c7                    ; Use 78% threshold instead (hysteresis)              
4575   DD43                         
4576   DD43                         ;-----------------------------------------------------------------
4577   DD43                         ; Check if TPS is above/below threshold and set varFlags0 accordingly
4578   DD43                         ;-----------------------------------------------------------------
4579   DD43 03 F8 01    L1263       orm     varFlags0, #$01         ; Assume this bit will be set (reset below)                               
4580   DD46 91 D2                   cmpa    tpsRaw                  ;                            
4581   DD48 23 07                   bls     L1264                   ; Branch if threshold smaller than TPS (TPS higher than threshold)
4582   DD4A             
4583   DD4A                         ;----------------------------------------------------------------------------------
4584   DD4A                         ; TPS lower than threshold, reset varFlags0.0 flag and set timer T40_acCut to 5s
4585   DD4A                         ;----------------------------------------------------------------------------------
4586   DD4A 02 F8 FE                andm    varFlags0, #$fe         ; TPS lower than threshold, reset varFlags0.0                               
4587   DD4D 86 C8                   ldaa    #$c8                    ; 5s at 40Hz                            
4588   DD4F A7 02                   staa    $02,x                   ; Init T40_acCut to 5s (delay before turning A/C back on)                             
4589   DD51             #endif
4590   DD51             
4591   DD51                         ;---------------------------------------------------------------------------
4592   DD51                         ; Make sure both T40_acOn and T40_acOnRpm are 0 before attempting to turn A/C on
4593   DD51                         ; Implement a min delay before engaging A/C 
4594   DD51                         ; clutch once car has started or A/C button is pressed
4595   DD51                         ;---------------------------------------------------------------------------
4596   DD51 A6 00       L1264       ldaa    $00,x                   ; a = T40_acOn
4597   DD53 AA 01                   oraa    $01,x                   ; a = T40_acOn | T40_acOnRpm                                                  
4598   DD55 26 11                   bne     L1266                   ; Branch if at least one timert not yet 0 (turn A/C off)                                       
4599   DD57                         
4600   DD57                         ;-----------------------------------------------------------------------------
4601   DD57                         ; At this point, both T40_acOn and T40_acOnRpm timers are at 0, we can turn A/C on
4602   DD57                         ;-----------------------------------------------------------------------------
4603   DD57             #ifdef E932
4604   DD57                         ;--------------------------------------------------------------
4605   DD57                         ; For AT, decide if we will turn A/C on/off based on TPS...
4606   DD57                         ; Seems A/C is cutoff for a maximum of 5 seconds when TPS>80%
4607   DD57                         ; but it is turned back on whenever TPS goes below 80% (no delay)
4608   DD57                         ; It would probably be better to turn-it off for 5s anyway...
4609   DD57                         ;--------------------------------------------------------------
4610   DD57 8F F8 01 08             brclr   varFlags0, #$01, L1265  ; Branch if TPS was lower than threshold (turn it back on immediately, not the best????)
4611   DD5B 87 D7 20 04             brset   port3Snap0, #$20, L1265 ; TPS is higher than threshold, branch if Park/neutral flag is set (no need to cutoff if in park)
4612   DD5F A6 02                   ldaa    $02,x                   ; Get T40_acCut value to see if we can turn A/C back on (5 second delay)                              
4613   DD61 26 05                   bne     L1266                   ; Branch if timer not expired                            
4614   DD63             #endif
4615   DD63             
4616   DD63                         ;----------------
4617   DD63                         ; Turn A/C on 
4618   DD63                         ;----------------
4619   DD63 02 02 DF    L1265       andm    port1, #$df             ; Turn A/C clutch bit to 0 
4620   DD66 20 03                   bra     L1267    
4621   DD68                                                                                                   
4622   DD68                         ;----------------
4623   DD68                         ; Turn A/C off
4624   DD68                         ;----------------
4625   DD68 03 02 20    L1266       orm     port1, #$20             ; Turn A/C clutch bit to 1 
4626   DD6B             
4627   DD6B                         ;--------------------------------------------------------------
4628   DD6B                         ; Section to update the purge solenoid activation/deactivation
4629   DD6B                         ;--------------------------------------------------------------
4630   DD6B                         ;------------------------------------------------------------
4631   DD6B                         ; Reset forced activation and forced deactivation flags 
4632   DD6B                         ; since we are going to update them
4633   DD6B                         ;------------------------------------------------------------
4634   DD6B 02 F8 9F    L1267       andm    varFlags0, #$9f         ; Reset bits 01100000 ($20 and $40)
4635   DD6E             
4636   DD6E                         ;-----------------------------------
4637   DD6E                         ; Branch according to engine state
4638   DD6E                         ;-----------------------------------
4639   DD6E 8F E6 10 0E             brclr   state1, #$10, L1270     ; Branch if notRotating clear
4640   DD72             
4641   DD72                         ;-----------------------------------------------------------
4642   DD72                         ; Engine notRotating, check if an OBD command is ongoing
4643   DD72                         ; to activate solenoid, set flags in consequence
4644   DD72                         ;-----------------------------------------------------------
4645   DD72 87 FB 01 05             brset   obdActCmd, #$01, L1269  ; Branch if purge solenoid is actuated by OBD
4646   DD76 03 F8 20                orm     varFlags0, #$20         ; Set "forced deactivation flag" 
4647   DD79 20 46                   bra     L1276                   ; Branch to continue                             
4648   DD7B 03 F8 40    L1269       orm     varFlags0, #$40         ; Set "forced activation" flag
4649   DD7E 20 41                   bra     L1276                   ; Branch to reset pulsewidth modulation flag since engine not rotating...  
4650   DD80                                                     
4651   DD80                         ;----------------------------------------------------------------
4652   DD80                         ; Engine rotating
4653   DD80                         ; Check if minimum conditions are met to activate purge solenoid
4654   DD80                         ;----------------------------------------------------------------
4655   DD80 B6 01 34    L1270       ldaa    T2_crank                ; a = T2_crank                                 
4656   DD83 8B 78                   adda    #$78                    ;                             
4657   DD85 25 0A                   bcs     L1271                   ; Branch if engine stopped "startingToCrank" less than 60 sec ago.
4658   DD87 8F E5 03 06             brclr   ftrimFlags, #$03, L1271 ; Branch if current trim range is "low"                                    
4659   DD8B 96 D3                   ldaa    ectFiltered             ; a = ectFiltered                                    
4660   DD8D 81 2D                   cmpa    #$2d                    ; 66degC                            
4661   DD8F 23 05                   bls     L1272                   ; Branch if temperature(ectFiltered) >= 66degC                             
4662   DD91             
4663   DD91                         ;-----------------------------------------------------------
4664   DD91                         ; Conditions are not good to activate purge solenoid
4665   DD91                         ; Set "forced deactivation" flag
4666   DD91                         ;-----------------------------------------------------------
4667   DD91 03 F8 20    L1271       orm     varFlags0, #$20         ; Set flag                               
4668   DD94 20 13                   bra     L1274                   ; Branch to continue        
4669   DD96                                              
4670   DD96                         ;---------------------------------------------------------------
4671   DD96                         ; Minimum condition for activation are met, check if there are
4672   DD96                         ; special conditions where we should always activate???
4673   DD96                         ;---------------------------------------------------------------
4674   DD96 8F E6 80 0C L1272       brclr   state1, #$80, L1273     ; Branch to activate if open loop mode is active
4675   DD9A                         
4676   DD9A                         ;------------------------------
4677   DD9A                         ; We are in closed loop mode
4678   DD9A                         ;------------------------------
4679   DD9A 96 D5                   ldaa    baroChecked             ; a = baroChecked
4680   DD9C 81 9C                   cmpa    #$9c                    ; 1 bar                            
4681   DD9E 25 06                   bcs     L1273                   ; Branch to activate if baroChecked < 0.76 bar, activate if baro is very low?                             
4682   DDA0 96 D4                   ldaa    iatChecked              ; a = iatChecked                                  
4683   DDA2 81 49                   cmpa    #$49                    ; 50degC                            
4684   DDA4 22 03                   bhi     L1274                   ; Branch if temperature(iatChecked) < 50degC                              
4685   DDA6             
4686   DDA6                         ;--------------------------------------------------------------------------------
4687   DDA6                         ; At this point, min conditions are met and either
4688   DDA6                         ;   open loop mode is active 
4689   DDA6                         ; or 
4690   DDA6                         ;   closed loop mode is active  and (baroChecked < 0.76 or temperature(iatChecked) >= 50degC)
4691   DDA6                         ;
4692   DDA6                         ; Set "forced activation" flag indicating 
4693   DDA6                         ; we should activate purge solenoid 
4694   DDA6                         ;--------------------------------------------------------------------------------
4695   DDA6 03 F8 40    L1273       orm     varFlags0, #$40         ; Set flag                                
4696   DDA9             
4697   DDA9                         ;----------------------------------------------------------------
4698   DDA9                         ; Continuation from code flows above when engine is rotating...
4699   DDA9                         ; Update varFlags0.7 deactivation flag if its timer is expired
4700   DDA9                         ;
4701   DDA9                         ; varFlags0.7 deactivation flag is used to activate/deactivate 
4702   DDA9                         ; solenoid when none of the other two flags are set. Flag 
4703   DDA9                         ; stays set for 24sec and stays reset for 212 sec. Toggled 
4704   DDA9                         ; between the two states, basically implementing pulsewidth 
4705   DDA9                         ; modulation with a very long period...
4706   DDA9                         ;----------------------------------------------------------------
4707   DDA9 B6 01 42    L1274       ldaa    T0p5_purge              ; a = T0p5_purge                                  
4708   DDAC 26 1B                   bne     L1278                   ; Bail to activate/deactivate if timer not expired                             
4709   DDAE             
4710   DDAE                         ;-----------------------------------------------------------------
4711   DDAE                         ; Timer is expired, time to toggle the flag, 
4712   DDAE                         ; branch to appropriate section depending on current flag value
4713   DDAE                         ;-----------------------------------------------------------------
4714   DDAE 87 F8 80 0B             brset   varFlags0, #$80, L1275  ; Branch if deactivation flag was set previously
4715   DDB2             
4716   DDB2                         ;-----------------------------------------------------------------------
4717   DDB2                         ; Flag is not set, first check if "forced activation" is requested
4718   DDB2                         ; in that case we just bail since it doesn't matter anymore...
4719   DDB2                         ;-----------------------------------------------------------------------
4720   DDB2 87 F8 40 13             brset   varFlags0, #$40, L1278  ; Bail to activate if solenoid needs "forced activation"                              
4721   DDB6             
4722   DDB6                         ;-----------------------------------------------------------------------
4723   DDB6                         ; Time has come to toggle the flag to 1 and reset the timer to 24sec
4724   DDB6                         ;-----------------------------------------------------------------------
4725   DDB6 86 0C                   ldaa    #$0c                    ; a = 24s                            
4726   DDB8 03 F8 80                orm     varFlags0, #$80         ; Set flag                               
4727   DDBB 20 09                   bra     L1277                   ; Branch to update timer and activate/deactivate    
4728   DDBD             
4729   DDBD                         ;-----------------------------------------------------------------------
4730   DDBD                         ; Flag is set, first check if "forced deactivation" is requested
4731   DDBD                         ; in that case we just bail since it doesn't matter anymore...
4732   DDBD                         ;-----------------------------------------------------------------------
4733   DDBD 87 F8 20 08 L1275       brset   varFlags0, #$20, L1278  ; Bail to activate/deactivate if "forced deactivation" flag is set                              
4734   DDC1             
4735   DDC1                         ;-----------------------------------------------------------------------
4736   DDC1                         ; Time has come to toggle the flag to 0 and reset the timer to 212sec
4737   DDC1                         ;-----------------------------------------------------------------------
4738   DDC1 86 6A       L1276       ldaa    #$6a                    ; 212s
4739   DDC3 02 F8 7F                andm    varFlags0, #$7f         ; Reset flag                               
4740   DDC6 B7 01 42    L1277       staa    T0p5_purge              ; T0p5_purge = 212sec         
4741   DDC9                                   
4742   DDC9                         ;------------------------------------------------------------------
4743   DDC9                         ; Continuation from all code flows above...
4744   DDC9                         ; Based on flags, decide to activate or deactivate purge solenoid
4745   DDC9                         ; Flags are tested in priority order...
4746   DDC9                         ;------------------------------------------------------------------
4747   DDC9 87 F8 40 08 L1278       brset   varFlags0, #$40, L1279      ; 1st priority, branch to activate if forced activation is set
4748   DDCD 87 F8 20 09             brset   varFlags0, #$20, L1280      ; 2nd priority, branch to deactivate if forced deactivation is set                              
4749   DDD1 87 F8 80 05             brset   varFlags0, #$80, L1280      ; 3rd priority, branch to deactivate if pulswidth modulation flag is set                              
4750   DDD5             
4751   DDD5                         ;---------------------------
4752   DDD5                         ; Activate purge solenoid
4753   DDD5                         ;---------------------------
4754   DDD5 02 2F EF    L1279       andm    port6, #$ef             ; Activate purge solenoid
4755   DDD8 20 03                   bra     L1281                   ;                              
4756   DDDA             
4757   DDDA                         ;----------------------------
4758   DDDA                         ; Deactivate purge solenoid
4759   DDDA                         ;----------------------------
4760   DDDA 03 2F 10    L1280       orm     port6, #$10             ; Deactivate purge solenoid
4761   DDDD             
4762   DDDD             
4763   DDDD                         ;--------------------------------------------------------------
4764   DDDD                         ; Section to update the EGR solenoid activation/deactivation
4765   DDDD                         ;--------------------------------------------------------------
4766   DDDD                         ;----------------------------------------------------------------
4767   DDDD                         ; Compute egr duty cycle factor 
4768   DDDD                         ; as a function of rpm and airVol from 2D table t_egrDutyFact 
4769   DDDD                         ;----------------------------------------------------------------
4770   DDDD F6 01 51    L1281       ldab    rpmIndex1               ;                              
4771   DDE0 86 70                   ldaa    #$70                    ; max of rpm                            
4772   DDE2 BD EC 21                jsr     abmin                   ; b = max(rpmIndex1, $70)                             
4773   DDE5 D7 5C                   stab    temp6                   ; column index is rpm                             
4774   DDE7 D6 E0                   ldab    airVol                  ;                               
4775   DDE9 86 80                   ldaa    #$80                    ; max of airVol
4776   DDEB BD EC 1C                jsr     rpmRange                ;                                 
4777   DDEE D7 5D                   stab    temp7                   ; row index is airVol                        
4778   DDF0 C6 80                   ldab    #$80                    ; b = 100% duty cycle                            
4779   DDF2 8F E6 10 04             brclr   state1, #$10, L1282     ; Branch if notRotating clear
4780   DDF6 87 FB 08 1F             brset   obdActCmd, #$08, L1283  ; Engine notRotating, branch if EGR solenoid actuated (by OBD) -> use 100% duty
4781   DDFA 5F          L1282       clrb                            ; b = 0% duty cycle                           
4782   DDFB 87 D6 08 1A             brset   state2, #$08, L1283     ; Branch if no pulse accumulator interrupts  -> use 0% duty cycle                                
4783   DDFF 87 E6 11 16             brset   state1, #$11, L1283     ; Branch if notRotating or startingToCrank -> use 0% duty cycle
4784   DE03 CE FF 40                ldx     #t_egrDutyFact          ;                               
4785   DE06 CD CE 08 00             ldy     #$0800                  ;                               
4786   DE0A BD EA D6                jsr     lookup2D                ; b = t_egrDutyFact(rpm, airVol)                                 
4787   DE0D 4F                      clra                            ;                             
4788   DE0E DD 5C                   std     temp6                   ; temp6:temp7 = t_egrDutyFact(rpm,airVol)                              
4789   DE10             
4790   DE10                         ;---------------------------------------------------------------------------------
4791   DE10                         ; Get EGR solenoid duty cycle from t_egrDuty and apply factor from above
4792   DE10                         ;---------------------------------------------------------------------------------
4793   DE10 CE FF 88                ldx     #t_egrDuty              ;                                   
4794   DE13 B6 01 4E                ldaa    ectCond                 ;                                
4795   DE16 BD EB 5D                jsr     interp32mul             ; b = t_egrDutyFact(rpm,airVol) * t_egrDuty(ect)                                   
4796   DE19 F7 01 7D    L1283       stab    egrDuty128              ; egrDuty128 = t_egrDutyFact(rpm,airVol) * t_egrDuty(ect) with $80=100%                                   
4797   DE1C                         
4798   DE1C                         ;-------------------------------------
4799   DE1C                         ; Scale duty factor to 00 - $30 range
4800   DE1C                         ;-------------------------------------
4801   DE1C 86 30                   ldaa    #$30                    ; 
4802   DE1E 3D                      mul                             ;                             
4803   DE1F BD EB 95                jsr     scale128                ; b = $30 * egrDuty128/128                              
4804   DE22 F7 01 7E                stab    egrDuty                 ; egrDuty with max of $30=100%
4805   DE25             
4806   DE25                         ;--------------------------------------------------------------------
4807   DE25                         ; Re-Init T2_EcuPower to $ff if T40_noPower expired
4808   DE25                         ; (T2_EcuPower will start counting from $ff when power is back on...
4809   DE25                         ;--------------------------------------------------------------------
4810   DE25 B6 01 24                ldaa    T40_noPower             ;                                    
4811   DE28 26 05                   bne     L1284                   ; Branch if ECU still has power                             
4812   DE2A 86 FF                   ldaa    #$ff                    ; ECU about to loose power, reset T2_EcuPower to max (127.5sec)                               
4813   DE2C B7 01 35                staa    T2_EcuPower             ;
4814   DE2F                                                                 
4815   DE2F                         ;-----------------------------------------------------------
4816   DE2F                         ; Section to update boost control solenoid duty cycle
4817   DE2F                         ;-----------------------------------------------------------
4818   DE2F                         ;-----------------------------------------------------------
4819   DE2F                         ; Check if time has come, section is updated at ~40Hz
4820   DE2F                         ;-----------------------------------------------------------
4821   DE2F 8F D9 01 5A L1284       brclr   Tclocks, #$01, L1298    ; Bail of section if 40Hz signal no set                                   
4822   DE33 D6 F9                   ldab    fpsBcsFlags             ; b = old fpsBcsFlags                              
4823   DE35 02 F9 8F                andm    fpsBcsFlags, #$8f       ; Assume those three flags are reset, updated below (0111 0000)
4824   DE38             
4825   DE38                         ;-------------------------------------------------------------------
4826   DE38                         ; Check if octane is above/below threshold with hysteresis 
4827   DE38                         ; (high $c0, low $9a) and update fpsBcsFlags.5 flag (reset above) 
4828   DE38                         ;-------------------------------------------------------------------
4829   DE38 86 9A                   ldaa    #$9a                    ; start with low threshold, a = $9a
4830   DE3A C5 20                   bitb    #$20                    ; test bit                                                                   
4831   DE3C 26 02                   bne     L1285                   ; Branch if old fpsBcsFlags.5 was set                                     
4832   DE3E 86 C0                   ldaa    #$c0                    ; bit was not set, use higher threshold a = $c0
4833   DE40 91 52       L1285       cmpa    octane                  ; 
4834   DE42 24 03                   bcc     L1286                   ; Branch if octane <= threshold
4835   DE44 03 F9 20                orm     fpsBcsFlags, #$20       ; set flag since we are above threshold 
4836   DE47             
4837   DE47                         ;-------------------------------------------------------------------
4838   DE47                         ; Check if mafRaw16 is above/below threshold with hysteresis 
4839   DE47                         ; (high $4e, low $38) and update fpsBcsFlags.4 flag (reset above) 
4840   DE47                         ;-------------------------------------------------------------------
4841   DE47 86 38       L1286       ldaa    #$38                    ; a = #0038                                                        
4842   DE49 C5 10                   bitb    #$10                    ;                                                                  
4843   DE4B 26 02                   bne     L1287                   ; Branch if old fpsBcsFlags.4 was set  
4844   DE4D~            #ifdef E931                                  
4845   DE4D~                        ldaa    #$4e                    ; a = #004e
4846   DE4D             #else
4847   DE4D 86 4A                   ldaa    #$4a                    ;                             
4848   DE4F             #endif
4849   DE4F B1 01 4B    L1287       cmpa    mafRaw16                ; 
4850   DE52 24 03                   bcc     L1288                   ; branch if mafRaw16 <= threshold
4851   DE54 03 F9 10                orm     fpsBcsFlags, #$10       ; set flag since we are above threshold 
4852   DE57             
4853   DE57             
4854   DE57                         ;-------------------------------------------------
4855   DE57                         ; Branch to proper section if engine not running
4856   DE57                         ;-------------------------------------------------
4857   DE57 8F E6 10 04 L1288       brclr   state1, #$10, L1289     ; Branch if notRotating clear 
4858   DE5B 87 FB 20 23             brset   obdActCmd, #$20, L1295  ; Engine notRotating, branch if boost solenoid actuated (by OBD command I assume)
4859   DE5F 87 E6 11 1A L1289       brset   state1, #$11, L1293     ; branch if notRotating or startingToCrank
4860   DE63             
4861   DE63                         ;----------------------------------------------------
4862   DE63                         ; Engine is running...
4863   DE63                         ; Check if time has come to update
4864   DE63                         ;----------------------------------------------------
4865   DE63 B6 01 80                ldaa    T40s_bcs                ; 
4866   DE66 26 21                   bne     L1297                   ; Branch if timer not expired                             
4867   DE68             
4868   DE68                         ;----------------------------------------------------
4869   DE68                         ; Timer expired, time to update has come (~2Hz)
4870   DE68                         ;
4871   DE68                         ; By default, increase bcsDuty by 8 and test if we
4872   DE68                         ; should not reduce it instead
4873   DE68                         ;----------------------------------------------------
4874   DE68 F6 01 81                ldab    bcsDuty                  ; b = bcsDuty
4875   DE6B CB 08                   addb    #$08                     ; b = bcsDuty + 8
4876   DE6D 87 D6 28 08             brset   state2, #$28, L1292      ; Branch if no pulse accumulator interrupts being received or knock sensor not working
4877   DE71 87 F9 10 04             brset   fpsBcsFlags, #$10, L1292 ; Branch if mafRaw16 above threshold 
4878   DE75 87 F9 20 05             brset   fpsBcsFlags, #$20, L1294 ; Branch if octane above threshold 
4879   DE79             
4880   DE79                         ;--------------------------------------------------------------
4881   DE79                         ; At this point, knock sensor is not working or we are not
4882   DE79                         ; receiving airflow sensor interrupts or mafRaw16 is above
4883   DE79                         ; threshold or octane is below threshold, basically these
4884   DE79                         ; are onditions where we would want to reduce turbo pressure 
4885   DE79                         ;
4886   DE79                         ; Reduce bcsDuty by 2 instead of increasing by 8 
4887   DE79                         ;--------------------------------------------------------------
4888   DE79 C0 10       L1292       subb    #$10                     ; b = bcsDuty + 8 - 10 = bcsDuty - 2
4889   DE7B 24 01                   bcc     L1294                    ; Branch if no underflow                             
4890   DE7D 5F          L1293       clrb                             ; Use min of 0                            
4891   DE7E             
4892   DE7E                         ;---------------------------------------
4893   DE7E                         ; Check new bcsDuty for max of $30, 
4894   DE7E                         ; store new value and update the timer
4895   DE7E                         ;---------------------------------------
4896   DE7E C1 30       L1294       cmpb    #$30                     ;                             
4897   DE80 25 02                   bcs     L1296                    ; Branch if new bcsDuty < $30                               
4898   DE82 C6 30       L1295       ldab    #$30                     ; Use max of $30
4899   DE84 F7 01 81    L1296       stab    bcsDuty                  ; Store new bcsDuty
4900   DE87 86 14                   ldaa    #$14                     ; Re-init timer to 20 (0.5sec)                            
4901   DE89 4A          L1297       deca                             ; Decrement timer                            
4902   DE8A B7 01 80                staa    T40s_bcs                 ; Store updated timer                             
4903   DE8D             
4904   DE8D             
4905   DE8D                         ;-------------------------------------
4906   DE8D                         ; Decrement T40s_tps at 40Hz
4907   DE8D                         ;-------------------------------------
4908   DE8D 0F          L1298       sei                             ;                             
4909   DE8E CE 01 82                ldx     #T40s_tps               ;                               
4910   DE91 BD EB F1                jsr     decX40Hz                ; Decrement T40s_tps at 40Hz 
4911   DE94 0E                      cli                             ;                             
4912   DE95             
4913   DE95                         ;------------------------------------
4914   DE95                         ; Compute the boost gauge duty cycle 
4915   DE95                         ; depending on current conditions
4916   DE95                         ;------------------------------------
4917   DE95 5F                      clrb                            ; load default duty cycle of b = 0                             
4918   DE96 B6 01 24                ldaa    T40_noPower             ;                               
4919   DE99 27 13                   beq     L1299                   ; Bail if timer expired (ECU is about to shut-down...) (use 0 duty)                              
4920   DE9B C6 0C                   ldab    #$0c                    ; Load default duty cycle of b = $0c
4921   DE9D 87 E6 10 0D             brset   state1, #$10, L1299     ; Bail if notRotating (use half duty...)
4922   DEA1 5F                      clrb                            ; load default duty cycle of b = 0 
4923   DEA2 87 D6 08 08             brset   state2, #$08, L1299     ; Bail if no pulse accumulator interrupts (use 0 duty)                               
4924   DEA6 CE FF 37                ldx     #t_bGauge               ; x points to boost gauge table                              
4925   DEA9 96 E1                   ldaa    airVolT                 ; a = airVolT                                
4926   DEAB~            #ifdef batteryGauge
4927   DEAB~                        jsr     battGauge               ;
4928   DEAB             #else
4929   DEAB BD EB 41                jsr     interp32                ; b = t_bGauge(airVolT) (max value is $18...)                                
4930   DEAE             #endif
4931   DEAE                         ;-------------------------------------------------
4932   DEAE                         ; Update bGaugeODuty with $18-dutyCycle (min of 0)
4933   DEAE                         ; bGaugeODuty is the off-duty cycle... 
4934   DEAE                         ;-------------------------------------------------
4935   DEAE 86 18       L1299       ldaa    #$18                    ; a = $18                              
4936   DEB0 10                      sba                             ; a = $18-t_bGauge(airVolT)                              
4937   DEB1 24 01                   bcc     L1300                   ; Branch if no underflow                              
4938   DEB3 4F                      clra                            ; underflow, use min                             
4939   DEB4 B7 01 7F    L1300       staa    bGaugeODuty             ; Update boost gauge off-duty cycle                                  
4940   DEB7             
4941   DEB7                         ;----------------------------------------------
4942   DEB7                         ; Section to update the fuel pressure solenoid
4943   DEB7                         ;----------------------------------------------
4944   DEB7                         ;-----------------------------------------------------
4945   DEB7                         ; First check if there are any reason to activate it
4946   DEB7                         ;-----------------------------------------------------
4947   DEB7 D6 F9                   ldab    fpsBcsFlags              ; b = old fpsBcsFlags, used later...                         
4948   DEB9 02 F9 FB                andm    fpsBcsFlags, #$fb        ; Reset bit indicating solenoid was just deactivated will be updated below if required                          
4949   DEBC 8F E6 11 1C             brclr   state1, #$11, L1302      ; branch if notRotating and startingToCrank clear   
4950   DEC0 02 F9 F7                andm    fpsBcsFlags, #$f7        ; engine is either notRotating or startingToCrank                               
4951   DEC3 8F E6 10 06             brclr   state1, #$10, L1301      ; Branch if notRotating clear (startingToCrank is set...)                           
4952   DEC7 87 FB 04 39             brset   obdActCmd, #$04, L1306   ; branch to activate solenoid if OBD command activated
4953   DECB 20 3C                   bra     L1307                    ; No reason to activate it, branch to deactivate solenoid                         
4954   DECD             
4955   DECD                         ;-----------------------------------------------------------------
4956   DECD                         ; Engine is startingToCrank, check if we should set fpsBcsFlags.3 flag (vapor lock)
4957   DECD                         ; Basically set the flag when vapor lock conditions exists
4958   DECD                         ;-----------------------------------------------------------------
4959   DECD 96 D4       L1301       ldaa    iatChecked               ;                               
4960   DECF 81 9D                   cmpa    #$9d                     ;                         
4961   DED1 22 09                   bhi     L1302                    ; Branch if temperature(iatChecked) < 10degC                         
4962   DED3 96 D3                   ldaa    ectFiltered              ;                                
4963   DED5 81 27                   cmpa    #$27                     ; 72degC                         
4964   DED7 22 03                   bhi     L1302                    ; Branch if  temperature(ectFiltered) < 72degC                           
4965   DED9             
4966   DED9                         ;------------------------------------------------------------------------------------------
4967   DED9                         ; At this point engine is startingToCrank and temperature(iatChecked) >= 10degC 
4968   DED9                         ; and temperature(ectFiltered) >= 72degC, set flag indicating vapor lock conditions exist, NOT???
4969   DED9                         ;------------------------------------------------------------------------------------------
4970   DED9 03 F9 08                orm     fpsBcsFlags, #$08        ; Set flag indicating vapor lock conditions exist
4971   DEDC             
4972   DEDC                         ;--------------------------------------------------------------------
4973   DEDC                         ; Engine is running or notRotating or startingToCrank
4974   DEDC                         ; Check if we should reset vapor lock flag: 3 minutes after
4975   DEDC                         ; engine was started or if o2Fbk < $4d (meaning we are running rich)
4976   DEDC                         ;--------------------------------------------------------------------
4977   DEDC B6 01 40    L1302       ldaa    T0p5_crank1              ;                               
4978   DEDF 8B 5A                   adda    #$5a                     ;                         
4979   DEE1 24 06                   bcc     L1303                    ; branch to reset flag if engine stopped "startingToCrank" more than 180s ago (engine has been running for 3 minutes)
4980   DEE3 96 E9                   ldaa    o2Fbk                    ; a = o2Fbk                         
4981   DEE5 81 4D                   cmpa    #$4d                     ;                         
4982   DEE7 22 03                   bhi     L1304                    ; Dont reset if o2Fbk > $4d  (running lean???)                       
4983   DEE9 02 F9 F7    L1303       andm    fpsBcsFlags, #$f7        ; Reset vappor lock flag
4984   DEEC                                         
4985   DEEC                         ;---------------------------------------------
4986   DEEC                         ; Check whether we have vapor lock conditions
4987   DEEC                         ;---------------------------------------------
4988   DEEC 87 F9 08 09 L1304       brset   fpsBcsFlags, #$08, L1305 ; Branch if vapor lock flag is set
4989   DEF0                                       
4990   DEF0                         ;---------------------------------------------------------------------
4991   DEF0                         ; Vapor lock flag is not set, at this point b = old fpsBcsFlags
4992   DEF0                         ; Check if solenoid deactivation is just happening now and 
4993   DEF0                         ; set flag to indicate so
4994   DEF0                         ;---------------------------------------------------------------------
4995   DEF0 C5 08                   bitb    #$08                     ;                         
4996   DEF2 27 15                   beq     L1307                    ; Branch to reset solenoid if bit was also 0 on previous iteration                         
4997   DEF4 03 F9 04                orm     fpsBcsFlags, #$04        ; Set flag indicating solenoid was just deactivated                            
4998   DEF7 20 10                   bra     L1307                    ; Branch to deactivate it                         
4999   DEF9             
5000   DEF9                         ;----------------------------------------------
5001   DEF9                         ; Vapor lock flag is set, check additional 
5002   DEF9                         ; conditions before activating solenoid 
5003   DEF9                         ;----------------------------------------------
5004   DEF9 B6 01 1A    L1305       ldaa    T40_crank                  ;                              
5005   DEFC 8B 50                   adda    #$50                       ;                         
5006   DEFE 25 04                   bcs     L1306                      ; branch to activate solenoid if engine stopped "startingToCrank" less than 2s ago                              
5007   DF00 87 E8 01 05             brset   closedLpFlags, #$01, L1307 ; Branch to deactivate solenoid if the ECU has determined that we should be using closed loop mode (or getting close to it)                          
5008   DF04             
5009   DF04                         ;-------------------------------------
5010   DF04                         ; Activate the fuel pressure solenoid
5011   DF04                         ;-------------------------------------
5012   DF04 02 16 EF    L1306       andm    port5, #$ef             ; Activate the fuel pressure solenoid                                 
5013   DF07 20 03                   bra     L1309                                                 
5014   DF09             
5015   DF09                         ;----------------------------------------
5016   DF09                         ; Deactivate the fuel pressure solenoid
5017   DF09                         ;----------------------------------------
5018   DF09 03 16 10    L1307       orm     port5, #$10             ; Deactivate the fuel pressure solenoid                                 
5019   DF0C 39          L1309       rts                                                          
5020   DF0D             
5021   DF0D             
5022   DF0D             
5023   DF0D             ;******************************************************************
5024   DF0D             ;
5025   DF0D             ;
5026   DF0D             ; Second subroutine
5027   DF0D             ;
5028   DF0D             ;
5029   DF0D             ;******************************************************************
5030   DF0D                         ;--------------------------------------------------
5031   DF0D                         ; Build port3Snap1 from port3Snap0 using a 
5032   DF0D                         ; 
5033   DF0D                         ; Set port3Snap1.2 if vssCnt1!=0, reset otherwise
5034   DF0D                         ;--------------------------------------------------
5035   DF0D 96 D7       subroutine2 ldaa    port3Snap0              ; start with a = port3Snap1 = port3Snap0                                  
5036   DF0F 84 FB                   anda    #$fb                    ; reset 00000100                             
5037   DF11 D6 C4                   ldab    vssCnt1                 ; b = vssCnt1                                
5038   DF13 27 02                   beq     L1311                   ;                               
5039   DF15 8A 04                   oraa    #$04                    ; Set flag
5040   DF17             
5041   DF17                         ;---------------------------------------------------------------
5042   DF17                         ; Reset iscFlags0.6 if key is in start and T40_noPower not expired?????? 
5043   DF17                         ; (meaning engine is cranking and battery not KO? 
5044   DF17                         ;---------------------------------------------------------------
5045   DF17 85 40       L1311       bita    #$40                    ;                              
5046   DF19 26 08                   bne     L1312                   ; Bail if key is not is start                              
5047   DF1B 7D 01 24                tst     T40_noPower             ; Key in start                               
5048   DF1E 27 03                   beq     L1312                   ; Bail if timer expired                              
5049   DF20 02 4B BF                andm    iscFlags0, #$bf         ; Key in start and timer not expired, reset max calibration flag 0100 0000
5050   DF23             
5051   DF23                         ;----------------------------------------------------------
5052   DF23                         ; Re-init T40_noPower at 5 (0.125s) if ECU still has power
5053   DF23                         ;----------------------------------------------------------
5054   DF23 85 02       L1312       bita    #$02                    ;                              
5055   DF25 26 05                   bne     L1313                   ; Branch if IG1 at 0V (No more power, ECU about to turn off?)                              
5056   DF27 C6 05                   ldab    #$05                    ; ECU not about to turn off, restart timer                             
5057   DF29 F7 01 24                stab    T40_noPower             ;                              
5058   DF2C             
5059   DF2C                         ;-------------------------------------------
5060   DF2C                         ; Move old port3Snap1 to oldP3Snap1 and 
5061   DF2C                         ; update port3Snap1 with new value
5062   DF2C                         ;-------------------------------------------
5063   DF2C D6 F1       L1313       ldab    port3Snap1              ; b = old port3Snap1                              
5064   DF2E 97 F1                   staa    port3Snap1              ; port3Snap1 = new port3Snap1                              
5065   DF30 D7 F2                   stab    oldP3Snap1              ; oldP3Snap1 = old port3Snap1                               
5066   DF32             
5067   DF32                         ;-------------------
5068   DF32                         ; Update iscStepMax 
5069   DF32                         ;-------------------
5070   DF32 86 78                   ldaa    #$78                    ; I believe this is the max iscStepCurr value (120 decimal)                           
5071   DF34 97 F0                   staa    iscStepMax              ; iscStepMax = max possible value?                                
5072   DF36 01                      nop                             ;                             
5073   DF37 01                      nop                             ;                             
5074   DF38 01                      nop                             ;
5075   DF39                                                                                 
5076   DF39                         ;---------------------------------------------------------------
5077   DF39                         ; Decrement T40s_iscStable at 40Hz if iscStepCurr = iscStepTarg   
5078   DF39                         ;---------------------------------------------------------------
5079   DF39 96 FD                   ldaa    iscStepTarg             ;                                 
5080   DF3B 91 49                   cmpa    iscStepCurr             ;                                
5081   DF3D 26 06                   bne     L1314                   ; Branch if iscStepCurr != iscStepTarg                             
5082   DF3F CE 01 62                ldx     #T40s_iscStable         ;                                   
5083   DF42 BD EB F1                jsr     decX40Hz                ; Decrement T40s_iscStable at 40Hz 
5084   DF45             
5085   DF45                         ;-----------------------------------------------------
5086   DF45                         ; If engine is notRotating, re-init some ISC variables
5087   DF45                         ;-----------------------------------------------------
5088   DF45 8F E6 10 0F L1314       brclr   state1, #$10, L1315     ; Bail if notRotating clear
5089   DF49 BD E5 06                jsr     iscYnInit               ; Init isc variables
5090   DF4C 7F 01 63                clr     iscStStall              ;                              
5091   DF4F             #ifdef E932
5092   DF4F 7F 01 6B                clr     iscStBaseAcAdj          ;                              
5093   DF52             #endif
5094   DF52 02 F4 5F                andm    iscFlags1, #$5f         ; reset flags used when engine rotating or running, 1010 0000                                
5095   DF55 03 F4 01                orm     iscFlags1, #$01         ; set flag (flag is only 0 when key in start and iscStTargSpec = iscStepCurr)
5096   DF58             
5097   DF58                         ;-----------------------------------------------------
5098   DF58                         ; Update isc stable timer if  power 
5099   DF58                         ; steering flag changed since last time
5100   DF58                         ;-----------------------------------------------------
5101   DF58 96 F1       L1315       ldaa    port3Snap1               ;                                  
5102   DF5A 98 F2                   eora    oldP3Snap1               ;                                  
5103   DF5C 85 08                   bita    #$08                     ;                            
5104   DF5E 27 05                   beq     L1316                    ; Branch if port3Snap1.3 did not change value since last time                             
5105   DF60 C6 50                   ldab    #$50                     ;                            
5106   DF62 BD E4 AD                jsr     updIscStableTimer        ;                                 
5107   DF65             
5108   DF65                         ;-----------------------------------------------------
5109   DF65                         ; Update isc stable timer if A/C state
5110   DF65                         ; changed since last time 
5111   DF65                         ;-----------------------------------------------------
5112   DF65 85 10       L1316       bita    #$10                     ;                            
5113   DF67 27 05                   beq     L1317                    ; Branch if port3Snap1.4 did not change value since last time                             
5114   DF69 C6 50                   ldab    #$50                     ;                            
5115   DF6B BD E4 AD                jsr     updIscStableTimer        ;                                 
5116   DF6E             L1317       .equ    $                        ;
5117   DF6E             
5118   DF6E                         ;-----------------------------------------------------
5119   DF6E                         ; Update isc stable timer if park/neutral
5120   DF6E                         ; changed since last time (E932)
5121   DF6E                         ;-----------------------------------------------------
5122   DF6E             #ifdef E932                                  
5123   DF6E 85 20                   bita    #$20                     ;                            
5124   DF70 27 0B                   beq     L1319                    ; Branch if port3Snap1.5 did not change value since last time                             
5125   DF72 C6 50                   ldab    #$50                     ;                            
5126   DF74 8F F1 20 02             brclr   port3Snap1, #$20, L1318  ; Makes no difference, $50 used anyway...
5127   DF78 C6 50                   ldab    #$50                     ;                            
5128   DF7A BD E4 AD    L1318       jsr     updIscStableTimer        ;                                 
5129   DF7D             #endif
5130   DF7D             
5131   DF7D                         ;-----------------------------------------------------
5132   DF7D                         ; Update isc stable timer if tpsDiffMax2 > $04
5133   DF7D                         ; i.e. gas pedal is moving...
5134   DF7D                         ;-----------------------------------------------------
5135   DF7D B6 01 4D    L1319       ldaa    tpsDiffMax2              ;                                   
5136   DF80 81 04                   cmpa    #$04                     ;                            
5137   DF82 25 05                   bcs     L1320                    ;                             
5138   DF84 C6 28                   ldab    #$28                     ;                            
5139   DF86 BD E4 AD                jsr     updIscStableTimer        ;                                 
5140   DF89             
5141   DF89                         ;----------------------------------------------------------------
5142   DF89                         ; Update isc stable timer if idle switch is off
5143   DF89                         ; Timer value is from table t_iscStableIdleSw
5144   DF89                         ; Timer will only start counting when idle switch is back on...
5145   DF89                         ;----------------------------------------------------------------
5146   DF89 96 F1       L1320       ldaa    port3Snap1              ;                                    
5147   DF8B 2B 1E                   bmi     L1323                   ; Bail if idle switch is ON                             
5148   DF8D DC DA                   ldd     rpm4                    ;                             
5149   DF8F 04                      lsrd                            ; d = rpm4/2                             
5150   DF90 D0 FE                   subb    idleSpdTarg             ;                              
5151   DF92 82 00                   sbca    #$00                    ; d = rpm4/2 - idleSpdTarg                            
5152   DF94 24 02                   bcc     L1321                   ; Branch if no overflow                              
5153   DF96 4F                      clra                            ;                             
5154   DF97 5F                      clrb                            ; Use min of d=0                             
5155   DF98 04          L1321       lsrd                            ;                             
5156   DF99 04                      lsrd                            ; d = (rpm4/2 - idleSpdTarg)/4                              
5157   DF9A 1C 00 A0                cmpd    #$00a0                  ;                               
5158   DF9D 25 02                   bcs     L1322                   ; Branch if (rpm4/2 - idleSpdTarg)/4 < $a0 (5000rpm)
5159   DF9F C6 A0                   ldab    #$a0                    ; Use max of $a0 (5000rpm)                            
5160   DFA1 17          L1322       tba                             ; a = (rpm4/2 - idleSpdTarg)/4                             
5161   DFA2 CE FE DF                ldx     #t_iscStableIdleSw      ;                               
5162   DFA5 BD EB 3E                jsr     interp16b               ; b = t_iscStableIdleSw((rpm4/2 - idleSpdTarg)/4)                                 
5163   DFA8 BD E4 AD                jsr     updIscStableTimer       ;                                  
5164   DFAB             
5165   DFAB                         ;---------------------------------------------------
5166   DFAB                         ; Update isc stable timer if engine is not runnning
5167   DFAB                         ; or if min or max isc calibration is ongoing or if  
5168   DFAB                         ; we have ignition problems
5169   DFAB                         ;---------------------------------------------------
5170   DFAB 87 E6 11 08 L1323       brset   state1, #$11, L1324        ; Branch to update if notRotating or startingToCrank
5171   DFAF 87 4B A0 04             brset   iscFlags0, #$a0, L1324     ; Branch to update if min or max calibration requested flag is set
5172   DFB3 8F 85 80 05             brclr   coilChkFlags, #$80, L1325  ; Bail if no problem found on ignition signal
5173   DFB7 C6 78       L1324       ldab    #$78                       ; 
5174   DFB9 BD E4 AD                jsr     updIscStableTimer          ; 
5175   DFBC             
5176   DFBC                         ;-----------------------------------------------------------------
5177   DFBC                         ; Update idleSpdInit = t_idleSpd(ect) or t_idleSpdDr(ect) (E932)
5178   DFBC                         ;-----------------------------------------------------------------
5179   DFBC             L1325       .equ    $
5180   DFBC~            #ifdef E931
5181   DFBC~                        ldx     #t_idleSpd               ;                                   
5182   DFBC~                        jsr     interpEct                ; b = t_idleSpd(ect)                                  
5183   DFBC             #else
5184   DFBC CE FE B1                ldx     #t_idleSpdDr             ;                                     
5185   DFBF 8F F1 20 03             brclr   port3Snap1, #$20, L1326  ;                                    
5186   DFC3 CE FE A9                ldx     #t_idleSpd               ;                                  
5187   DFC6 BD EB 2F    L1326       jsr     interpEct                ;                                 
5188   DFC9             #endif
5189   DFC9 F7 01 6C                stab    idleSpdInit              ; idleSpdInit = t_idleSpd(ect) or t_idleSpdDr(ect)                                   
5190   DFCC             
5191   DFCC                         ;-----------------------------------------------------------------
5192   DFCC                         ; Update idleSpdMin with 0 if A/C switch is on 
5193   DFCC                         ; or if AT is in drive or if T0p5_crCold timer expired 
5194   DFCC                         ;-----------------------------------------------------------------
5195   DFCC 5F                      clrb                             ; preload default value of 0                            
5196   DFCD 96 F1                   ldaa    port3Snap1               ;                                  
5197   DFCF 84 30                   anda    #$30                     ;                            
5198   DFD1 81 30                   cmpa    #$30                     ;                            
5199   DFD3 26 1A                   bne     L1328                    ; Branch to use default of 0 if A/C switch is on or if AT is in drive
5200   DFD5 B6 01 41                ldaa    T0p5_crCold              ;                              
5201   DFD8 27 15                   beq     L1328                    ; Branch to use default of 0 if T0p5_crCold timer expired                            
5202   DFDA             
5203   DFDA                         ;-----------------------------------------------
5204   DFDA                         ; A/C switch is off and AT is in not in drive 
5205   DFDA                         ; and  T0p5_crCold timer not expired
5206   DFDA                         ;
5207   DFDA                         ; Compute  idleSpdMin
5208   DFDA                         ;-----------------------------------------------
5209   DFDA 86 3C                   ldaa    #$3c                     ; a = $3c                            
5210   DFDC 97 57                   staa    temp1                    ; temp1 = $3c                            
5211   DFDE 86 13                   ldaa    #$13                     ; a = $13                            
5212   DFE0 87 F4 20 02             brset   iscFlags1, #$20, L1327   ; Branch if engine startingToCrank and temperature(iat) < 75degC
5213   DFE4~            #ifdef E931
5214   DFE4~                        ldaa    #$20                     ; Use higher value                           
5215   DFE4             #else
5216   DFE4 86 13                   ldaa    #$13                     ; Use same value                            
5217   DFE6             #endif
5218   DFE6 F6 01 41    L1327       ldab    T0p5_crCold              ; b = T0p5_crCold                              
5219   DFE9 3D                      mul                              ; d = ($13 or $20) * T0p5_crCold                           
5220   DFEA 15 57                   div     temp1                    ; b = ($13 or $20) * T0p5_crCold / $3c                            
5221   DFEC FB FE A9                addb    t_idleSpd                ; b = ($13 or $20) * T0p5_crCold / $3c + t_idleSpd(0)                                 
5222   DFEF F7 01 6D    L1328       stab    idleSpdMin               ; idleSpdMin = 0 or (t_idleSpd(0) + (0.32 0r 0.53) * T0p5_crCold)                             
5223   DFF2             
5224   DFF2                         ;----------------------------------------------------------------------------------
5225   DFF2                         ; Update idleSpdTarg from idleSpdInit and idleSpdMin and A/C park/neutral conditions
5226   DFF2                         ;----------------------------------------------------------------------------------
5227   DFF2 B6 01 6C                ldaa    idleSpdInit             ; a = idleSpdInit                              
5228   DFF5 87 F1 10 0C             brset   port3Snap1, #$10, L1331 ; Branch if A/C switch is off?                               
5229   DFF9             #ifdef E932
5230   DFF9 C6 53                   ldab    #$53                    ; 648rpm                             
5231   DFFB 8F F1 20 02             brclr   port3Snap1, #$20, L1330 ; Branch if park/neutral???                                   
5232   DFFF             #endif
5233   DFFF C6 6D                   ldab    #$6d                    ; 852rpm                            
5234   E001 11          L1330       cba                             ;                             
5235   E002 24 01                   bcc     L1331                   ; Branch if idleSpdInit >= $6d                              
5236   E004 17                      tba                             ; Use min of a = $6d 
5237   E005                                                      
5238   E005 B1 01 6D    L1331       cmpa    idleSpdMin              ;                              
5239   E008 24 03                   bcc     L1332                   ; Branch if idleSpdInit >= idleSpdMin                            
5240   E00A B6 01 6D                ldaa    idleSpdMin              ; Use min of idleSpdMin                             
5241   E00D 97 FE       L1332       staa    idleSpdTarg             ; idleSpdTarg = ...                             
5242   E00F             
5243   E00F             
5244   E00F~            #ifdef E931
5245   E00F~                        ;-------------------------------------------
5246   E00F~                        ; Update iscStBase for E931
5247   E00F~                        ; iscStBase = t_iscStEct0(ect)
5248   E00F~                        ;-------------------------------------------
5249   E00F~                        ldx     #t_iscStEct0            ;                                     
5250   E00F~                        jsr     interpEct               ;                                   
5251   E00F~                        stab    iscStBase               ; iscStBase = t_iscStEct0(ect)                              
5252   E00F             #else       
5253   E00F                         ;------------------------------------------------------------------
5254   E00F                         ; Update iscStBase for E932
5255   E00F                         ; Choose a different table if transmission is engaged (e.g. drive)
5256   E00F                         ;
5257   E00F                         ; iscStBase = t_iscStEct1(ect) or t_iscStEct0(ect) 
5258   E00F                         ;------------------------------------------------------------------
5259   E00F CE FE C1                ldx     #t_iscStEct1            ;                               
5260   E012 8F F1 20 03             brclr   port3Snap1, #$20, L1334 ; Branch if park/neutral                                    
5261   E016 CE FE B9                ldx     #t_iscStEct0            ;                                    
5262   E019 BD EB 2F    L1334       jsr     interpEct               ;                                  
5263   E01C F7 01 67                stab    iscStBase               ; iscStBase = t_iscStEct0(ect) or t_iscStEct1(ect)                               
5264   E01F             
5265   E01F                         ;-------------------------------------------------------------------
5266   E01F                         ; For E932, decrement iscStBaseAcAdj by 1 (min of 0) at ~2.2Hz 
5267   E01F                         ;-------------------------------------------------------------------
5268   E01F B6 01 2C                ldaa    T40_21                  ; a = T40_21                              
5269   E022 26 10                   bne     L1336                   ; Branch if timer not expired                             
5270   E024 86 12                   ldaa    #$12                    ; Timer expired, re-init to 0.45sec                            
5271   E026 B7 01 2C                staa    T40_21                  ; T40_21 = 0.45sec                              
5272   E029 B6 01 6B                ldaa    iscStBaseAcAdj          ; a = iscStBaseAcAdj                             
5273   E02C 80 01                   suba    #$01                    ; a = iscStBaseAcAdj - 1                            
5274   E02E 24 01                   bcc     L1335                   ; Branch if no underflow                              
5275   E030 4F                      clra                            ; Underflow, use min of 0                            
5276   E031 B7 01 6B    L1335       staa    iscStBaseAcAdj          ; update iscStBaseAcAdj                             
5277   E034             #endif
5278   E034             
5279   E034                         ;---------------------------------------------------
5280   E034                         ; Compute iscStBaseAc, basic iscStep corrected for 
5281   E034                         ; additional A/C and transmission load
5282   E034                         ;---------------------------------------------------
5283   E034 4F          L1336       clra                            ; preload default value of offset = 0                             
5284   E035 87 F1 10 28             brset   port3Snap1, #$10, L1342 ; Bail to use offset of 0 if A/C switch off                                     
5285   E039 86 1C                   ldaa    #$1c                    ; A/C is on, offset = a = $1c                            
5286   E03B C6 37                   ldab    #$37                    ; minValue = b = $37                            
5287   E03D             #ifdef E932
5288   E03D 87 F1 20 04             brset   port3Snap1, #$20, L1337 ; Branch if park/neutral                                   
5289   E041 86 0A                   ldaa    #$0a                    ; AT in drive, offset = $0a                           
5290   E043 C6 25                   ldab    #$25                    ; minValue = $25                            
5291   E045             #endif
5292   E045 BB 01 67    L1337       adda    iscStBase               ; a = t_iscStEct0(ect) + offset                              
5293   E048 24 02                   bcc     L1338                   ; Branch if no overflow                             
5294   E04A 86 FF                   ldaa    #$ff                    ; Use max of $ff                            
5295   E04C 11          L1338       cba                             ;                             
5296   E04D 24 01                   bcc     L1339                   ; Branch if t_iscStEct0(ect) + offset >= minValue                              
5297   E04F 17                      tba                             ; Use minValue                             
5298   E050             L1339       .equ    $
5299   E050             #ifdef E932
5300   E050 8F F1 20 05             brclr   port3Snap1, #$20, L1341 ; Branch if AT not in park/neutral
5301   E054 B7 01 6B                staa    iscStBaseAcAdj          ; AT in park, iscStBaseAcAdj = t_iscStEct0(ect) + offset                               
5302   E057 20 08                   bra     L1342                   ;                              
5303   E059 B1 01 6B    L1341       cmpa    iscStBaseAcAdj          ; AT in drive, update iscStBaseAc with minimum of iscStBaseAcAdj                             
5304   E05C 24 03                   bcc     L1342                   ;                              
5305   E05E B6 01 6B                ldaa    iscStBaseAcAdj          ;                              
5306   E061             #endif
5307   E061 B7 01 68    L1342       staa    iscStBaseAc             ; For E931, iscStBaseAc = min(t_iscStEct0(ect) + offset, minValue)
5308   E064             
5309   E064                                                           
5310   E064                         ;------------------------------------------------------------------
5311   E064                         ; Init iscStStartUsed and iscStStartMaster as long as we are 
5312   E064                         ; startingToCrank. These values are used at engine startup
5313   E064                         ;------------------------------------------------------------------
5314   E064 8F E6 01 0C             brclr   state1, #$01, L1343     ; Bail if startingToCrank clear
5315   E068 CE FE 99                ldx     #L2023                  ; Engine is startingToCrank                               
5316   E06B BD EB 2F                jsr     interpEct               ; b = L2023(ect)                                 
5317   E06E F7 01 64                stab    iscStStartUsed          ; iscStStartUsed = L2023(ect)                               
5318   E071 F7 01 8D                stab    iscStStartMaster        ; iscStStartMaster = L2023(ect)                             
5319   E074             
5320   E074                         ;----------------------------------------------------------------
5321   E074                         ; Section to update iscStStartUsed, iscStStartMaster
5322   E074                         ; and eventually iscYn after the engine is started
5323   E074                         ;
5324   E074                         ; learning variable iscYn is only updated after a certain delay 
5325   E074                         ; has passed since the engine was started. At that point we have 
5326   E074                         ; a good idea of how far we are from the ideal isc step we 
5327   E074                         ; should be using...
5328   E074                         ;----------------------------------------------------------------
5329   E074                         ;------------------------------------------
5330   E074                         ; First check if basic conditions are met 
5331   E074                         ;------------------------------------------
5332   E074 87 E6 11 37 L1343       brset   state1, #$11, L1349     ; bail if notRotating or startingToCrank 
5333   E078 B6 01 8D                ldaa    iscStStartMaster        ; a = iscStStartMaster 
5334   E07B 27 32                   beq     L1349                   ; Bail if iscStStartMaster = 0 (we already updated iscYn once)                             
5335   E07D B6 01 29                ldaa    T40_iscStart            ;                                
5336   E080 26 21                   bne     L1347                   ; Branch if T40_iscStart no yet expired                               
5337   E082             
5338   E082                         ;---------------------------------------------------------------
5339   E082                         ; Engine is running, iscStStartMaster!=0 and T40_iscStart is expired
5340   E082                         ;---------------------------------------------------------------
5341   E082                         ;--------------------------------------------------------------------------
5342   E082                         ; Decrement iscStStartMaster by 1 (min of 0) at around 6Hz (3Hz if cold)
5343   E082                         ;
5344   E082                         ; T40_iscStart is initialized with values from L2024(ect) on
5345   E082                         ; every timer expiry, if L2024(ect)=7 then freqency 
5346   E082                         ; will be around 6Hz... In colder temperature, iscStStartMaster will
5347   E082                         ; be decremented at a slower rate, e.g 3Hz
5348   E082                         ;--------------------------------------------------------------------------
5349   E082 CE FE A1                ldx     #L2024                  ; x points to L2024                              
5350   E085 BD EB 2F                jsr     interpEct               ; b = L2024(ect)                                 
5351   E088 F7 01 29                stab    T40_iscStart            ; T40_iscStart = L2024(ect)                                
5352   E08B 7A 01 8D                dec     iscStStartMaster        ; iscStStartMaster = iscStStartMaster - 1                              
5353   E08E 26 13                   bne     L1347                   ; Branch if iscStStartMaster!=0                             
5354   E090             
5355   E090                         ;------------------------------------------------------------------------
5356   E090                         ; iscStStartMaster reached 0, update iscYn = old iscYn + iscStStartUsed + L2023(ect)
5357   E090                         ; and reset iscStStartUsed since we are now finished updating iscYn
5358   E090                         ; i.e. both iscStStartMaster and iscStStartUsed are now 0
5359   E090                         ;
5360   E090                         ; Basically, update the isc learning variables with how much isc offset
5361   E090                         ; was required to get the isc step stable upon engine startup. If isc
5362   E090                         ; was not stable then iscStStartUsed=0 and we didn't learn anything...
5363   E090                         ;------------------------------------------------------------------------
5364   E090 BD E4 DD                jsr     iscPointers             ;                                 
5365   E093 B6 01 64                ldaa    iscStStartUsed          ; a = iscStStartUsed
5366   E096 AB 80                   adda    $00,y                   ; a = iscStStartUsed + iscYn, y = y+1                              
5367   E098 CD 09                   decy                            ; y = y - 1                            
5368   E09A 24 02                   bcc     L1346                   ; Branch if no overflow                             
5369   E09C 86 FF                   ldaa    #$ff                    ; Use max of $ff                            
5370   E09E A7 80       L1346       staa    $00,y                   ; iscYn = old iscYn + iscStStartUsed + L2023(ect)
5371   E0A0 7F 01 64                clr     iscStStartUsed          ; iscStStartUsed = 0 since we are now finished updating iscYn
5372   E0A3                                                      
5373   E0A3                         ;-------------------------------------------------
5374   E0A3                         ; Check if we should re-init isc Yn variables???
5375   E0A3                         ;-------------------------------------------------
5376   E0A3 B6 01 62    L1347       ldaa    T40s_iscStable           ;                                  
5377   E0A6 26 04                   bne     L1348                    ; Branch to re-init if T40s_iscStable not expired, i.e. isc is not yet stable                            
5378   E0A8 87 F3 10 09             brset   iscLrnFlags, #$10, L1350 ; Branch if conditions are good to update isc learning variables
5379   E0AC             
5380   E0AC                         ;-------------------------------------------------
5381   E0AC                         ; At this point, isc is not yet stable or 
5382   E0AC                         ; conditions are not good to update isc variables
5383   E0AC                         ;
5384   E0AC                         ; Re-init isc Yn variables 
5385   E0AC                         ;-------------------------------------------------
5386   E0AC BD E5 06    L1348       jsr     iscYnInit               ;                                     
5387   E0AF             
5388   E0AF                         ;----------------------------------------------------------------------------
5389   E0AF                         ; At this point isc not yet stable or engine notRotating or startingToCrank
5390   E0AF                         ; iscStStartUsed = iscStStartMaster 
5391   E0AF                         ; 
5392   E0AF                         ; Basically synch the isc step currently in use with the master value
5393   E0AF                         ;----------------------------------------------------------------------------
5394   E0AF B6 01 8D    L1349       ldaa    iscStStartMaster        ; a = iscStStartMaster                              
5395   E0B2 B7 01 64                staa    iscStStartUsed          ; iscStStartUsed = iscStStartMaster                             
5396   E0B5             
5397   E0B5                         ;-----------------------------------------------------------------------
5398   E0B5                         ; Decrement iscStStall by 3 (min of 0) at 20Hz (T40_stall looping at 2?)???
5399   E0B5                         ;-----------------------------------------------------------------------
5400   E0B5 B6 01 63    L1350       ldaa    iscStStall              ; a = iscStStall                             
5401   E0B8 27 21                   beq     L1355                   ; Bail if iscStStall already at 0                              
5402   E0BA F6 01 27                ldab    T40_stall                  ;                               
5403   E0BD 26 08                   bne     L1352                   ; Branch if T40_stall not expired                              
5404   E0BF 80 03                   suba    #$03                    ; a = iscStStall-3                            
5405   E0C1 24 01                   bcc     L1351                   ; Branch if no underflow                            
5406   E0C3 4F                      clra                            ; use min of 0                           
5407   E0C4 B7 01 63    L1351       staa    iscStStall              ; iscStStall = max(iscStStall-3, 0)                            
5408   E0C7 C6 02       L1352       ldab    #$02                    ; b = $02                           
5409   E0C9             #ifdef E932
5410   E0C9 87 F1 20 02             brset   port3Snap1, #$20, L1353 ; Branch if park/neutral                                    
5411   E0CD C6 02                   ldab    #$02                    ; Use same value anyway...                             
5412   E0CF             #endif
5413   E0CF B6 01 27    L1353       ldaa    T40_stall                  ; a = T40_stall                              
5414   E0D2 27 04                   beq     L1354                   ; Branch if T40_stall expired                             
5415   E0D4 11                      cba                             ;                              
5416   E0D5 24 01                   bcc     L1354                   ; Branch to use 2 if T40_stall >= 2                              
5417   E0D7 16                      tab                             ; Use b = T40_stall when T40_stall < 2                           
5418   E0D8 F7 01 27    L1354       stab    T40_stall                  ; T40_stall = min(T40_stall, 2)                              
5419   E0DB             
5420   E0DB                         ;--------------------------------------------
5421   E0DB                         ; Re-init T40_revving to 0.5sec if  
5422   E0DB                         ; tpsRaw < 86% or airVol >= $3a  ???
5423   E0DB                         ;
5424   E0DB                         ; T40_revving will start counting when tpsRaw>86%
5425   E0DB                         ; and airVol < $3a???? 
5426   E0DB                         ;--------------------------------------------
5427   E0DB 96 D2       L1355       ldaa    tpsRaw                  ; a = tpsRaw                              
5428   E0DD 81 DC                   cmpa    #$dc                    ;                             
5429   E0DF 25 06                   bcs     L1356                   ; Branch to re-init if tpsRaw < 86%                             
5430   E0E1 96 E0                   ldaa    airVol                  ; a = airVol                              
5431   E0E3 81 3A                   cmpa    #$3a                    ;                             
5432   E0E5 25 05                   bcs     L1357                   ; Branch if airVol < $3a                             
5433   E0E7 86 14       L1356       ldaa    #$14                    ; 0.5sec                            
5434   E0E9 B7 01 25                staa    T40_revving             ; Re-init T40_revving to 0.5sec                              
5435   E0EC             
5436   E0EC                         ;-------------------------------------------------
5437   E0EC                         ; Set iscFlags1.7 flag if T40_revving is expired
5438   E0EC                         ;
5439   E0EC                         ; Basically, this flag is set when tps has been 
5440   E0EC                         ; high and airVol low for more than 0.5sec 
5441   E0EC                         ;-------------------------------------------------
5442   E0EC 02 F4 7F    L1357       andm    iscFlags1, #$7f         ; Assume flag is 0                               
5443   E0EF B6 01 25                ldaa    T40_revving             ;                               
5444   E0F2 26 03                   bne     L1358                   ; Branch if T40_revving not expired                               
5445   E0F4 03 F4 80                orm     iscFlags1, #$80         ; T40_revving expired, set flag                                
5446   E0F7             
5447   E0F7                         ;---------------------------------------------------------
5448   E0F7                         ; Section to update iscStStall as long as idle switch 
5449   E0F7                         ; is off and rpm8>=500 and iscFlags1.7 = 0 (set to 1 when 
5450   E0F7                         ; tps has been high and airVol low for more than 0.5sec)
5451   E0F7                         ;
5452   E0F7                         ; iscStStall will therefore be "stuck" to the value
5453   E0F7                         ; calculated when all these conditions were met the last 
5454   E0F7                         ; time. Basically says where we are coming from when 
5455   E0F7                         ; the throttle plate closes (likeliness of stalling the 
5456   E0F7                         ; engine...)??
5457   E0F7                         ;---------------------------------------------------------
5458   E0F7                         ;------------------------------
5459   E0F7                         ; First check those conditions
5460   E0F7                         ;------------------------------
5461   E0F7 96 F1       L1358       ldaa    port3Snap1              ;                                   
5462   E0F9 2B 37                   bmi     L1362                   ; Bail if idle position switch is on                             
5463   E0FB 96 F4                   ldaa    iscFlags1               ;                              
5464   E0FD 2B 33                   bmi     L1362                   ; Bail if  tps has been high and airVol low for more than 0.5sec
5465   E0FF 96 DC                   ldaa    rpm8                    ;                             
5466   E101 81 40                   cmpa    #$40                    ; 500rpm                             
5467   E103 25 2D                   bcs     L1362                   ; Bail if rpm8 < 500                             
5468   E105             
5469   E105                         ;------------------------------------------------
5470   E105                         ; Set flag, not directly related to calculation
5471   E105                         ;------------------------------------------------
5472   E105 03 F3 20                orm     iscLrnFlags, #$20       ; 
5473   E108             
5474   E108                         ;---------------------------------------------------------------
5475   E108                         ; Compute conditionned tps and store in temp2 for 
5476   E108                         ; table interpolation below
5477   E108                         ; condTps (with range of $00 to $a0) = 
5478   E108                         ;       2* max(min(tpsRaw,$ba)-$1a,0)      if tpsRaw <= 23%
5479   E108                         ;       max(min(tpsRaw,$ba)-$1a,0) + $20   if tpsRaw >  23%
5480   E108                         ;---------------------------------------------------------------
5481   E108 D6 D2                   ldab    tpsRaw                  ;                               
5482   E10A CE BA 1A                ldx     #$ba1a                  ;                               
5483   E10D BD EB B9                jsr     clipOffset              ; b = max(min(tpsRaw,$ba)-$1a,0)-> returns b = $00 to $a0  (tpsRaw 10% to 73%)                                    
5484   E110 C1 20                   cmpb    #$20                    ;                              
5485   E112 22 03                   bhi     L1359                   ; Branch if max(min(tpsRaw,$ba)-$1a,0) > $20 (tpsRaw>23%)                               
5486   E114 58                      aslb                            ; b =  2* max(min(tpsRaw,$ba)-$1a,0)                              
5487   E115 20 02                   bra     L1360                   ;                              
5488   E117 CB 20       L1359       addb    #$20                    ; b = max(min(tpsRaw,$ba)-$1a,0) + $20                             
5489   E119 D7 58       L1360       stab    temp2                   ; temp2 = condTps                             
5490   E11B             
5491   E11B                         ;--------------------------------------------------------------
5492   E11B                         ; Update iscStStall =  max(old iscStStall, t_iscStStall(condTps)) 
5493   E11B                         ;--------------------------------------------------------------
5494   E11B CE FE C9                ldx     #t_iscStStall           ; x points to t_iscStStall                               
5495   E11E             #ifdef E932
5496   E11E 87 F1 20 03             brset   port3Snap1, #$20, L1361 ; Branch if park/neutral                                    
5497   E122 CE FE D0                ldx     #L2030                  ; x points to L2030 for E932                               
5498   E125             #endif
5499   E125 96 58       L1361       ldaa    temp2                   ; a = condTps                             
5500   E127 BD EB 41                jsr     interp32                ; b = t_iscStStall(condTps)                                 
5501   E12A F1 01 63                cmpb    iscStStall              ;                              
5502   E12D 25 03                   bcs     L1362                   ; Branch if t_iscStStall(condTps) < iscStStall                             
5503   E12F F7 01 63                stab    iscStStall              ; iscStStall =  max(old iscStStall, t_iscStStall(condTps))
5504   E132                                                       
5505   E132                         ;--------------------------------------------------------
5506   E132                         ; If idle switch if off, 
5507   E132                         ; subtract (iscStepTarg - iscStepCurr) from iscStStall 
5508   E132                         ;
5509   E132                         ; Basically reduce iscStStall if the current isc step is
5510   E132                         ; lower than the target. Reduce it by the same amount...
5511   E132                         ;--------------------------------------------------------
5512   E132 96 F1       L1362       ldaa    port3Snap1              ; a = port3Snap1                                  
5513   E134 2A 15                   bpl     L1365                   ; Bail if idle switch is on                              
5514   E136 98 F2                   eora    oldP3Snap1              ;                                   
5515   E138 2A 11                   bpl     L1365                   ; Bail if it changed in that split second?????? (Am I missing something??? maybe they changed their mind...)                              
5516   E13A             
5517   E13A D6 FD                   ldab    iscStepTarg             ; b = iscStepTarg                                 
5518   E13C D0 49                   subb    iscStepCurr             ; b = iscStepTarg - iscStepCurr                                
5519   E13E 24 01                   bcc     L1363                   ; Branch if result positive                             
5520   E140 5F                      clrb                            ; Use min of 0                            
5521   E141 B6 01 63    L1363       ldaa    iscStStall              ; a = iscStStall                              
5522   E144 10                      sba                             ; a = iscStStall - (iscStepTarg - iscStepCurr)                            
5523   E145 24 01                   bcc     L1364                   ; Branch if no underflow                             
5524   E147 4F                      clra                            ; Use min of 0                            
5525   E148 B7 01 63    L1364       staa    iscStStall              ; iscStStall =  iscStStall - (iscStepTarg - iscStepCurr) 
5526   E14B                                                             
5527   E14B                         ;----------------------------------
5528   E14B                         ; Update  iscStBarOff
5529   E14B                         ;----------------------------------
5530   E14B B6 01 52    L1365       ldaa    baroCond                ; a = baroCond                                  
5531   E14E CE FE EE                ldx     #t_iscStBaro            ;                                     
5532   E151 BD EB 41                jsr     interp32                ; b = t_iscStBaro(baroCond)                                
5533   E154 F7 01 6A                stab    iscStBarOff             ; iscStBarOff = t_iscStBaro(baroCond)
5534   E157                                                                        
5535   E157                         ;--------------------------------------------
5536   E157                         ; Reset T0p5_crCold to 0 if notRotating
5537   E157                         ; or if T0p5_crCold >= $3c (not possible???)
5538   E157                         ;--------------------------------------------
5539   E157 87 E6 10 07             brset   state1, #$10, L1367     ; Branch to reset T0p5_crCold if notRotating
5540   E15B 86 3C                   ldaa    #$3c                    ;                             
5541   E15D B1 01 41                cmpa    T0p5_crCold             ;                                    
5542   E160 24 03                   bcc     L1368                   ; Branch if T0p5_crCold <= $3c                              
5543   E162 7F 01 41    L1367       clr     T0p5_crCold             ; reset T0p5_crCold to 0                              
5544   E165             
5545   E165                         ;---------------------------------------
5546   E165                         ; Update T0p5_crCold to $00 or $3c 
5547   E165                         ; and iscFlags1.1 flag when startingToCrank
5548   E165                         ;---------------------------------------
5549   E165 8F E6 01 18 L1368       brclr   state1, #$01, L1370     ; Bail if startingToCrank clear
5550   E169 5F                      clrb                            ; preload b=0                            
5551   E16A 96 D3                   ldaa    ectFiltered             ;                                    
5552   E16C 81 1B                   cmpa    #$1b                    ; 88degC                               
5553   E16E 24 02                   bcc     L1369                   ; Branch if temperature(ectFiltered) <= 88degC                              
5554   E170 C6 3C                   ldab    #$3c                    ; b= $3c                             
5555   E172 F7 01 41    L1369       stab    T0p5_crCold             ; T0p5_crCold = 0 or $3c                                
5556   E175 02 F4 DF                andm    iscFlags1, #$df         ; Assume we reset bit                                
5557   E178 96 D4                   ldaa    iatChecked              ;                                   
5558   E17A 81 29                   cmpa    #$29                    ; 75degC                             
5559   E17C 25 03                   bcs     L1370                   ; Branch if temperature(iat) > 75degC
5560   E17E 03 F4 20                orm     iscFlags1, #$20         ; Set flag                                
5561   E181             
5562   E181                         ;-------------------------------------------------------------
5563   E181                         ; Update iscStBaseCSt if T0p5_crCold not expired, else use iscStBaseCSt = 0
5564   E181                         ;
5565   E181                         ;      iscStBaseCSt =  (0 or $1e or $0f) * T0p5_crCold / $3c +  t_iscStEct0
5566   E181                         ;
5567   E181                         ; iscStBaseCSt is basically the iscStep when a cold engine 
5568   E181                         ; is being started, starts with a high value and then is 
5569   E181                         ; decreased (through T0p5_crCold) towards normal  isc step 
5570   E181                         ; over a period of 120sec
5571   E181                         ;-------------------------------------------------------------
5572   E181 5F          L1370       clrb                            ; preload b = 0                            
5573   E182 B6 01 41                ldaa    T0p5_crCold             ;                                    
5574   E185 27 15                   beq     L1372                   ; Bail to store 0 if T0p5_crCold expired                              
5575   E187 86 3C                   ldaa    #$3c                    ;                             
5576   E189 97 57                   staa    temp1                   ; temp1 = $3c                               
5577   E18B~            #ifdef E931
5578   E18B~                        ldaa    #$1e                    ; assume low iat, high value...a = $1e                            
5579   E18B             #else
5580   E18B 86 19                   ldaa    #$19                    ;                             
5581   E18D             #endif
5582   E18D 8F F4 20 02             brclr   iscFlags1, #$20, L1371  ; Branch if not (startingToCrank and temperature(iat) < 75degC)                               
5583   E191 86 0F                   ldaa    #$0f                    ; high iat, use lower value... a = $0f                            
5584   E193 F6 01 41    L1371       ldab    T0p5_crCold             ; b = T0p5_crCold                                   
5585   E196 3D                      mul                             ; d = $1e * T0p5_crCold                            
5586   E197 15 57                   div     temp1                   ; d = $1e * T0p5_crCold / $3c                            
5587   E199 FB FE B9                addb    t_iscStEct0             ; b = $1e * T0p5_crCold / $3c +  t_iscStEct0                                  
5588   E19C F7 01 69    L1372       stab    iscStBaseCSt            ; iscStBaseCSt =  0 or $1e * T0p5_crCold / $3c +  t_iscStEct0                               
5589   E19F             
5590   E19F                         ;--------------------------------------------------
5591   E19F                         ; Check if iscStepCurr and iscStepCom are in synch?
5592   E19F                         ;--------------------------------------------------
5593   E19F 0F                      sei                             ; We don't want ISC values to change during check                                           
5594   E1A0 96 49                   ldaa    iscStepCurr             ;                                                                                              
5595   E1A2 43                      coma                            ;                                                                                           
5596   E1A3 84 7F                   anda    #$7f                    ;                                                                                           
5597   E1A5 91 48                   cmpa    iscStepCom              ;                                                                                                 
5598   E1A7 0E                      cli                             ;                                                                                           
5599   E1A8 26 1C                   bne     L1373                   ; Branch if  iscStepCurr and iscStepCom are not in synch                                             
5600   E1AA             
5601   E1AA                         ;-------------------------------------------
5602   E1AA                         ; iscStepCurr and iscStepCom are in synch
5603   E1AA                         ; Check ISC variables against min/max
5604   E1AA                         ;-------------------------------------------
5605   E1AA CE B0 00                ldx     #$b000                  ; x = $b000                                
5606   E1AD 9C 44                   cpx     isc0                    ;                             
5607   E1AF 25 15                   bcs     L1373                   ; Branch to re-init if isc0 > $b000                               
5608   E1B1 9C 46                   cpx     isc1                    ;                             
5609   E1B3 25 11                   bcs     L1373                   ; Branch to re-init if isc1 > $b000                              
5610   E1B5 CE 6C 00                ldx     #$6c00                  ; x = $6c00                              
5611   E1B8 9C 44                   cpx     isc0                    ;                             
5612   E1BA 22 0A                   bhi     L1373                   ; Branch to re-init if isc0 < $6c00                             
5613   E1BC 9C 46                   cpx     isc1                    ;                             
5614   E1BE 22 06                   bhi     L1373                   ; Branch to re-init if isc1 < $6c00                             
5615   E1C0 87 4B 20 10             brset   iscFlags0, #$20, L1374  ; Branch if the ISC needs min calibration
5616   E1C4 20 3C                   bra     L1379                   ; Branch to continue processing normal flow???                              
5617   E1C6             
5618   E1C6                         ;-----------------------------------------------
5619   E1C6                         ; iscStepCurr and iscStepCom are not in synch
5620   E1C6                         ; re-initialize ISC variables 
5621   E1C6                         ; set isc flag indicating we need min calibration
5622   E1C6                         ; reset all other isc flags
5623   E1C6                         ;-----------------------------------------------
5624   E1C6 CC 8C 00    L1373       ldd     #$8c00                  ;                               
5625   E1C9 DD 44                   std     isc0                    ;                             
5626   E1CB DD 46                   std     isc1                    ;                             
5627   E1CD BD E5 06                jsr     iscYnInit               ;                                     
5628   E1D0 86 20                   ldaa    #$20                    ; Set flag indicating we need to calibrate ISC, reset all other flags
5629   E1D2 97 4B                   staa    iscFlags0               ;                              
5630   E1D4             
5631   E1D4                         ;------------------------------------------------------------------------
5632   E1D4                         ; Section for ISC min calibration, code is triggered by iscFlags0.5 being set
5633   E1D4                         ;
5634   E1D4                         ; Min calibration proceed as follows. 
5635   E1D4                         ;
5636   E1D4                         ;       1) iscFlags0.5 is set to indicate calibration is required, 
5637   E1D4                         ;          iscStepCurr init to 135, iscStepTarg init to 0
5638   E1D4                         ;       2) iscFlags0.0 is set to indicate calibration is started, 
5639   E1D4                         ;          waiting for iscStepCurr to reach iscStepTarg of 0
5640   E1D4                         ;       3) iscFlags0.1 is set to indicate calibration is finished,
5641   E1D4                         ;          iscStepCurr reached 0, we are therefore now certain that
5642   E1D4                         ;          the isc pintle is physically at position 0.iscStepTarg 
5643   E1D4                         ;          is now init to 6, waiting for iscStepCurr to reach iscStepTarg
5644   E1D4                         ;       4) iscStepCurr reached iscStepTarg = 6, iscFlags0.0.1.5 
5645   E1D4                         ;          are all reset
5646   E1D4                         ; 
5647   E1D4                         ;------------------------------------------------------------------------
5648   E1D4 87 4B 02 16 L1374       brset   iscFlags0, #$02, L1376  ; Branch if calibration is finished, we are waiting for ISC to go back to iscStepCurr=6                                
5649   E1D8 87 4B 01 0A             brset   iscFlags0, #$01, L1375  ; Branch if calibration is started, we are waiting for ISC to reach iscStepCurr=0                              
5650   E1DC 86 87                   ldaa    #$87                    ; calibration not started, use iscStepCurr = a = $87  (135, above max, maybe during calibration?)                          
5651   E1DE 0F                      sei                             ;                             
5652   E1DF BD E4 A4                jsr     iscStepComp             ; iscStepCurr = $87, iscStepCom = (~$87 & 7F) 
5653   E1E2 0E                      cli                             ;                             
5654   E1E3 03 4B 01                orm     iscFlags0, #$01         ; Set flag indicating we just calculated iscStepCom?                              
5655   E1E6 5F          L1375       clrb                            ; use iscStepTarg = b = 0                             
5656   E1E7 96 49                   ldaa    iscStepCurr             ; a = iscStepCurr                               
5657   E1E9 26 09                   bne     L1377                   ; Branch if iscStepCurr != 0                             
5658   E1EB 03 4B 02                orm     iscFlags0, #$02         ; iscStepCurr=0, set flag                               
5659   E1EE C6 06       L1376       ldab    #$06                    ; b = $06                            
5660   E1F0 D1 49                   cmpb    iscStepCurr             ;                                
5661   E1F2 27 05                   beq     L1378                   ; Branch if iscStepCurr=$06                             
5662   E1F4 D7 FD       L1377       stab    iscStepTarg             ; iscStepTarg = $00 or $06                                
5663   E1F6 7E E2 94                jmp     L1389                   ; Bail
5664   E1F9 4F          L1378       clra                            ; a = 0                            
5665   E1FA 0F                      sei                             ;                             
5666   E1FB BD E4 A4                jsr     iscStepComp             ; iscStepCurr = $0, iscStepCom = (~$0 & 7F)                                   
5667   E1FE 0E                      cli                             ;                             
5668   E1FF 02 4B DC                andm    iscFlags0, #$dc         ; Calibration is over, reset all flags 0010 0011                                
5669   E202             
5670   E202                         ;--------------------------------------------------------
5671   E202                         ; Normal flow continues,
5672   E202                         ; Check if  max calibration need to be performed
5673   E202                         ;--------------------------------------------------------
5674   E202 87 4B 80 09 L1379       brset   iscFlags0, #$80, L1380  ; Branch if max calibration is required?
5675   E206 7D 01 24                tst     T40_noPower             ;                                    
5676   E209 26 1F                   bne     L1382                   ; Branch to normal flow if we are not about to loose power                              
5677   E20B 87 4B 40 1B             brset   iscFlags0, #$40, L1382  ; Branch to normal flow if max calibration already performed                              
5678   E20F             
5679   E20F                         ;-------------------------------------------------------------
5680   E20F                         ; At this point max calibration flag is set or we are about 
5681   E20F                         ; to loose power and max calibration was not performed
5682   E20F                         ;
5683   E20F                         ; Set iscStepTarg to 135 if iscStepCurr not already at 135
5684   E20F                         ;-------------------------------------------------------------
5685   E20F 03 4B 80    L1380       orm     iscFlags0, #$80         ; Set max calibration flag is case it was not set                               
5686   E212 86 87                   ldaa    #$87                    ; a = 135                            
5687   E214 91 49                   cmpa    iscStepCurr             ;                                
5688   E216 27 05                   beq     L1381                   ; Branch if iscStepCurr already at 135
5689   E218 97 FD                   staa    iscStepTarg             ; Set target to iscStepTarg = 135                                
5690   E21A 7E E2 94                jmp     L1389                   ;                              
5691   E21D             
5692   E21D                         ;-------------------------------------------------------------
5693   E21D                         ; At this point iscStepCurr is 135, we are therefore sure the 
5694   E21D                         ; isc pintle is physically at its maximum value of 120,
5695   E21D                         ; set iscStepCurr=120 and set/reset flags
5696   E21D                         ;-------------------------------------------------------------
5697   E21D 86 78       L1381       ldaa    #$78                    ; a = $78 (120, max usable value)                            
5698   E21F 0F                      sei                             ;                             
5699   E220 BD E4 A4                jsr     iscStepComp             ; iscStepCurr = $78, iscStepCom = (~$78 & 7F)
5700   E223 0E                      cli                             ;                             
5701   E224 03 4B 40                orm     iscFlags0, #$40         ; set flag 0100 0000, calibration done?                               
5702   E227 02 4B 7F                andm    iscFlags0, #$7f         ; reset flag indicating we need max calibration 1000 0000                               
5703   E22A             
5704   E22A                         ;-----------------------------------------------------
5705   E22A                         ; if the ECU is about to loose power then 
5706   E22A                         ;
5707   E22A                         ; set/reset flags 
5708   E22A                         ; use a fixed ISC step of $5a 
5709   E22A                         ; don't re-init updIscStableTimer since we loose power...
5710   E22A                         ;-----------------------------------------------------
5711   E22A 02 4B EF    L1382       andm    iscFlags0, #$ef         ; Assume we reset 0001 0000, updated below                               
5712   E22D B6 01 24                ldaa    T40_noPower             ;                                    
5713   E230 26 0A                   bne     L1383                   ; Branch if timer not expired                             
5714   E232 02 4B 40                andm    iscFlags0, #$40         ; reset max calibration flag? 0100 0000                               
5715   E235 03 4B 10                orm     iscFlags0, #$10         ; Set 0001 0000                               
5716   E238 C6 5A                   ldab    #$5a                    ; b = $5a                            
5717   E23A 20 53                   bra     L1388                   ; Branch to use fix ISC step of $5a, i.e. 3/4 of full range
5718   E23C             
5719   E23C                         ;----------------------------------------------------
5720   E23C                         ; If the engine is running but we are not receiving 
5721   E23C                         ; airflow sensor interrupts then 
5722   E23C                         ;
5723   E23C                         ; set/reset flags
5724   E23C                         ; re-init iscYn variables
5725   E23C                         ; re-init updIscStableTimer
5726   E23C                         ; use a fixed ISC step of $3a
5727   E23C                         ;----------------------------------------------------
5728   E23C 02 4B F7    L1383       andm    iscFlags0, #$f7         ; Assume we reset 00001000, updated below                               
5729   E23F 8F E6 02 16             brclr   state1, #$02, L1384     ; Bail if pulse accumulator interrupts are being received 
5730   E243 87 E6 11 12             brset   state1, #$11, L1384     ; Bail if notRotating or startingToCrank
5731   E247 BD E5 06                jsr     iscYnInit               ; Init variables                                     
5732   E24A 02 4B 40                andm    iscFlags0, #$40         ; reset max calibration flag? 0100 0000                               
5733   E24D 03 4B 08                orm     iscFlags0, #$08         ; set 0000 1000                               
5734   E250 C6 50                   ldab    #$50                    ;                             
5735   E252 BD E4 AD                jsr     updIscStableTimer       ; re-init updIscStableTimer                                 
5736   E255 C6 3A                   ldab    #$3a                    ; b = $3a                            
5737   E257 20 36                   bra     L1388                   ; Branch to use fix ISC step of $3a               
5738   E259                                        
5739   E259                         ;---------------------------------------------------
5740   E259                         ; Section to check for idle speed adjustment mode, 
5741   E259                         ; i.e. both ECU test mode terminal grounded and 
5742   E259                         ; timing adjustment terminal grounded                             
5743   E259                         ;---------------------------------------------------
5744   E259 02 4B FB    L1384       andm    iscFlags0, #$fb         ; Reset 00000010
5745   E25C 96 D8                   ldaa    port4Snap               ; a = port4Snap                                  
5746   E25E 84 18                   anda    #$18                    ; Keep only ECU test mode terminal grounded & timing adjustment terminal grounded               
5747   E260 81 18                   cmpa    #$18                    ; ECU test mode terminal grounded & timing adjustment terminal grounded                             
5748   E262 26 0C                   bne     L1385                   ; Bail if not both of them grounded                             
5749   E264 87 F1 04 08             brset   port3Snap1, #$04, L1385 ; Both terminal grounded, bail if car is moving
5750   E268             #ifdef E932
5751   E268 8F F1 20 04             brclr   port3Snap1, #$20, L1385 ; Bail if not in park/neutral???                                    
5752   E26C             #endif
5753   E26C 8F E6 11 05             brclr   state1, #$11, L1386     ; branch if notRotating and startingToCrank clear
5754   E270             
5755   E270                         ;------------------------------------------------------------
5756   E270                         ; Engine is either notRotating or startingToCrank
5757   E270                         ; Reset timer (always done when both terminal not grounded)
5758   E270                         ;------------------------------------------------------------
5759   E270 86 08       L1385       ldaa    #$08                    ; 0.2s 
5760   E272 B7 01 2B                staa    T40_iSpAdj              ;                               
5761   E275             
5762   E275                         ;--------------------------------------------------
5763   E275                         ; If Timer T40_iSpAdj is expired (0.2 sec after
5764   E275                         ; both terminals grounded) we are in basic idle 
5765   E275                         ; speed adjustment mode. Branch accordingly...
5766   E275                         ;--------------------------------------------------
5767   E275 B6 01 2B    L1386       ldaa    T40_iSpAdj              ;                               
5768   E278 26 23                   bne     L1390                   ; Branch to next section if timer not expired
5769   E27A             
5770   E27A                         ;----------------------------------------------------
5771   E27A                         ; Timer is expired, we are in basic idle 
5772   E27A                         ; speed adjustment mode...
5773   E27A                         ;
5774   E27A                         ; Just compute iscStepTarg (target idle speed) as a
5775   E27A                         ; function of temperature and barometric pressure,
5776   E27A                         ; reset iscLrnFlags and iscStStall and exit from subroutine
5777   E27A                         ;----------------------------------------------------
5778   E27A 03 4B 04                orm     iscFlags0, #$04         ; Set flag                               
5779   E27D C6 50                   ldab    #$50                    ;                             
5780   E27F BD E4 AD                jsr     updIscStableTimer       ;                              
5781   E282 CE FE B9                ldx     #t_iscStEct0            ; x points to iscStepCurr(as a function of ECT) table                                
5782   E285 BD EB 2F                jsr     interpEct               ; b = t_iscStEct0(ect), basic isc value we want as a function of ECT                                 
5783   E288 FB 01 6A                addb    iscStBarOff             ; b = t_iscStEct0(ect) + iscStBarOff, Add an offset to compensate for barometric pressure
5784   E28B 24 02                   bcc     L1388                   ; Branch if no overflow                             
5785   E28D C6 FF                   ldab    #$ff                    ; Use max
5786   E28F BD E4 B6    L1388       jsr     iscStepMaxFunc          ; Apply maximum to calculated value                            
5787   E292 D7 FD                   stab    iscStepTarg             ; iscStepTarg =  t_iscStEct0(ect) + iscStBarOff 
5788   E294 4F          L1389       clra                            ;                             
5789   E295 97 F3                   staa    iscLrnFlags             ; iscLrnFlags = 0                             
5790   E297 B7 01 63                staa    iscStStall              ; iscStStall = 0                             
5791   E29A 7E E4 A3                jmp     L1431                   ; Bail of subroutine
5792   E29D                                                                        
5793   E29D                         ;------------------------------------------------
5794   E29D                         ; Basic idle speed adjustment mode is not active
5795   E29D                         ; Section to update ISC stuff, long...
5796   E29D                         ;------------------------------------------------
5797   E29D 87 E6 11 08 L1390       brset   state1, #$11, L1391     ; Branch if notRotating or startingToCrank
5798   E2A1             
5799   E2A1                         ;--------------------------------------
5800   E2A1                         ; Engine is running, set /reset flags
5801   E2A1                         ;--------------------------------------
5802   E2A1 02 F3 FE                andm    iscLrnFlags, #$fe       ; Reset bit 0                               
5803   E2A4 03 F4 01                orm     iscFlags1, #$01         ; Set flag indicating "normal running mode"??                               
5804   E2A7 20 12                   bra     L1392                   ; Branch to continue                             
5805   E2A9             
5806   E2A9                         ;----------------------------------
5807   E2A9                         ; notRotating or startingToCrank
5808   E2A9                         ;----------------------------------
5809   E2A9 C6 01       L1391       ldab    #$01                    ;                             
5810   E2AB D7 F3                   stab    iscLrnFlags             ; Reset all bit to 0 and set bit 0 to 1                              
5811   E2AD             
5812   E2AD                         ;---------------------------------------------------------------
5813   E2AD                         ; Reset iscFlags1.0 if key in start and iscStTargSpec = iscStepCurr??
5814   E2AD                         ;---------------------------------------------------------------
5815   E2AD 87 F1 40 0A             brset   port3Snap1, #$40, L1392 ; Branch if key is not is start                                   
5816   E2B1 B6 01 66                ldaa    iscStTargSpec           ;                              
5817   E2B4 91 49                   cmpa    iscStepCurr             ;                                
5818   E2B6 26 03                   bne     L1392                   ; Branch if iscStTargSpec != iscStepCurr                             
5819   E2B8 02 F4 FE                andm    iscFlags1, #$fe         ;                                
5820   E2BB             
5821   E2BB                         ;------------------------------------------------------------------
5822   E2BB                         ; Init T40_acOnTrans to 0.1sec if A/C switch was just turned on?
5823   E2BB                         ;------------------------------------------------------------------
5824   E2BB 96 F1       L1392       ldaa    port3Snap1              ;                                   
5825   E2BD 98 F2                   eora    oldP3Snap1              ;                                   
5826   E2BF 85 10                   bita    #$10                    ;                             
5827   E2C1 27 04                   beq     L1393                   ; Branch if A/C switch did not change state                              
5828   E2C3 8F F1 10 08             brclr   port3Snap1, #$10, L1394 ; Branch if A/C switch is on                                   
5829   E2C7             L1393       .equ    $
5830   E2C7~            #ifdef E931
5831   E2C7~                        bra     L1395                   ;                               
5832   E2C7             #else
5833   E2C7 85 20                   bita    #$20                    ;                             
5834   E2C9 27 09                   beq     L1395                   ;                              
5835   E2CB 87 F1 20 05             brset   port3Snap1, #$20, L1395 ;                                    
5836   E2CF             #endif
5837   E2CF C6 04       L1394       ldab    #$04                    ; 0.1sec                            
5838   E2D1 F7 01 28                stab    T40_acOnTrans           ; T40_acOnTrans = 0.1sec
5839   E2D4                                                        
5840   E2D4                         ;--------------------------------------------------------------
5841   E2D4                         ; Update iscLrnFlags.2, flag indicating engine is running too slow? 
5842   E2D4                         ;--------------------------------------------------------------
5843   E2D4 96 F3       L1395       ldaa    iscLrnFlags              ; a = old iscLrnFlags                             
5844   E2D6 02 F3 FB                andm    iscLrnFlags, #$fb        ; Assume we reset 00000100, updated below                               
5845   E2D9 D6 D3                   ldab    ectFiltered              ;                                    
5846   E2DB C1 3C                   cmpb    #$3c                     ; 55degC                             
5847   E2DD 24 19                   bcc     L1396                    ; Bail if temperature(ectFiltered) <= 55degC                               
5848   E2DF D6 DC                   ldab    rpm8                     ;                             
5849   E2E1 C1 40                   cmpb    #$40                     ;                             
5850   E2E3 24 13                   bcc     L1396                    ; Bail if rpm8 >=500                              
5851   E2E5 87 F3 01 0F             brset   iscLrnFlags, #$01, L1396 ; Bail if engine is notRotating or startingToCrank (and basic idle speed adjustment mode is off)                              
5852   E2E9 7D 01 28                tst     T40_acOnTrans            ;                               
5853   E2EC 26 0A                   bne     L1396                    ; Bail if timer not expired                              
5854   E2EE             
5855   E2EE                         ;----------------------------------------------------------------------------------
5856   E2EE                         ; At this point 
5857   E2EE                         ;    temperature(ectFiltered) > 55degC 
5858   E2EE                         ;    rpm8 < 500rpm 
5859   E2EE                         ;    engine is running
5860   E2EE                         ;    T40_acOnTrans is expired (A/C switch was turned on more than 0.1sec ago, or never...)
5861   E2EE                         ;
5862   E2EE                         ; Set iscLrnFlags.2 indicating the engine is running to slow 
5863   E2EE                         ; (even though A/C transcient was ignored for 0.1sec)
5864   E2EE                         ;
5865   E2EE                         ; Clear T40_checkTargRpm if this condition was just detected in order to perform
5866   E2EE                         ; current versus target rpm comparison right away and adjust isc step before 
5867   E2EE                         ; the engine stalls...
5868   E2EE                         ;----------------------------------------------------------------------------------
5869   E2EE 03 F3 04                orm     iscLrnFlags, #$04       ; set 0000 0100                               
5870   E2F1 84 04                   anda    #$04                    ; a = old iscLrnFlags & 0000 0100                            
5871   E2F3 26 03                   bne     L1396                   ; Bail if old iscLrnFlags.2 was set                              
5872   E2F5 7F 01 2A                clr     T40_checkTargRpm        ; old iscLrnFlags.2 was not set, reset timer to trigger fast rpm update... 
5873   E2F8                                                        
5874   E2F8                         ;---------------------------------
5875   E2F8                         ; Update updIscStableTimer if ???  
5876   E2F8                         ;---------------------------------
5877   E2F8 8F F3 20 05 L1396       brclr   iscLrnFlags, #$20, Ne301 ; Branch if                                
5878   E2FC C6 50                   ldab    #$50                     ;                             
5879   E2FE BD E4 AD                jsr     updIscStableTimer        ;                                         
5880   E301             Ne301        .equ    $
5881   E301             
5882   E301                         ;--------------------------------------------
5883   E301                         ; Update updIscStableTimer if ???  for E931 
5884   E301                         ;--------------------------------------------
5885   E301~            #ifdef E931
5886   E301~                        brclr    ftrimFlags, #$08, L1397 ; Branch if not (speed>24km/h and port3.0 is set???)                                      
5887   E301~                        ldab    #$50                     ; speed>24km/h and port3.0 is set, update timer                            
5888   E301~                        jsr     updIscStableTimer        ;                                          
5889   E301             #endif
5890   E301             
5891   E301                         ;-------------------------------------------------------------------
5892   E301                         ; Section to update iscLrnFlags.4, flag indicating that conditions are
5893   E301                         ; good to update the isc learning variables???
5894   E301                         ;-------------------------------------------------------------------
5895   E301 02 F3 EF    L1397       andm    iscLrnFlags, #$ef       ; Assume we reset iscLrnFlags.4 (0001 0000)                                
5896   E304 96 F1                   ldaa    port3Snap1              ;                                   
5897   E306 2A 0F                   bpl     L1398                   ; Branch if idle position switch is off                              
5898   E308 87 F1 04 0B             brset   port3Snap1, #$04, L1398 ; Branch if car is moving
5899   E30C B6 01 62                ldaa    T40s_iscStable          ;                                  
5900   E30F 26 06                   bne     L1398                   ; Branch if isc not stable yet
5901   E311 96 DC                   ldaa    rpm8                    ;                             
5902   E313 81 2A                   cmpa    #$2a                    ;                             
5903   E315 24 08                   bcc     L1399                   ; Branch if rpm8 >= 328rpm                              
5904   E317 8F E6 01 09 L1398       brclr   state1, #$01, L1400     ; Branch if startingToCrank clear
5905   E31B 87 F4 01 05             brset   iscFlags1, #$01, L1400  ; Branch if not (key in start and iscStTargSpec = iscStepCurr)
5906   E31F             
5907   E31F                         ;--------------------------------------------
5908   E31F                         ; At this point
5909   E31F                         ;      car is not moving
5910   E31F                         ; and idle switch is on 
5911   E31F                         ; and isc is stable
5912   E31F                         ; and rpm8 >= 328
5913   E31F                         ;
5914   E31F                         ; or these conditions are not met but 
5915   E31F                         ;     engine is startingToCrank 
5916   E31F                         ; and (key in start and iscStTargSpec = iscStepCurr)
5917   E31F                         ;
5918   E31F                         ; Set iscLrnFlags.4 indicating we can update the isc 
5919   E31F                         ; learning variables?
5920   E31F                         ;--------------------------------------------
5921   E31F 03 F3 10    L1399       orm     iscLrnFlags, #$10       ;                                
5922   E322 20 05                   bra     L1401                   ;                              
5923   E324             
5924   E324                         ;-----------------------------------------------------
5925   E324                         ; At this point, 
5926   E324                         ;     car is moving
5927   E324                         ;  or idle position switch is off 
5928   E324                         ;  or isc not yet stable
5929   E324                         ;  or rpm < 328
5930   E324                         ;
5931   E324                         ; and engine is startingToCrank or key is not 
5932   E324                         ; in start or iscStTargSpec != iscStepCurr
5933   E324                         ;
5934   E324                         ; Re-init T40_iscLrn to 5sec
5935   E324                         ; Conditions are not good to update ISC learning variables?
5936   E324                         ; Flag is already reset so just reset that timer so that
5937   E324                         ; we have a 5sec delay when we can go back to being able
5938   E324                         ; to update them...
5939   E324                         ;--------------------------------------------------------------
5940   E324 C6 C8       L1400       ldab    #$c8                    ; 5sec                            
5941   E326 F7 01 26                stab    T40_iscLrn              ; T40_iscLrn = 5sec                               
5942   E329             
5943   E329                         ;---------------------------------------------------------------------------------------------------
5944   E329                         ; Check whether abs(idleSpdTarg - rpm8) > (5/256 * idleSpdTarg)
5945   E329                         ;
5946   E329                         ; Basically chech if target and current rpm are more than 2% apart                            
5947   E329                         ;---------------------------------------------------------------------------------------------------
5948   E329 8F F3 10 19 L1401       brclr   iscLrnFlags, #$10, L1403 ; Bail if conditions are not good to update isc variables                               
5949   E32D B6 01 2A                ldaa    T40_checkTargRpm         ;                               
5950   E330 26 14                   bne     L1403                    ; Bail if timer not expired                             
5951   E332 96 FE                   ldaa    idleSpdTarg              ; a = idleSpdTarg                                  
5952   E334 90 DC                   suba    rpm8                     ; a = idleSpdTarg - rpm8                            
5953   E336 76 00 58                ror     temp2                    ; shift sign (carry) of result in temp2.7
5954   E339 2A 01                   bpl     L1402                    ; Branch if (idleSpdTarg - rpm8) >= 0                             
5955   E33B 40                      nega                             ; a =  abs(idleSpdTarg - rpm8)                            
5956   E33C 36          L1402       psha                             ; st0 = abs(idleSpdTarg - rpm8)                            
5957   E33D 96 FE                   ldaa    idleSpdTarg              ; a = idleSpdTarg                                   
5958   E33F C6 0A                   ldab    #$0a                     ; b = $0a                             
5959   E341 3D                      mul                              ; d = $0a * idleSpdTarg                            
5960   E342 33                      pulb                             ; b = abs(idleSpdTarg - rpm8); a = $0a/256 * idleSpdTarg                            
5961   E343 11                      cba                              ;                             
5962   E344 25 03                   bcs     L1404                    ; Branch if ($0a/256 * idleSpdTarg) < abs(idleSpdTarg - rpm8), basically branch if difference between current rpm and desired one is too high                            
5963   E346 7E E3 A5    L1403       jmp     L1416                    ; Jump to next section
5964   E349                                          
5965   E349                         ;------------------------------------------------------------------
5966   E349                         ; At this point abs(idleSpdTarg - rpm8) > (5/256 * idleSpdTarg)
5967   E349                         ; or equivalently  abs(idleSpdTarg - rpm8)/idleSpdTarg > 2%
5968   E349                         ; i.e. Target and current rpm are more than 2% apart
5969   E349                         ;
5970   E349                         ; Section to update iscYn (until L1415).
5971   E349                         ;
5972   E349                         ; Basically this section increases the current iscYn (iscY1, iscY2 
5973   E349                         ; or iscY3) if the current rpm is lower than the target and vice-versa
5974   E349                         ; iscYn is centered at $80 (100%, no correction). The isc step used 
5975   E349                         ; is increase/decreased by iscYn-$80 later in the code
5976   E349                         ;------------------------------------------------------------------
5977   E349 58          L1404       aslb                            ; b = 2 * abs(idleSpdTarg - rpm8)                            
5978   E34A 25 03                   bcs     L1405                   ; branch to use max of $ff if overflow                             
5979   E34C 58                      aslb                            ; b = 4 * abs(idleSpdTarg - rpm8)                             
5980   E34D 24 02                   bcc     L1406                   ; Branch if no overflow                             
5981   E34F C6 FF       L1405       ldab    #$ff                    ; use max of $ff                            
5982   E351 D7 57       L1406       stab    temp1                   ; temp1 = 4 * abs(idleSpdTarg - rpm8)                              
5983   E353 CE FE F3                ldx     #L2035                  ; x point to L2035                               
5984   E356 96 57                   ldaa    temp1                   ; a = 4 * abs(idleSpdTarg - rpm8)                              
5985   E358 BD EB 41                jsr     interp32                ; b = L2035(4 * abs(idleSpdTarg - rpm8))                                
5986   E35B D7 57                   stab    temp1                   ; temp1 = L2035(4 * abs(idleSpdTarg - rpm8))                              
5987   E35D BD E4 DD                jsr     iscPointers             ; have x point to isc0 or isc1 and have y point to iscY0, iscY1 or iscY2                                
5988   E360 E6 80                   ldab    $00,y                   ; b = iscYn, y = y + 1                              
5989   E362 CD 09                   decy                            ; y = y-1, points back to same value                             
5990   E364 96 58                   ldaa    temp2                   ; a.7 = sign(carry) of idleSpdTarg - rpm8 (see above L1402)
5991   E366 2A 11                   bpl     L1410                   ; Branch if  idleSpdTarg - rpm8 was positive
5992   E368             
5993   E368                         ;---------------------------------------------------------------------------
5994   E368                         ; idleSpdTarg - rpm8 was negative. i.e. current rpm is too high
5995   E368                         ; Compute b = iscYn - min (iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)))                             
5996   E368                         ;---------------------------------------------------------------------------
5997   E368 96 FD                   ldaa    iscStepTarg             ; a = iscStepTarg                                   
5998   E36A 27 39                   beq     L1416                   ; Branch if iscStepTarg = 0                             
5999   E36C 91 57                   cmpa    temp1                   ;                              
6000   E36E 22 02                   bhi     L1408                   ; Branch if iscStepTarg > L2035(4 * abs(idleSpdTarg - rpm8))
6001   E370 97 57                   staa    temp1                   ; Use max of = iscStepTarg                             
6002   E372 D0 57       L1408       subb    temp1                   ; b = iscYn - min (iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)))                             
6003   E374 24 01                   bcc     L1409                   ; Branch if no underflow                             
6004   E376 5F                      clrb                            ; Use min of 0                            
6005   E377 20 12       L1409       bra     L1412                   ; 
6006   E379                                          
6007   E379                         ;-------------------------------------------------------------------------------------
6008   E379                         ; idleSpdTarg - rpm8 was positive, i.e. current rpm is too low
6009   E379                         ; Compute b = iscYn + min(iscStepMax - iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)) 
6010   E379                         ;-------------------------------------------------------------------------------------
6011   E379 96 F0       L1410       ldaa    iscStepMax              ; a = iscStepMax                                   
6012   E37B 90 FD                   suba    iscStepTarg             ; a = iscStepMax - iscStepTarg                                  
6013   E37D 27 26                   beq     L1416                   ; Branch if iscStepTarg = iscStepMax
6014   E37F 91 57                   cmpa    temp1                   ;                              
6015   E381 22 02                   bhi     L1411                   ; Branch if iscStepMax - iscStepTarg > L2035(4 * abs(idleSpdTarg - rpm8))                               
6016   E383 97 57                   staa    temp1                   ; Use max of iscStepMax - iscStepTarg                             
6017   E385 DB 57       L1411       addb    temp1                   ; b = iscYn + min(iscStepMax - iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)) 
6018   E387 24 02                   bcc     L1412                   ; Branch if no overflow                              
6019   E389 C6 FF                   ldab    #$ff                    ; Use max of $ff                            
6020   E38B             
6021   E38B                         ;-------------------------------------------------------------------------------------
6022   E38B                         ; at this point 
6023   E38B                         ;        b = iscYn - min(iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)))                             
6024   E38B                         ;     or
6025   E38B                         ;        b = iscYn + min(iscStepMax - iscStepTarg, L2035(4 * abs(idleSpdTarg - rpm8)) 
6026   E38B                         ;
6027   E38B                         ; Restart T40_checkTargRpm to 1 sec and decide whether to apply min/max to new iscYn=b value
6028   E38B                         ;-------------------------------------------------------------------------------------
6029   E38B 86 28       L1412       ldaa    #$28                     ; 1sec                            
6030   E38D B7 01 2A                staa    T40_checkTargRpm         ; T40_checkTargRpm = 1sec                              
6031   E390 87 F3 01 03             brset   iscLrnFlags, #$01, L1413 ; Branch to min/max checking if engine is notRotating or startingToCrank                              
6032   E394 20 0D                   bra     L1415                    ; Branch to store b in iscYn, Skip min/max checking                             
6033   E396 01                      nop                              ;                             
6034   E397             
6035   E397                         ;-------------------------------------------------
6036   E397                         ; Check b for min and max and then store in iscYn
6037   E397                         ;-------------------------------------------------
6038   E397 C1 86       L1413       cmpb    #$86                    ;                             
6039   E399 25 02                   bcs     L1414                   ; Branch if b < $86                             
6040   E39B C6 86                   ldab    #$86                    ; Use max of $86                            
6041   E39D C1 7B       L1414       cmpb    #$7b                    ;                             
6042   E39F 24 02                   bcc     L1415                   ; Branch if b >= $7b                             
6043   E3A1 C6 7B                   ldab    #$7b                    ; Use min of $7b                            
6044   E3A3 E7 80       L1415       stab    $00,y                   ; iscYn = b....                             
6045   E3A5             
6046   E3A5             
6047   E3A5                         ;---------------------------------------------------------------
6048   E3A5                         ; re-init iscYn variables if car is moving and rpm8>=1000rpm
6049   E3A5                         ;---------------------------------------------------------------
6050   E3A5 8F F1 04 09 L1416       brclr   port3Snap1, #$04, L1417 ; Branch if car is not moving                                    
6051   E3A9 96 DC                   ldaa    rpm8                    ;                             
6052   E3AB 81 80                   cmpa    #$80                    ;                             
6053   E3AD 25 03                   bcs     L1417                   ; Branch if rpm8 < 1000rpm                              
6054   E3AF BD E5 06                jsr     iscYnInit               ;
6055   E3B2                                                              
6056   E3B2                         ;--------------------------------------------------------
6057   E3B2                         ; Transfer iscY0 to iscY2 if  power steering pump is off???  
6058   E3B2                         ;--------------------------------------------------------
6059   E3B2 87 F1 08 04 L1417       brset   port3Snap1, #$08, L1418 ; Bail if power steering pump is activated
6060   E3B6 96 ED                   ldaa    iscY0                   ;                              
6061   E3B8 97 EF                   staa    iscY2                   ; iscY2 = iscY0 
6062   E3BA                                                      
6063   E3BA                         ;---------------------------------------------------------
6064   E3BA                         ; Section to compute iscStepTarg from various information
6065   E3BA                         ; Ends at L1428
6066   E3BA                         ;---------------------------------------------------------
6067   E3BA                         ;-------------------------------------------------------------------------
6068   E3BA                         ; Compute workIscStep = b = max(iscStBase, iscStBaseAc, iscStBaseCSt)
6069   E3BA                         ;-------------------------------------------------------------------------
6070   E3BA F6 01 67    L1418       ldab    iscStBase               ; b = iscStBase                              
6071   E3BD F1 01 68                cmpb    iscStBaseAc             ;                              
6072   E3C0 24 03                   bcc     L1419                   ; Branch if iscStBase >= iscStBaseAc                             
6073   E3C2 F6 01 68                ldab    iscStBaseAc             ; Use min of iscStBaseAc                              
6074   E3C5 F1 01 69    L1419       cmpb    iscStBaseCSt            ;                              
6075   E3C8 24 03                   bcc     Ne3cd                   ; Branch if max(iscStBase, iscStBaseAc) >= iscStBaseCSt                             
6076   E3CA F6 01 69                ldab    iscStBaseCSt            ; Use min of iscStBaseCSt
6077   E3CD             Ne3cd       .equ    $
6078   E3CD             
6079   E3CD                         ;-----------------------------------------------------------------
6080   E3CD                         ; At this point b = workIscStep
6081   E3CD                         ;
6082   E3CD                         ; Take into port3.0 signal for E931?????
6083   E3CD                         ; Basically continue calculating the max isc step to use, 
6084   E3CD                         ; this time check A/C and port3.0
6085   E3CD                         ;-----------------------------------------------------------------
6086   E3CD~            #ifdef E931
6087   E3CD~                        brclr   ftrimFlags, #$08, L1420 ; Bail if not (speed>24km/h and port3.0 set)                                   
6088   E3CD~                        ldaa    #$53                    ; Use $53 
6089   E3CD~                        brset   port3Snap1, #$10, Me3db ; Branch if A/C switch is off                                   
6090   E3CD~                        ldaa    #$78                    ; Use higher value since A/C is on                           
6091   E3CD~            Me3db       cba                             ;                            
6092   E3CD~                        bcs     L1420                   ; Branch if we already have max value, i.e.  workIscStep > a
6093   E3CD~                        tab                             ; Use new max value                           
6094   E3CD             #endif
6095   E3CD             
6096   E3CD                         ;---------------------------------------------
6097   E3CD                         ; At this point b = workIscStep
6098   E3CD                         ; Compensate for barometric pressure and  
6099   E3CD                         ;---------------------------------------------
6100   E3CD 4F          L1420       clra                            ; a = 0                          
6101   E3CE FB 01 6A                addb    iscStBarOff             ; d = workIscStep + iscStBarOff
6102   E3D1 89 00                   adca    #$00                    ; propagate carry                          
6103   E3D3             
6104   E3D3                         ;------------------------------------------------
6105   E3D3                         ; At this point b = workIscStep
6106   E3D3                         ; Increase iscStep according to iscStStartUsed
6107   E3D3                         ;
6108   E3D3                         ; i.e. isc step adjustment upon engine startup
6109   E3D3                         ;------------------------------------------------
6110   E3D3 FB 01 64                addb    iscStStartUsed          ; d = workIscStep + iscStBarOff + iscStStartUsed
6111   E3D6 89 00                   adca    #$00                    ; propagate carry                          
6112   E3D8 BD EB B3                jsr     ovfCheck                ; Check for overflow (force result to be in b with $ff max)                              
6113   E3DB             
6114   E3DB                         ;------------------------------------------------
6115   E3DB                         ; Check workIscStep for min value in iscStStall
6116   E3DB                         ;------------------------------------------------
6117   E3DB F1 01 63                cmpb    iscStStall              ;                            
6118   E3DE 24 05                   bcc     L1421                   ; Branch if workIscStep + iscStBarOff + iscStStartUsed  >= iscStStall
6119   E3E0 F6 01 63                ldab    iscStStall              ; Use min of iscStStall                            
6120   E3E3 20 06                   bra     L1422                   ; Branch to continue                           
6121   E3E5             
6122   E3E5                         ;-------------------------------------------------------------------
6123   E3E5                         ; At this point workIscStept + iscStBarOff + iscStStartUsed  >= iscStStall
6124   E3E5                         ;
6125   E3E5                         ; i.e. what we are using is already higher 
6126   E3E5                         ; than the minimum we therefore don't need 
6127   E3E5                         ; that minimum anymore...
6128   E3E5                         ;
6129   E3E5                         ; Reset iscStStall to 0 and reset flag
6130   E3E5                         ;-------------------------------------------------------------------
6131   E3E5 7F 01 63    L1421       clr     iscStStall              ; iscStStall = 0                           
6132   E3E8 02 F3 DF                andm    iscLrnFlags, #$df       ; Reset 00100000                              
6133   E3EB             
6134   E3EB                         ;---------------------------------------------------------------------------------
6135   E3EB                         ; At this point, b = workIscStep
6136   E3EB                         ; Add the effect of power steering pump
6137   E3EB                         ;---------------------------------------------------------------------------------
6138   E3EB 8F F1 08 06 L1422       brclr   port3Snap1, #$08, L1423 ; Branch if power steering pump is off                                 
6139   E3EF~            #ifdef E931
6140   E3EF~                        addb    #$0f                    ; b = workIscStep + $0f
6141   E3EF             #else       
6142   E3EF CB 11                   addb    #$11                    ;                           
6143   E3F1             #endif
6144   E3F1 24 02                   bcc     L1423                   ; Branch if no overflow                             
6145   E3F3 C6 FF                   ldab    #$ff                    ; Use max of $ff
6146   E3F5                                                     
6147   E3F5                         ;---------------------------------------------------------------
6148   E3F5                         ; increase the iscStep if the engine is running too slow 
6149   E3F5                         ; (stall conditions?) and  conditions are not good to update 
6150   E3F5                         ; isc variables (to avoid getting confused with cranking maybe?) 
6151   E3F5                         ;---------------------------------------------------------------
6152   E3F5 8F F3 04 0A L1423       brclr   iscLrnFlags, #$04, L1424 ; Branch if engine is not running too slow                              
6153   E3F9 87 F3 10 06             brset   iscLrnFlags, #$10, L1424 ; Branch if conditions are good to update isc variables                             
6154   E3FD CB 22                   addb    #$22                     ; b = workIscStep + $22
6155   E3FF 24 02                   bcc     L1424                    ; Branch if no overflow                              
6156   E401 C6 FF                   ldab    #$ff                     ; Use max of $ff                                    
6157   E403             
6158   E403                         ;-------------------------------------------------------------------
6159   E403                         ; Compute temp3 = workIscStep + (iscm/256 - $80) + (iscYn - $80)
6160   E403                         ;                 workIscStep'+ iscStBarOff + (iscm/256 - $80) + (iscYn - $80)
6161   E403                         ; This is isc step we are going to use if engine is running
6162   E403                         ;-------------------------------------------------------------------
6163   E403 BD E4 BD    L1424       jsr     iscCalc3                ; b = workIscStep + (iscm/256 - $80)
6164   E406 BD E4 F5                jsr     iscCalc4                ; b = workIscStep + (iscm/256 - $80) + (iscYn - $80) 
6165   E409 D7 59                   stab    temp3                   ; temp3 =  workIscStep + (iscm/256 - $80) + (iscYn - $80)
6166   E40B             
6167   E40B                         ;---------------------------------------------------------------
6168   E40B                         ; Compute temp2 = L2031(ect) + iscStBarOff + (iscm/256 - $80)
6169   E40B                         ; This is isc step we are going to use if the engine is notRotating
6170   E40B                         ;---------------------------------------------------------------
6171   E40B CE FE D7                ldx     #L2031                  ; x points to L2031                               
6172   E40E BD EB 2F                jsr     interpEct               ; b = L2031(ect)                                   
6173   E411 FB 01 6A                addb    iscStBarOff             ; b = L2031(ect) + iscStBarOff                                    
6174   E414 24 02                   bcc     L1425                   ; Branch if no overflow                             
6175   E416 C6 FF                   ldab    #$ff                    ; overflow, use max
6176   E418 BD E4 BD    L1425       jsr     iscCalc3                ; b = L2031(ect) + iscStBarOff + (iscm/256 - $80)
6177   E41B D7 58                   stab    temp2                   ; temp2 = L2031(ect) + iscStBarOff + (iscm/256 - $80)
6178   E41D             
6179   E41D                         ;-----------------------------------------------------------------------------
6180   E41D                         ; Compute iscStTargSpec = temp2 + (iscYn - $80) 
6181   E41D                         ;                       = L2031(ect) + iscStBarOff + (iscm/256 - $80) + (iscYn - $80) 
6182   E41D                         ;
6183   E41D                         ; This is isc step we are going to use if engine is starting to crank
6184   E41D                         ;-----------------------------------------------------------------------------
6185   E41D BD E4 F5                jsr     iscCalc4                ; b = L2031(ect) + iscStBarOff + (iscm/256 - $80) + (iscYn - $80) 
6186   E420 BD E4 B6                jsr     iscStepMaxFunc          ; apply max to b                                      
6187   E423 F7 01 66                stab    iscStTargSpec           ; iscStTargSpec = L2031(ect) + iscStBarOff + (iscm/256 - $80) + (iscYn - $80) 
6188   E426             
6189   E426                         ;-----------------------------------------------------------------------
6190   E426                         ; At this point,
6191   E426                         ;
6192   E426                         ;      temp3 = workIscStep' + iscStBarOff  + (iscm/256 - $80) + (iscYn - $80)
6193   E426                         ;          b = L2031(ect)   + iscStBarOff  + (iscm/256 - $80) + (iscYn - $80)
6194   E426                         ;      temp2 = L2031(ect)   + iscStBarOff  + (iscm/256 - $80)
6195   E426                         ;
6196   E426                         ; Now decide which value we are going to use 
6197   E426                         ; as working isc step  either b, temp2 or temp3
6198   E426                         ; Not sure why engine state is taken from a mix of state1 and iscLrnFlags???
6199   E426                         ;-----------------------------------------------------------------------
6200   E426 8F F3 01 08             brclr   iscLrnFlags, #$01, L1427 ; Branch to use temp3 if engine is not (notRotating or startingToCrank), runnning, normally or not...
6201   E42A 8F E6 10 06             brclr   state1, #$10, L1428      ; Branch to use iscStTargSpec (already loaded in b) if notRotating clear, only startingToCrank left??? 
6202   E42E D6 58                   ldab    temp2                    ; notRotating, use temp2
6203   E430 20 02                   bra     L1428                    ;                              
6204   E432 D6 59       L1427       ldab    temp3                    ; use temp3
6205   E434             
6206   E434                         ;-------------------------------------------------------------------------
6207   E434                         ; At this point b contains the working isc step that we have been
6208   E434                         ; updating/calculating for a while now, apply a max to it and store it 
6209   E434                         ; in iscStepTarg, this is the is isc step target...
6210   E434                         ;-------------------------------------------------------------------------
6211   E434 BD E4 B6    L1428       jsr     iscStepMaxFunc          ; apply max to b                                       
6212   E437 D7 FD                   stab    iscStepTarg             ; iscStepTarg
6213   E439                                                            
6214   E439                         ;--------------------------------------------
6215   E439                         ; Section to update iscYn and iscm variables
6216   E439                         ;--------------------------------------------
6217   E439                         ;------------------------------------------------------------------------------
6218   E439                         ; Check if a bunch of conditions are met to update the isc learning variables
6219   E439                         ;------------------------------------------------------------------------------
6220   E439 8F F3 10 66             brclr   iscLrnFlags, #$10, L1431 ; Bail if conditions are not good to update isc variables                              
6221   E43D D6 F0                   ldab    iscStepMax               ; b = iscStepMax                                  
6222   E43F 96 FD                   ldaa    iscStepTarg              ; a = iscStepTarg                                   
6223   E441 27 60                   beq     L1431                    ; bail if iscStepTarg = 0
6224   E443 11                      cba                              ;                             
6225   E444 27 5D                   beq     L1431                    ; bail if iscStepTarg = iscStepMax
6226   E446 87 F1 08 59             brset   port3Snap1, #$08, L1431  ; bail if power steering pump is on                                   
6227   E44A 87 F3 01 55             brset   iscLrnFlags, #$01, L1431 ; bail if notRotating or startingToCrank                               
6228   E44E B6 01 41                ldaa    T0p5_crCold              ; a = T0p5_crCold                                    
6229   E451 26 50                   bne     L1431                    ; bail if timer not expired                              
6230   E453 96 D3                   ldaa    ectFiltered              ; a = ectFiltered                                   
6231   E455 81 1C                   cmpa    #$1c                     ; 86degC                             
6232   E457 24 4A                   bcc     L1431                    ; bail if temperature(ectFiltered) <= 86degC                             
6233   E459 87 D8 10 46             brset   port4Snap, #$10, L1431   ; Bail if timing terminal grounded                                   
6234   E45D B6 01 64                ldaa    iscStStartUsed           ; a = iscStStartUsed                              
6235   E460 26 41                   bne     L1431                    ; Bail if iscStStartUsed != 0                             
6236   E462 8F 16 10 3D             brclr   port5, #$10, L1431       ; Bail if fuel pressure solenoid activated                               
6237   E466             
6238   E466                         ;-----------------------------------------------------------
6239   E466                         ; All the conditions are met, update iscm and iscYn at 1 Hz
6240   E466                         ;-----------------------------------------------------------
6241   E466                         ;------------------------------------------
6242   E466                         ; First check if time has come to update 
6243   E466                         ; variables and then re-init timer 
6244   E466                         ;------------------------------------------
6245   E466 B6 01 26                ldaa    T40_iscLrn              ; a = T40_iscLrn                              
6246   E469 26 38                   bne     L1431                   ; Bail to exit subr. if timer T40_iscLrn not expired (time has not come yet...)                            
6247   E46B 86 28                   ldaa    #$28                    ; Timer is expired, a = 1sec                            
6248   E46D B7 01 26                staa    T40_iscLrn              ; re-init T40_iscLrn to 1 sec                              
6249   E470             
6250   E470                         ;-----------------------------------------
6251   E470                         ; Get current pointers and compute 
6252   E470                         ; newIscm = old iscm + 3 * (iscYn - $80)
6253   E470                         ;-----------------------------------------
6254   E470 BD E4 DD                jsr     iscPointers             ; have x point to isc0 or isc1 and have y point to iscY0, iscY1 or iscY2                                
6255   E473 CC 01 80                ldd     #$0180                  ; d = $0180                              
6256   E476 DD 58                   std     temp2                   ; temp2:temp3 = $0180                             
6257   E478 86 03                   ldaa    #$03                    ; a = $03                             
6258   E47A E6 80                   ldab    $00,y                   ; b = iscYn, y = y + 1                              
6259   E47C CD 09                   decy                            ; y = y - 1  
6260   E47E 3D                      mul                             ; d = 3 * iscYn                             
6261   E47F 93 58                   subd    temp2                   ; d = 3 * (iscYn - $80)                              
6262   E481 E3 00                   addd    $00,x                   ; d = iscm + 3 * (iscYn - $80)                             
6263   E483 BD E4 CC                jsr     iscMinMax               ; Apply min and max to d                                
6264   E486 DD 57                   std     temp1                   ; temp1:temp2 = newIscm = iscm + 3 * (iscYn - $80)                             
6265   E488             
6266   E488                         ;---------------------------------------------------
6267   E488                         ; Compute newIscYn = newIscm + 3 * (iscYn - $80)
6268   E488                         ;---------------------------------------------------
6269   E488 16                      tab                             ; b = newIscm/256                            
6270   E489 A6 80                   ldaa    $00,y                   ; a = iscYn, y = y + 1                             
6271   E48B CD 09                   decy                            ; y = y - 1                             
6272   E48D E0 00                   subb    $00,x                   ; b = newIscm/256 - iscm/256                              
6273   E48F 24 08                   bcc     L1429                   ; Branch to continue if newIscm >= old iscm
6274   E491                                                  
6275   E491                         ;---------------------
6276   E491                         ; newIscm < old iscm
6277   E491                         ;---------------------
6278   E491 50                      negb                            ; b = (iscm - newIscm)/256                              
6279   E492 1B                      aba                             ; a = iscYn + (iscm - newIscm)/256
6280   E493 24 08                   bcc     L1430                   ; Branch if no overflow                             
6281   E495 86 FF                   ldaa    #$ff                    ; Use max of $ff                            
6282   E497 20 04                   bra     L1430                   ; Branch to store           
6283   E499                                           
6284   E499                         ;----------------------
6285   E499                         ; newIscm >= old iscm
6286   E499                         ;----------------------
6287   E499 10          L1429       sba                             ; a = iscYn - (newIscm - iscm)/256
6288   E49A 24 01                   bcc     L1430                   ; branch if no underflow                             
6289   E49C 4F                      clra                            ; Use min of 0                            
6290   E49D             
6291   E49D                         ;---------------------------------------------------------
6292   E49D                         ; At this point 
6293   E49D                         ;               a = newIscYn 
6294   E49D                         ;   [temp1:temp2] = newIscm
6295   E49D                         ;
6296   E49D                         ; Where
6297   E49D                         ;
6298   E49D                         ;     newIscm = oldIscm + 3 * (oldIscYn - $80)
6299   E49D                         ;
6300   E49D                         ;                | oldIscYn + (oldIscm - newIscm)/256 if newIscm < oldIscm
6301   E49D                         ;     newIscYn = |
6302   E49D                         ;                | oldIscYn - (newIscm - oldIscm)/256 if newIscm >= oldIscm
6303   E49D                         ;
6304   E49D                         ;---------------------------------------------------------
6305   E49D A7 80       L1430       staa    $00,y                   ; Update iscYn with new value
6306   E49F DC 57                   ldd     temp1                   ; d = newIscm
6307   E4A1 ED 00                   std     $00,x                   ; Update iscm with new value
6308   E4A3 39          L1431       rts                             ;                             
6309   E4A4             
6310   E4A4             
6311   E4A4             
6312   E4A4             ;******************************************************************
6313   E4A4             ;
6314   E4A4             ; ISC step calculation
6315   E4A4             ;
6316   E4A4             ;    input:  A = step
6317   E4A4             ;    output: A =(~step & 7F)
6318   E4A4             ;
6319   E4A4             ;            (~step & 7F) stored in iscStepCom 
6320   E4A4             ;             step stored in iscStepCurr
6321   E4A4             ;
6322   E4A4             ;
6323   E4A4             ;******************************************************************
6324   E4A4 37          iscStepComp pshb                            ; st0 = val                             
6325   E4A5 16                      tab                             ; b = step                            
6326   E4A6 43                      coma                            ; a = ~step                             
6327   E4A7 84 7F                   anda    #$7f                    ; a = ~step & $7f                             
6328   E4A9 DD 48                   std     iscStepCom              ; iscStepCom = ~step & $7f, iscStepCurr = step
6329   E4AB 33                      pulb                            ; b = val                             
6330   E4AC 39                      rts                             ;                             
6331   E4AD             
6332   E4AD             
6333   E4AD             
6334   E4AD             ;******************************************************************
6335   E4AD             ;
6336   E4AD             ; Increase the value of T40s_iscStable timer if the 
6337   E4AD             ; new value is higher than the current one
6338   E4AD             ; 
6339   E4AD             ; T40s_iscStable = max(T40s_iscStable, b)
6340   E4AD             ;
6341   E4AD             ;******************************************************************
6342   E4AD             updIscStableTimer   
6343   E4AD F1 01 62                cmpb    T40s_iscStable  ;                                  
6344   E4B0 25 03                   bcs     L1434                   ; Branch if b < T40s_iscStable                             
6345   E4B2 F7 01 62                stab    T40s_iscStable          ; Use new higher value                                  
6346   E4B5 39          L1434       rts                             ;                             
6347   E4B6             
6348   E4B6             
6349   E4B6             
6350   E4B6             ;******************************************************************
6351   E4B6             ;
6352   E4B6             ;
6353   E4B6             ; b = min(b,iscStepMax)
6354   E4B6             ;
6355   E4B6             ;
6356   E4B6             ;******************************************************************
6357   E4B6 D1 F0       iscStepMaxFunc cmpb    iscStepMax                                                 
6358   E4B8 25 02                      bcs     L1436                                                 
6359   E4BA D6 F0                      ldab    iscStepMax                                                 
6360   E4BC 39          L1436          rts                                                          
6361   E4BD             
6362   E4BD             
6363   E4BD             
6364   E4BD             ;******************************************************************
6365   E4BD             ;
6366   E4BD             ; Input:
6367   E4BD             ;       b = val1
6368   E4BD             ;
6369   E4BD             ;
6370   E4BD             ;******************************************************************
6371   E4BD D7 57       iscCalc3    stab    temp1                   ; temp1 = val1                             
6372   E4BF 8D 1C                   bsr     iscPointers             ; x points to iscm; y points to iscYn                                 
6373   E4C1 EC 00                   ldd     $00,x                   ; d = iscm                             
6374   E4C3 8D 07                   bsr     iscMinMax               ; apply min and max, d = ...                                  
6375   E4C5 16                      tab                             ; b = iscm/256                             
6376   E4C6 4F                      clra                            ; a = 0                           
6377   E4C7 DB 57                   addb    temp1                   ; b = iscm/256 + val1                             
6378   E4C9 49                      rola                            ; propagate carry, d = iscm/256 + val1                             
6379   E4CA 20 30                   bra     L1445                   ; go to subtract $80 with min check and then make sure result fits in b (max of $ff)                             
6380   E4CC             
6381   E4CC             
6382   E4CC             ;******************************************************************
6383   E4CC             ;
6384   E4CC             ; ISC step related, apply min and max to D
6385   E4CC             ;
6386   E4CC             ; Input:
6387   E4CC             ;       d = val
6388   E4CC             ; Output:
6389   E4CC             ;       d = max($6c00, min($b000, val))
6390   E4CC             ;******************************************************************
6391   E4CC 1C B0 00    iscMinMax   cmpd    #$b000                   ;                              
6392   E4CF 25 03                   bcs     L1439                    ; Branch if d < $b000                             
6393   E4D1 CC B0 00                ldd     #$b000                   ; Use max of $b000                             
6394   E4D4 1C 6C 00    L1439       cmpd    #$6c00                   ;                              
6395   E4D7 24 03                   bcc     L1440                    ; Branch if d >= $6c00                            
6396   E4D9 CC 6C 00                ldd     #$6c00                   ; Use min of $6c00                             
6397   E4DC 39          L1440       rts                              ;                            
6398   E4DD             
6399   E4DD             
6400   E4DD             
6401   E4DD             ;******************************************************************
6402   E4DD             ;
6403   E4DD             ; Get current pointers to ISC step learning variables 
6404   E4DD             ;
6405   E4DD             ;        input: none (port3Snap1 is used)
6406   E4DD             ;       output: X points to isc0 if A/C switch off, isc1 otherwise
6407   E4DD             ;               Y points to iscY0, iscY1 or iscY2
6408   E4DD             ;
6409   E4DD             ;           A/C switch   PS pump        x         y
6410   E4DD             ;              off         off        isc0     iscY0
6411   E4DD             ;              off         on         isc0     iscY2
6412   E4DD             ;              on          off        isc1     iscY1
6413   E4DD             ;              on          on         isc1     iscY2
6414   E4DD             ;
6415   E4DD             ;******************************************************************
6416   E4DD CE 00 44    iscPointers ldx     #isc0                    ; x points to isc0                               
6417   E4E0 CD CE 00 ED             ldy     #iscY0                   ; y points to iscY0                             
6418   E4E4 87 F1 10 04             brset   port3Snap1, #$10, L1442  ; Branch if A/C switch off                                   
6419   E4E8 08                      inx                              ;                            
6420   E4E9 08                      inx                              ; x points to isc1                           
6421   E4EA CD 08                   incy                             ; y points to iscY1                            
6422   E4EC 8F F1 08 04 L1442       brclr   port3Snap1, #$08, L1443  ; Branch if power steering pump is deactivated?                                  
6423   E4F0 CD CE 00 EF             ldy     #iscY2                   ; y points to iscY2                             
6424   E4F4 39          L1443       rts                              ;                            
6425   E4F5             
6426   E4F5             
6427   E4F5             
6428   E4F5             ;******************************************************************
6429   E4F5             ;
6430   E4F5             ; Input:
6431   E4F5             ;       b = val
6432   E4F5             ;
6433   E4F5             ;
6434   E4F5             ;******************************************************************
6435   E4F5 8D E6       iscCalc4    bsr     iscPointers             ; x points to iscm; y points to iscYn                                 
6436   E4F7 4F                      clra                            ; a = 0                             
6437   E4F8 EB 80                   addb    $00,y                   ; d = val + iscYn                              
6438   E4FA 89 00                   adca    #$00                    ; propagate carry                            
6439   E4FC 83 00 80    L1445       subd    #$0080                  ; d = val + iscYn -$80                               
6440   E4FF 24 02                   bcc     L1446                   ; Branch if no underflow                             
6441   E501 4F                      clra                            ;                             
6442   E502 5F                      clrb                            ; Use min of 0                            
6443   E503 7E EB B3    L1446       jmp     ovfCheck                ; Check that result fits in b ($ff max)                                 
6444   E506                         
6445   E506             
6446   E506             
6447   E506             
6448   E506             ;******************************************************************
6449   E506             ;
6450   E506             ; Initialize ISC iscYn variables
6451   E506             ;
6452   E506             ; E931:
6453   E506             ;
6454   E506             ;    iscY0 = $86
6455   E506             ;    iscY1 = $8a
6456   E506             ;    iscY2 = $86
6457   E506             ;
6458   E506             ; E932:
6459   E506             ;
6460   E506             ;    iscY0 = $86     or   iscY0 = $83 
6461   E506             ;    iscY1 = $8a          iscY1 = $83 
6462   E506             ;    iscY2 = $86          iscY2 = $83 
6463   E506             ;
6464   E506             ;******************************************************************
6465   E506             iscYnInit   .equ    $
6466   E506~            #ifdef E931
6467   E506~                        ldaa    #$86                                               
6468   E506~                        ldab    #$8a                                               
6469   E506             #else
6470   E506 86 83                   ldaa    #$83                                                 
6471   E508 16                      tab                                                          
6472   E509 8F F1 20 04             brclr   port3Snap1, #$20, L1448                                     
6473   E50D 86 86                   ldaa    #$86                                                 
6474   E50F C6 8A                   ldab    #$8a                                                 
6475   E511             #endif
6476   E511             
6477   E511 97 ED       L1448       staa    iscY0                                                 
6478   E513 97 EF                   staa    iscY2                                                 
6479   E515 D7 EE                   stab    iscY1                                                 
6480   E517 39                      rts                                                          
6481   E518             
6482   E518             
6483   E518             
6484   E518             ;******************************************************************
6485   E518             ;
6486   E518             ;
6487   E518             ; Sensor check related table, 
6488   E518             ; correspond one for one to table at t_snsrChk
6489   E518             ; Each entry is the bit to set/reset in the faulth:faultl 
6490   E518             ; for the corresponding sensor
6491   E518             ;
6492   E518             ;
6493   E518             ;******************************************************************
6494   E518 02 00 40 00 t_snsrChkBit  .word   $0200, $4000, $8000, $0001    
6494   E51C 80 00 00 01 
6495   E520 00 08 00 10               .word   $0008, $0010, $0040, $2000    
6495   E524 00 40 20 00 
6496   E528 00 04 04 00               .word   $0004, $0400, $0800, $0002    
6496   E52C 08 00 00 02 
6497   E530             
6498   E530             
6499   E530             
6500   E530             ;****************************************************************
6501   E530             ;
6502   E530             ; Used for output of error codes to test connector
6503   E530             ;
6504   E530             ; in order: o2   maf  iat  tps  N/A   ect  cas   tdc    (high fault, $01, $02, $04, $08, $10, $20, $40, $80)
6505   E530             ;           vss  bar  knk  inj  fuel  egr  coil  N/A    (low fault,  $01, $02, $04, $08, $10, $20, $40, $80)
6506   E530             ;
6507   E530             ; Format: 
6508   E530             ;
6509   E530             ;       high nibble = number of "long pulse" to output (max of 7?)
6510   E530             ;        low nibble = number of "short pulse" to output (max of 15?)
6511   E530             ;
6512   E530             ;****************************************************************
6513   E530 11 12 13 14 t_snsrChkCode .byte   $11, $12, $13, $14, $15, $21, $22, $23, $24, $25, $31, $41, $42, $43, $44, $00
6513   E534 15 21 22 23 
6513   E538 24 25 31 41 
6513   E53C 42 43 44 00 
6514   E540             
6515   E540             
6516   E540             
6517   E540             ;****************************************************************
6518   E540             ;
6519   E540             ; Sensor check subroutine vectors
6520   E540             ;
6521   E540             ;****************************************************************
6522   E540 E8 F0 E9 05 t_snsrChk   .word   test_maf,    test_cas,    test_tdc,    test_reed  
6522   E544 E9 12 E9 29 
6523   E548 E9 50 E9 70             .word   test_inj,    test_fpump,  test_coil,   test_ect  
6523   E54C E9 80 E9 AF 
6524   E550 E9 92 E9 98             .word   test_knock,  test_iat,    test_tps,    test_baro  
6524   E554 E9 9E E9 ED 
6525   E558             
6526   E558             
6527   E558             
6528   E558             ;****************************************************************
6529   E558             ;
6530   E558             ; Actuator activate lookup table (OBD command processing)
6531   E558             ;
6532   E558             ;****************************************************************
6533   E558 20 10 08 04 t_obdActMask       .byte   $20, $10, $08, $04, $01, $02
6533   E55C 01 02 
6534   E55E             
6535   E55E             
6536   E55E             
6537   E55E             ;****************************************************************
6538   E55E             ;
6539   E55E             ; Injector disable lookup table (OBD command processing)
6540   E55E             ;
6541   E55E             ;****************************************************************
6542   E55E FB FD F7 FE t_obdInjMask       .byte   $fb, $fd, $f7, $fe      
6543   E562             
6544   E562             
6545   E562             
6546   E562             ;******************************************************************
6547   E562             ;
6548   E562             ;
6549   E562             ; Fourth subroutine
6550   E562             ;
6551   E562             ;
6552   E562             ;******************************************************************
6553   E562                         ;--------------------------------------------------
6554   E562                         ; Reset a few things (most fault codes, etc)
6555   E562                         ; if ECU power has been on for less than 0.5 sec
6556   E562                         ;--------------------------------------------------
6557   E562 B6 01 35    subroutine4 ldaa    T2_EcuPower             ;                             
6558   E565 8B 01                   adda    #$01                    ;                             
6559   E567 24 19                   bcc     L1454                   ; Branch if its been more than 0.5sec since ECU power has been on
6560   E569 02 FC F9                andm    validFlags, #$f9        ; Reset o2 and egrt "sensor condition determined" flags
6561   E56C 03 FC 01                orm     validFlags, #$01        ; set flag indicating no CAS interrupt received for a long time                               
6562   E56F 02 4E 01                andm    faultHi, #$01           ; Reset all current faults but o2 sensor bit
6563   E572 02 4F 20                andm    faultLo, #$20           ; Reset all current faults but egrt sensor bit
6564   E575 86 08                   ldaa    #$08                    ;                             
6565   E577 B7 01 3B                staa    T2_snsrChk              ; re-init T2_snsrChk with 4 sec                             
6566   E57A 86 FF                   ldaa    #$ff                    ;                             
6567   E57C B7 01 3E                staa    T2_stCrank              ; re-init T2_stCrank with max value (127.5sec)                             
6568   E57F 02 D6 EF                andm    state2, #$ef            ; Reset ECT related flag???                                
6569   E582             
6570   E582                         ;------------------------------------
6571   E582                         ; Set flag if engine not rotating
6572   E582                         ;------------------------------------
6573   E582 B6 01 20    L1454       ldaa    T40_engRot                                                 
6574   E585 26 05                   bne     L1455                   ; Branch if engine rotating                              
6575   E587 03 FC 01                orm     validFlags, #$01        ; Engine not rotating (or very slowly) set flag                                
6576   E58A 20 25                   bra     L1458                   ; Branch to continue
6577   E58C                                                                       
6578   E58C                         ;------------------------------------------------------
6579   E58C                         ; If the engine is startingToCrank or was not rotating 
6580   E58C                         ; the last time we were here and is now rotating                                
6581   E58C                         ;
6582   E58C                         ; Update ectStCrank and related timers, the ect when
6583   E58C                         ; we started cranking...
6584   E58C                         ;------------------------------------------------------
6585   E58C 87 FC 01 04 L1455       brset   validFlags, #$01, L1456 ; Branch if engine was not rotating the last time we checked                               
6586   E590 8F E6 01 1D             brclr   state1, #$01, L1458     ; Bail if startingToCrank clear
6587   E594 02 FC FE    L1456       andm    validFlags, #$fe        ;  startingToCrank or was not rotating the last time we were here and is now rotating                                
6588   E597 96 D3                   ldaa    ectFiltered             ;                                    
6589   E599 B7 01 83                staa    ectStCrank              ; ectStCrank = ectFiltered                              
6590   E59C C6 FF                   ldab    #$ff                    ;                             
6591   E59E F7 01 3E                stab    T2_stCrank              ; T2_stCrank = $ff  (127.5sec)                            
6592   E5A1 F7 01 43                stab    T0p5_crank2             ; T0p5_crank2 = $ff  (510sec)                             
6593   E5A4 96 CB                   ldaa    ectRaw                  ;                               
6594   E5A6 C6 5A                   ldab    #$5a                    ; 180sec                            
6595   E5A8 81 1C                   cmpa    #$1c                    ; 86 degC                            
6596   E5AA 23 02                   bls     L1457                   ; Branch if temperature(ectRaw)>= 86degC                              
6597   E5AC C6 B4                   ldab    #$b4                    ; 360 sec                            
6598   E5AE F7 01 78    L1457       stab    egrtTimerThr            ; egrtTimerThr = $5a or $b4 (180sec or 360sec depending on ect)                              
6599   E5B1             
6600   E5B1                         ;-------------------------------------------------
6601   E5B1                         ; Section performing the sensor check functions..
6602   E5B1                         ;-------------------------------------------------
6603   E5B1                         ;--------------------------------------------------------------------------
6604   E5B1                         ; Loop sensrChkIdx from 0 to 7 if T2_stCrank (startingToCrank) started counting 
6605   E5B1                         ; less than 60 sec ago (only first 8 sensor tests are performed,
6606   E5B1                         ; the most important ones I suppose to start the car, except for reed 
6607   E5B1                         ; switch, safety maybe?) else loop at 12 (all tests are performed)
6608   E5B1                         ;--------------------------------------------------------------------------
6609   E5B1 86 08       L1458       ldaa    #$08                    ; a = $08                             
6610   E5B3 F6 01 3E                ldab    T2_stCrank              ; b = T2_stCrank                             
6611   E5B6 CB 78                   addb    #$78                    ; b = T2_stCrank + $78   (60sec)                         
6612   E5B8 25 02                   bcs     L1459                   ; Branch if T2_stCrank started counting less than 60 sec ago
6613   E5BA 8B 04                   adda    #$04                    ; a = $0c                           
6614   E5BC F6 01 79    L1459       ldab    sensrChkIdx             ; b = sensrChkIdx                              
6615   E5BF 11                      cba                             ;                             
6616   E5C0 22 09                   bhi     L1460                   ; Branch to start checking if sensrChkIdx < $0c or $08                             
6617   E5C2             
6618   E5C2                         ;-------------------------------------------------
6619   E5C2                         ; sensrChkIdx >= $0c or $08 
6620   E5C2                         ; re-init T2_snsrChk to 4 sec and sensrChkIdx to 0
6621   E5C2                         ;-------------------------------------------------
6622   E5C2 86 08                   ldaa    #$08                    ;                             
6623   E5C4 B7 01 3B                staa    T2_snsrChk              ; T2_snsrChk = 8 (4 sec)                            
6624   E5C7 5F                      clrb                            ;                             
6625   E5C8 F7 01 79                stab    sensrChkIdx             ; sensrChkIdx = 0                             
6626   E5CB             
6627   E5CB                         ;----------------------------------------------------------
6628   E5CB                         ; Call the sensor check rountine according to sensrChkIdx 
6629   E5CB                         ;----------------------------------------------------------
6630   E5CB 58          L1460       aslb                            ; b = 2*sensrChkIdx (2 bytes per address...)                            
6631   E5CC CE E5 40                ldx     #t_snsrChk              ; x = t_snsrChk
6632   E5CF 3A                      abx                             ; x = t_snsrChk + 2*sensrChkIdx                            
6633   E5D0 CD EE 00                ldy     $00,x                   ; y points to sensor check function                              
6634   E5D3 CE E5 18                ldx     #t_snsrChkBit           ; x = t_snsrChkBit (sensor "fault bit position" table)
6635   E5D6 3A                      abx                             ; x = t_snsrChkBit + 2*sensrChkIdx                           
6636   E5D7 5F                      clrb                            ; b = 0                            
6637   E5D8 AD 80                   jsr     $00,y                   ; call sensor check subroutine                              
6638   E5DA 5D                      tstb                            ;                             
6639   E5DB 27 21                   beq     L1462                   ; Branch if no error found                              
6640   E5DD 2A 29                   bpl     L1463                   ; Branch if inconclusive                             
6641   E5DF             
6642   E5DF                         ;------------------------------------------------------
6643   E5DF                         ; Sensor check returned negative, error is detected 
6644   E5DF                         ; 
6645   E5DF                         ; Check if T2_snsrChk is expired, which would mean we have 
6646   E5DF                         ; been stuck on testing the same sensor for 4 sec and 
6647   E5DF                         ; it never worked properly...)
6648   E5DF                         ;------------------------------------------------------
6649   E5DF EC 00                   ldd     $00,x                   ; [a:b] = t_snsrChkBit(sensrChkIdx)
6650   E5E1 7D 01 3B                tst     T2_snsrChk              ;                                                                                                   
6651   E5E4 27 0A                   beq     L1461                   ; branch if T2_snsrChk is 0 (more than 4 sec elapsed since sensrChkIdx was reset to 0)
6652   E5E6             
6653   E5E6                         ;------------------------------------------------------
6654   E5E6                         ; T2_snsrChk is not expired, don't set the error flags but 
6655   E5E6                         ; if it they were already set increase sensrChkIdx
6656   E5E6                         ; (meaning this sensor was already detected as bad
6657   E5E6                         ; with a 4 sec check, don't do it again for that 
6658   E5E6                         ; sensor, go to the next one)
6659   E5E6                         ;------------------------------------------------------
6660   E5E6 94 4E                   anda    faultHi                 ; 
6661   E5E8 26 1E                   bne     L1463                   ; Branch to increase sensrChkIdx if error bit was already set (if it was located in faultHi)                                                                                               
6662   E5EA D4 4F                   andb    faultLo                 ;                                                                                                  
6663   E5EC 26 1A                   bne     L1463                   ; Branch to increase sensrChkIdx if error bit was alrready set (if it was located in faultLo)                                                                                               
6664   E5EE 20 20                   bra     L1464                   ; Error bit was not already set, don't change sensrChkIdx (check it agaian next time)                                                                                               
6665   E5F0             
6666   E5F0                         ;-----------------------------------------------------------------------
6667   E5F0                         ; More than 4 sec elapsed since sensrChkIdx was reset to 0
6668   E5F0                         ; (this means that we have been stuck on testing the same sensor
6669   E5F0                         ; for 4 sec and it never worked properly...)
6670   E5F0                         ;
6671   E5F0                         ; Set the error flags and increase sensrChkIdx
6672   E5F0                         ;-----------------------------------------------------------------------
6673   E5F0 9A 4E       L1461       oraa    faultHi                ; Set the error bit if located in faultHi                                                                                       
6674   E5F2 DA 4F                   orab    faultLo                ; Set the error bit if located in faultLo                                                                                                  
6675   E5F4 DD 4E                   std     faultHi                ; Update faultHi:faultLo
6676   E5F6 9A 4C                   oraa    stFaultHi              ; Set the error bit if located in stFaultHi
6677   E5F8 DA 4D                   orab    stFaultLo              ; Set the error bit if located in stFaultLo
6678   E5FA DD 4C                   std     stFaultHi              ; Update stFaultHi:stFaultLo
6679   E5FC 20 0A                   bra     L1463                  ; Branch to increase sensrChkIdx                                                                                               
6680   E5FE             
6681   E5FE                         ;---------------------------------------------------
6682   E5FE                         ; Sensor check returned zero, no error, reset bit
6683   E5FE                         ;---------------------------------------------------
6684   E5FE EC 00       L1462       ldd     $00,x                   ; [a:b] = t_snsrChkBit(sensrChkIdx)
6685   E600 43                      coma                            ; complement all bits                            
6686   E601 53                      comb                            ; complement all bits                            
6687   E602 94 4E                   anda    faultHi                 ; reset the bit if it was in faultHi 
6688   E604 D4 4F                   andb    faultLo                 ; reset the bit if it was in faultLo                               
6689   E606 DD 4E                   std     faultHi                 ; Update faultHi:faultLo                                
6690   E608             
6691   E608                         ;------------------------------------------------------
6692   E608                         ; Go to next sensor and re-init T2_snsrChk to 4 sec 
6693   E608                         ;------------------------------------------------------
6694   E608 7C 01 79    L1463       inc     sensrChkIdx             ; Increment index (go to next sensor check subroutine next time)                                    
6695   E60B 86 08                   ldaa    #$08                    ; 4 sec                            
6696   E60D B7 01 3B                staa    T2_snsrChk              ; re-init timer to 4 sec                                  
6697   E610             
6698   E610                         ;-------------------------------------------------------------------------------
6699   E610                         ; Section to verify the O2 sensor under specific conditions 
6700   E610                         ;-------------------------------------------------------------------------------
6701   E610                         ;-------------------------------------------------------------------------------
6702   E610                         ; First check if o2Raw indicate rich or lean, set a flag in b for now
6703   E610                         ;-------------------------------------------------------------------------------
6704   E610 5F          L1464       clrb                            ; assume we are running lean, b = 0                            
6705   E611 96 CE                   ldaa    o2Raw                   ; a = o2Raw                             
6706   E613 81 1F                   cmpa    #$1f                    ;                             
6707   E615 25 02                   bcs     L1465                   ; Branch if o2Raw < 0.6V (lean)                             
6708   E617 CA 80                   orab    #$80                    ; Set flag indicating we are running rich
6709   E619                                                     
6710   E619                         ;-------------------------------------------------------------------------------
6711   E619                         ; Now check if all the conditions are met to do the verfication
6712   E619                         ;
6713   E619                         ;       engine has been running for more than 180sec
6714   E619                         ;       baro sensor value is reliable
6715   E619                         ;       no fault code on baro, coil, iat, ect, cas
6716   E619                         ;       ectRaw and iatRaw are within acceptable range
6717   E619                         ;       temperature(ectRaw) > 86degC
6718   E619                         ;       temperature(iatRaw) > 0degC
6719   E619                         ;       temperature(iatRaw) < 55degC
6720   E619                         ;       engine is running normally (no fuel cut, etc..)
6721   E619                         ;       airVolTB < $68 
6722   E619                         ;       airVolTB > $33
6723   E619                         ;       rpm31 < 4000
6724   E619                         ;       rpm31 > 2000
6725   E619                         ;       all conditions for closed loop mode are met
6726   E619                         ;
6727   E619                         ;-------------------------------------------------------------------------------
6728   E619 B6 01 43    L1465       ldaa    T0p5_crank2             ; a = T0p5_crank2                              
6729   E61C 8B 5A                   adda    #$5a                    ;                             
6730   E61E 25 5E                   bcs     L1467                   ; Bail if its been less than 180sec since engine started rotating                             
6731   E620 B6 01 1B                ldaa    T40_baro                ; T40_baro                                 
6732   E623 26 59                   bne     L1467                   ; Bail if T40_baro not zero (meaning baro sensor value is not reliable)
6733   E625 87 4F 42 55             brset   faultLo, #$42, L1467    ; Bail if errors on baro or coil                                 
6734   E629 87 4E 26 51             brset   faultHi, #$26, L1467    ; Bail if errors on iat, ect or cas                                 
6735   E62D 87 D6 03 4D             brset   state2, #$03, L1467     ; Bail ifectRaw or iatRaw out of acceptable range                                
6736   E631 96 CB                   ldaa    ectRaw                  ; a = ectRaw                              
6737   E633 81 1C                   cmpa    #$1c                    ;                             
6738   E635 24 47                   bcc     L1467                   ; Bail if temperature(ectRaw) <= 86degC                             
6739   E637 96 CC                   ldaa    iatRaw                  ; a = iatRaw                               
6740   E639 81 B3                   cmpa    #$b3                    ;                             
6741   E63B 24 41                   bcc     L1467                   ; Bail if temperature(iatRaw) <= 0degC                              
6742   E63D 81 41                   cmpa    #$41                    ;                             
6743   E63F 23 3D                   bls     L1467                   ; Bail if  temperature(iatRaw) >= 55degC                               
6744   E641 87 E6 1F 39             brset   state1, #$1f, L1467     ; Bail if engine not running normally (i.e. notRotating or startingToCrank or rotatingStopInj or runningFast or no pulse accumulator interrupts received )
6745   E645 96 E2                   ldaa    airVolTB                ; a = airVolTB 
6746   E647~            #ifdef E931
6747   E647~                        cmpa    #$68                    ;                             
6748   E647~                        bcc     L1467                   ; Bail if airVolTB >= $68 
6749   E647~                        cmpa    #$33                    ;                             
6750   E647             #else
6751   E647 81 90                   cmpa    #$90                    ;                             
6752   E649 24 33                   bcc     L1467                   ;                              
6753   E64B 81 1A                   cmpa    #$1a                    ;                             
6754   E64D             #endif
6755   E64D 23 2F                   bls     L1467                   ; Bail if airVolTB <= $33 
6756   E64F 96 DD                   ldaa    rpm31                   ; a = rpm31                              
6757   E651 81 80                   cmpa    #$80                    ;                             
6758   E653 24 29                   bcc     L1467                   ; Bail if rpm31 >= 4000                              
6759   E655 81 40                   cmpa    #$40                    ;                             
6760   E657 23 25                   bls     L1467                   ; Bail if rpm31 <= 2000                              
6761   E659 8F E8 02 21             brclr   closedLpFlags, #$02, L1467   ; Bail if not all conditions for closed loop mode are met
6762   E65D             
6763   E65D                         ;---------------------------------------------------------
6764   E65D                         ; All the conditions are met
6765   E65D                         ; At this point, b = $80 if o2Raw is rich, $00 otherwise
6766   E65D                         ;---------------------------------------------------------
6767   E65D 17                      tba                             ; a = $80 if o2Raw rich else $00                               
6768   E65E 9B FC                   adda    validFlags              ; a = validFlags + ($80 or $00)                              
6769   E660 2B 16                   bmi     L1466                   ; Branch if running rich (validFlags + ($80 or $00) > $80 only if o2Raw>=0.6V above...)                             
6770   E662             
6771   E662                         ;-------------------------------
6772   E662                         ; Running lean (o2Raw < 0.6V)
6773   E662                         ;-------------------------------
6774   E662 B6 01 3C                ldaa    T2_o2Chk                ; a = T2_o2Chk                            
6775   E665 26 1C                   bne     L1468                   ; Branch if timer not expired, its been less than 30sec since all conditions were met and we are running lean                            
6776   E667 87 FC 02 18             brset   validFlags, #$02, L1468 ; Branch if o2 sensor condition already determined (no need to check further)
6777   E66B             
6778   E66B                         ;------------------------------------------------------
6779   E66B                         ; Timer is expired and the o2 sensor condition is not 
6780   E66B                         ; already determined. Since we have been running lean
6781   E66B                         ; for over 30sec, we know the sensor is bad...
6782   E66B                         ;
6783   E66B                         ; Set the flag indicating the o2 sensor conditions was
6784   E66B                         ; determined, and increment o2BadCnt (with max of 255) to
6785   E66B                         ; indicate we have an error condition
6786   E66B                         ; Note that o2BadCnt increase by 1 max every time 
6787   E66B                         ; the ECU is turned on (which resets validFlags.1)
6788   E66B                         ;------------------------------------------------------
6789   E66B 03 FC 02                orm     validFlags, #$02        ; Set flag indicating o2 sensor condition was checked (bad in this case)                               
6790   E66E 7C 00 50                inc     o2BadCnt                ; o2BadCnt = o2BadCnt + 1                              
6791   E671 26 10                   bne     L1468                   ; Branch to continue if o2BadCnt != 0                              
6792   E673 7A 00 50                dec     o2BadCnt                ; o2BadCnt equals 0, go back to 255                               
6793   E676 20 0B                   bra     L1468                   ; branch to continue                             
6794   E678             
6795   E678                         ;-----------------------------------------------------------------
6796   E678                         ; Running rich (o2Raw >= 0.6V)
6797   E678                         ; As soon as we are running rich we know the sensor 
6798   E678                         ; is good, clear fault and set flag indicating o2 sensor 
6799   E678                         ; conditions was determined (good in this case)
6800   E678                         ;-----------------------------------------------------------------
6801   E678 7F 00 50    L1466       clr     o2BadCnt                ; o2BadCnt = 0                               
6802   E67B 03 FC 02                orm     validFlags, #$02             ; Set flag indicating o2 sensor condition was checked (ok in this case)                               
6803   E67E             
6804   E67E                         ;-------------------------------
6805   E67E                         ; Re-init timer T2_o2Chk to 30sec
6806   E67E                         ;-------------------------------
6807   E67E 86 3C       L1467       ldaa    #$3c                    ; 30sec                             
6808   E680 B7 01 3C                staa    T2_o2Chk                ;                             
6809   E683             
6810   E683                         ;------------------------------------------------------------
6811   E683                         ; Update validFlags.7 rich/lean flag with current o2 conditions
6812   E683                         ;------------------------------------------------------------
6813   E683 02 FC 7F    L1468       andm    validFlags, #$7f             ; Reset rich/lean flag 
6814   E686 DB FC                   addb    validFlags                   ; Add current rich/lean flag (set to 1 if rich)                            
6815   E688 D7 FC                   stab    validFlags                   ; Update validFlags                             
6816   E68A             
6817   E68A                         ;---------------------------------------------------------------------------
6818   E68A                         ; if o2BadCnt >= 1, set o2 fault code in current and stored fault variables
6819   E68A                         ;---------------------------------------------------------------------------
6820   E68A 96 50                   ldaa    o2BadCnt                ;                               
6821   E68C 81 01                   cmpa    #$01                    ;                             
6822   E68E 25 08                   bcs     L1469                   ; Branch to no o2 fault if o2BadCnt=0                             
6823   E690 03 4E 01                orm     faultHi, #$01           ; set oxygen sensor fault code?
6824   E693 03 4C 01                orm     stFaultHi, #$01         ;                                    
6825   E696 20 03                   bra     L1470                   ;                              
6826   E698             
6827   E698                         ;------------------------------------------------------------
6828   E698                         ; Reset o2 fault code in only current fault variables
6829   E698                         ;------------------------------------------------------------
6830   E698 02 4E FE    L1469       andm    faultHi, #$fe           ; Clear oxygen sensor fault code
6831   E69B             
6832   E69B                         ;-------------------------------------------------------------------------------
6833   E69B                         ; Check if all the conditions are met to test the egrt sensor validity
6834   E69B                         ;
6835   E69B                         ;       more than ($5a or $b4)/0.5 sec have elapsed since engine started rotating                             
6836   E69B                         ;       baro sensor value is reliable
6837   E69B                         ;       no fault code on baro, coil, iat, ect, cas
6838   E69B                         ;       ectRaw and iatRaw are within acceptable range
6839   E69B                         ;       temperature(ectRaw) > 86degC
6840   E69B                         ;       temperature(iatRaw) < 55degC
6841   E69B                         ;       baroRaw > 0.92bar
6842   E69B                         ;       rpm31 < 3500
6843   E69B                         ;       rpm31 > 2094
6844   E69B                         ;       airVol < L2048(rpm)
6845   E69B                         ;       airVol > L2047(rpm)
6846   E69B                         ;
6847   E69B                         ;-------------------------------------------------------------------------------
6848   E69B B6 01 78    L1470       ldaa    egrtTimerThr            ; a = egrtTimerThr                             
6849   E69E BB 01 43                adda    T0p5_crank2             ;                               
6850   E6A1 25 61                   bcs     L1474                   ; Bail if less than ($5a or $b4)/0.5 sec have elapsed since engine started rotating                             
6851   E6A3 B6 01 1B                ldaa    T40_baro                ;                                 
6852   E6A6 26 5C                   bne     L1474                   ; Bail if T40_baro not zero (meaning baro sensor value is not reliable)
6853   E6A8 87 4F 42 58             brset   faultLo, #$42, L1474    ; Bail if errors on baro or coil                                      
6854   E6AC 87 4E 26 54             brset   faultHi, #$26, L1474    ; Bail if errors on iat, ect or cas                                  
6855   E6B0 87 D6 03 50             brset   state2, #$03, L1474     ; Bail ifectRaw or iatRaw out of acceptable range                                
6856   E6B4 96 CB                   ldaa    ectRaw                  ;                               
6857   E6B6 81 1C                   cmpa    #$1c                    ;                             
6858   E6B8 24 4A                   bcc     L1474                   ; Bail if temperature(ectRaw) <= 86degC                             
6859   E6BA 96 CC                   ldaa    iatRaw                  ;                               
6860   E6BC 81 42                   cmpa    #$42                    ;                             
6861   E6BE 23 44                   bls     L1474                   ; Bail if  temperature(iatRaw) >= 55degC                             
6862   E6C0 96 CD                   ldaa    baroRaw                 ;                                
6863   E6C2 81 BD                   cmpa    #$bd                    ;                             
6864   E6C4 25 3E                   bcs     L1474                   ; Bail if baroRaw < 0.92bar                               
6865   E6C6 96 DD                   ldaa    rpm31                   ;                              
6866   E6C8 81 70                   cmpa    #$70                    ;                             
6867   E6CA 24 38                   bcc     L1474                   ; Bail if rpm >=3500                              
6868   E6CC 81 43                   cmpa    #$43                    ;                             
6869   E6CE 23 34                   bls     L1474                   ; Bail if rpm <= 2094                              
6870   E6D0 CE FF A1                ldx     #L2048                  ;                               
6871   E6D3 BD EB 34                jsr     interp16rpm             ; b = L2048(rpm)                                    
6872   E6D6 D1 E0                   cmpb    airVol                  ;                               
6873   E6D8 23 2A                   bls     L1474                   ; Bail if airVol >= L2048(rpm)                               
6874   E6DA CE FF 97                ldx     #L2047                  ;                               
6875   E6DD BD EB 34                jsr     interp16rpm             ; b = L2047(rpm)                                   
6876   E6E0 D1 E0                   cmpb    airVol                  ;                               
6877   E6E2 24 20                   bcc     L1474                   ; Bail if airVol <= L2047(rpm)                              
6878   E6E4             
6879   E6E4                         ;------------------------------------------
6880   E6E4                         ; All basic condition are met,
6881   E6E4                         ; bail if T2_egrtChk > 10
6882   E6E4                         ;------------------------------------------
6883   E6E4 B6 01 3D                ldaa    T2_egrtChk              ;                             
6884   E6E7 81 0A                   cmpa    #$0a                    ;                             
6885   E6E9 22 3A                   bhi     L1478                   ; Bail if T2_egrtChk > 10 ????      
6886   E6EB                                                
6887   E6EB                         ;----------------------------------------------------
6888   E6EB                         ; All basic condition are met and  T2_egrtChk <= 10
6889   E6EB                         ; Check the temperature indicated by the egrt 
6890   E6EB                         ; sensor and branch accordingly 
6891   E6EB                         ;----------------------------------------------------
6892   E6EB 86 05                   ldaa    #$05                    ;                             
6893   E6ED 91 CF                   cmpa    egrtRaw                 ;                                
6894   E6EF 22 20                   bhi     L1477                   ; Branch if temperature(egrtRaw) > 307degCC (error, too hot)                            
6895   E6F1 CE FF 90                ldx     #L2046                  ;                               
6896   E6F4 BD EB 39                jsr     iatCInterp              ; b = L2046(iat)                                  
6897   E6F7 D1 CF                   cmpb    egrtRaw                 ;                                
6898   E6F9 25 16                   bcs     L1477                   ; Branch if temperature(egrtRaw) < L2046(iat) (error, too cold)                               
6899   E6FB             
6900   E6FB                         ;--------------------------------------------------------
6901   E6FB                         ; At this point we know the egrt sensor is good 
6902   E6FB                         ; clear fault and set flag indicating sensor condition
6903   E6FB                         ; was determined (good in this case)
6904   E6FB                         ;--------------------------------------------------------
6905   E6FB 7F 00 51                clr     egrtBadCnt              ; egrtBadCnt = 0, no fault                               
6906   E6FE 03 FC 04                orm     validFlags, #$04             ; Set flag indicating sensor condition was checked (ok in this case)                               
6907   E701 4F                      clra                            ; a = 0                            
6908   E702 20 02                   bra     L1475                   ; Branch to set timer to 5 sec such that we continously check the sensor                           
6909   E704             
6910   E704                         ;----------------------------------------
6911   E704                         ; Reset T2_egrtChk timer to 20 sec and bail
6912   E704                         ;----------------------------------------
6913   E704 86 1E       L1474       ldaa    #$1e                    ; a = 15sec                            
6914   E706 8B 0A       L1475       adda    #$0a                    ; a = a + 5sec                            
6915   E708 24 02                   bcc     L1476                   ; Branch if no overflow                             
6916   E70A 86 FF                   ldaa    #$ff                    ; Use max of $ff                            
6917   E70C B7 01 3D    L1476       staa    T2_egrtChk              ; Update T2_egrtChk                            
6918   E70F 20 14                   bra     L1478                   ; Bail                             
6919   E711             
6920   E711                         ;----------------------------------------------------------------------------------
6921   E711                         ; At this point we found that the sensor temperature is out of range (bad sensor)
6922   E711                         ;----------------------------------------------------------------------------------
6923   E711 B6 01 3D    L1477       ldaa    T2_egrtChk            ; a = T2_egrtChk                             
6924   E714 26 0F                   bne     L1478                   ; Branch if timer not expired                             
6925   E716 87 FC 04 0B             brset   validFlags, #$04, L1478      ; Branch if egrt sensor condition already determined
6926   E71A             
6927   E71A                         ;--------------------------------------------------------------------------
6928   E71A                         ; Sensor is bad, timer is expired and sensor condition not yet determined
6929   E71A                         ;
6930   E71A                         ; Set flag indicating sensor condition was determined (bad in this case)
6931   E71A                         ; and increment egrtBadCnt (255 max) to indicate we have an error condition 
6932   E71A                         ; Note that egrtBadCnt increase by 1 max every time the ECU is turned off/on
6933   E71A                         ; (which resets validFlags.1)
6934   E71A                         ;--------------------------------------------------------------------------
6935   E71A 03 FC 04                orm     validFlags, #$04             ; Set flag                               
6936   E71D 7C 00 51                inc     egrtBadCnt              ; egrtBadCnt = egrtBadCnt + 1                              
6937   E720 26 03                   bne     L1478                   ; Bail if egrtBadCnt != 0                               
6938   E722 7A 00 51                dec     egrtBadCnt              ; egrtBadCnt equals 0, go back to 255                              
6939   E725             
6940   E725                         ;---------------------------------------------------------------------------
6941   E725                         ; if egrtBadCnt >= 2, set egrt fault code in current and stored fault variables
6942   E725                         ;
6943   E725                         ; egrtBadCnt >= 2 only if the ECU is turned off and then on again 
6944   E725                         ;---------------------------------------------------------------------------
6945   E725 96 51       L1478       ldaa    egrtBadCnt              ;                               
6946   E727 81 02                   cmpa    #$02                    ;                             
6947   E729 25 08                   bcs     L1479                   ; Branch if egrtBadCnt < 2
6948   E72B 03 4F 20                orm     faultLo, #$20           ; Set egrt sensor fault flag                                 
6949   E72E 03 4D 20                orm     stFaultLo, #$20         ; Set egrt sensor fault flag                                   
6950   E731 20 03                   bra     L1480                   ;                              
6951   E733             
6952   E733                         ;------------------------------------------------
6953   E733                         ; Reset egrt fault code in current fault variable
6954   E733                         ;------------------------------------------------
6955   E733 02 4F DF    L1479       andm    faultLo, #$df           ;                                  
6956   E736             
6957   E736                         ;---------------------------------------------------------------------------
6958   E736                         ; Reset egrt errors and fault codes if vehicle is not for California 
6959   E736                         ;---------------------------------------------------------------------------
6960   E736 87 55 04 09 L1480       brset   config1, #$04, L1481    ; Bail if California car                                
6961   E73A 7F 00 51                clr     egrtBadCnt              ; reset egrt error count                               
6962   E73D 02 4D DF                andm    stFaultLo, #$df         ; Reset egrt stored fault code                                   
6963   E740 02 4F DF                andm    faultLo, #$df           ; Reset egrt current fault code                                 
6964   E743             
6965   E743                         ;---------------------------------------------------------------------------
6966   E743                         ; Reset N/A stored fault codes (fault codes don't correspond to anything)
6967   E743                         ;---------------------------------------------------------------------------
6968   E743 02 4C EF    L1481       andm    stFaultHi, #$ef         ;                                    
6969   E746 02 4D 7F                andm    stFaultLo, #$7f         ;                                    
6970   E749             
6971   E749                         ;----------------------------------------------------------------
6972   E749                         ; If ECU is not about to turn-off check if there are faults set
6973   E749                         ; and inital 5 sec "check engine light on" delay
6974   E749                         ;----------------------------------------------------------------
6975   E749 B6 01 24                ldaa    T40_noPower             ;                                    
6976   E74C 27 11                   beq     L1482                   ; Branch to clear check engine light if timer expired (ECU is about to turn-off)
6977   E74E DC 4E                   ldd     faultHi                 ; d = faultHi:faultLo (current faults)                               
6978   E750 84 EF                   anda    #$ef                    ; Reset N/A sensor fault bit                             
6979   E752 26 10                   bne     L1483                   ; Branch to set check engine light if any errors left in faultHi
6980   E754 C4 7E                   andb    #$7e                    ; Reset vss and baro sensor in faultLo                            
6981   E756 26 0C                   bne     L1483                   ; Branch to set check engine light if any errors left in faultLo
6982   E758 B6 01 35                ldaa    T2_EcuPower             ;                                    
6983   E75B 8B 0A                   adda    #$0a                    ;                             
6984   E75D 25 05                   bcs     L1483                   ; Branch if its been less than 5 sec since ECU power has been on                             
6985   E75F             
6986   E75F                         ;------------------------------------------------------------------
6987   E75F                         ; Its been more than 5 sec since ECU power has been on
6988   E75F                         ; and there is no fault set in faultHi:faultLo (apart from vss)
6989   E75F                         ; and ECU in not about to turn off
6990   E75F                         ;
6991   E75F                         ; Clear check engine light                             
6992   E75F                         ;------------------------------------------------------------------
6993   E75F 03 2F 08    L1482       orm     port6, #$08             ; clear CE light                                                                            
6994   E762 20 03                   bra     L1484                   ;                                                                                             
6995   E764             
6996   E764                         ;-------------------------------------------------------------
6997   E764                         ; Its been less than 5 sec since ECU power has been on
6998   E764                         ; or there are faults set in faultHi:faultLo (apart from vss) 
6999   E764                         ; or ECU is about to turn off
7000   E764                         ;
7001   E764                         ; Activate check engine light                             
7002   E764                         ;-------------------------------------------------------------
7003   E764 02 2F F7    L1483       andm    port6, #$f7             ; activate CE light                                                                               
7004   E767             
7005   E767             
7006   E767                         ;-----------------------------------------------------------------
7007   E767                         ; Section to process diagnostic connector port commands/requests
7008   E767                         ;-----------------------------------------------------------------
7009   E767                         ;--------------------------------------------------------------
7010   E767                         ; Bail to "heart beat" mode section if port rx is not enabled
7011   E767                         ;--------------------------------------------------------------
7012   E767 87 11 08 03 L1484       brset   sci_scr, #$08, L1485    ; Branch if serial port rx enabled.                                                                      
7013   E76B 7E E8 4F                jmp     L_heartBeat             ; rx not enabled, branch to section processing heart beat code
7014   E76E             
7015   E76E                         ;-----------------------------------------------------------
7016   E76E                         ; rx is enabled, we are in test mode. Check if anything 
7017   E76E                         ; is being transmited or if anything new was received
7018   E76E                         ;-----------------------------------------------------------
7019   E76E 8F 11 20 04 L1485       brclr   sci_scr, #$20, L1486    ; Branch if transmit data register is not empty (1 = empty...)                                 
7020   E772 87 FA 40 0C             brset   obdFlags, #$40, L1487   ; tx empty, branch if anything to process (e.g. a code was received (in interupt) and stored in obdCode)?
7021   E776             
7022   E776                         ;-------------------------------------------------
7023   E776                         ; At this point rx enabled but tx not empty 
7024   E776                         ; or it is empty but there is nothing to process
7025   E776                         ;
7026   E776                         ; Reset action related registers and bail
7027   E776                         ;-------------------------------------------------
7028   E776 03 BA 3F    L1486       orm     obdInjCmd, #$3f         ; reset any injector action
7029   E779 7F 00 FB                clr     obdActCmd               ; reset any actuator action
7030   E77C 7F 01 2D                clr     T40_obdCmd              ; Clear action timer                                                                         
7031   E77F 7E E8 44                jmp     L1504                   ; Bail to rest of code                                               
7032   E782             
7033   E782                         ;------------------------------------------------------------
7034   E782                         ; At this point we are in test mode, transmit register is 
7035   E782                         ; empty and a new code was received and stored in obdCode
7036   E782                         ; Process the new code,
7037   E782                         ;------------------------------------------------------------
7038   E782                         ;------------------------------------------
7039   E782                         ; Check if code is $fd (serial link test)
7040   E782                         ;------------------------------------------
7041   E782~            #ifdef E931
7042   E782~            L1487       ldaa    #$b5                    ; Default value returned if code = $fd. (serial link test)
7043   E782             #else
7044   E782 86 B7       L1487       ldaa    #$b7                    ; Default value returned if code = $fd. (serial link test)
7045   E784             #endif
7046   E784 F6 01 7A                ldab    obdCode                 ; load received OBD code                       
7047   E787 C1 FD                   cmpb    #$fd                    ;                                              
7048   E789 25 11                   bcs     L1490                   ; branch if code is lower than $FD             
7049   E78B 27 5D                   beq     L1496                   ; bail to send response if code is equal to $fd
7050   E78D             
7051   E78D                         ;--------------------------------------------------------
7052   E78D                         ; obdCode equals $fe or $ff, respond with high or low
7053   E78D                         ; part ($fe or $ff code) of configration data (t_strap3)
7054   E78D                         ;--------------------------------------------------------
7055   E78D CE FB 17                ldx     #t_strap3               ; x = configuration data
7056   E790 17                      tba                             ;                                              
7057   E791 BD EC 02                jsr     cfgLookup16             ;                                              
7058   E794 81 FE                   cmpa    #$fe                    ; compare to FE                                
7059   E796 1A                      xgdx                            ;
7060   E797 27 01                   beq     L1489                   ;
7061   E799 17                      tba                             ;
7062   E79A 20 4E       L1489       bra     L1496                   ; branch to send on serial                                    
7063   E79C             
7064   E79C                         ;------------------------
7065   E79C                         ; obdCode lower than $fd
7066   E79C                         ;------------------------
7067   E79C C1 F1       L1490       cmpb    #$f1                    ;                                                             
7068   E79E 24 32                   bcc     L1494                   ; branch if code is larger or equal to $f1                    
7069   E7A0 C1 40                   cmpb    #$40                    ;                                                             
7070   E7A2 25 0A                   bcs     L1491                   ; branch if code is lower than $40                            
7071   E7A4             
7072   E7A4                         ;------------------------
7073   E7A4                         ; $40 <= obdCode < $f1
7074   E7A4                         ; Check if it is $ca
7075   E7A4                         ;------------------------
7076   E7A4 C1 CA                   cmpb    #$ca                    ;                                                             
7077   E7A6 27 18                   beq     L1493                   ; branch if code equals $ca                                    
7078   E7A8             
7079   E7A8                         ;----------------------------------------------------------------------
7080   E7A8                         ; $40 <= obdCode < $f1 and it is not $ca
7081   E7A8                         ; just respond with whatever is stored in the corresponding memory
7082   E7A8                         ;----------------------------------------------------------------------
7083   E7A8 4F                      clra                            ; a=0
7084   E7A9 1A                      xgdx                            ; x = obdCode
7085   E7AA A6 00                   ldaa    $00,x                   ; a = whatever is in corresponding memory
7086   E7AC 20 3C                   bra     L1496                   ; branch to send on serial                                    
7087   E7AE             
7088   E7AE                         ;----------------------------------------------------------------------
7089   E7AE                         ; obdCode lower than $40, respond with sensor value 
7090   E7AE                         ; ($3e and $3f are converted to $3d)
7091   E7AE                         ;----------------------------------------------------------------------
7092   E7AE CE D0 00    L1491       ldx     #obdTable               ; x points to obdTable
7093   E7B1 C1 3D                   cmpb    #$3d                    ;                                                             
7094   E7B3 23 02                   bls     L1492                   ; branch if obdCode <= $3d                                         
7095   E7B5 C6 3D                   ldab    #$3d                    ; Use max of $3d ($3e and $3f are converted to $3d???)                     
7096   E7B7 3A          L1492       abx                             ; x points to "sensor" address in table                                
7097   E7B8 E6 00                   ldab    $00,x                   ; b = obdTable(obdCode)
7098   E7BA 4F                      clra                            ; a = 0                                                            
7099   E7BB 1A                      xgdx                            ; x = d = obdTable(obdCode)
7100   E7BC A6 00                   ldaa    $00,x                   ; a = sensor value
7101   E7BE 20 2A                   bra     L1496                   ; branch to send on serial                                    
7102   E7C0             
7103   E7C0                         ;----------------------------------------------------
7104   E7C0                         ; obdCode = $ca, clear error faults if engine is not 
7105   E7C0                         ; rotating and respond with $00
7106   E7C0                         ;----------------------------------------------------
7107   E7C0 B6 01 20    L1493       ldaa    T40_engRot              ;                                                                                                         
7108   E7C3 26 6C                   bne     L1502                   ; Don't reset fault codes if engine is rotating, we use them to run the car...                                                                     
7109   E7C5 4F                      clra                            ;                                                                                                         
7110   E7C6 5F                      clrb                            ;                                                                                                                                      
7111   E7C7 DD 4C                   std     stFaultHi               ; Erase fault codes                                                                                                                     
7112   E7C9 DD 4E                   std     faultHi                 ; Erase fault codes                                                                                                                     
7113   E7CB 97 50                   staa    o2BadCnt                ; Erase o2 sensor error count
7114   E7CD 97 51                   staa    egrtBadCnt              ; Erase egrt sensor error count
7115   E7CF 4F                      clra                            ;                                                                                                                                      
7116   E7D0 20 18                   bra     L1496                   ; Branch to send $00 on serial
7117   E7D2                                                                                                                                                                   
7118   E7D2                         ;----------------------------------------------------
7119   E7D2                         ; obdCode >= $f1, this is a command/action code
7120   E7D2                         ; Check if any action is already ongoing
7121   E7D2                         ;----------------------------------------------------
7122   E7D2 96 BA       L1494       ldaa    obdInjCmd               ; a = obdInjCmd            
7123   E7D4 43                      coma                            ; a = ~obdInjCmd           
7124   E7D5 84 3F                   anda    #$3f                    ; a = ~obdInjCmd & 00111111                                                                                                                                        
7125   E7D7 26 04                   bne     L1495                   ; branch if any injector already turned-off
7126   E7D9 8F FB FF 10             brclr   obdActCmd, #$ff, L1497  ; branch to continue processing if no actuator previously activated
7127   E7DD                                                                                                                      
7128   E7DD                         ;----------------------------------------------------
7129   E7DD                         ; obdCode >= $f1 and an action is already ongoing
7130   E7DD                         ;----------------------------------------------------
7131   E7DD B6 01 2D    L1495       ldaa    T40_obdCmd              ; 
7132   E7E0 26 0B                   bne     L1497                   ; Branch if timer not expired                                                                                                                                      
7133   E7E2             
7134   E7E2                         ;----------------------------------------------------
7135   E7E2                         ; Action already ongoing and timer is expired,
7136   E7E2                         ; reset all injector and actuators to normal mode and 
7137   E7E2                         ; respond with $00 (ignore new action)
7138   E7E2                         ;----------------------------------------------------
7139   E7E2 03 BA 3F                orm     obdInjCmd, #$3f         ; set all injectors to normal operation                                                                                                                 
7140   E7E5 7F 00 FB                clr     obdActCmd               ; clear current actuator commands                                                                                                                 
7141   E7E8 86 00                   ldaa    #$00                    ;                                                                                                                                      
7142   E7EA 7E E8 3C    L1496       jmp     L1503                   ;                                                                                                                                       
7143   E7ED             
7144   E7ED                         ;-----------------------------------------------
7145   E7ED                         ; No action is ongoing or an action is ongoing 
7146   E7ED                         ; but not finished (timer not expired)
7147   E7ED                         ;
7148   E7ED                         ; continue processing new code
7149   E7ED                         ;-----------------------------------------------
7150   E7ED C1 F6       L1497       cmpb    #$f6                    ;                                                                                                                                      
7151   E7EF 23 06                   bls     L1498                   ; branch if code is $f1 to $f6                                                                                                            
7152   E7F1             
7153   E7F1                         ;-----------------------------------------------------------
7154   E7F1                         ; $f7 <= obdCode <= $fc, this is a turn injector off command
7155   E7F1                         ; Bail if vehicle is moving
7156   E7F1                         ;-----------------------------------------------------------
7157   E7F1 96 C4                   ldaa    vssCnt1                 ; a = check speed                                                                                                                                      
7158   E7F3 27 07                   beq     L1499                   ; Branch if speed is close to 0                                                                                                                                      
7159   E7F5 20 3A                   bra     L1502                   ; speed too high, bail (safety I assume)        
7160   E7F7                                                                                                                                                       
7161   E7F7                         ;----------------------------------------------------
7162   E7F7                         ; $f1 <= obdCode <= f6, this is an actuator command
7163   E7F7                         ; Bail if engine is rotating
7164   E7F7                         ;----------------------------------------------------
7165   E7F7 B6 01 20    L1498       ldaa    T40_engRot              ; code is F1 to F6, check if "engine running"?                                                                                          
7166   E7FA 26 35                   bne     L1502                   ; bail if engine is rotating  (safety I assume)
7167   E7FC             
7168   E7FC                         ;------------------------------------------------------------
7169   E7FC                         ; $f1<= obdCode <= $f6 and it is safe to perform the action
7170   E7FC                         ; continue processing command/action code
7171   E7FC                         ;------------------------------------------------------------
7172   E7FC                         ;----------------------------------
7173   E7FC                         ; Bail if any injector is already 
7174   E7FC                         ; turned-off by previous command
7175   E7FC                         ;----------------------------------
7176   E7FC 96 BA       L1499       ldaa    obdInjCmd               ; a = obdInjCmd
7177   E7FE 43                      coma                            ; a = ~obdInjCmd
7178   E7FF 84 3F                   anda    #$3f                    ; a = ~obdInjCmd & 00111111
7179   E801 26 41                   bne     L1504                   ; bail if any injector already off                                                                                                                
7180   E803             
7181   E803                         ;----------------------------------
7182   E803                         ; Bail if an actuator is already 
7183   E803                         ; turned-on by previous command
7184   E803                         ;----------------------------------
7185   E803 87 FB FF 3D             brset   obdActCmd, #$ff, L1504  ; bail if a previous action is ongoing
7186   E807             
7187   E807                         ;-----------------------------------------
7188   E807                         ; Check if injector or actuator command
7189   E807                         ;-----------------------------------------
7190   E807 C0 F7                   subb    #$f7                    ; b = obdCode - $f7
7191   E809 25 0D                   bcs     L1500                   ; Branch if obdCode < $f7 (actuator command)
7192   E80B             
7193   E80B                         ;-------------------------------------------
7194   E80B                         ; obdCode >=$f7, it is an injector command, 
7195   E80B                         ; Ignore it for injectors 5 and 6
7196   E80B                         ;-------------------------------------------
7197   E80B C0 02                   subb    #$02                    ; b = injIndex = obdCode - $f7 - $02 = -2 to 3 range (injector 6 to 1 respectively...)
7198   E80D 25 22                   bcs     L1502                   ; branch if code is negative (injectors 5 and 6, do nothing)                                                                           
7199   E80F             
7200   E80F                         ;----------------------------------
7201   E80F                         ; obdCode >=$f7, injector command
7202   E80F                         ;----------------------------------
7203   E80F CE E5 5E                ldx     #t_obdInjMask           ; x points to t_obdInjMask (table t_obdInjMask: $fb $fd $f7 $fe)                                                                                                             
7204   E812 3A                      abx                             ; 
7205   E813 A6 00                   ldaa    $00,x                   ; a = t_obdInjMask(injIndex) ($fb $fd $f7 $fe for injector 4 3 2 1 resp.-> order in nibble -> 2 4 3 1)
7206   E815 5F                      clrb                            ; b = $00                                                                                                                                     
7207   E816 20 0A                   bra     L1501                   ;     
7208   E818                                                                                                                                                           
7209   E818                         ;--------------------------------------------
7210   E818                         ; obdCode <$f7, it is an actuator command
7211   E818                         ;--------------------------------------------
7212   E818 CB 06       L1500       addb    #$06                    ; b = actIndex = obdCode - $f7 + $06 = 0 to 5
7213   E81A CE E5 58                ldx     #t_obdActMask           ; x points to t_obdActMask: 20 10 08 04 01 02                                                                                                          
7214   E81D 3A                      abx                             ;                                                                                                                                      
7215   E81E E6 00                   ldab    $00,x                   ; b = t_obdActMask(actIndex)
7216   E820 86 FF                   ldaa    #$ff                    ; a = $ff
7217   E822             
7218   E822                         ;-----------------------------------------------------------
7219   E822                         ; At this point, 
7220   E822                         ; a contains the new injector to turn off, if any 
7221   E822                         ; b contains the new actuator to turn on, if any 
7222   E822                         ;
7223   E822                         ; Update obdInjCmd and obdActCmd. Notice that only one 
7224   E822                         ; actuator is activated at a time but multiple injectors 
7225   E822                         ; can be turned off...
7226   E822                         ;-----------------------------------------------------------
7227   E822 0F          L1501       sei                             ; Disable interrupts                                                                                                                                     
7228   E823 94 BA                   anda    obdInjCmd               ; Turn off the new injector and continue turning off the existing ones
7229   E825 97 BA                   staa    obdInjCmd               ; Update  obdInjCmd 
7230   E827 D7 FB                   stab    obdActCmd               ; Turn on the new actuator
7231   E829 0E                      cli                             ;                                                                                                                                      
7232   E82A             
7233   E82A                         ;--------------------------------------------
7234   E82A                         ; Re-init T40_obdCmd timer to 6sec and bail
7235   E82A                         ;--------------------------------------------
7236   E82A 86 F0                   ldaa    #$f0                    ; 6 sec
7237   E82C B7 01 2D                staa    T40_obdCmd              ; T40_obdCmd = 6 sec                                                                                                                                      
7238   E82F 20 13                   bra     L1504                   ; jump to RTS                                                                                                                           
7239   E831             
7240   E831                         ;--------------------------------------------
7241   E831                         ; Reset any ongoing actions (injector or actuator)
7242   E831                         ;--------------------------------------------
7243   E831 03 BA 3F    L1502       orm     obdInjCmd, #$3f         ; Set all injectors to on                                                                                                                 
7244   E834 7F 00 FB                clr     obdActCmd               ; Set all actuators to off                                                                                                  
7245   E837 7F 01 2D                clr     T40_obdCmd              ; Clear timer
7246   E83A 86 FF                   ldaa    #$ff                    ; respond with $ff                                                                                                                                     
7247   E83C             
7248   E83C                         ;-----------------------------------------------------------------
7249   E83C                         ; At this point a contains the response to send on diagnostic port
7250   E83C                         ; send it...
7251   E83C                         ;-----------------------------------------------------------------
7252   E83C 97 13       L1503       staa    sci_tx                  ; either FF or 00 or output value to serial port                                                                                    
7253   E83E 03 FA 80                orm     obdFlags, #$80          ; set bit indicating something has been sent
7254   E841 02 FA BF                andm    obdFlags, #$bf          ; reset bit $40 since we finished processing the request
7255   E844             
7256   E844                         ;---------------------------------------------
7257   E844                         ; Jump to rest of code (skip heart beat mode)
7258   E844                         ;---------------------------------------------
7259   E844 7E E8 EF    L1504       jmp     L1524                   ; Jump to RTS                                                                                                                           
7260   E847                                                                                
7261   E847             
7262   E847             
7263   E847             ;****************************************************************
7264   E847             ;
7265   E847             ; Used in processing the output of error codes to test connector
7266   E847             ;
7267   E847             ; Used to Represent the number of shift we need to apply...
7268   E847             ;
7269   E847             ;****************************************************************
7270   E847 80 40 20 10 t_errCodeShift .byte   $80, $40, $20, $10, $08, $04, $02, $01
7270   E84B 08 04 02 01 
7271   E84F             
7272   E84F             
7273   E84F             
7274   E84F             ;****************************************************************
7275   E84F             ;
7276   E84F             ; Output error codes to test connector (heart beat mode)
7277   E84F             ;
7278   E84F             ; a and b are used throughout this code to contain 
7279   E84F             ; the old/new values of errCodeProc and errCodeIdx
7280   E84F             ;
7281   E84F             ; Freakin difficult code to disassemble! 
7282   E84F             ;
7283   E84F             ;
7284   E84F             ;****************************************************************
7285   E84F                         ;----------------------------
7286   E84F                         ; Only execute code at 2Hz
7287   E84F                         ;----------------------------
7288   E84F 87 D9 04 03 L_heartBeat brset   Tclocks, #$04, L1507    ; Branch if 2Hz signal set
7289   E853 7E E8 EF                jmp     L1524                   ; 2Hz signal not yet set, bail 
7290   E856             
7291   E856                         ;--------------------------------------------------
7292   E856                         ; Load basic variables and check whether 
7293   E856                         ; a code is currently being output to connector
7294   E856                         ;--------------------------------------------------
7295   E856 B6 01 7C    L1507       ldaa    errCodeProc             ; a = errCodeProc
7296   E859 F6 01 7B                ldab    errCodeIdx              ; b = errCodeIdx                                                                                         
7297   E85C 4D                      tsta                            ;                             
7298   E85D 26 04                   bne     L1508                   ; Branch if errCodeProc != 0 ( a code is currently being output)
7299   E85F C5 E0                   bitb    #$e0                    ; test 3 bit 2Hz timer...                            
7300   E861 27 03                   beq     L1509                   ; Branch if timer is expired (we are really finished with previous code...)
7301   E863 7E E8 DC    L1508       jmp     L1520                   ; Jump to continue processing the code currently being output
7302   E866                          
7303   E866                         ;---------------------------------------------------------------
7304   E866                         ; At this point we are not processing anything, continue trying
7305   E866                         ;---------------------------------------------------------------
7306   E866 4F          L1509       clra                            ; a = 0                             
7307   E867 97 57                   staa    temp1                   ; temp1 = 0                             
7308   E869 96 4C       L1510       ldaa    stFaultHi               ; preload a = stFaultHi                                   
7309   E86B D7 58                   stab    temp2                   ; temp1:temp2 = errCodeIdx, notice "stab" changes zero flag for branch below...                              
7310   E86D 27 18                   beq     L1512                   ; Branch if errCodeIdx = 0
7311   E86F             
7312   E86F                         ;---------------------------------------------
7313   E86F                         ; errCodeIdx > 0
7314   E86F                         ; Check if errCodeIdx <= 8                 
7315   E86F                         ;---------------------------------------------
7316   E86F CE E8 46                ldx     #t_errCodeShift-1       ; x points to t_errCodeShift-1                              
7317   E872 C0 08                   subb    #$08                    ; b = errCodeIdx - 8                            
7318   E874 23 0B                   bls     L1511                   ; Branch if errCodeIdx <= 8                             
7319   E876             
7320   E876                         ;----------------------------------------------
7321   E876                         ; errCodeIdx > 8, current index is in low fault                 
7322   E876                         ;----------------------------------------------
7323   E876 96 4D                   ldaa    stFaultLo               ; a = stFaultLo since thats what we should be using                                 
7324   E878 3A                      abx                             ; x points to t_errCodeShift - 1 + (errCodeIdx - 8)                            
7325   E879 E6 00                   ldab    $00,x                   ; b = t_errCodeShift(errCodeIdx)
7326   E87B 3D                      mul                             ; shift whats left to process in high part of d (in a)
7327   E87C DE 57                   ldx     temp1                   ; x = 0:errCodeIdx
7328   E87E 4D                      tsta                            ; test if any fault bit set
7329   E87F 20 10                   bra     L1513                   ; Branch 
7330   E881             
7331   E881                         ;-----------------------------------------------
7332   E881                         ; errCodeIdx <= 8, current index is in high fault                
7333   E881                         ;-----------------------------------------------
7334   E881 CB 08       L1511       addb    #$08                    ; b = errCodeIdx - 8 + 8 = errCodeIdx                           
7335   E883 3A                      abx                             ; x points to t_errCodeShift-1 + errCodeIdx                           
7336   E884 E6 00                   ldab    $00,x                   ; b = t_errCodeShift(errCodeIdx)
7337   E886 3D                      mul                             ; shift whats left to process in high part of d (in a)
7338   E887             
7339   E887 DE 57       L1512       ldx     temp1                   ; x = 0:errCodeIdx
7340   E889 4D                      tsta                            ; test if any fault bit set
7341   E88A 26 07                   bne     L1514                   ; Branch if any fault bit were set
7342   E88C             
7343   E88C                         ;-----------------------------------------------
7344   E88C                         ; No fault bit set in high part, try low part now
7345   E88C                         ;-----------------------------------------------
7346   E88C CE 00 08                ldx     #$0008                  ; new errCodeIdx x = 8                              
7347   E88F 96 4D                   ldaa    stFaultLo               ; a = stFaultLo                                  
7348   E891             
7349   E891                         ;--------------------------------------------------                 
7350   E891                         ; At this point, a contains the error bits left (if any)
7351   E891                         ; to process and x is the current index error 
7352   E891                         ;--------------------------------------------------                 
7353   E891 27 16       L1513       beq     L1515                   ; branch if no error are set in what is left to process
7354   E893             
7355   E893                         ;---------------------------------
7356   E893                         ; Loop until we find the bit
7357   E893                         ;---------------------------------                 
7358   E893 08          L1514       inx                             ; ++x
7359   E894 44                      lsra                            ; Shift lowest bit in carry
7360   E895 24 FC                   bcc     L1514                   ; Loop if bit was 0                             
7361   E897             
7362   E897                         ;----------------------------------------------------------------
7363   E897                         ; We found a bit set -> we found the next error code to output...
7364   E897                         ; update new errCodeProc value (in a for now) and new errCodeIdx
7365   E897                         ; (in a for now)
7366   E897                         ;----------------------------------------------------------------
7367   E897 DF 57                   stx     temp1                   ; temp1:temp2 = newBitIndex of next code????
7368   E899 D6 58                   ldab    temp2                   ; b = newBitIndex
7369   E89B CE E5 2F                ldx     #t_snsrChkCode-1        ; x points to t_snsrChkCode-1
7370   E89E 3A                      abx                             ; x points to t_snsrChkCode-1 + newBitIndex
7371   E89F A6 00                   ldaa    $00,x                   ; a = t_snsrChkCode(newBitIndex)                              
7372   E8A1 8A 80                   oraa    #$80                    ; a = t_snsrChkCode(newBitIndex) | $80                            
7373   E8A3 C4 1F                   andb    #$1f                    ; b = newBitIndex & $1f                            
7374   E8A5 CA A0                   orab    #$a0                    ; Set newBitIndex high bits (timer) to 2.5 sec
7375   E8A7 20 3B                   bra     L1521                   ; Branch to set heart beat output and store a and b                             
7376   E8A9             
7377   E8A9                         ;------------------------------------------------------
7378   E8A9                         ; No error found in stFaultLo, this means we are 
7379   E8A9                         ; at the end of the cycle... (we checked high part 
7380   E8A9                         ; first and then low part), restart the whole 
7381   E8A9                         ; thing from errCodeIdx=0 if errCodeIdx not already at 0
7382   E8A9                         ;------------------------------------------------------
7383   E8A9 5F          L1515       clrb                            ; b = 0 = new value of errCodeIdx                             
7384   E8AA 96 58                   ldaa    temp2                   ; a = old errCodeIdx                             
7385   E8AC 26 BB                   bne     L1510                   ; Loop back if old errCodeIdx != 0                             
7386   E8AE             
7387   E8AE                         ;--------------------------------------------------------------------------
7388   E8AE                         ; errCodeIdx already at 0, there where no error during the cycle
7389   E8AE                         ; toggle heart beat sent to diagnostic port, this is the "no fault" signal
7390   E8AE                         ;--------------------------------------------------------------------------
7391   E8AE 36                      psha                            ; st0 = a, why, we know a=0 from test above???????????
7392   E8AF 0F                      sei                             ; Make sure no interrupt plays with port2 while we change it
7393   E8B0 96 03                   ldaa    port2                   ;                               
7394   E8B2 88 10                   eora    #$10                    ; Toggle heart beat sent to diagnostic port?
7395   E8B4 97 03                   staa    port2                   ; Update port                             
7396   E8B6 0E                      cli                             ;                             
7397   E8B7 32                      pula                            ; a = st0 = 0                               
7398   E8B8 20 2F                   bra     L1523                   ; Branch to exit       
7399   E8BA                                               
7400   E8BA                         ;----------------------------------------------------------------
7401   E8BA                         ; errCodeIdx upper 3 bit timer is expired (Branch from below)
7402   E8BA                         ; First check if there are more long pulse to ouptput
7403   E8BA                         ;----------------------------------------------------------------
7404   E8BA 85 70       L1516       bita    #$70                    ;                             
7405   E8BC 27 0B                   beq     L1518                   ; Branch if no more long pulse code (errCodeProc & 01110000 = 0)                             
7406   E8BE             
7407   E8BE                         ;-------------------------------------
7408   E8BE                         ; There are more long pulse to output
7409   E8BE                         ;-------------------------------------
7410   E8BE 80 10                   suba    #$10                    ; decrement the number of long pulse by 1
7411   E8C0 C4 1F                   andb    #$1f                    ; reset timer to 0 (upper 3 bits)                            
7412   E8C2 CA 80                   orab    #$80                    ; Set 2Hz 3 bit timer to 4 (2 sec)
7413   E8C4 02 03 EF    L1517       andm    port2, #$ef             ; Set heart beat sent to diagnostic port
7414   E8C7 20 1E                   bra     L1522                   ; Branch to update timer and exit
7415   E8C9                                                      
7416   E8C9                         ;----------------------------------------------------
7417   E8C9                         ; No more long pulse to output 
7418   E8C9                         ; Check if bit 7 is set (was set when we 
7419   E8C9                         ; started output of this code)
7420   E8C9                         ;----------------------------------------------------
7421   E8C9 85 80       L1518       bita    #$80                    ;                             
7422   E8CB 27 08                   beq     L1519                   ; Branch if bit is not set
7423   E8CD             
7424   E8CD                         ;-----------------------------------------------------------------------------
7425   E8CD                         ; bit 7 is set, we are therefore at the midpoint between long and short pulse
7426   E8CD                         ;
7427   E8CD                         ; reset the flag, set the timer to 1.5 sec, reset output and exit
7428   E8CD                         ; This is basically a 1.5 sec pause in between long and short pulse
7429   E8CD                         ;-----------------------------------------------------------------------------
7430   E8CD 84 7F                   anda    #$7f                    ; Reset bit 7 (nothing left to output flag). At this point a should be equal to $7f ???
7431   E8CF C4 1F                   andb    #$1f                    ; Reset timer to 0 (upper 3 bits)                            
7432   E8D1 CA 60                   orab    #$60                    ; Set 2Hz 3 bit timer to 3 (1.5 sec)
7433   E8D3 20 0F                   bra     L1521                   ; Branch to reset hearth beat, update timer and exit                               
7434   E8D5             
7435   E8D5                         ;-----------------------------------------------------------------
7436   E8D5                         ; Flag was not set, just output whatever short pulses are left...
7437   E8D5                         ;-----------------------------------------------------------------
7438   E8D5 4A          L1519       deca                            ; decrement the number of short pulse by 1
7439   E8D6 C4 1F                   andb    #$1f                    ; reset timer to 0 (upper 3 bits)                       
7440   E8D8 CA 40                   orab    #$40                    ; Set 2Hz 3 bit timer to 2 (1 sec)                           
7441   E8DA 20 E8                   bra     L1517                   ; Branch to set hearth beat, update timer and exit                             
7442   E8DC             
7443   E8DC                         ;---------------------------------
7444   E8DC                         ; A code is currently being output...
7445   E8DC                         ; At this point we have
7446   E8DC                         ;       a = errCodeProc   
7447   E8DC                         ;       b = errCodeIdx  
7448   E8DC                         ;---------------------------------                 
7449   E8DC C1 20       L1520       cmpb    #$20                    ;                             
7450   E8DE 25 DA                   bcs     L1516                   ; Branch if errCodeIdx < $20 (e.g. timer=0, upper 3 bit timer is expired)                            
7451   E8E0             
7452   E8E0                         ;-------------------------------------                 
7453   E8E0                         ; Timer not expired check if timer>1
7454   E8E0                         ;-------------------------------------                 
7455   E8E0 C1 3F                   cmpb    #$3f                    ;                             
7456   E8E2 22 03                   bhi     L1522                   ; Branch if errCodeIdx > $3f (timer>1)
7457   E8E4             
7458   E8E4                         ;-------------------------------------------
7459   E8E4                         ; timer = 1, set heart beat mode output
7460   E8E4                         ;-------------------------------------------
7461   E8E4             
7462   E8E4                         ;-------------------------------------------
7463   E8E4                         ; Reset heart beat output on diagnostic port 
7464   E8E4                         ;-------------------------------------------
7465   E8E4 03 03 10    L1521       orm     port2, #$10             ; Reset heart beat sent to diagnostic port 
7466   E8E7             
7467   E8E7                         ;-------------------------------------------------------------
7468   E8E7                         ; Decrement errCodeIdx timer (upper 3 bits) by $20 (0.5sec)
7469   E8E7                         ;-------------------------------------------------------------
7470   E8E7 C0 20       L1522       subb    #$20                    ;                             
7471   E8E9             
7472   E8E9                         ;-----------------------------------------------------
7473   E8E9                         ; Store new errCodeProc and errCodeIdx and return
7474   E8E9                         ;-----------------------------------------------------
7475   E8E9 B7 01 7C    L1523       staa    errCodeProc             ;                              
7476   E8EC F7 01 7B                stab    errCodeIdx              ;                              
7477   E8EF 39          L1524       rts                             ;                             
7478   E8F0             
7479   E8F0             
7480   E8F0             
7481   E8F0             ;****************************************************************
7482   E8F0             ;
7483   E8F0             ;
7484   E8F0             ; Maf sensor check:
7485   E8F0             ;
7486   E8F0             ;
7487   E8F0             ;****************************************************************
7488   E8F0 96 DD       test_maf    ldaa    rpm31                   ;                                                                  
7489   E8F2 81 10                   cmpa    #$10                    ;                                                                 
7490   E8F4 23 0D                   bls     L1528                   ;                                                                  
7491   E8F6 B6 01 21                ldaa    T40_mas                 ; 
7492   E8F9 27 06                   beq     L1526                   ; Branch if timer expired (no mas interrupt for a long time...)
7493   E8FB 96 9A                   ldaa    t2_diff8                ;                                                                    
7494   E8FD 81 31                   cmpa    #$31                    ; t2_diff8 more than 49 is an error?                                
7495   E8FF 25 01                   bcs     L1527                   ;                                                                  
7496   E901 5A          L1526       decb                            ;                                                                 
7497   E902 39          L1527       rts                             ;                                                                 
7498   E903 5C          L1528       incb                            ; return 1 (test not conclusive)                                                                 
7499   E904 39                      rts                             ;                                                                 
7500   E905             
7501   E905             
7502   E905             
7503   E905             ;******************************************************************
7504   E905             ;
7505   E905             ;
7506   E905             ; Crank angle sensor
7507   E905             ;
7508   E905             ;
7509   E905             ;******************************************************************
7510   E905 B6 01 20    test_cas    ldaa    T40_engRot              ; 
7511   E908 26 05                   bne     L1530                   ; Branch if sensor is fine. T40_engRot is non-zero when CAS interrupts are being received... sensor must be fine...
7512   E90A 87 D7 40 02             brset   port3Snap0, #$40, L1531 ; Branch if key is not in start
7513   E90E 5A                      decb                            ; Key is in start but T40_engRot is 0, should not happen -> CAS is bad                            
7514   E90F 39          L1530       rts                             ;                             
7515   E910 5C          L1531       incb                            ; return 1 (test not conclusive)                             
7516   E911 39                      rts                                                          
7517   E912             
7518   E912             
7519   E912             
7520   E912             ;******************************************************************
7521   E912             ;
7522   E912             ;
7523   E912             ; Top dead sensor
7524   E912             ;
7525   E912             ;
7526   E912             ;******************************************************************
7527   E912 B6 01 20    test_tdc    ldaa    T40_engRot              ;                                     
7528   E915 27 10                   beq     L1535                   ; Branch if timer is 0, (engine not rotating)                             
7529   E917 96 B6                   ldaa    tdcCheck                ; Engine rotating, check if #1 TDC signal is being received
7530   E919 27 0A                   beq     L1533                   ; Branch to error if #1 TDC signal is not being received
7531   E91B 96 83                   ldaa    tdcCasCount             ;                              
7532   E91D 81 04                   cmpa    #$04                    ;                             
7533   E91F 24 05                   bcc     L1534                   ; Branch if tdcCasCount>=4                              
7534   E921 8F 06 40 02             brclr   port3, #$40, L1535      ; tdcCasCount<4, branch if key is in start
7535   E925 5A          L1533       decb                            ; Set error                             
7536   E926 39          L1534       rts                             ;                             
7537   E927 5C          L1535       incb                            ; return 1 (test not conclusive)                            
7538   E928 39                      rts                             ;                             
7539   E929             
7540   E929             
7541   E929             
7542   E929             ;******************************************************************
7543   E929             ;
7544   E929             ;
7545   E929             ; Reed switch (VSS) sensor check:
7546   E929             ;
7547   E929             ;
7548   E929             ;******************************************************************
7549   E929 96 C4       test_reed   ldaa    vssCnt1                                                 
7550   E92B 26 20                   bne     L1537                    ; branch if car is moving (no error since we detected that...)                             
7551   E92D 87 E6 02 1D             brset   state1, #$02, L1538      ; Branch if no pulse accumulator interrupts?                                
7552   E931 87 D7 80 19             brset   port3Snap0, #$80, L1538  ; Branch if Idle switch on (car most likely not moving...)                                   
7553   E935 96 DD                   ldaa    rpm31                    ;                             
7554   E937 81 60                   cmpa    #$60                     ;                            
7555   E939 23 13                   bls     L1538                    ;                             
7556   E93B 96 E0                   ldaa    airVol                   ;                              
7557   E93D 81 6D                   cmpa    #$6d                     ;                            
7558   E93F 23 0D                   bls     L1538                    ;                             
7559   E941 87 A2 04 09             brset   state3, #$04, L1538      ; Branch if rev limiter active
7560   E945 B6 01 3E                ldaa    T2_stCrank               ;                                  
7561   E948 8B 78                   adda    #$78                     ;                            
7562   E94A 25 02                   bcs     L1538                    ;                             
7563   E94C 5A                      decb                             ;                            
7564   E94D 39          L1537       rts                              ;                            
7565   E94E 5C          L1538       incb                             ; return 1 (test not conclusive)                             
7566   E94F 39                      rts                              ;                            
7567   E950             
7568   E950             
7569   E950             
7570   E950             ;******************************************************************
7571   E950             ;
7572   E950             ;
7573   E950             ; Injector circuit check
7574   E950             ;
7575   E950             ;
7576   E950             ;******************************************************************
7577   E950 96 BA       test_inj    ldaa    obdInjCmd               ; First check if we disabled an injector on purpose (OBD command)                             
7578   E952 43                      coma                            ;                             
7579   E953 85 3F                   bita    #$3f                    ; only keep 6 bits (6 inj.)                             
7580   E955 26 17                   bne     L1541                   ; Branch if disabled on purpose                              
7581   E957 B6 01 20                ldaa    T40_engRot              ;                               
7582   E95A 27 12                   beq     L1541                   ; Branch if engine not rotating                              
7583   E95C 96 DD                   ldaa    rpm31                   ;                              
7584   E95E 81 20                   cmpa    #$20                    ;                             
7585   E960 24 0C                   bcc     L1541                   ; Branch if rpm > 1000                             
7586   E962 96 D2                   ldaa    tpsRaw                  ;                            
7587   E964 81 24                   cmpa    #$24                    ;                             
7588   E966 24 06                   bcc     L1541                   ; Branch if tpsRaw > $24                             
7589   E968 8F B9 01 01             brclr   injBad, #$01, L1540     ; Branch if injector OK?
7590   E96C 5A                      decb                            ; Error, set flag                            
7591   E96D 39          L1540       rts                             ;                             
7592   E96E 5C          L1541       incb                            ; return 1 (test not conclusive)                             
7593   E96F 39                      rts                                                          
7594   E970             
7595   E970             
7596   E970             
7597   E970             ;******************************************************************
7598   E970             ;
7599   E970             ;
7600   E970             ; Fuel pump relay check
7601   E970             ;
7602   E970             ;
7603   E970             ;******************************************************************
7604   E970 8F D7 40 04 test_fpump  brclr   port3Snap0, #$40, L1543     ; Branch if key in start position                               
7605   E974 87 02 10 06             brset   port1, #$10, L1545          ; Branch if fuel pump relay bit set 
7606   E978 8F D8 40 01 L1543       brclr   port4Snap, #$40, L1544      ; Fuel pump driven feedback???                                
7607   E97C 5A                      decb                                                         
7608   E97D 39          L1544       rts                                                          
7609   E97E 5C          L1545       incb                                ; return 1 (test not conclusive)                         
7610   E97F 39                      rts                                                          
7611   E980             
7612   E980             
7613   E980             
7614   E980             ;******************************************************************
7615   E980             ;
7616   E980             ;
7617   E980             ; Ignition coil check:
7618   E980             ;
7619   E980             ;
7620   E980             ;******************************************************************
7621   E980 87 E6 11 0C test_coil   brset   state1, #$11, L1548       ; Branch if notRotating or startingToCrank
7622   E984 96 DD                   ldaa    rpm31                     ;                              
7623   E986 81 A0                   cmpa    #$a0                      ;                             
7624   E988 24 06                   bcc     L1548                     ; Branch if RPM >= 5000                              
7625   E98A 8F 85 80 01             brclr   coilChkFlags, #$80, L1547 ; Branch if no error found on ignition signal
7626   E98E 5A                      decb                              ; Error was found                             
7627   E98F 39          L1547       rts                               ;                             
7628   E990 5C          L1548       incb                              ; return 1 (test not conclusive)                             
7629   E991 39                      rts                                                          
7630   E992             
7631   E992             
7632   E992             
7633   E992             ;******************************************************************
7634   E992             ;
7635   E992             ;
7636   E992             ; Knock sensor check:
7637   E992             ;
7638   E992             ;
7639   E992             ;******************************************************************
7640   E992 87 D8 20 01 test_knock  brset   port4Snap, #$20, L1550  ; Knock sensor related???
7641   E996 5A                      decb                                                         
7642   E997 39          L1550       rts                                                          
7643   E998             
7644   E998             
7645   E998             
7646   E998             ;******************************************************************
7647   E998             ;
7648   E998             ;
7649   E998             ; Intake air temperature sensor check:
7650   E998             ;
7651   E998             ;
7652   E998             ;******************************************************************
7653   E998 8F D6 02 01 test_iat    brclr   state2, #$02, L1552                                     
7654   E99C 5A                      decb                                                         
7655   E99D 39          L1552       rts                                                          
7656   E99E             
7657   E99E             
7658   E99E             
7659   E99E             ;******************************************************************
7660   E99E             ;
7661   E99E             ;
7662   E99E             ; Tps sensor check:
7663   E99E             ;
7664   E99E             ;
7665   E99E             ;******************************************************************
7666   E99E 96 D2       test_tps    ldaa    tpsRaw                                                 
7667   E9A0 81 66                   cmpa    #$66                                                 
7668   E9A2 22 05                   bhi     L1554                   ; branch if tpsRaw voltage higher 40%                                   
7669   E9A4 81 0A                   cmpa    #$0a                    ;                                                                       
7670   E9A6 25 05                   bcs     L1555                   ; branch if voltage lower than 4%                                      
7671   E9A8 39                      rts                             ;                                                                       
7672   E9A9 8F D7 80 01 L1554       brclr   port3Snap0, #$80, L1556 ; branch if idle switch is off                                            
7673   E9AD 5A          L1555       decb                            ;                                                                       
7674   E9AE 39          L1556       rts                             ;                                                                       
7675   E9AF             
7676   E9AF             
7677   E9AF             
7678   E9AF             ;******************************************************************
7679   E9AF             ;
7680   E9AF             ;
7681   E9AF             ; Ect sensor check:
7682   E9AF             ;
7683   E9AF             ;
7684   E9AF             ;******************************************************************
7685   E9AF 87 D6 10 38 test_ect    brset   state2, #$10, L1563     ; Branch if flag was previously set when we were here (once in error always in error????)                                
7686   E9B3 8F D6 01 07             brclr   state2, #$01, L1558     ; Branch if no ect error flag set in main code
7687   E9B7 B6 01 3E                ldaa    T2_stCrank              ; ect error flag is set in main code, check timer                             
7688   E9BA 8B 78                   adda    #$78                    ;                             
7689   E9BC 24 25                   bcc     L1562                   ; Branch if more than 60sec have elapsed since engine startedToCrank (should have cleared by now?, sensor is in error)                              
7690   E9BE 87 E6 10 1F L1558       brset   state1, #$10, L1560     ; Branch if notRotating (not conclusive)
7691   E9C2 B6 01 44                ldaa    T0p5_ect                ;                               
7692   E9C5 27 24                   beq     L1563                   ; Branch if temperature stayed at exactly 88degC for more than 5 minutes (????)
7693   E9C7 B6 01 43                ldaa    T0p5_crank2             ;                               
7694   E9CA 8B 5A                   adda    #$5a                    ;                             
7695   E9CC 25 0D                   bcs     L1559                   ; Branch if less than 180s have elapsed since ectStCrank was loaded                              
7696   E9CE             
7697   E9CE                         ;----------------------------------------------------------
7698   E9CE                         ; More than 180s have elapsed since ectStCrank was loaded
7699   E9CE                         ;----------------------------------------------------------
7700   E9CE B6 01 83                ldaa    ectStCrank              ;                                   
7701   E9D1 81 FF                   cmpa    #$ff                    ; Not sure how we would get that value, maybe if sensor is broken??                            
7702   E9D3 25 06                   bcs     L1559                   ; Branch if ectStCrank < $ff (branch almost always???????)                              
7703   E9D5 80 0A                   suba    #$0a                    ; a=ectStCrank-$0a = $ff-$0a = $f5, am I missing someting??????????????                             
7704   E9D7 91 D3                   cmpa    ectFiltered             ;                                     
7705   E9D9 25 08                   bcs     L1562                   ; Branch if  ectFiltered > $f5 ?????? (sensor error)                             
7706   E9DB 96 D3       L1559       ldaa    ectFiltered             ;                                    
7707   E9DD 81 54                   cmpa    #$54                    ; 41degC                             
7708   E9DF 25 01                   bcs     L1561                   ; Branch if temperature(ectFiltered) > 41degC (no error)                               
7709   E9E1 5C          L1560       incb                            ; return 1 (test not conclusive)                             
7710   E9E2 39          L1561       rts                                                          
7711   E9E3 B6 01 3B    L1562       ldaa    T2_snsrChk                                                 
7712   E9E6 26 03                   bne     L1563                                                 
7713   E9E8 03 D6 10                orm     state2, #$10                                             
7714   E9EB 5A          L1563       decb                                                         
7715   E9EC 39                      rts                                                          
7716   E9ED             
7717   E9ED             
7718   E9ED             
7719   E9ED             ;******************************************************************
7720   E9ED             ;
7721   E9ED             ;
7722   E9ED             ; Barometer sensor check
7723   E9ED             ;
7724   E9ED             ;
7725   E9ED             ;******************************************************************
7726   E9ED B6 01 1B    test_baro   ldaa    T40_baro                ;                                  
7727   E9F0 26 0C                   bne     L1567                   ;                              
7728   E9F2 96 CD                   ldaa    baroRaw                 ;                                
7729   E9F4 81 E6                   cmpa    #$e6                    ;                             
7730   E9F6 22 04                   bhi     L1565                   ;                              
7731   E9F8 81 0A                   cmpa    #$0a                    ;                             
7732   E9FA 24 01                   bcc     L1566                   ;                              
7733   E9FC 5A          L1565       decb                            ;                             
7734   E9FD 39          L1566       rts                             ;                             
7735   E9FE 5C          L1567       incb                            ; return 1 (test not conclusive)                             
7736   E9FF 39                      rts                                                          
7737   EA00             
7738   EA00             
7739   EA00             
7740   EA00             ;******************************************************************
7741   EA00             ;
7742   EA00             ;
7743   EA00             ; Serial port interrupt subroutine 
7744   EA00             ;
7745   EA00             ;
7746   EA00             ;******************************************************************
7747   EA00 DC 11       serialRxInt ldd     sci_scr                 ; A=sci_cr, B=sci_read                                                                                       
7748   EA02 85 80                   bita    #$80                    ; Check if something was received??/start of sequence to clear flag                                      
7749   EA04 27 0F                   beq     L1570                   ;                                                                                                            
7750   EA06 87 FA 80 08             brset   obdFlags, #$80, L1569   ; Branch if the code we received is the echo of the one we just sent                                          
7751   EA0A F7 01 7A                stab    obdCode                 ;                                                                                                            
7752   EA0D 03 FA 40                orm     obdFlags, #$40          ; Indicate new value available                                                                                 
7753   EA10 20 03                   bra     L1570                   ;                                                                                                            
7754   EA12 02 FA 7F    L1569       andm    obdFlags, #$7f          ; The code we received is the echo of what we sent, just drop it and reset flag                                
7755   EA15 3B          L1570       rti                             ;                                                                                                           
7756   EA16             
7757   EA16             
7758   EA16             
7759   EA16             ;******************************************************************
7760   EA16             ;
7761   EA16             ;
7762   EA16             ;
7763   EA16             ;
7764   EA16             ;
7765   EA16             ;******************************************************************
7766   EA16 CE FB 07    loadConfig  ldx     #t_strap1               ;                                  
7767   EA19 D6 07                   ldab    port4                   ;                              
7768   EA1B 01                      nop                             ;                             
7769   EA1C C4 03                   andb    #$03                    ; Keep only config resistor bits                             
7770   EA1E 58                      aslb                            ;                             
7771   EA1F 3A                      abx                             ;                             
7772   EA20 EC 00                   ldd     $00,x                   ;                              
7773   EA22 DD 55                   std     config1                 ;                              
7774   EA24 39                      rts                             ;                             
7775   EA25             
7776   EA25             
7777   EA25             
7778   EA25             ;******************************************************************
7779   EA25             ;
7780   EA25             ;
7781   EA25             ; Initialize a few things
7782   EA25             ;
7783   EA25             ;
7784   EA25             ;******************************************************************
7785   EA25 CC 7E 16    initFunc1   ldd     #$7e16                  ;                                                                                                  
7786   EA28 DD 00                   std     p1_ddr                  ; Initialize port1 and port2 data direction registers                                              
7787   EA2A CC 00 00                ldd     #$0000                  ;                                                                                                  
7788   EA2D DD 04                   std     p3_ddr                  ; Initialize port3 and port4 data direction register (all inputs)                                  
7789   EA2F 86 FE                   ldaa    #$fe                    ;                                                                                                
7790   EA31 97 15                   staa    p5_ddr                  ; Initialize port5 data direction register
7791   EA33 4F                      clra                            ;                             
7792   EA34 97 0F                   staa    L000f                   ;                              
7793   EA36 97 17                   staa    L0017                   ;                              
7794   EA38 02 02 BF                andm    port1, #$bf             ; Reset ??????                               
7795   EA3B 86 00                   ldaa    #$00                    ;                             
7796   EA3D 97 24                   staa    L0024                   ;                              
7797   EA3F             
7798   EA3F                         ;-------------------------------------------------------
7799   EA3F                         ; rti_freq is setting the real time interrupt frequency:
7800   EA3F                         ;    F=125000/(256-x)
7801   EA3F                         ;       x      F
7802   EA3F                         ;      0x64  1*801.28Hz
7803   EA3F                         ;      0xb2  2*801.28Hz
7804   EA3F                         ;      0xcc  3*801.28Hz
7805   EA3F                         ;      0xd9  4*801.28Hz
7806   EA3F                         ;-------------------------------------------------------
7807   EA3F CC 4D 64                ldd     #$4d64                  ; 
7808   EA42 DD 26                   std     rti_ctl                                                 
7809   EA44 39                      rts                                                          
7810   EA45             
7811   EA45             
7812   EA45             
7813   EA45             ;******************************************************************
7814   EA45             ;
7815   EA45             ; Input: D = Tcas (period of cas interrupts in sec * 125000)
7816   EA45             ; Output: freq = $EA600/D = 960000/D
7817   EA45             ;
7818   EA45             ;        in the end, rpm = freq/8*31.25 
7819   EA45             ;
7820   EA45             ;        e.g. 1000RPM -> Tcas = 60/1000* 125000/2 = 3750
7821   EA45             ;                        freq = 960000/3750 = 256
7822   EA45             ;                        rpm = freq/8*31.25 = 1000 RPM 
7823   EA45             ;
7824   EA45             ;******************************************************************
7825   EA45 DD 5A       calcFreq    std     temp4                   ;                                                                 
7826   EA47 CC A6 00                ldd     #$a600                  ;                                                                  
7827   EA4A DD 58                   std     temp2                   ;                                     
7828   EA4C CC 00 0E                ldd     #$000e                  ; numerator = D:temp2 = 000EA600                                   
7829   EA4F 20 62                   bra     div3216                 ; D = (#$000EA600)/([$5A $5B])      
7830   EA51             
7831   EA51             
7832   EA51                                                                        
7833   EA51             ;******************************************************************
7834   EA51             ;
7835   EA51             ;
7836   EA51             ;
7837   EA51             ;
7838   EA51             ;******************************************************************
7839   EA51 F6 01 60    mul816_baro ldab    baroFact                                                 
7840   EA54             
7841   EA54             ;******************************************************************
7842   EA54             ;
7843   EA54             ;
7844   EA54             ;
7845   EA54             ;
7846   EA54             ;******************************************************************
7847   EA54 BD EB 5F    mul816_256  jsr     mul816_128              ; D and [temp6:temp7] = b*[temp6:temp7]/128                                   
7848   EA57 7E EB AE                jmp     scale2m                                                 
7849   EA5A             
7850   EA5A             
7851   EA5A             
7852   EA5A             ;******************************************************************
7853   EA5A             ;
7854   EA5A             ; Input 
7855   EA5A             ;     x = point to table1
7856   EA5A             ;     y = point to table2
7857   EA5A             ;
7858   EA5A             ; Output
7859   EA5A             ;     d = injMasComp * table1(rpm)/128 * table2(ect)/16 * baroFact/128
7860   EA5A             ;
7861   EA5A             ;******************************************************************
7862   EA5A FC 01 53    L1577       ldd     injMasComp              ; d = injMasComp                                   
7863   EA5D DD 5C                   std     temp6                   ; temp6:temp7 = injMasComp                             
7864   EA5F BD EB 34                jsr     interp16rpm             ; b = table1(rpm)                              
7865   EA62 BD EB 5F                jsr     mul816_128              ; [temp6:temp7] = injMasComp * table1(rpm)/128                                   
7866   EA65 18                      xgxy                            ; x points to table2                              
7867   EA66 BD EB 2F                jsr     interpEct               ; b = table2(ect)                                  
7868   EA69 B6 01 60                ldaa    baroFact                ; a = baroFact                                
7869   EA6C 3D                      mul                             ; d =  table2(ect) * baroFact                           
7870   EA6D 7E EB 7B                jmp     mul1616_2K              ; d = 8* injMasComp * table1(rpm)/128 * table2(ect)/128 * baroFact/128
7871   EA70             
7872   EA70             
7873   EA70             
7874   EA70             ;******************************************************************
7875   EA70             ;
7876   EA70             ; 8 bit by 16 bit multiplication
7877   EA70             ;
7878   EA70             ; Input
7879   EA70             ;   b: 8 bit value
7880   EA70             ;   [temp6:temp7]: 16 bit value, optionally in X if called from mul816b
7881   EA70             ;
7882   EA70             ; Output: 
7883   EA70             ;   D and [temp1:temp2] = b*[temp6:temp7]/256
7884   EA70             ;   temp3 = Lo(b*temp7) (fractional part of result) 
7885   EA70             ;
7886   EA70             ;
7887   EA70             ;
7888   EA70             ;******************************************************************
7889   EA70 DE 5C       mul816      ldx     temp6                   ;                              
7890   EA72 DF 57       mul816b     stx     temp1                   ; temp1,temp2 = temp6,temp7                              
7891   EA74 37                      pshb                            ; save b                            
7892   EA75 96 58                   ldaa    temp2                   ; a = temp7                             
7893   EA77 3D                      mul                             ; d = b*temp7                            
7894   EA78 DD 58                   std     temp2                   ; temp2, temp3 = b*temp7                             
7895   EA7A 96 57                   ldaa    temp1                   ; a=temp6                             
7896   EA7C 33                      pulb                            ;                             
7897   EA7D 3D                      mul                             ; d = b*temp6                              
7898   EA7E DB 58                   addb    temp2                   ; d = b*temp6 + b*temp7/256 = b*(temp6+temp7/256) = b*[temp6:temp7]/256
7899   EA80 89 00                   adca    #$00                    ; Propagate addition carry                            
7900   EA82 DD 57                   std     temp1                   ; temp1, temp2 = b*[temp6:temp7]/256
7901   EA84 39                      rts                             ;                             
7902   EA85             
7903   EA85             
7904   EA85             
7905   EA85             ;******************************************************************
7906   EA85             ;
7907   EA85             ;
7908   EA85             ; 16 bit by 16 bit multiplication:
7909   EA85             ;
7910   EA85             ; Input:
7911   EA85             ;               a:b = 16 bit value  (val1:val2)
7912   EA85             ;       temp6:temp7 = 16 bit value1 (val3:val4)
7913   EA85             ;
7914   EA85             ; Output:
7915   EA85             ;               d = [a:b]*[temp6:temp7]/65536  (or equivalently, 16 upper bits of result)
7916   EA85             ;           temp2 = lower 8 bits (of 24) of results
7917   EA85             ;----------------------------------------
7918   EA85             ;
7919   EA85             ; D * temp6:temp7
7920   EA85             ; - 16 bit multiplication:
7921   EA85             ; - D * temp6:temp7 , High bytes stored in D
7922   EA85             ; -
7923   EA85             ; - (1) * (2) is equal to ( 1A + 1B ) * ( 2A + 2B )
7924   EA85             ; 
7925   EA85             ; - = 1A * 2A + 1A * 2B + 1B * 2A + 1B * 2B
7926   EA85             ; 
7927   EA85             ; - Where:
7928   EA85             ; - lets call temp6:temp7 Argument (1)
7929   EA85             ; - lets call reg D Argument (2)
7930   EA85             ; -
7931   EA85             ; - temp6 is then named (1A)
7932   EA85             ; - temp7 is then named (1B)
7933   EA85             ; - and temp6:temp7 = (1A) * #$100 + (1B)
7934   EA85             ; -
7935   EA85             ; - Reg D is reg A:reg B
7936   EA85             ; - A is then named (2A)
7937   EA85             ; - B is then named (2B)
7938   EA85             ; - temp6:temp7 = (1A) * #$100 + (1B)
7939   EA85             ; 
7940   EA85             ; - D consists of (2A) * #$100 + (2B)
7941   EA85             ; 
7942   EA85             ; -Result (R) will be 32 bit, (R3)-(R0) where
7943   EA85             ; -temp3 = (R0) low
7944   EA85             ; -temp2 = (R1)
7945   EA85             ; -temp1 = (R2) --\ Stored and returned in D
7946   EA85             ;
7947   EA85             ;******************************************************************
7948   EA85 CE 00 5C    mul1616     ldx     #temp6                  ; x points to temp6
7949   EA88 36                      psha                            ; st0 = val1                            
7950   EA89 37                      pshb                            ; st1 = val2                            
7951   EA8A A6 01                   ldaa    $01,x                   ; a = val4                             
7952   EA8C 3D                      mul                             ; d = val4*val2                            
7953   EA8D DD 58                   std     temp2                   ; temp2:temp3=val4*val2                             
7954   EA8F 33                      pulb                            ; b = val2                            
7955   EA90 A6 00                   ldaa    $00,x                   ; a = val3                             
7956   EA92 3D                      mul                             ; d = val2*val3                            
7957   EA93 DB 58                   addb    temp2                   ; d = val2*val3 + val4*val2/256
7958   EA95 89 00                   adca    #$00                    ; propagate carry                            
7959   EA97 DD 57                   std     temp1                   ; temp1:temp2 = val2*val3 + val4*val2/256
7960   EA99 32                      pula                            ; a = val1                            
7961   EA9A 36                      psha                            ; st0 = val1                            
7962   EA9B E6 01                   ldab    $01,x                   ; b = val4                             
7963   EA9D 3D                      mul                             ; d = val1*val4                            
7964   EA9E D3 57                   addd    temp1                   ; d = val1*val4 + val2*val3 + val4*val2/256
7965   EAA0 DD 57                   std     temp1                   ; temp1:temp2 = val1*val4 + val2*val3 + val4*val2/256
7966   EAA2 32                      pula                            ; a = val1                            
7967   EAA3 56                      rorb                            ; shift in carry bit                            
7968   EAA4 C4 80                   andb    #$80                    ; keep only carry bit                             
7969   EAA6 37                      pshb                            ; st0 = carry bit in position $80                            
7970   EAA7 E6 00                   ldab    $00,x                   ; b=val3                             
7971   EAA9 3D                      mul                             ; d=val1*val3                            
7972   EAAA 1A                      xgdx                            ; x=val1*val3, d points to temp6
7973   EAAB 33                      pulb                            ; b=carry bit in position $80                            
7974   EAAC 3A                      abx                             ; add 2 x carry bit (since shifted right previously)                            
7975   EAAD 3A                      abx                             ; x=val1*val3 + carry                               
7976   EAAE D6 57                   ldab    temp1                   ; b = (val1*val4 + val2*val3 + val4*val2/256)/256
7977   EAB0 3A                      abx                             ; x = val1*val3 + carry + (val1*val4 + val2*val3 + val4*val2/256)/256
7978   EAB1 1A                      xgdx                            ; x points to temp6, d = val1*val3 + carry + (val1*val4 + val2*val3 + val4*val2/256)/256
7979   EAB2 39                      rts                             ;                             
7980   EAB3                                                         
7981   EAB3             
7982   EAB3             
7983   EAB3             ;******************************************************************
7984   EAB3             ;
7985   EAB3             ;
7986   EAB3             ; fractional 32 bit by 16 bit division:
7987   EAB3             ; input: D:temp2:temp3 = 32 bit numerator; 
7988   EAB3             ;        temp4:temp5 = 16 bit denominator
7989   EAB3             ;
7990   EAB3             ; output: D = quotient
7991   EAB3             ;         X = remainder
7992   EAB3             ;
7993   EAB3             ;******************************************************************
7994   EAB3 1D 5A       div3216     cmpd1   temp4                   ;                                                                                    
7995   EAB5 25 05                   bcs     L1582                   ; Branch if denominator > numerator (results<1)                                      
7996   EAB7 CC FF FF                ldd     #$ffff                  ; denominator<=numerator, return .99998....                                           
7997   EABA 20 19                   bra     L1586                   ;                                                                                    
7998   EABC                                                                                                                
7999   EABC CD CE 00 10 L1582       ldy     #$0010                  ; Loop 16 times                                                                       
8000   EAC0 DE 58                   ldx     temp2                                                 
8001   EAC2 1A          L1583       xgdx                                                         
8002   EAC3 05                      asld                                                         
8003   EAC4 1A                      xgdx                                                         
8004   EAC5 59                      rolb                                                         
8005   EAC6 49                      rola                                                         
8006   EAC7 25 04                   bcs     L1584                                                 
8007   EAC9 1D 5A                   cmpd1   temp4                                                 
8008   EACB 25 03                   bcs     L1585                                                 
8009   EACD 93 5A       L1584       subd    temp4                                                 
8010   EACF 08                      inx                                                          
8011   EAD0 CD 09       L1585       decy                                                         
8012   EAD2 26 EE                   bne     L1583                                                 
8013   EAD4 1A                      xgdx                                                         
8014   EAD5 39          L1586       rts                                                          
8015   EAD6                         
8016   EAD6             
8017   EAD6             
8018   EAD6             ;******************************************************************
8019   EAD6             ;
8020   EAD6             ;
8021   EAD6             ; 2D table lookup/interpolation
8022   EAD6             ;
8023   EAD6             ; Input:
8024   EAD6             ;       temp6 = in1 (column index*16) (optionally in a if using 2Dlookup2)
8025   EAD6             ;       temp7 = in2 (row index*16)    (optionally in b if using 2Dlookup2)
8026   EAD6             ;       hi(Y) = scale, number of elements per row in the table 
8027   EAD6             ;       lo(Y) = offset, added to value loaded from table before interpolation
8028   EAD6             ;           X = 2Dtable address
8029   EAD6             ;
8030   EAD6             ; Output: A and B contain the same 2D interpolated value from the table 
8031   EAD6             ;         
8032   EAD6             ;
8033   EAD6             ;
8034   EAD6             ;******************************************************************
8035   EAD6 DC 5C       lookup2D    ldd     temp6                   ; a=in1, b=in2                              
8036   EAD8 CD DF 59    lookup2D2   sty     temp3                   ; temp3 = scale temp4=offset                              
8037   EADB 97 5B                   staa    temp5                   ; temp5 = in1                              
8038   EADD 4F                      clra                            ; a=0, b=in2
8039   EADE 05                      asld                            ;                             
8040   EADF 05                      asld                            ;                             
8041   EAE0 05                      asld                            ;                             
8042   EAE1 05                      asld                            ; d = in2*16                             
8043   EAE2 37                      pshb                            ; st0 = LO(in2*16)                            
8044   EAE3 D6 59                   ldab    temp3                   ; b=scale                             
8045   EAE5 3D                      mul                             ; d = in2*16/256*scale                             
8046   EAE6 DF 57                   stx     temp1                   ; temp1:temp2 = 2Dtable
8047   EAE8 D3 57                   addd    temp1                   ; d = 2Dtable + in2*16/256*scale
8048   EAEA DD 57                   std     temp1                   ; temp1:temp2 = 2Dtable + in2*16/256*scale
8049   EAEC DE 57                   ldx     temp1                   ; X =  2Dtable + in2*16/256*scale, first row of interpolation
8050   EAEE 3C                      pshx                            ; st1:st2 = 2Dtable + in2*16/256*scale
8051   EAEF D6 59                   ldab    temp3                   ; b=scale                              
8052   EAF1 3A                      abx                             ; X = 2Dtable + in2*16/256*scale + scale, go to next row of interpolation...
8053   EAF2 8D 0D                   bsr     L1589                   ; Calculate interpolated value on second row, result in b                              
8054   EAF4 D7 59                   stab    temp3                   ; temp3 = interpolated value on second row                             
8055   EAF6 38                      pulx                            ; x = 2Dtable + in2*16/256*scale (first row)
8056   EAF7 8D 08                   bsr     L1589                   ; Calculate interpolated value on first row, result in b                               
8057   EAF9 D7 58                   stab    temp2                   ; temp3 = interpolated value on first row                               
8058   EAFB 32                      pula                            ; a = LO(in2*16)                              
8059   EAFC CE 00 58                ldx     #temp2                  ;                                
8060   EAFF 20 4A                   bra     interpSpec              ; Interpolate temp variables temp2 and temp3 using fractional part a=LO(in2*16) with no scaling on a and return to calling sub, result in b
8061   EB01             
8062   EB01             
8063   EB01             
8064   EB01             ;******************************************************************
8065   EB01             ;
8066   EB01             ;
8067   EB01             ; Used by lookup2D, interpolate on one row between two columns
8068   EB01             ;
8069   EB01             ;
8070   EB01             ;******************************************************************
8071   EB01 96 5B       L1589       ldaa    temp5                   ; a = in1                              
8072   EB03 5F                      clrb                            ; b=0                             
8073   EB04 04                      lsrd                            ;                             
8074   EB05 04                      lsrd                            ;                             
8075   EB06 04                      lsrd                            ;                             
8076   EB07 04                      lsrd                            ; d = in1*256/16 = in1*16                             
8077   EB08 37                      pshb                            ; st3 = LO(in1*16)
8078   EB09 16                      tab                             ; b=in1*16/256=in1/16
8079   EB0A 32                      pula                            ; a=LO(in1*16)
8080   EB0B 3A                      abx                             ; X = startOfRow + in1/16
8081   EB0C E6 00                   ldab    $00,x                   ; b = val1, table lookup, get value in row                             
8082   EB0E DB 5A                   addb    temp4                   ; b = val1 + offset                             
8083   EB10 D7 57                   stab    temp1                   ; temp1 = val1 + offset                             
8084   EB12 E6 01                   ldab    $01,x                   ; b = val2, next value in table on same row                             
8085   EB14 DB 5A                   addb    temp4                   ; b = val2 + offset                            
8086   EB16 D7 58                   stab    temp2                   ; temp2 = val2 + offset                             
8087   EB18 CE 00 57                ldx     #temp1                  ; X points to temp variables
8088   EB1B 20 2E                   bra     interpSpec              ; Interpolate temp variables temp1 and temp2 using fractional part a=LO(in1*16) with no scaling on a and return to calling sub, result in b
8089   EB1D             
8090   EB1D             
8091   EB1D             
8092   EB1D             ;******************************************************************
8093   EB1D             ;
8094   EB1D             ; Interpolate a table using ectCond, (ectCond is inv. proportional to temp)
8095   EB1D             ; This one compensate for non constant distance between the table points
8096   EB1D             ;
8097   EB1D             ; Used in the calculation of injPwStart
8098   EB1D             ; Input X = table
8099   EB1D             ;
8100   EB1D             ;
8101   EB1D             ;
8102   EB1D             ;******************************************************************
8103   EB1D F6 01 4E    interpEct2  ldab    ectCond                 ; b = ectCond (ect conditionned for table interp..)                            
8104   EB20 C1 C0                   cmpb    #$c0                    ; -7degC                            
8105   EB22 25 08                   bcs     L1591                   ; Branch if ectCond < $c0
8106   EB24 4F                      clra                            ; a = 0, d = ectCond 
8107   EB25 05                      asld                            ; d = 2*ectCond                            
8108   EB26 83 00 C0                subd    #$00c0                  ; d = 2*ectCond -$c0                              
8109   EB29 BD EB B3                jsr     ovfCheck                ;                              
8110   EB2C 17          L1591       tba                             ; a = 2*ectCond -$c0                              
8111   EB2D 20 12                   bra     interp32                ;                                 
8112   EB2F             
8113   EB2F             
8114   EB2F             
8115   EB2F             ;******************************************************************
8116   EB2F             ;
8117   EB2F             ;
8118   EB2F             ; Interpolate a table using ECT (ectCond is inv. proportional to temp)
8119   EB2F             ; Input X = table
8120   EB2F             ;
8121   EB2F             ;
8122   EB2F             ;******************************************************************
8123   EB2F B6 01 4E    interpEct   ldaa    ectCond                                                 
8124   EB32 20 0D                   bra     interp32                                                 
8125   EB34             
8126   EB34             
8127   EB34             
8128   EB34             ;******************************************************************
8129   EB34             ;
8130   EB34             ;
8131   EB34             ;
8132   EB34             ;
8133   EB34             ;
8134   EB34             ;******************************************************************
8135   EB34 B6 01 51    interp16rpm ldaa    rpmIndex1                                                 
8136   EB37 20 05                   bra     interp16b                                                 
8137   EB39             
8138   EB39             
8139   EB39             
8140   EB39             ;******************************************************************
8141   EB39             ;
8142   EB39             ;
8143   EB39             ; Interpolate table using Conditionned IAT (iatCond)
8144   EB39             ;
8145   EB39             ;
8146   EB39             ;******************************************************************
8147   EB39 B6 01 4F    iatCInterp  ldaa    iatCond                                                 
8148   EB3C 20 03                   bra     interp32                                                 
8149   EB3E             
8150   EB3E             
8151   EB3E             
8152   EB3E             ;******************************************************************
8153   EB3E             ;
8154   EB3E             ;
8155   EB3E             ;
8156   EB3E             ;
8157   EB3E             ;
8158   EB3E             ;******************************************************************
8159   EB3E 5F          interp16b   clrb                                                         
8160   EB3F 20 02                   bra     interp16                                                 
8161   EB41             
8162   EB41             
8163   EB41             
8164   EB41             ;******************************************************************
8165   EB41             ;
8166   EB41             ; Table lookup with fractional interpolation
8167   EB41             ; input value = A
8168   EB41             ; input table = X
8169   EB41             ; output value in a and b is (interpolated table) = X(A/32)
8170   EB41             ;
8171   EB41             ;
8172   EB41             ;******************************************************************
8173   EB41 5F          interp32    clrb                            ;                             
8174   EB42 04                      lsrd                            ; 
8175   EB43 04          interp16    lsrd                            ;                             
8176   EB44 04                      lsrd                            ;                             
8177   EB45 04                      lsrd                            ;                             
8178   EB46 04                      lsrd                            ; A=A/32, B = 5 LSB of A in upper part 
8179   EB47 37          interp1     pshb                            ; \                                                                                                
8180   EB48 16                      tab                             ;  >transfer A to B, only 3 bits left                                                              
8181   EB49 32                      pula                            ; / At this point, B=integer part of input/32, A=fractional part                                   
8182   EB4A 3A                      abx                             ; ADD B TO X:  B = 0 to 7 (3 bits) (integer table lookup), X=V(0)     
8183   EB4B                                                                                                                                                        
8184   EB4B 4D          interpSpec  tsta                            ; 
8185   EB4C 27 0B                   beq     L1601                   ; Branch if a = 0 (no fractional interp)                                                       
8186   EB4E E6 01                   ldab    $01,x                   ; B=V(1)                                                                                            
8187   EB50 E0 00                   subb    $00,x                   ; B=V(1)-V(0)                                                                                       
8188   EB52 24 03                   bcc     L1600                   ; banch if V(1)-V(0) > 0                                                                             
8189   EB54 08                      inx                             ; negative->X=V(1)                                                                                 
8190   EB55 50                      negb                            ;                                                                                                  
8191   EB56 40                      nega                            ;                                                                                                  
8192   EB57 3D          L1600       mul                             ; D=A*B (                                                                                          
8193   EB58 58                      aslb                            ; shift left B (... carry)                                                                         
8194   EB59 A9 00       L1601       adca    $00,x                   ; add to a with carry                                                                               
8195   EB5B 16                      tab                                                          
8196   EB5C 39                      rts                                                          
8197   EB5D             
8198   EB5D             
8199   EB5D             
8200   EB5D             ;******************************************************************
8201   EB5D             ;
8202   EB5D             ; Interpolate table an multiply result by [temp6:temp7]
8203   EB5D             ; 
8204   EB5D             ;
8205   EB5D             ;
8206   EB5D             ;******************************************************************
8207   EB5D 8D E2       interp32mul   bsr     interp32                                                 
8208   EB5F                         ; continued below...
8209   EB5F             
8210   EB5F             
8211   EB5F             
8212   EB5F             ;******************************************************************
8213   EB5F             ;
8214   EB5F             ;  Multiply 8 bit by 16 bits, final result is scaled by 128, 
8215   EB5F             ;  rounded and checked for overflow
8216   EB5F             ;
8217   EB5F             ; input:
8218   EB5F             ;   b: 8 bit value
8219   EB5F             ;   [temp6:temp7]: 16 bit value
8220   EB5F             ;
8221   EB5F             ; output:      
8222   EB5F             ;   D and [temp6:temp7]: rounded 2*b*[temp6:temp7]/256 = b*[temp6:temp7]/128
8223   EB5F             ;
8224   EB5F             ;
8225   EB5F             ;******************************************************************
8226   EB5F BD EA 70    mul816_128  jsr     mul816                  ; D = b*[temp6:temp7]/256                              
8227   EB62 78 00 59                asl     temp3                   ; Get lowest bit from fractional part                              
8228   EB65 59                      rolb                            ; Shift it in                            
8229   EB66 49                      rola                            ; shift it in, D = 2*b*[temp6:temp7]/256 
8230   EB67 25 09                   bcs     L1604                   ; Branch if overflow                             
8231   EB69 78 00 59                asl     temp3                   ; No overflow, Get second lowest bit from fractional part
8232   EB6C C9 00                   adcb    #$00                    ; Add it to result (round-up result)                            
8233   EB6E 89 00                   adca    #$00                    ; propagate                            
8234   EB70 24 02                   bcc     L1605                   ; Branch if no overflow                             
8235   EB72 86 FF       L1604       ldaa    #$ff                    ; Overflow, return max value                            
8236   EB74 DD 5C       L1605       std     temp6                   ; Store result                             
8237   EB76 39                      rts                             ;                             
8238   EB77                                                         
8239   EB77             
8240   EB77             
8241   EB77             ;******************************************************************
8242   EB77             ;
8243   EB77             ; Input:
8244   EB77             ;               D = 16 bit value1 (should be only 11 or 12 bits???)
8245   EB77             ;     temp6:temp7 = 16 bit value2
8246   EB77             ;
8247   EB77             ; Output:
8248   EB77             ;       D and [temp6:temp7] = rounded value1*value2/128 (a=$ff in case of overflow)
8249   EB77             ;       Optionally, divided by and additional 4 if mul1616_512 is used or 16 if mul1616_2K is used
8250   EB77             ;
8251   EB77             ;******************************************************************
8252   EB77 05          mul1616_128 asld                            ;                              
8253   EB78 05                      asld                            ;                             
8254   EB79 05          mul1616_512 asld                            ;                             
8255   EB7A 05                      asld                            ; D = value1 * 16                            
8256   EB7B BD EA 85    mul1616_2K  jsr     mul1616                 ; D = (value1 * 16 * value2)/65536 (upper 16 bits of mul1616)                              
8257   EB7E DE 58                   ldx     temp2                   ; X = lower 16 bits of (value1 * 16 * value2)                             
8258   EB80 1A                      xgdx                            ; D = lower 16 bits of (value1 * 16 * value2), X = (value1 * 16 * value2)/65536                           
8259   EB81 C6 03                   ldab    #$03                    ; a = 3rd part of mul1616, b=3=number of loop to execute                            
8260   EB83             
8261   EB83                         ;--------------------------------------------
8262   EB83                         ; Loop 3 times to divide 24 bit result by 8 
8263   EB83                         ;--------------------------------------------
8264   EB83 1A          L1609       xgdx                            ; Xhi = 3rd part of mul1616, Xlo = 3, D = (value1 * 16 * value2)/65536
8265   EB84 04                      lsrd                            ; D = (value1 * 16 * value2)/65536/2^n, carry = lower bit
8266   EB85 1A                      xgdx                            ; X = (value1 * 16 * value2)/65536/2^n, a = 3rd part of mul1616/2^(n-1), b=3 on first loop                             
8267   EB86 46                      rora                            ; shift in carry, a = (3rd part of mul1616)/2^n, b=3 on first loop
8268   EB87 5A                      decb                            ; b=b-1                           
8269   EB88 26 F9                   bne     L1609                   ; loop
8270   EB8A             
8271   EB8A                         ;------------------------------------------------------------
8272   EB8A                         ; Round-up and check for overflow in A
8273   EB8A                         ; At this point, 24 bit result should have been
8274   EB8A                         ; shifted down to fit only in 16 bits, upper 8 bit
8275   EB8A                         ; should be 0, if not, b will be loaded with $ff in scale1m
8276   EB8A                         ;------------------------------------------------------------
8277   EB8A 89 00                   adca    #$00                    ; Round-up result 3rd part of result                            
8278   EB8C 36                      psha                            ; st0 = lower 8 bit of result                            
8279   EB8D 1A                      xgdx                            ; D = (value1 * 16 * value2)/65536/8                             
8280   EB8E 8D 1F                   bsr     scale1m                 ; Propagate carry from 3rd part of result to D and check for overflow 
8281   EB90             
8282   EB90                         ;-----------------------------------------------------------------------
8283   EB90                         ; At this point, we assume upper 8 bits=0 and only keep lower 16 bits
8284   EB90                         ;-----------------------------------------------------------------------
8285   EB90 17                      tba                             ; a =  2nd part of 24 bit result                            
8286   EB91 33                      pulb                            ; b =  lower 8 bit of 24 bit result, in short, D=(value1 * 16 * value2)/256/8 = value1*value2/128
8287   EB92 DD 5C                   std     temp6                   ; temp6:temp7 = value1*value2/128
8288   EB94 39                      rts                             ;                             
8289   EB95                         
8290   EB95             
8291   EB95             
8292   EB95             ;******************************************************************
8293   EB95             ;
8294   EB95             ; Scaling function with rounding
8295   EB95             ; Divide d by 128 or 64, etc.
8296   EB95             ;
8297   EB95             ;
8298   EB95             ;
8299   EB95             ;******************************************************************
8300   EB95 04          scale128    lsrd                              ;                           
8301   EB96 04          scale64     lsrd                              ;                           
8302   EB97 04                      lsrd                              ;                           
8303   EB98 04          scale16     lsrd                              ;                           
8304   EB99 04          scale8      lsrd                              ;                           
8305   EB9A 04                      lsrd                              ;                           
8306   EB9B 04                      lsrd                              ;                           
8307   EB9C C9 00                   adcb    #$00                      ; Round-up by adding carry bit                          
8308   EB9E 89 00                   adca    #$00                      ; propagate addition                          
8309   EBA0 39                      rts                               ;                            
8310   EBA1                                                          
8311   EBA1             
8312   EBA1             
8313   EBA1             ;******************************************************************
8314   EBA1             ;
8315   EBA1             ; Input:
8316   EBA1             ;       d = v1:v0
8317   EBA1             ;
8318   EBA1             ; Output:
8319   EBA1             ;       a = v1 rounded up depending on v0, up to max of $ff
8320   EBA1             ;
8321   EBA1             ;
8322   EBA1             ;******************************************************************
8323   EBA1 58          round256    aslb                            ; Shift high bit of b in carry
8324   EBA2 89 00                   adca    #$00                    ; roundup a                            
8325   EBA4 24 01                   bcc     L1615                   ; branch if no overflow                             
8326   EBA6 4A                      deca                            ; Overflow, use max of $ff                            
8327   EBA7 39          L1615       rts                             ;                             
8328   EBA8             
8329   EBA8             
8330   EBA8             
8331   EBA8             ;******************************************************************
8332   EBA8             ;
8333   EBA8             ;
8334   EBA8             ; Divide D by 128 or 64 or 32... in order for the value to fit
8335   EBA8             ; only in b (with a=0). If it does not fit (a<>0), b is loaded with 
8336   EBA8             ; max value of $ff
8337   EBA8             ;
8338   EBA8             ;
8339   EBA8             ;
8340   EBA8             ;******************************************************************
8341   EBA8 04          scale128m   lsrd                                                         
8342   EBA9 04          scale64m    lsrd                                                         
8343   EBAA 04                      lsrd                                                         
8344   EBAB 04          scale16m    lsrd                                                         
8345   EBAC 04          scale8m     lsrd                                                         
8346   EBAD 04          scale4m     lsrd                                                         
8347   EBAE 04          scale2m     lsrd                            ; D = D/128, carry contains last bit shifted out                                        
8348   EBAF C9 00       scale1m     adcb    #$00                    ; Add last bit shifted out (round-up number)                                            
8349   EBB1 89 00                   adca    #$00                    ; propagate addition of last bit                                                        
8350   EBB3 4D          ovfCheck    tsta                                                         
8351   EBB4 27 02                   beq     L1624                   ; branch if A=0                                                                                            
8352   EBB6 C6 FF                   ldab    #$ff                    ; A is not 0, set fractional part to FF (the only one returned...)                              
8353   EBB8 39          L1624       rts                                                          
8354   EBB9             
8355   EBB9             
8356   EBB9             
8357   EBB9             ;******************************************************************
8358   EBB9             ;
8359   EBB9             ;
8360   EBB9             ; Apply an offset and clip input, the result is usually used to 
8361   EBB9             ; interpolate a table with a value of known range...
8362   EBB9             ;
8363   EBB9             ;        in Xhi = max value
8364   EBB9             ;        in Xlo = offset
8365   EBB9             ;        in   b = input value
8366   EBB9             ;
8367   EBB9             ;        out b = max(min(b,Xhi)-Xlo,0)
8368   EBB9             ;
8369   EBB9             ;
8370   EBB9             ;******************************************************************
8371   EBB9 DF 57       clipOffset  stx     temp1                                                 
8372   EBBB D1 57                   cmpb    temp1                                                 
8373   EBBD 25 02                   bcs     L1626                                                 
8374   EBBF D6 57                   ldab    temp1                                                 
8375   EBC1 D0 58       L1626       subb    temp2                                                 
8376   EBC3 24 01                   bcc     L1627                                                 
8377   EBC5 5F                      clrb                                                         
8378   EBC6 39          L1627       rts                                                          
8379   EBC7             
8380   EBC7             
8381   EBC7             
8382   EBC7             ;******************************************************************
8383   EBC7             ;
8384   EBC7             ; This function is used to apply a piecewise linear transformation
8385   EBC7             ; to the input value, see L2052, L2053 and L2054. This can be seen
8386   EBC7             ; as calculating the index into a table where the spacing between
8387   EBC7             ; table entries is not constant (first three entries spaced by x,
8388   EBC7             ; next three spaced by 2x, etc...)
8389   EBC7             ;
8390   EBC7             ; Input:
8391   EBC7             ;       a = val
8392   EBC7             ;       b = 0 (ignored or cleared)
8393   EBC7             ;       y = points to table with first two values being a max 
8394   EBC7             ;           and offset and the rest being triplets (addVal, nshift, compVal)
8395   EBC7             ;           where compVal is monotonicaly increasing... 
8396   EBC7             ;
8397   EBC7             ; Output:
8398   EBC7             ;       a = (min(val,max) - offset + addVal)/2^(nshift-1)
8399   EBC7             ;       
8400   EBC7             ;       where max and offset are the first two values of the table
8401   EBC7             ;       and where addVal and nShift are taken from the table according to val-offset
8402   EBC7             ;
8403   EBC7             ;******************************************************************
8404   EBC7                         ;------------------------------------------------------
8405   EBC7                         ; Apply max value of table, a = min(val,table[0])
8406   EBC7                         ;------------------------------------------------------
8407   EBC7 A1 80       pwiseLin    cmpa    $00,y                   ; Operation does ++y...I assume                             
8408   EBC9 25 05                   bcs     L1629                   ; Branch if a < table[0]                             
8409   EBCB CD 09                   decy                            ; --y, go back to 0                           
8410   EBCD A6 80                   ldaa    $00,y                   ; a=table[y++]                             
8411   EBCF 5F                      clrb                            ; b=0
8412   EBD0                               
8413   EBD0                         ;----------------------------------------------------------                      
8414   EBD0                         ; Subtract offset of table, a = val-table[1] = val-offset
8415   EBD0                         ;----------------------------------------------------------                      
8416   EBD0 A0 80       L1629       suba    $00,y                   ; a = val-table[y++] = val-offset                             
8417   EBD2 24 02                   bcc     L1630                   ; Branch if result positive                             
8418   EBD4 4F                      clra                            ; Result negative, d=0                            
8419   EBD5 5F                      clrb                            ; d=0
8420   EBD6                                                     
8421   EBD6                         ;----------------------------------------------
8422   EBD6                         ; Loop until we find compVal > a 
8423   EBD6                         ;----------------------------------------------
8424   EBD6 EE 80       L1630       ldx     $00,y                   ; x = table[y]:table[y+1]; y = y + 2                               
8425   EBD8 A1 80                   cmpa    $00,y                   ; Operation does ++y...I assume                             
8426   EBDA 24 FA                   bcc     L1630                   ; Loop if  a >= table[y]                              
8427   EBDC             
8428   EBDC                         ;-------------------------------------------------------------- 
8429   EBDC                         ; Store the corresponding addVal and nshift in temp1 and temp2
8430   EBDC                         ;-------------------------------------------------------------- 
8431   EBDC DF 57                   stx     temp1                   ; temp1 = addVal;, temp2 = nshift
8432   EBDE             
8433   EBDE                         ;--------------------------------------------
8434   EBDE                         ; Add addVal to a, a = val - offset + addVal
8435   EBDE                         ;--------------------------------------------
8436   EBDE 9B 57                   adda    temp1                   ; a = a-offset+addVal 
8437   EBE0                         
8438   EBE0                         ;----------------------------------------------------------------
8439   EBE0                         ; Apply nshift to a, a =  (val - offset + addVal)/2^(nshift-1)
8440   EBE0                         ;----------------------------------------------------------------
8441   EBE0 7A 00 58    L1631       dec     temp2                   ; temp2=table[y+1]-1
8442   EBE3 27 03                   beq     L1632                   ; Btanch if table[y+1]-1 =0
8443   EBE5 04                      lsrd                            ; d = d/2                            
8444   EBE6 20 F8                   bra     L1631                   ; Loop                             
8445   EBE8 39          L1632       rts                             ;                             
8446   EBE9             
8447   EBE9             
8448   EBE9             
8449   EBE9             ;******************************************************************
8450   EBE9             ;
8451   EBE9             ; Input: 
8452   EBE9             ;       y: point to piecewise linear transformation table
8453   EBE9             ;
8454   EBE9             ; Apply piecewise linear transformation to rpm4 and scale
8455   EBE9             ;
8456   EBE9             ;
8457   EBE9             ;******************************************************************
8458   EBE9 DC DA       rpmPwise    ldd     rpm4                    ;                              
8459   EBEB 05                      asld                            ;                             
8460   EBEC 05                      asld                            ; d = rpm4*4                            
8461   EBED 8D D8                   bsr     pwiseLin                ;                              
8462   EBEF 20 BA                   bra     scale16m                ;                                 
8463   EBF1             
8464   EBF1             
8465   EBF1             
8466   EBF1             ;******************************************************************
8467   EBF1             ;
8468   EBF1             ;
8469   EBF1             ; Decrement value at X by 1 (min of 0) if Tclocks.0 (40Hz signal) is set
8470   EBF1             ;
8471   EBF1             ;
8472   EBF1             ;******************************************************************
8473   EBF1 C6 01       decX40Hz    ldab    #$01                                                 
8474   EBF3 8F D9 01 0A             brclr   Tclocks, #$01, L1637                                     
8475   EBF7             
8476   EBF7             
8477   EBF7             
8478   EBF7             ;******************************************************************
8479   EBF7             ;
8480   EBF7             ;
8481   EBF7             ; Decrement all values in a given table by 1, stop at min value 0
8482   EBF7             ; X points to table, b is number of elements
8483   EBF7             ;
8484   EBF7             ;
8485   EBF7             ;******************************************************************
8486   EBF7 CF 00 FF 02 decTable    brclr   $0000,x,#$ff,L1636  
8487   EBFB 6A 00                   dec     $0000,x                                                 
8488   EBFD 08          L1636       inx                                                          
8489   EBFE 5A                      decb                                                         
8490   EBFF 26 F6                   bne     decTable                                                 
8491   EC01 39          L1637       rts                                                          
8492   EC02             
8493   EC02             
8494   EC02             
8495   EC02             ;******************************************************************
8496   EC02             ;
8497   EC02             ; Lookup the given table using config2 
8498   EC02             ; lowest 2 bits as index to 16 bits values
8499   EC02             ;
8500   EC02             ; Input:
8501   EC02             ;     x: points to table
8502   EC02             ;
8503   EC02             ; Output:
8504   EC02             ;
8505   EC02             ;     x(16 bits): table(2*(config2 & $03))
8506   EC02             ;
8507   EC02             ;******************************************************************
8508   EC02 D6 56       cfgLookup16 ldab    config2                 ; b = config2                               
8509   EC04 C4 03                   andb    #$03                    ;                             
8510   EC06 58                      aslb                            ; b = 2*(config2 & $03)                            
8511   EC07 3A                      abx                             ; x points to table(2*(config2 & $03))                            
8512   EC08 EE 00                   ldx     $00,x                   ; x =  table(2*(config2 & $03))                             
8513   EC0A 39                      rts                             ;                             
8514   EC0B             
8515   EC0B             
8516   EC0B             
8517   EC0B             ;******************************************************************
8518   EC0B             ;
8519   EC0B             ; Read value from IO port (ADC) using a and b (d) as the values
8520   EC0B             ; to write to adc_ctl and adc_data respectively. a should be set
8521   EC0B             ; to the port number (0 to 7 as indicated below) with the start bit
8522   EC0B             ; set to 1 ($08) 
8523   EC0B             ;
8524   EC0B             ;     Port $00: ECT (engine coolant temp)
8525   EC0B             ;     Port $01: IAT
8526   EC0B             ;     Port $02: BARO
8527   EC0B             ;     Port $03: O2
8528   EC0B             ;     Port $04: EGRT
8529   EC0B             ;     Port $05: BATT
8530   EC0B             ;     Port $06: KNOCK count
8531   EC0B             ;     Port $07: TPS
8532   EC0B             ;
8533   EC0B             ;
8534   EC0B             ;******************************************************************
8535   EC0B 0F          readAdc1    sei                            ; set interrupt mask             
8536   EC0C DD 1F       readAdc2    std     adc_ctl                ; set port #                     
8537   EC0E 21 00                   brn     L1641                  ; time delay                     
8538   EC10 15 FF       L1641       div     airCntDef              ; time delay                     
8539   EC12 3D                      mul                            ; time delay                     
8540   EC13 3D                      mul                            ; time delay                     
8541   EC14 3D                      mul                            ; time delay                     
8542   EC15 3D                      mul                            ; time delay                     
8543   EC16 3D                      mul                            ; time delay                     
8544   EC17 3D                      mul                            ; time delay                     
8545   EC18 3D                      mul                            ; time delay                     
8546   EC19 DC 1F                   ldd     adc_ctl                ; get port value                 
8547   EC1B 39                      rts                                                          
8548   EC1C             
8549   EC1C             
8550   EC1C             
8551   EC1C             ;******************************************************************
8552   EC1C             ;
8553   EC1C             ;
8554   EC1C             ; input: rpm in b, maxRpm in a 
8555   EC1C             ;        (note that airVol is also used instead of rpm in 
8556   EC1C             ;         calling this function)
8557   EC1C             ;
8558   EC1C             ; output:   b = min(max(rpm-$10,0), maxRpm)      $10->500rpm
8559   EC1C             ;
8560   EC1C             ;******************************************************************
8561   EC1C C0 10       rpmRange    subb    #$10                    ;                                              
8562   EC1E 24 01                   bcc     abmin                   ; Branch if result positive
8563   EC20 5F                      clrb                            ; Use min of 0
8564   EC21             
8565   EC21                         ;--------------------------------------------
8566   EC21                         ; Code below also called as a function
8567   EC21                         ; abmin -> b = minimum of a and b (can also 
8568   EC21                         ; be seen as applying a max...)
8569   EC21                         ;--------------------------------------------
8570   EC21 11          abmin       cba                             ; compare (A-B)                                
8571   EC22 24 01                   bcc     L1644                   ; Branch if b<=maxRpm
8572   EC24 16                      tab                             ; b = maxRpm
8573   EC25 39          L1644       rts                             ; return                                  
8574   EC26             
8575   EC26             
8576   EC26             
8577   EC26             ;******************************************************************
8578   EC26             ;
8579   EC26             ; Input:
8580   EC26             ;     None (a=airVol if called from L1647)
8581   EC26             ;
8582   EC26             ; Output: in b (same result in a):
8583   EC26             ; 
8584   EC26             ;     airVol[T]B  < 60: airVol[T]B - $20
8585   EC26             ;     airVol[T]B >= 60: 0.668 * airVol[T]B
8586   EC26             ;
8587   EC26             ; The maximum of airVolTB or airVolB is used, see comments below
8588   EC26             ;
8589   EC26             ;----------------------------------------
8590   EC26             ;
8591   EC26             ; the ecu makes a temp value for the table lookup..
8592   EC26             ; so if 0xe3 <= 96, value = 0xe3 - 32,
8593   EC26             ; if 0xe3 > 96, value = 0xe3 * 2/3
8594   EC26             ;
8595   EC26             ;******************************************************************
8596   EC26             getLoadForMaps
8597   EC26~            #ifdef extLoadRange
8598   EC26~            #ifdef extLoadRange2
8599   EC26~                        ldaa    L0054                   ; a = airVol16/4
8600   EC26~                        ldab    baroFact                ; b = baroFact
8601   EC26~                        mul                             ; d = airVol16/4 * baroFact
8602   EC26~                        jsr     scale128m               ; b = airVol16/4 * baroFact/128
8603   EC26~                        ldaa    iatCompFact             ; a = iatCompFact 
8604   EC26~                        bpl     test123                 ; Branch if iatCompFact < $80
8605   EC26~                        mul                             ; d = airVol16/4 * baroFact/128  * iatCompFact
8606   EC26~                        jsr     scale128m               ; b = airVol16/4 * baroFact/128  * iatCompFact/128
8607   EC26~            test123     tba                             ; a = airVol16/4 * baroFact/128 [* iatCompFact/128]
8608   EC26~            #else
8609   EC26~                        ldaa    L0054                   ; a = airVol16/4
8610   EC26~                        bra     L1647
8611   EC26~                        nop
8612   EC26~                        nop
8613   EC26~                        nop
8614   EC26~                        nop
8615   EC26~                        nop
8616   EC26~                        nop
8617   EC26~                        nop
8618   EC26~            #endif
8619   EC26             #else
8620   EC26                         ;-----------------------------------------------------
8621   EC26                         ; Decide on which value to use, airVolTB or airVolB
8622   EC26                         ;
8623   EC26                         ; Done this way, it correspond to taking the 
8624   EC26                         ; highest of the two since:
8625   EC26                         ;
8626   EC26                         ;       airVolTB = airVolB * iatCompFact/128
8627   EC26                         ;
8628   EC26                         ;       if iatCompFact<128  -> max is airVolB 
8629   EC26                         ;       if iatCompFact>=128 -> max is airVolTB 
8630   EC26                         ;
8631   EC26                         ; Since the load is used to interpolate the fuel map,
8632   EC26                         ; it is probably safer to use the maximum of the two 
8633   EC26                         ; value, i.e. assume there is more air than less and 
8634   EC26                         ; therefore risk of running too rich. The risk of using 
8635   EC26                         ; only airVolTB is that if the temperature sensor is 
8636   EC26                         ; heat soaked then it will report a higher temperature 
8637   EC26                         ; than the actual temperature of the air getting in.
8638   EC26                         ; This means that airVolTB will report less air than
8639   EC26                         ; is actually getting in and there won't be enough 
8640   EC26                         ; fuel injected -> we will run too lean... 
8641   EC26                         ;-----------------------------------------------------
8642   EC26 B6 01 5F                ldaa    iatCompFact             ; a=iatCompFact ($80=100%)                                   
8643   EC29 2A 04                   bpl     L1646                   ; Branch if iatCompFact<100%                              
8644   EC2B 96 E2                   ldaa    airVolTB                ; iatCompFact>=100%, a = airVolTB                                 
8645   EC2D 20 02                   bra     L1647                   ;                              
8646   EC2F 96 E3       L1646       ldaa    airVolB                 ; iatCompFact<100%, a = airVolB                               
8647   EC31             #endif
8648   EC31             
8649   EC31                         ;-------------------------------------
8650   EC31                         ; Compute load index from air volume
8651   EC31                         ;-------------------------------------
8652   EC31 16          L1647       tab                             ; a = b = airVol[T]B
8653   EC32 C0 60                   subb    #$60                    ; b = airVol[T]B - $60
8654   EC34 25 08                   bcs     L1648                   ; branch if underflow (airVol[T]B <$60)
8655   EC36 86 AB                   ldaa    #$ab                    ; a = $ab                            
8656   EC38 3D                      mul                             ; d = $ab * (airVol[T]B - $60)
8657   EC39 58                      aslb                            ; Shift higher bit of b in carry
8658   EC3A 89 00                   adca    #$00                    ; Round-up a                            
8659   EC3C 8B 60                   adda    #$60                    ; a = rounded $ab * (airVol[T]B - $60)/256 + $60
8660   EC3E 80 20       L1648       suba    #$20                    ; a = a-20                             
8661   EC40 24 01                   bcc     L1649                   ; branch if no overflow                             
8662   EC42 4F                      clra                            ; use min value                            
8663   EC43 16          L1649       tab                             ; a = b = result                            
8664   EC44 39                      rts                             ;                             
8665   EC45             
8666   EC45             
8667   EC45             
8668   EC45             ;******************************************************************
8669   EC45             ;
8670   EC45             ; Input: temp22:temp23 = v1:v0 (set to Tcas)
8671   EC45             ;
8672   EC45             ; Output 
8673   EC45             ;       d = abs([temp22:temp23] - TcasLast0) - [temp22:temp23] * $30//256
8674   EC45             ;
8675   EC45             ;******************************************************************
8676   EC45 96 80       L1650       ldaa    temp22                  ; a = v1
8677   EC47 C6 30                   ldab    #$30                    ; b = $30                             
8678   EC49 3D                      mul                             ; d = $30 * v1                             
8679   EC4A 1A                      xgdx                            ; x = $30 * v1                            
8680   EC4B 96 81                   ldaa    temp23                  ; a = v0                             
8681   EC4D C6 30                   ldab    #$30                    ; b = $30                            
8682   EC4F 3D                      mul                             ; d = $30 * v0                            
8683   EC50 16                      tab                             ; b = $30 * v0 /256                            
8684   EC51 3A                      abx                             ; x = $30 * v1 + $30 * v0 /256 = $30*(v1+v0/256) = [temp22:temp23] * $30//256                           
8685   EC52 DF 7E                   stx     temp20                  ; temp20 = [temp22:temp23] * $30//256                           
8686   EC54             
8687   EC54                         ;---------------------------------------
8688   EC54                         ; Compute abs(temp22:temp23 - TcasLast0)
8689   EC54                         ;---------------------------------------
8690   EC54 DC 80                   ldd     temp22                  ; d = temp22:temp23                             
8691   EC56 93 64                   subd    TcasLast0                ; d = temp22:temp23 - TcasLast0                              
8692   EC58 24 05                   bcc     L1651                   ; Branch if result positive
8693   EC5A 43                      coma                            ; Result negative, make it positive                            
8694   EC5B 53                      comb                            ;                             
8695   EC5C C3 00 01                addd    #$0001                  ; two's complement...                              
8696   EC5F             
8697   EC5F                         ;----------------
8698   EC5F                         ; Compute result
8699   EC5F                         ;----------------
8700   EC5F 93 7E       L1651       subd    temp20                  ; d = abs(temp22:temp23 - TcasLast0) - [temp22:temp23] * $30//256                                    
8701   EC61 39                      rts                             ;                             
8702   EC62             
8703   EC62             
8704   EC62             
8705   EC62             ;******************************************************************
8706   EC62             ;
8707   EC62             ;
8708   EC62             ; Input capture interrupt 1
8709   EC62             ;
8710   EC62             ; Main CAS interrupt routine, triggered on both the rising
8711   EC62             ; and falling edge of the CAS signal (edge detection polarity 
8712   EC62             ; is toggled in the code upon each interrupt)
8713   EC62             ;
8714   EC62             ;
8715   EC62             ;******************************************************************
8716   EC62                         ;------------------------------------------------
8717   EC62                         ; Read t3_clock1 for later use and then 
8718   EC62                         ; read t1_csr (not used so I assume it ackowledges 
8719   EC62                         ; the interrupt ?) 
8720   EC62                         ;------------------------------------------------
8721   EC62 DE 29       inCaptInt1  ldx     t3_clock1               ; Get current coil clock value when the cas edge changed?
8722   EC64 D6 08                   ldab    t1_csr                  ; Acknowledge cas input capture interrupt?                                                                                                                              
8723   EC66             
8724   EC66                         ;--------------------------------------------------------
8725   EC66                         ; Update t1_lastCas for eventual aiflow calculation
8726   EC66                         ;--------------------------------------------------------
8727   EC66 DC 0D                   ldd     t1_inCapt               ; Get cas input timer capture high/low                                                                                            
8728   EC68 DD 96                   std     t1_lastCas              ; store it here                                                                                                               
8729   EC6A             
8730   EC6A                         ;------------------------------------------------
8731   EC6A                         ; Update temp20 assuming interrupt is from t2
8732   EC6A                         ; will be changed later if assumption was wrong
8733   EC6A                         ;------------------------------------------------
8734   EC6A DC 2D                   ldd     t3_clock2               ; Get current counter value
8735   EC6C DD 7E                   std     temp20                  ; temp20 = t3_clock2                                                                                                                            
8736   EC6E             
8737   EC6E                         ;-------------------------------------------
8738   EC6E                         ; Branch to rising or falling edge section 
8739   EC6E                         ; depending on the interrupt source
8740   EC6E                         ;-------------------------------------------
8741   EC6E 8F 08 02 03             brclr   t1_csr, #$02, casRiseProc ; Branch if this is the cas rising edge
8742   EC72 7E F0 92                jmp     casFallProc               ; Branch to cas failling edge section
8743   EC75             
8744   EC75             
8745   EC75             
8746   EC75             ;******************************************************************
8747   EC75             ;
8748   EC75             ;
8749   EC75             ; Section processing the CAS interrupt on the rising edge
8750   EC75             ;   
8751   EC75             ;;
8752   EC75             ;
8753   EC75             ;******************************************************************
8754   EC75                         ;-------------------------------------------------------------------------
8755   EC75                         ; Check which of t3_clock1 or t3_clock2 should be used?
8756   EC75                         ; Not sure what that bit means???????????
8757   EC75                         ;-------------------------------------------------------------------------
8758   EC75 8F 19 10 03 casRiseProc brclr   t3_csr0, #$10, L1654    ; Branch if we should use t3_clock2, nothing to do, that's what we assumed above
8759   EC79             
8760   EC79                         ;-------------------------------------------------------------------------
8761   EC79                         ; t3_clock1 should be used, our assumption that it was
8762   EC79                         ; t3_clock2 was wrong, update d and  temp20 with the correct values
8763   EC79                         ;-------------------------------------------------------------------------
8764   EC79 1A                      xgdx                            ; d = t3_clock1
8765   EC7A DD 7E                   std     temp20                  ; temp20 = t3_clock1
8766   EC7C             
8767   EC7C                         ;-------------------------------------------------------------
8768   EC7C                         ; Branch to rest of code if the time between CAS
8769   EC7C                         ; interrupts makes sense (rpm is not too high...)
8770   EC7C                         ;
8771   EC7C                         ; The time measured here is the time in-between cas
8772   EC7C                         ; pulses since it is measured from the falling edge to the 
8773   EC7C                         ; rising edge. Since this time correspond to 110deg
8774   EC7C                         ; then the 1ms below correspond to 360/110*1ms = 3.27ms 
8775   EC7C                         ; per rotation which correspond to 18333rpm. The threshold of
8776   EC7C                         ; 1ms or 0.5 ms (18333 or 23333rpm) on the cas rising and falling 
8777   EC7C                         ; edge section is not the same and it might be due to the fact
8778   EC7C                         ; that on the cas falling edge, we measure a smaller interval 
8779   EC7C                         ; (70deg instead of 110deg) and therefore the uncertainty is 
8780   EC7C                         ; higher???
8781   EC7C                         ;-------------------------------------------------------------
8782   EC7C 93 6A       L1654       subd    casFallTime0            ; d = t3_clock1 - casFallTime0
8783   EC7E 1C 00 FA                cmpd    #$00fa                  ; 1ms at 250KHz                                                                                                                             
8784   EC81 24 07                   bcc     L1655                   ; Branch if (t3_clock1 or  t3_clock2 - casFallTime0) >= $00fa
8785   EC83             
8786   EC83                         ;------------------------------------------------
8787   EC83                         ; RPM seems too high to make sense, check if it is
8788   EC83                         ; not instead because RPM is so low that the 16 bit 
8789   EC83                         ; counter subtraction above rolled-over.
8790   EC83                         ;
8791   EC83                         ; Branch to rest of code if the T200_casFall timer shows
8792   EC83                         ; that rpm is very low... 
8793   EC83                         ;------------------------------------------------
8794   EC83 96 C0                   ldaa    T200_casFall            ;                                                                                                                             
8795   EC85 81 0E                   cmpa    #$0e                    ; 70ms at 200Hz                                                                                                                             
8796   EC87 25 01                   bcs     L1655                   ; branch if T200_casFall<70ms, T200_casFall is init with 265ms, the time between interrupt is very high                                                                                                                            
8797   EC89             
8798   EC89                         ;-------------------------------------------------------------
8799   EC89                         ; Time between interrupts doesn't make sense, just ignore it
8800   EC89                         ; Return from interrupt
8801   EC89                         ;-------------------------------------------------------------
8802   EC89 3B                      rti                             ;                                                                                                                            
8803   EC8A             
8804   EC8A                         ;---------------------------------------------------------------
8805   EC8A                         ; Update temp22:temp23 = Tcas measured on the cas rising edge
8806   EC8A                         ;---------------------------------------------------------------
8807   EC8A DC 7E       L1655       ldd     temp20                  ; D = temp20
8808   EC8C 93 68                   subd    casRiseTime0            ; D = temp20-casRiseTime0(old counter) = Tcas = 250000/2/(rpm/60)                                      
8809   EC8E DD 80                   std     temp22                  ; temp22:temp23 = Tcas (temp22 is not dedicated for that purpose...)                                 
8810   EC90             
8811   EC90                         ;--------------------------------
8812   EC90                         ; Validate temp22:temp23 = Tcas
8813   EC90                         ;--------------------------------
8814   EC90 D6 BF                   ldab    T200_casRise            ;                                
8815   EC92 27 07                   beq     L1656                   ; Branch if timer expired (very long Tcas...)                            
8816   EC94 4D                      tsta                            ;                             
8817   EC95 2B 09                   bmi     L1657                   ; Branch if Tcas/256 >= 128 (rpm<229)                             
8818   EC97 C1 0E                   cmpb    #$0e                    ;                             
8819   EC99 22 05                   bhi     L1657                   ; Branch if T200_casRise > $0e (70ms)                             
8820   EC9B CC FF FF    L1656       ldd     #$ffff                  ; Use max Tcas                              
8821   EC9E DD 80                   std     temp22                  ; store Tcas
8822   ECA0             
8823   ECA0                         ;----------------------------------------------
8824   ECA0                         ; Section to calculate new casFlags0 value but do 
8825   ECA0                         ; not store it now. It will be stored once the 
8826   ECA0                         ; interrupt is validated
8827   ECA0                         ;----------------------------------------------
8828   ECA0                         ;----------------------------------------------
8829   ECA0                         ; First transfer some bits to "old" positions 
8830   ECA0                         ; and assume some bits will be set...
8831   ECA0                         ;----------------------------------------------
8832   ECA0 96 61       L1657       ldaa    casFlags0               ; a = casFlags0                              
8833   ECA2 84 05                   anda    #$05                    ; a = casFlags0 & 00000101 (keep some old bits)                            
8834   ECA4 48                      asla                            ; Move the old bits to the "old" positions                            
8835   ECA5 8A 35                   oraa    #$35                    ; preload some bits (00110101)
8836   ECA7             
8837   ECA7                         ;--------------------------------------------------
8838   ECA7                         ; Set flag if timing adjustement mode is active
8839   ECA7                         ;--------------------------------------------------
8840   ECA7 8F 87 80 02             brclr   timAdjFlags, #$80, L1658 ; Branch if we are not in timing adjustement mode                               
8841   ECAB 8A 40                   oraa    #$40                     ; a = (casFlags0 & 00001001)*2 | 01110101                            
8842   ECAD             
8843   ECAD                         ;-------------------------------------------------
8844   ECAD                         ; Reset some new casFlags0 bits depending on rpm
8845   ECAD                         ;-------------------------------------------------
8846   ECAD DE 80       L1658       ldx     temp22                   ; x = temp22:temp23 = Tcas                             
8847   ECAF 8C 06 1A                cpx     #$061a                  ; 4801rpm                                   
8848   ECB2 25 1E                   bcs     L1662                   ; Branch if rpm(Tcas) >  4801rpm                                        
8849   ECB4 84 DF                   anda    #$df                    ; Reset 00100000                                        
8850   ECB6 8C 10 81                cpx     #$1081                  ; 1775rpm                                    
8851   ECB9 25 02                   bcs     L1659                   ; Branch if rpm(Tcas) >  1775rpm
8852   ECBB 84 FB                   anda    #$fb                    ; Reset 00000100                                        
8853   ECBD 8C 13 06    L1659       cpx     #$1306                  ; 1540rpm                                    
8854   ECC0 25 02                   bcs     L1660                   ; Branch if rpm(Tcas) >  1540rpm                                           
8855   ECC2 84 EF                   anda    #$ef                    ; reset 00010000                                        
8856   ECC4             
8857   ECC4                         ;---------------------------------------
8858   ECC4                         ; At this point rpm(Tcas) <= 4801rpm
8859   ECC4                         ; Choose rpm threshold with hysteresis
8860   ECC4                         ;---------------------------------------
8861   ECC4 C6 49       L1660       ldab    #$49                    ; b = $49 (401rpm)                            
8862   ECC6 85 02                   bita    #$02                    ;                              
8863   ECC8 26 02                   bne     L1661                   ; Branch if bit was already set                             
8864   ECCA C6 3A                   ldab    #$3a                    ; use lower threshold if bit alread set b = $3a (505rpm)                             
8865   ECCC             
8866   ECCC                         ;---------------------------------------------------------------------
8867   ECCC                         ; Reset flag bit if we are above/below threshold, with hysteresis
8868   ECCC                         ;---------------------------------------------------------------------
8869   ECCC D1 80       L1661       cmpb    temp22                  ;                              
8870   ECCE 22 02                   bhi     L1662                   ; Branch if rpm(Tcas) < b (401rpm or 505rpm)                             
8871   ECD0 84 FE                   anda    #$fe                    ; Reset 00000001                      
8872   ECD2                               
8873   ECD2                         ;-----------------------------------------------------------
8874   ECD2                         ; Store new value of casFlags0 in temp location for now
8875   ECD2                         ;-----------------------------------------------------------
8876   ECD2 97 82       L1662       staa    temp24                  ; Store new casFlags0 in temp memory for now
8877   ECD4                         
8878   ECD4                         ;--------------------------------------------------------------------
8879   ECD4                         ; At this point, we will check the CAS signal to make sure it stays
8880   ECD4                         ; set until 56us after the start of the interrupt. I guess this might
8881   ECD4                         ; be to filter eventual glitches in the CAS signal
8882   ECD4                         ;--------------------------------------------------------------------
8883   ECD4 DC 7E                   ldd     temp20                  ;                                   
8884   ECD6 C3 00 0E                addd    #$000e                  ; d = StartInterruptTime + $0e (56us)                              
8885   ECD9 8F 16 01 01 L1663       brclr   port5, #$01, L1664      ; Branch as long as CAS bit is clear (CAS signal is set)
8886   ECDD 3B                      rti                             ; CAS bit was set, Bail of interrupt
8887   ECDE 1D 29       L1664       cmpd1   t3_clock1               ; Compare current time to time stored when we started the interrupt processing                                 
8888   ECE0 2A F7                   bpl     L1663                   ; Loop if t3_clock1 < (temp20 + $0e (56us)), i.e. if its been less than 56us since interrupt was called
8889   ECE2             
8890   ECE2             
8891   ECE2             
8892   ECE2             ;******************************************************************
8893   ECE2             ;
8894   ECE2             ; Interrupt was valid
8895   ECE2             ; Proceed with processing stuff on the CAS rising edge
8896   ECE2             ;
8897   ECE2             ;
8898   ECE2             ;******************************************************************
8899   ECE2                         ;------------------------------------------
8900   ECE2                         ; Update p4Latched
8901   ECE2                         ; (get our own copy of port4, we don't want 
8902   ECE2                         ; changes during processing) 
8903   ECE2                         ;------------------------------------------
8904   ECE2 96 07                   ldaa    port4                   ;                              
8905   ECE4 97 86                   staa    p4Latched               ;                                  
8906   ECE6             
8907   ECE6                         ;-----------------------
8908   ECE6                         ; Update casRiseTime0 
8909   ECE6                         ;-----------------------
8910   ECE6 DC 7E                   ldd     temp20                  ; d = temp20                                   
8911   ECE8 DD 68                   std     casRiseTime0            ; casRiseTime0 = time at interrupt start 
8912   ECEA             
8913   ECEA                         ;--------------------------------------
8914   ECEA                         ; Finally store the new casFlags0 value  
8915   ECEA                         ; (we now know interrupt was valid...)
8916   ECEA                         ;--------------------------------------
8917   ECEA 96 82                   ldaa    temp24                  ;                              
8918   ECEC 97 61                   staa    casFlags0               ;                              
8919   ECEE             
8920   ECEE                         ;---------------------------------------------------------
8921   ECEE                         ; Reset flag ignFallFlags.0
8922   ECEE                         ;---------------------------------------------------------
8923   ECEE 02 62 FE                andm    ignFallFlags, #$fe             ;                                
8924   ECF1             
8925   ECF1                         ;---------------------------------------------------------
8926   ECF1                         ; restart T200_casRise timer to 175ms
8927   ECF1                         ;---------------------------------------------------------
8928   ECF1 86 35                   ldaa    #$35                    ; 175ms                             
8929   ECF3 97 BF                   staa    T200_casRise            ;                              
8930   ECF5             
8931   ECF5                         ;------------------------------------
8932   ECF5                         ; Store current TDC state in temp24
8933   ECF5                         ;------------------------------------
8934   ECF5 96 06                   ldaa    port3                   ;                             
8935   ECF7 84 04                   anda    #$04                    ; Keep only TDC bit                           
8936   ECF9 97 82                   staa    temp24                  ; temp24.2 = TDC bit
8937   ECFB             
8938   ECFB                         ;-----------------------------------------------
8939   ECFB                         ; Toggle tdcMask0:tdcMask1 (between $0402 and $0204)
8940   ECFB                         ;-----------------------------------------------
8941   ECFB CC 04 02                ldd     #$0402                  ;                              
8942   ECFE 87 7B 02 03             brset   tdcMask0, #$02, L1665   ; Branch if old tdcMask0.1 is set
8943   ED02 CC 02 04                ldd     #$0204                  ;                               
8944   ED05 DD 7B       L1665       std     tdcMask0                ; Store new value
8945   ED07                                
8946   ED07                         ;-----------------------------------------------------
8947   ED07                         ; Only execute the following section if the TDC signal 
8948   ED07                         ; did not change. Why? we just stored it 
8949   ED07                         ; a few lines earlier????? and if we really are on the
8950   ED07                         ; CAS rising edge then TDC cannot change at this time...
8951   ED07                         ;
8952   ED07                         ; Maybe this is some kind of safety/glitch/noise 
8953   ED07                         ; safety precaution. TDC signal could get corrupted
8954   ED07                         ; when the engine is cranking, low battery...? 
8955   ED07                         ;-----------------------------------------------------
8956   ED07 96 82                   ldaa    temp24                  ; a.2 = TDC bit, we just stored this value a few lines earlier, probability of it changing must be very low? I guess we MUST ensure temp24 is in synch with port3.2?????
8957   ED09 98 06                   eora    port3                   ; a.2 = oldTdcbit eor newTdcBit                             
8958   ED0B 84 04                   anda    #$04                    ; Keep only TDC bit
8959   ED0D 26 35                   bne     L1671                   ; branch if TDC bit changed, very low probability or even impossible if we really are on the CAS rising edge????
8960   ED0F             
8961   ED0F                         ;--------------------------------------------------------------
8962   ED0F                         ; TDC bit did not change (normal case), execute the section
8963   ED0F                         ;--------------------------------------------------------------
8964   ED0F                         ;-----------------------
8965   ED0F                         ; First check start key
8966   ED0F                         ;-----------------------
8967   ED0F 8F 06 40 22             brclr   port3, #$40, L1668      ; Branch if key is in start position                                
8968   ED13             
8969   ED13                         ;----------------------------------------------------
8970   ED13                         ; Key is not in start
8971   ED13                         ; Increment tdcCasCount up to a max of 6 
8972   ED13                         ;----------------------------------------------------
8973   ED13 96 83                   ldaa    tdcCasCount             ; a = old tdcCasCount                             
8974   ED15 7C 00 83                inc     tdcCasCount             ; tdcCasCount += 1
8975   ED18 81 05                   cmpa    #$05                    ;                             
8976   ED1A 23 04                   bls     L1666                   ; branch if old tdcCasCount <=5 (new one is then <=6, no need to check max)                            
8977   ED1C 86 06                   ldaa    #$06                    ; use max of 6                            
8978   ED1E 97 83                   staa    tdcCasCount             ; store new value                             
8979   ED20             
8980   ED20                         ;----------------------------------------------------
8981   ED20                         ; Load b=$02 or $04 depending on TDC current value
8982   ED20                         ;----------------------------------------------------
8983   ED20 C6 02       L1666       ldab    #$02                    ; b = $02                            
8984   ED22 8F 82 FF 02             brclr   temp24, #$ff, L1667     ; Branch if TDC bit is 0 (TDC signal active)                              
8985   ED26 C6 04                   ldab    #$04                    ; b = $04                            
8986   ED28             
8987   ED28                         ;------------------------------------------------------------
8988   ED28                         ; At this point b=$02 if TDC signal is active, $04 otherwise
8989   ED28                         ;------------------------------------------------------------
8990   ED28 D1 7B       L1667       cmpb    tdcMask0                ;                              
8991   ED2A 27 18                   beq     L1671                   ; Branch if b = tdcMask0 (tdcMask0 is in synch with TDC???)                             
8992   ED2C             
8993   ED2C                         ;----------------------------------------------------
8994   ED2C                         ; b != tdcMask0, we are out of synch, reinstate old 
8995   ED2C                         ; tdcCasCount and branch to re-init tdcMask0
8996   ED2C                         ;----------------------------------------------------
8997   ED2C 4A                      deca                            ;                            
8998   ED2D 97 83                   staa    tdcCasCount             ; tdcCasCount -= 1                                   
8999   ED2F 81 03                   cmpa    #$03                    ;                            
9000   ED31 27 05                   beq     L1669                   ; Branch if tdcCasCount=3                            
9001   ED33 2A 0F                   bpl     L1671                   ; Branch if tdcCasCount>3                           
9002   ED35             
9003   ED35                         ;-----------------------------------------------
9004   ED35                         ; Key in start or tdcCasCount<3, restart synch 
9005   ED35                         ; from scratch, i.e. tdcCasCount=0
9006   ED35                         ;-----------------------------------------------
9007   ED35 4F          L1668       clra                            ;                             
9008   ED36 97 83                   staa    tdcCasCount             ; tdcCasCount = 0                                   
9009   ED38             
9010   ED38                         ;------------------------------------------------------------------
9011   ED38                         ; Init tdcMask0 with $0204 if TDC is active $0402 otherwise
9012   ED38                         ;------------------------------------------------------------------
9013   ED38 CC 04 02    L1669       ldd     #$0402                  ;                               
9014   ED3B 87 82 FF 03             brset   temp24, #$ff, L1670     ; Branch if TDC bit is 1 (TDC signal inactive)                               
9015   ED3F CC 02 04                ldd     #$0204                  ;                               
9016   ED42 DD 7B       L1670       std     tdcMask0                ;                              
9017   ED44             
9018   ED44                         ;---------------------------------------------
9019   ED44                         ; Decide if we are going to calculate timing 
9020   ED44                         ; or use fix timing of 5deg BTDC 
9021   ED44                         ;---------------------------------------------
9022   ED44 CE 00 2A    L1671       ldx     #$002a                   ; x = $002a in case we have to bail to L1679                               
9023   ED47 8F 83 FE 04             brclr   tdcCasCount, #$fe, L1672 ; Branch if tdcCasCount = 0 or 1
9024   ED4B 8F 61 40 04             brclr   casFlags0, #$40, L1673   ; Branch if timing adjustment mode is not active
9025   ED4F                                                      
9026   ED4F                         ;-----------------------------------------------------------------------
9027   ED4F                         ; tdcCasCount = 0 or 1 or timing adjustment mode is active
9028   ED4F                         ; Use default timing of 5 deg BTDC (or 4.75deg? close enough)
9029   ED4F                         ;-----------------------------------------------------------------------
9030   ED4F C6 A0       L1672       ldab    #$a0                     ; Use default value of tim61 = $a0 = 160 = 4.75deg BTDC (tech manual says 5deg BTDC)                             
9031   ED51 20 35                   bra     L1679                    ;                             
9032   ED53             
9033   ED53                         ;------------------------------------
9034   ED53                         ; tdcCasCount >= 2 and casFlags0.6 = 0 
9035   ED53                         ; Reset knockSum if knockSum>43 ???
9036   ED53                         ;------------------------------------
9037   ED53 D6 8B       L1673       ldab    knockSum                 ;                                
9038   ED55 C1 2B                   cmpb    #$2b                     ;                            
9039   ED57 23 03                   bls     L1674                    ; Branch if knockSum<= $2b (43)                            
9040   ED59 5F                      clrb                             ;                            
9041   ED5A D7 8B                   stab    knockSum                 ;
9042   ED5C                                                         
9043   ED5C                         ;---------------------------------------------------------------
9044   ED5C                         ; Compute the new target timing tim61Tot1 
9045   ED5C                         ;
9046   ED5C                         ;      tim61Tot1 = temp24 = min(knockSum+tim61Tot0, $bc)
9047   ED5C                         ;
9048   ED5C                         ; tim61Tot1 is therefore tim61Tot0 which is further retarded
9049   ED5C                         ; by a number of degrees equal to knockSum. Maximum value is
9050   ED5C                         ;
9051   ED5C                         ;       max = $bc = 188 =  256 * 66deg / 90
9052   ED5C                         ;
9053   ED5C                         ; which is +5deg ATDC since it is referenced to 61degBTDC
9054   ED5C                         ;---------------------------------------------------------------
9055   ED5C DB 88       L1674       addb    tim61Tot0                ; b = knockSum + tim61Tot0                            
9056   ED5E 25 04                   bcs     L1675                    ; Branch if overflow                            
9057   ED60 C1 BC                   cmpb    #$bc                     ; Check for max                           
9058   ED62 25 02                   bcs     L1676                    ; Branch if knockSum+tim61Tot0 < $bc                            
9059   ED64 C6 BC       L1675       ldab    #$bc                     ; Use max              
9060   ED66 D7 82       L1676       stab    temp24                   ; temp24 = tim61Tot1 = min(knockSum+tim61Tot0, $bc)
9061   ED68             
9062   ED68                         ;-------------------------------------------------------------
9063   ED68                         ; Compute the new timing newTim61 we are going to apply 
9064   ED68                         ;
9065   ED68                         ; We start with tim61Tot1 computed above but the code below 
9066   ED68                         ; seem to limit the rate of change of the timing by 22.5 
9067   ED68                         ; deg per iteration ($40). 
9068   ED68                         ;-------------------------------------------------------------
9069   ED68 DC 6C                   ldd     timCas0                 ; d = timCas0:timCas1                            
9070   ED6A 83 00 2A                subd    #$002a                  ; d = timCas0:timCas1 - $002a                              
9071   ED6D D1 82                   cmpb    temp24                  ;                              
9072   ED6F 24 0A                   bcc     L1677                   ; Branch if timCas0:timCas1 - $002a >= tim61Tot1
9073   ED71             
9074   ED71                         ;----------------------------------------------------
9075   ED71                         ; low(timCas0:timCas1 - $002a) < tim61Tot1
9076   ED71                         ;----------------------------------------------------
9077   ED71 CB 40                   addb    #$40                    ; b = timCas0:timCas1 - $002a + $40                            
9078   ED73 25 0E                   bcs     L1678                   ; Branch if overflow                            
9079   ED75 D1 82                   cmpb    temp24                  ;                               
9080   ED77 25 0F                   bcs     L1679                   ; Branch if  timCas0:timCas1 - $002a + $40 < tim61Tot1
9081   ED79 20 08                   bra     L1678                   ; Use tim61Tot1                            
9082   ED7B             
9083   ED7B                         ;----------------------------------------------------
9084   ED7B                         ; low(timCas0:timCas1 - $002a) >= min(knockSum+tim61Tot0, $bc)
9085   ED7B                         ;----------------------------------------------------
9086   ED7B C0 40       L1677       subb    #$40                    ; b = timCas0:timCas1 - $002a - $40                           
9087   ED7D 25 04                   bcs     L1678                   ; Branch if  timCas0:timCas1 - $002a - $40 < 0                            
9088   ED7F D1 82                   cmpb    temp24                  ;                              
9089   ED81 24 05                   bcc     L1679                   ; Branch if timCas0:timCas1 - $002a - $40 >= tim61Tot1
9090   ED83             
9091   ED83                         ;-------------------
9092   ED83                         ; Use tim61Tot1 
9093   ED83                         ;-------------------
9094   ED83 D6 82       L1678       ldab    temp24                  ; Use tim61Tot1                             
9095   ED85 CE 00 2A                ldx     #$002a                  ; reload x = $002a (why, did not change)                             
9096   ED88             
9097   ED88                         ;-----------------------------------------------------------------------------------------------
9098   ED88                         ;
9099   ED88                         ; At this point x = $002a, b = newTim61
9100   ED88                         ;
9101   ED88                         ; Where newTim61 is tim61Tot1 with a limit on its 
9102   ED88                         ; rate of change (21.5deg/iteration max):
9103   ED88                         ;
9104   ED88                         ;    if oldtim61 >= tim61Tot1                    if old timing is more retarded
9105   ED88                         ;           if oldtim61 - $40 < 0                    if oldtim61< 22.5deg (minimum allowed)
9106   ED88                         ;                tim61Tot1                               Use new value
9107   ED88                         ;           else if oldtim61 - $40 >= 0               else if oldtim61 >= 22.5deg (minimum allowed)
9108   ED88                         ;                max(oldtim61 - $40, tim61Tot1)          Use the one with the least amount of change... 
9109   ED88                         ;
9110   ED88                         ;   else if oldtim61 < tim61Tot1                  else if old timing is less retarded
9111   ED88                         ;            if oldtim61 + $40 > 256                 if oldtim61 > 67.5deg (max allowed)  
9112   ED88                         ;                tim61Tot1                               Use new value
9113   ED88                         ;            else if oldtim61 + $40 < 256            else if oldtim61 < 67.5deg (max allowed)
9114   ED88                         ;                min(oldtim61 + $40, tim61Tot1)          Use the one withe the least amount of change...
9115   ED88                         ;
9116   ED88                         ; where tim61Tot1 = min(knockSum+tim61Tot0, $bc)
9117   ED88                         ;       oldtim61 = [timCas0:timCas1] - $002a
9118   ED88                         ;
9119   ED88                         ;-----------------------------------------------------------------------------------------------
9120   ED88                         ;----------------------------------------------------
9121   ED88                         ;
9122   ED88                         ; Update tim61 and [timCas0:timCas1]
9123   ED88                         ;     timCas0:timCas1 = tim61 + $002a
9124   ED88                         ;                 = 256 * (61 - degAdv) / 90 + 42
9125   ED88                         ;                 = 256 * ((61 - degAdv) + 14.77) / 90
9126   ED88                         ;                 = 256 * (75.77 - degAdv) / 90
9127   ED88                         ;
9128   ED88                         ; Since each CAS pulse rising edge is at 75deg BTDC,  
9129   ED88                         ; [timCas0:timCas1] is the timing referenced to  
9130   ED88                         ; the CAS pulse rising edge
9131   ED88                         ;----------------------------------------------------
9132   ED88 3A          L1679       abx                            ; x = tim61 + $002a                            
9133   ED89 DF 6C                   stx     timCas0                ; [timCas0:timCas1] = tim61 + $002a
9134   ED8B D7 7D                   stab    tim61                  ;                              
9135   ED8D             
9136   ED8D                         ;----------------------------------------------------------------------
9137   ED8D                         ; Branch to re-init timing stuff if rpm<505 or key in start position
9138   ED8D                         ;----------------------------------------------------------------------
9139   ED8D 8F 61 01 14             brclr   casFlags0, #$01, L1680  ; Branch to re-init timing stuff if rpm<505, with hysteresis                              
9140   ED91 8F 06 40 10             brclr   port3, #$40, L1680      ; Branch to re-init timing stuff if key in start position                               
9141   ED95             
9142   ED95                         ;---------------------------------------------------
9143   ED95                         ; At this point rpm>505 and key is not is start
9144   ED95                         ;
9145   ED95                         ; branch to normal code if rpm>505rpm the previous time
9146   ED95                         ; else update TcasLast0 and re-init timing stuff 
9147   ED95                         ;---------------------------------------------------
9148   ED95 87 61 02 0F             brset   casFlags0, #$02, L1681  ; Branch to normal code if rpm>=505rpm the previous time                               
9149   ED99 BD EC 45                jsr     L1650                   ; d = abs(Tcas - TcasLast0) - Tcas * $30/256
9150   ED9C 24 07                   bcc     L1680                   ; Branch to re-init timing stuff if abs(Tcas - TcasLast0) >= Tcas * $30//256, i.e. abs(Tcas - TcasLast0)/Tcas >= 18.75%
9151   ED9E DE 80                   ldx     temp22                  ; abs(Tcas - TcasLast0)/Tcas < 18.75%
9152   EDA0 DF 64                   stx     TcasLast0               ; Update TcasLast0
9153   EDA2 7E EF 55                jmp     L1710                   ; Jump to re-init timing stuff
9154   EDA5             
9155   EDA5                         ;------------------------------
9156   EDA5                         ; Jump to re-init timing stuff
9157   EDA5                         ;------------------------------
9158   EDA5 7E EF 4E    L1680       jmp     L1709                                                 
9159   EDA8             
9160   EDA8                         ;--------------------------------------------
9161   EDA8                         ; Section to perform some additional Tcas 
9162   EDA8                         ; validation when  rpm(Tcas) <= 4801rpm
9163   EDA8                         ;--------------------------------------------
9164   EDA8 8F 61 20 03 L1681       brclr   casFlags0, #$20, L1682  ; Branch if rpm(Tcas) <= 4801rpm
9165   EDAC 7E EE 16                jmp     L1685                   ; Bail to next section
9166   EDAF             
9167   EDAF                         ;---------------------------
9168   EDAF                         ; rpm(Tcas) <= 4801rpm
9169   EDAF                         ;---------------------------
9170   EDAF                         ;---------------------------
9171   EDAF                         ; Check rpm
9172   EDAF                         ;---------------------------
9173   EDAF 96 80       L1682       ldaa    temp22                  ; a = Tcas/256                             
9174   EDB1 81 14                   cmpa    #$14                    ; 1464rpm                            
9175   EDB3 23 0F                   bls     L1683                   ; Branch if rpm(Tcas) >= 1464rpm
9176   EDB5                                                      
9177   EDB5                         ;----------------------------------------------------
9178   EDB5                         ; rpm(Tcas) < 1464
9179   EDB5                         ;----------------------------------------------------
9180   EDB5 DE 6C                   ldx     timCas0                 ; x = timCas0                              
9181   EDB7 8C 00 CA                cpx     #$00ca                  ;                               
9182   EDBA 22 08                   bhi     L1683                   ; branch if timCas0 > $ca (4deg BTDC)                               
9183   EDBC BD EC 45                jsr     L1650                   ; d = abs(Tcas - TcasLast0) - Tcas * $30/256                             
9184   EDBF 25 03                   bcs     L1683                   ; Branch if result was negative                             
9185   EDC1 7E EF 4E                jmp     L1709                   ;                              
9186   EDC4             
9187   EDC4                         ;----------------------------------------------------
9188   EDC4                         ;    timCas0 > $ca (4deg BTDC)
9189   EDC4                         ; or abs(Tcas - TcasLast0) - Tcas * $30/256 < 0
9190   EDC4                         ; or rpm(Tcas) >= 1464
9191   EDC4                         ;----------------------------------------------------
9192   EDC4 DC 80       L1683       ldd     temp22                  ; d = Tcas                             
9193   EDC6 81 19                   cmpa    #$19                    ; 1171rpm                       
9194   EDC8 24 4C                   bcc     L1685                   ; Branch if rpm(Tcas) >= 1171rpm
9195   EDCA 04                      lsrd                            ;                             
9196   EDCB 04                      lsrd                            ;                             
9197   EDCC 04                      lsrd                            ;                             
9198   EDCD 04                      lsrd                            ;                             
9199   EDCE 04                      lsrd                            ;                             
9200   EDCF 04                      lsrd                            ; d = Tcas/64                            
9201   EDD0 DD 7E                   std     temp20                  ; temp20 = Tcas/64                                   
9202   EDD2             
9203   EDD2 DC 64                   ldd     TcasLast0               ; d = TcasLast0                             
9204   EDD4 93 80                   subd    temp22                  ; d = TcasLast0 - Tcas                              
9205   EDD6 24 1F                   bcc     L1684                   ; Branch if result positive (rpm is increasing????)                            
9206   EDD8             
9207   EDD8 DC 80                   ldd     temp22                  ;                              
9208   EDDA 93 64                   subd    TcasLast0               ; d =                              
9209   EDDC 93 7E                   subd    temp20                  ; d = Tcas - TcasLast0 - Tcas/64                                    
9210   EDDE 25 36                   bcs     L1685                   ; Branch if result negative                              
9211   EDE0             
9212   EDE0                         ;------------------------------------------------------------
9213   EDE0                         ; d = Tcas - TcasLast0 - Tcas/64 >= 0
9214   EDE0                         ; Multiply result d = v1:v0 by $80/$80 = 1.0
9215   EDE0                         ;
9216   EDE0                         ; Maybe I miss something but this is useless. My guess
9217   EDE0                         ; is that the multiplicative factor (1.0 in this case) was 
9218   EDE0                         ; configurable but in the end they chose 1.0 which renders this
9219   EDE0                         ; code useless???
9220   EDE0                         ;
9221   EDE0                         ;------------------------------------------------------------
9222   EDE0 D7 82                   stab    temp24                  ; save b                              
9223   EDE2 C6 80                   ldab    #$80                    ; b = $80                             
9224   EDE4 3D                      mul                             ; d = v1*$80                            
9225   EDE5 1A                      xgdx                            ; x = v1*$80                            
9226   EDE6 96 82                   ldaa    temp24                  ; a = v0                              
9227   EDE8 C6 80                   ldab    #$80                    ; b = $80                            
9228   EDEA 3D                      mul                             ; d = v0 * $80                            
9229   EDEB 16                      tab                             ; b = v0 * $80/256                            
9230   EDEC 3A                      abx                             ; x = v1*$80 +  v0 * $80/256 = [v1:v0] * $80/256
9231   EDED 1A                      xgdx                            ; d = $80/256 * (Tcas - TcasLast0 - Tcas/64)                              
9232   EDEE 05                      asld                            ; d = $80/128 * (Tcas - TcasLast0 - Tcas/64) = Tcas - TcasLast0 - Tcas/64                            
9233   EDEF             
9234   EDEF                         ;---------------------------------------------------------------------------
9235   EDEF                         ; Branch to re-init if Tcas + (Tcas - TcasLast0 - Tcas/64)  > 32767
9236   EDEF                         ;                              (TcasLast0 - Tcas - Tcas/64) > Tcas
9237   EDEF                         ;                                       (TcasLast0 - Tcas ) > Tcas(1+1/64)
9238   EDEF                         ;                                  (TcasLast0 - Tcas )/Tcas > 101.6%
9239   EDEF                         ;
9240   EDEF                         ; We are basically checking if Tcas increased by more than 101.6%
9241   EDEF                         ;---------------------------------------------------------------------------
9242   EDEF 25 30                   bcs     L1687                   ; Branch to re-init if overflow                              
9243   EDF1 D3 80                   addd    temp22                  ; d = Tcas + (Tcas - TcasLast0 - Tcas/64) = Tcas(2-1/64) - TcasLast0                             
9244   EDF3 25 2C                   bcs     L1687                   ; Branch to re-init if overflow                             
9245   EDF5 20 21                   bra     L1686                   ; Branch to code continuation
9246   EDF7                                                       
9247   EDF7                         ;----------------------------------------------------
9248   EDF7                         ; (TcasLast0 - Tcas) > 0 (rpm is increasing),
9249   EDF7                         ;
9250   EDF7                         ; Check if  
9251   EDF7                         ;               TcasLast0 - Tcas < Tcas/64
9252   EDF7                         ;        (TcasLast0 - Tcas)/Tcas < 1/64
9253   EDF7                         ;        (TcasLast0 - Tcas)/Tcas < 1.6%
9254   EDF7                         ; 
9255   EDF7                         ; We are basically checking if Tcas changed by less than 1.6%
9256   EDF7                         ; This also correspond to a change of rpm of 1.6%
9257   EDF7                         ;----------------------------------------------------
9258   EDF7 93 7E       L1684       subd    temp20                  ; d = TcasLast0 - Tcas - Tcas/64                                    
9259   EDF9 25 1B                   bcs     L1685                   ; Branch if result negative, i.e. change in Tcas is less than 1/64                            
9260   EDFB             
9261   EDFB                         ;------------------------------------------------------------
9262   EDFB                         ; At this point, rpm increased by more than 1.6%
9263   EDFB                         ; and d = TcasLast0 - Tcas - Tcas/64 >= 0
9264   EDFB                         ; Multiply result d = v1:v0 by $80/$80 = 1.0
9265   EDFB                         ;
9266   EDFB                         ; Maybe I miss something but this is useless. My guess
9267   EDFB                         ; is that the multiplicative factor (1.0 in this case) was 
9268   EDFB                         ; configurable but in the end they chose 1.0 which renders this
9269   EDFB                         ; code useless???
9270   EDFB                         ;------------------------------------------------------------
9271   EDFB D7 82                   stab    temp24                  ; temp24 = v0
9272   EDFD C6 80                   ldab    #$80                    ; b = $80                           
9273   EDFF 3D                      mul                             ; d = $80 * v1                            
9274   EE00 1A                      xgdx                            ; x = $80 * v1                           
9275   EE01 96 82                   ldaa    temp24                  ; a = v0
9276   EE03 C6 80                   ldab    #$80                    ; b = $80                             
9277   EE05 3D                      mul                             ; d = $80 * v0                            
9278   EE06 16                      tab                             ; b = $80/256 * v0                             
9279   EE07 3A                      abx                             ; x = $80 * v1 + $80/256 * v0 = $80/256 * [v1:v0]
9280   EE08 1A                      xgdx                            ; d = $80/256 * (TcasLast0 - Tcas - Tcas/64)
9281   EE09 05                      asld                            ; d = $80/128 * (TcasLast0 - Tcas - Tcas/64) = (TcasLast0 - Tcas - Tcas/64)
9282   EE0A                                                      
9283   EE0A                         ;-----------------------------------------------------------------------------
9284   EE0A                         ; Branch to re-init if  Tcas - (TcasLast0 - Tcas - Tcas/64) < 0???
9285   EE0A                         ;                              (TcasLast0 - Tcas - Tcas/64) > Tcas
9286   EE0A                         ;                                       (TcasLast0 - Tcas ) > Tcas(1+1/64)
9287   EE0A                         ;                                  (TcasLast0 - Tcas )/Tcas > 101.6%
9288   EE0A                         ;
9289   EE0A                         ; We are basically checking if Tcas increased by more than 101.6%
9290   EE0A                         ;-----------------------------------------------------------------------------
9291   EE0A 25 15                   bcs     L1687                   ; Branch to re-init if overflow
9292   EE0C DD 7E                   std     temp20                  ; temp20 = TcasLast0 - Tcas - Tcas/64                                   
9293   EE0E DC 80                   ldd     temp22                  ; d = Tcas                             
9294   EE10 93 7E                   subd    temp20                  ; d = Tcas - (TcasLast0 - Tcas - Tcas/64) =  Tcas(2+1/64) - TcasLast0 
9295   EE12 25 0D                   bcs     L1687                   ; Branch to re-init if Tcas increased by more than 101.6%
9296   EE14 20 02                   bra     L1686                   ; Branch to code continuation
9297   EE16             
9298   EE16                         ;----------------------------------------
9299   EE16                         ; Update TcasNew0:TcasNew1
9300   EE16                         ; Check if Tcas is within normal range
9301   EE16                         ; Branch to re-init if not
9302   EE16                         ;----------------------------------------
9303   EE16 DC 80       L1685       ldd     temp22                  ; d = Tcas                              
9304   EE18 DD 66       L1686       std     TcasNew0                ; [TcasNew0:TcasNew1] = Tcas                             
9305   EE1A 2B 05                   bmi     L1687                   ; Branch if sign bit set, Tcas at max value, jump to re-init???                             
9306   EE1C 1C 01 46                cmpd    #$0146                  ; Compare to min (max of 23006rpm??)                               
9307   EE1F 24 03                   bcc     L1688                   ; Branch if d >= min (rpm < 23006rpm)                              
9308   EE21 7E EF 4E    L1687       jmp     L1709                   ; rpm >= 23006rpm, jump to re-init
9309   EE24             
9310   EE24                         ;-------------------------------
9311   EE24                         ; Tcas is within normal range
9312   EE24                         ; Update TcasLast0
9313   EE24                         ;-------------------------------
9314   EE24 DC 80       L1688       ldd     temp22                   ;                              
9315   EE26 DD 64                   std     TcasLast0                ;
9316   EE28                                                                         
9317   EE28                         ;--------------------------------------------------------
9318   EE28                         ; Compute d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256
9319   EE28                         ; We assume timCas0 can only be 0 or 1 
9320   EE28                         ; (Higher values are impossible, huge timing retard...)
9321   EE28                         ;--------------------------------------------------------
9322   EE28 D6 6D                   ldab    timCas1                 ;                              
9323   EE2A 96 67                   ldaa    TcasNew1                ;                              
9324   EE2C 3D                      mul                             ; d = timCas1 * TcasNew1                            
9325   EE2D 97 7E                   staa    temp20                  ;                                    
9326   EE2F 96 6D                   ldaa    timCas1                 ;                              
9327   EE31 D6 66                   ldab    TcasNew0                ;                              
9328   EE33 3D                      mul                             ; d = timCas1 * TcasNew0                             
9329   EE34 DB 7E                   addb    temp20                  ;                                    
9330   EE36 89 00                   adca    #$00                    ; d = [TcasNew0:TcasNew1] * timCas1/256
9331   EE38 8F 6C FF 02             brclr   timCas0, #$ff, L1689    ; Branch if timCas0=0
9332   EE3C D3 66                   addd    TcasNew0                ; d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256
9333   EE3E             
9334   EE3E                         ;--------------------------------------------------------------------------------------
9335   EE3E                         ; At this point d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256
9336   EE3E                         ; Update ignRelTime0:ignRelTime1 (ignition timing measured in time instead of degrees)
9337   EE3E                         ;
9338   EE3E                         ;       ignRelTime0:ignRelTime1 = [TcasNew0:TcasNew1]/2 * [timCas0:timCas1]/256 - $0012
9339   EE3E                         ;
9340   EE3E                         ; timCas0/256 is a ratio from 0 to 1 corresponding to 0 to 90deg, since Tcas 
9341   EE3E                         ; correspond to 180 deg, Tcas/2 * timsCas0/256 is equal to the "timing time" referenced
9342   EE3E                         ; to 75 BTDC
9343   EE3E                         ;
9344   EE3E                         ; ignRelTime0:ignRelTime1 is therefore the ignition timing (in timer time) 
9345   EE3E                         ; referenced to 75BTDC and minus 72us
9346   EE3E                         ;--------------------------------------------------------------------------------------
9347   EE3E 04          L1689       lsrd                            ; d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256/2
9348   EE3F 83 00 12                subd    #$0012                  ; d = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256/2 - $0012
9349   EE42 24 02                   bcc     L1690                   ; Branch if no underflow                              
9350   EE44 4F                      clra                            ; use min of 0                            
9351   EE45 5F                      clrb                            ; use min of 0                            
9352   EE46 DD 6E       L1690       std     ignRelTime0             ; [ignRelTime0:ignRelTime1] = [TcasNew0:TcasNew1] * [timCas0:timCas1]/256/2 - $0012
9353   EE48             
9354   EE48                         ;----------------------------------------------------
9355   EE48                         ; Check if the current coil is already energized
9356   EE48                         ;----------------------------------------------------
9357   EE48 96 16                   ldaa    port5                   ;                              
9358   EE4A 94 7B                   anda    tdcMask0                ; $02 or $04                              
9359   EE4C 27 78                   beq     L1698                   ; Branch if coil is already energized
9360   EE4E             
9361   EE4E                         ;----------------------------------------------------------------------
9362   EE4E                         ; Coil is not yet energized, section to calculate energization time
9363   EE4E                         ; and schedule the energization...
9364   EE4E                         ;----------------------------------------------------------------------
9365   EE4E                         ;-----------------------------------------
9366   EE4E                         ; Init enerFlags to $02 since we know we 
9367   EE4E                         ; are going to schedule energization
9368   EE4E                         ;-----------------------------------------
9369   EE4E 86 02                   ldaa    #$02                    ; a = $02                             
9370   EE50 97 63                   staa    enerFlags               ; enerFlags = $02 
9371   EE52                                                     
9372   EE52                         ;-----------------------------------------------------------------------------
9373   EE52                         ; If rpm(Tcas) > 1775rpm and previously rpm(Tcas) >  1775rpm
9374   EE52                         ; The we can  use enerLenX0 (already calculated in previous iteration?)
9375   EE52                         ;-----------------------------------------------------------------------------
9376   EE52 8F 61 04 06             brclr   casFlags0, #$04, L1691  ; Branch to compute energization time if rpm(Tcas) <=  1775rpm
9377   EE56 DC 72                   ldd     enerLenX0               ; d = [enerLenX0:enerLenX1]
9378   EE58 87 61 08 37             brset   casFlags0, #$08, L1695  ; Branch to use enerLenX0 if rpm(Tcas) >  1775rpm the previous time
9379   EE5C             
9380   EE5C                         ;--------------------------------------------------------------------------
9381   EE5C                         ;    rpm(Tcas) <=  1775rpm
9382   EE5C                         ; or rpm(Tcas) >  1775rpm  but  previously rpm(Tcas) <=  1775rpm
9383   EE5C                         ; We need to compute the energization time
9384   EE5C                         ;
9385   EE5C                         ; Check if we can use a short or long energization time??? not sure
9386   EE5C                         ; why 
9387   EE5C                         ;--------------------------------------------------------------------------
9388   EE5C DC 66       L1691       ldd     TcasNew0                ; d = TcasNew0
9389   EE5E 83 11 30                subd    #$1130                  ; d = TcasNew0 - $1130  (18ms????) (check for rollover???)
9390   EE61 24 09                   bcc     L1692                   ; Branch if no underflow                             
9391   EE63             
9392   EE63                         ;------------------------------------------------------------------
9393   EE63                         ; Underflow, use a shorter fixed value of d = 16*enerLen
9394   EE63                         ;------------------------------------------------------------------
9395   EE63 96 89                   ldaa    enerLen                 ; a = enerLen
9396   EE65 5F                      clrb                            ; d = enerLen*256                             
9397   EE66 04                      lsrd                            ;                              
9398   EE67 04                      lsrd                            ;                              
9399   EE68 04                      lsrd                            ;                              
9400   EE69 04                      lsrd                            ; d = enerLen*256/16 = 16*enerLen                              
9401   EE6A 20 27                   bra     L1695                   ; Bail                              
9402   EE6C             
9403   EE6C                         ;----------------------------------------------------------------------------------------------
9404   EE6C                         ; TcasNew0 >= $1130, i.e. rpm <= 1704rpm,
9405   EE6C                         ;
9406   EE6C                         ; Compute  a longer energization time????
9407   EE6C                         ;
9408   EE6C                         ;   d = 16*enerLen + TcasNew0/2 * (timCas0 - $00ca + $04)/256/2    + (TcasNew0 - $1130)/16
9409   EE6C                         ;     = 16*enerLen + TcasNew0/2 * (timCas0 - 71deg + 1.4deg)/256/2 + (TcasNew0 - $1130)/16
9410   EE6C                         ;
9411   EE6C                         ;----------------------------------------------------------------------------------------------
9412   EE6C 04          L1692       lsrd                            ;                              
9413   EE6D 04                      lsrd                            ;                              
9414   EE6E 04                      lsrd                            ;                              
9415   EE6F 04                      lsrd                            ; d = (TcasNew0 - $1130)/16
9416   EE70 DD 80                   std     temp22                  ; temp22 = (TcasNew0 - $1130)/16
9417   EE72 DC 6C                   ldd     timCas0                 ; d = timCas0                              
9418   EE74 83 00 CA                subd    #$00ca                  ; d = timCas0 - $00ca (71deg)                              
9419   EE77 23 11                   bls     L1694                   ; Branch if timCas0 <= $00ca (71deg)                             
9420   EE79 CB 04                   addb    #$04                    ; b = timCas0 - $00ca + $04                            
9421   EE7B 96 66                   ldaa    TcasNew0                ; a = TcasNew0/256                             
9422   EE7D 3D                      mul                             ; d = TcasNew0/256 * (timCas0 - $00ca + $04)                             
9423   EE7E 04                      lsrd                            ;                             
9424   EE7F 04                      lsrd                            ; d = TcasNew0/256/4 * (timCas0 - $00ca + $04)                            
9425   EE80 4D                      tsta                            ;                             
9426   EE81 27 03                   beq     L1693                   ; Branch if a=0 (result <= $ff)                             
9427   EE83 CC 01 00                ldd     #$0100                  ; Use max of $0100                              
9428   EE86 D3 80       L1693       addd    temp22                  ; d = TcasNew0/256/4 * (timCas0 - $00ca + $04) + (TcasNew0 - $1130)/16
9429   EE88 DD 80                   std     temp22                  ; temp22 = TcasNew0/256/4 * (timCas0 - $00ca + $04) + (TcasNew0 - $1130)/16
9430   EE8A 96 89       L1694       ldaa    enerLen                 ; a = enerLen                             
9431   EE8C 5F                      clrb                            ; d = enerLen*256                            
9432   EE8D 04                      lsrd                            ;                             
9433   EE8E 04                      lsrd                            ;                             
9434   EE8F 04                      lsrd                            ;                             
9435   EE90 04                      lsrd                            ; d = enerLen*256/16                             
9436   EE91 D3 80                   addd    temp22                  ; d = enerLen*16 + (TcasNew0 - $1130)/16 + [TcasNew0/2 * (timCas0 - $00ca + $04)/256/2]
9437   EE93 DD 80       L1695       std     temp22                  ; temp22 = enerLen*16 + (TcasNew0 - $1130)/16 + [TcasNew0/2 * (timCas0 - $00ca + $04)/256/2]
9438   EE95             
9439   EE95             
9440   EE95                         ;---------------------------------------------------------------------------------------
9441   EE95                         ; At this point temp22 = energizationDuration contains the energization time, 3 cases:
9442   EE95                         ; 
9443   EE95                         ;       temp22 = 16*enerLen 
9444   EE95                         ;    or temp22 = 16*enerLen + (TcasNew0 - $1130)/16 + [if timing >71deg, TcasNew0/2 * (timCas0 - $00ca + $04)/256/2]
9445   EE95                         ;    or temp22 = enerLenX0:enerLenX1
9446   EE95                         ;
9447   EE95                         ;
9448   EE95                         ; Compute temp22 = the absolute time (timer clock) at 
9449   EE95                         ; which the coil needs to start being energized
9450   EE95                         ;---------------------------------------------------------------------------------------
9451   EE95 DC 6E                   ldd     ignRelTime0             ;                              
9452   EE97 93 80                   subd    temp22                  ; d = ignRelTime0 - energizationDuration
9453   EE99 D3 68                   addd    casRiseTime0            ; d = casRiseTime0 + ignRelTime0 - energizationDuration
9454   EE9B DD 80                   std     temp22                  ; temp22 = casRiseTime0 + ignRelTime0 - energizationDuration
9455   EE9D             
9456   EE9D                         ;---------------------------------------------------------------------
9457   EE9D                         ; Check if the energization time of next coil is sufficientlty far
9458   EE9D                         ; away from the preceeding coil ignition time. If not then use
9459   EE9D                         ; an energization time as close as possible to that ignition time???
9460   EE9D                         ;---------------------------------------------------------------------
9461   EE9D DC 76                   ldd     ignTime0                ; d = ignTime0:ignTime1                            
9462   EE9F C3 00 FA                addd    #$00fa                  ; d = ignTime0 + $fa (1ms)                            
9463   EEA2 1D 80                   cmpd1   temp22                  ;                             
9464   EEA4 2B 02                   bmi     L1696                   ; Branch if ignTime0 + $fa < energization time, i.e. energization is sufficiently far away from the ignition of the preceeding cylinder, less than 1ms
9465   EEA6 DD 80                   std     temp22                  ; Replace energization time with ignTime0 + $fa 
9466   EEA8             
9467   EEA8                         ;-----------------------------------------
9468   EEA8                         ; Check that coil energization is 
9469   EEA8                         ; sufficiently in the future to be valid
9470   EEA8                         ;-----------------------------------------
9471   EEA8 DC 29       L1696       ldd     t3_clock1               ; d = t3_clock1                                   
9472   EEAA C3 00 0A                addd    #$000a                  ; d = t3_clock1 + $0a (40usec)                             
9473   EEAD 1A                      xgdx                            ; x = t3_clock1 + $0a                            
9474   EEAE 9C 80                   cpx     temp22                  ;                              
9475   EEB0 2A 02                   bpl     L1697                   ; Branch to use t3_clock1 + $0a if energization is "in the past"
9476   EEB2 DE 80                   ldx     temp22                  ; Energization time is valid, use it
9477   EEB4             
9478   EEB4                         ;---------------------------------------------------------------------------
9479   EEB4                         ; Schedule coil energization interrupt time and update enerAbsTime0 with it
9480   EEB4                         ;---------------------------------------------------------------------------
9481   EEB4 DF 2B       L1697       stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register
9482   EEB6 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                    
9483   EEB8 DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register
9484   EEBA DF 74                   stx     enerAbsTime0            ; Save energization interrupt time in memory
9485   EEBC                                                      
9486   EEBC                         ;-------------------------------------------------------------------------
9487   EEBC                         ; Reset the bit for the corresponding cylinder in control register
9488   EEBC                         ; in order to energize the proper coil at the scheduled time
9489   EEBC                         ;
9490   EEBC                         ; Bits in t3_csr0 are offset by 1 bit compared to tdcMask0, so shift 
9491   EEBC                         ; tdcMask0 by 1 bit and then reset that bit in t3_csr0...  
9492   EEBC                         ;-------------------------------------------------------------------------
9493   EEBC 96 7B                   ldaa    tdcMask0                ; a = $02 or $04                             
9494   EEBE 48                      asla                            ; a = $04 or $08 (shift tdcMask0 bit by 1 to have the corresponding bit in t3_csr0)                             
9495   EEBF 43                      coma                            ; a = ~($04 or $08)                            
9496   EEC0 94 19                   anda    t3_csr0                 ; reset that bit in t3_csr0 (energize coil at scheduled time)                            
9497   EEC2 97 19                   staa    t3_csr0                 ; Update t3_csr0 
9498   EEC4 20 09                   bra     L1699                   ; Bail to  ignition section                             
9499   EEC6             
9500   EEC6                         ;---------------------------------------------------------
9501   EEC6                         ; Coil is already energized
9502   EEC6                         ;
9503   EEC6                         ; Flush the first output compare register (write the 
9504   EEC6                         ; fartest possible time) since we don't need an interrupt
9505   EEC6                         ; to energize it???. Also make sure enerFlags = 1 to indicate 
9506   EEC6                         ; coil is energized?
9507   EEC6                         ;---------------------------------------------------------
9508   EEC6 DE 29       L1698       ldx     t3_clock1               ; x = t3_clock1                                   
9509   EEC8 09                      dex                             ; x = t3_clock1-1                            
9510   EEC9 DF 2B                   stx     t3_outCmpWr             ; Re-init first output compare register with t3_clock1-1, the fartest time possible
9511   EECB 86 01                   ldaa    #$01                    ; a = 1                            
9512   EECD 97 63                   staa    enerFlags               ; enerFlags = 1                             
9513   EECF             
9514   EECF                         ;------------------
9515   EECF                         ; Ignition section
9516   EECF                         ;------------------
9517   EECF                         ;-------------------------------------------------------------------
9518   EECF                         ; Compute ignTime0 = absolute ignition time (referenced to timer clock)
9519   EECF                         ;-------------------------------------------------------------------
9520   EECF DC 6E       L1699       ldd     ignRelTime0             ; d = ignRelTime0:ignRelTime1                              
9521   EED1 D3 68                   addd    casRiseTime0            ; d = ignRelTime0 + casRiseTime0                                       
9522   EED3 DD 76                   std     ignTime0                ; ignTime0:ignTime1 = ignRelTime0:ignRelTime1 + casRiseTime0                             
9523   EED5             
9524   EED5                         ;-----------------------------------------------------------
9525   EED5                         ; Based on ignition timing, check if we are going to schedule
9526   EED5                         ; ignition at this time or wait for the cas falling edge???
9527   EED5                         ;-----------------------------------------------------------
9528   EED5 DE 6C                   ldx     timCas0                 ; x = timCas0:timCas1                             
9529   EED7 8C 00 CA                cpx     #$00ca                  ; (71deg, 4deg BTDC)                              
9530   EEDA 25 0D                   bcs     L1701                   ; Branch if timCas0:timCas1 < $00ca (71deg, 4deg BTDC)                            
9531   EEDC 87 61 40 04             brset   casFlags0, #$40, L1700  ; Branch if timing adjustment mode is active                                
9532   EEE0 87 61 10 05             brset   casFlags0, #$10, L1701  ; Branch if rpm(Tcas) >  1540rpm
9533   EEE4             
9534   EEE4                         ;--------------------------------------------------------------
9535   EEE4                         ; timCas0:timCas1 >= $00ca (71deg, 4deg BTDC)  
9536   EEE4                         ; and  timing adjustement mode is active or rpm(Tcas)<=1540rpm
9537   EEE4                         ;
9538   EEE4                         ; Set flag and wait for the cas falling edge
9539   EEE4                         ;--------------------------------------------------------------
9540   EEE4 03 62 01    L1700       orm     ignFallFlags, #$01      ; Set flag indicating we need to schedule ignition on the cas falling edge                               
9541   EEE7 20 1D                   bra     L1703                   ; Branch to continue                             
9542   EEE9             
9543   EEE9                         ;---------------------------------------------------------------------
9544   EEE9                         ; At this point, enerFlags=1 if coil is energized or enerFlags=2
9545   EEE9                         ; if energization has been scheduled. In the case where enerFlags=2
9546   EEE9                         ; ignition will be scheduled in the output compare subroutine, i.e.
9547   EEE9                         ; coilFunc, we therefore don't need to schedule it here. In the case
9548   EEE9                         ; where enerFlags=1, we will now schedule ignition...
9549   EEE9                         ;---------------------------------------------------------------------
9550   EEE9 96 63       L1701       ldaa    enerFlags               ; a = enerFlags                             
9551   EEEB 81 02                   cmpa    #$02                    ;                             
9552   EEED 27 17                   beq     L1703                   ; Branch if enerFlags=2
9553   EEEF             
9554   EEEF                         ;------------------------------------------------------------
9555   EEEF                         ; enerFlags=1, we will now schedule ignition
9556   EEEF                         ; Make sure ignition time is sufficiently in 
9557   EEEF                         ; the future to be valid. If not, use ignition time of "now"
9558   EEEF                         ;------------------------------------------------------------
9559   EEEF DC 29                   ldd     t3_clock1               ; d = t3_clock1                                    
9560   EEF1 C3 00 06                addd    #$0006                  ; d = t3_clock1 + $0006 (24usec)                             
9561   EEF4 1A                      xgdx                            ; x = t3_clock1 + $0006                            
9562   EEF5 9C 76                   cpx     ignTime0                ;                              
9563   EEF7 2A 02                   bpl     L1702                   ; Branch to use t3_clock1 + $0006 if ignTime0 is "in the past"
9564   EEF9 DE 76                   ldx     ignTime0                ; ignTime0 is valid, use it
9565   EEFB             
9566   EEFB                         ;--------------------------------------------------------
9567   EEFB                         ; Schedule coil ignition time, set the proper coil bits
9568   EEFB                         ; and update ignTime0 with the interrupt time used
9569   EEFB                         ;--------------------------------------------------------
9570   EEFB DF 2B       L1702       stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register  
9571   EEFD 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                           
9572   EEFF DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register                                    
9573   EF01 03 19 0C                orm     t3_csr0, #$0c           ; Set both coil bits in t3_csr0, i.e. provoke ignition at scheduled time
9574   EF04 DF 76                   stx     ignTime0                ; Store actual value used                             
9575   EF06             
9576   EF06                         ;---------------------------------------------------------------------------------------
9577   EF06                         ; Common branching point for all code above (except re-init)
9578   EF06                         ;
9579   EF06                         ; Update enerAbsTimeNext0, The absolute coil energization time for the next cylinder???
9580   EF06                         ;---------------------------------------------------------------------------------------
9581   EF06 DC 66       L1703       ldd     TcasNew0                ; d = TcasNew0:TcasNew1                              
9582   EF08 93 72                   subd    enerLenX0               ; d = TcasNew0 - enerLenX0                             
9583   EF0A D3 6E                   addd    ignRelTime0             ; d = TcasNew0 - enerLenX0 + ignRelTime0                            
9584   EF0C D3 68                   addd    casRiseTime0            ; d = TcasNew0 - enerLenX0 + ignRelTime0 + casRiseTime0                                        
9585   EF0E DD 78                   std     enerAbsTimeNext0        ; enerAbsTimeNext0 = casRiseTime0 + TcasNew0 - enerLenX0 + ignRelTime0
9586   EF10             
9587   EF10                         ;------------------------------------------------------------------
9588   EF10                         ; Check enerAbsTimeNext0 to make sure it is not too close
9589   EF10                         ; to the current cylinder ignition time (1ms min between the two)
9590   EF10                         ;------------------------------------------------------------------
9591   EF10 DC 76                   ldd     ignTime0                 ; d = ignTime0                             
9592   EF12 C3 00 FA                addd    #$00fa                   ; d = ignTime0 + $fa (1ms)                              
9593   EF15 1D 78                   cmpd1   enerAbsTimeNext0         ;                              
9594   EF17 2B 02                   bmi     L1704                    ; Branch if ignTime0 + $fa < enerAbsTimeNext0, energization time of next cylinder is far enough                              
9595   EF19 DD 78                   std     enerAbsTimeNext0         ; Energization of next cylinder is to close to ignition of current cylinder, use closest possible value, enerAbsTimeNext0 = ignTime0 + $fa                              
9596   EF1B             
9597   EF1B                         ;----------------------------------------------------------------------------
9598   EF1B                         ; Section to update ignFallRelTime0, the ignition time relative to the cas falling edge
9599   EF1B                         ; It will be non zero only if it makes sense to schedule ignition on the falling edge
9600   EF1B                         ; i.e. timing >= 5degBTDC or timing adjustment mode is active, etc...
9601   EF1B                         ;----------------------------------------------------------------------------
9602   EF1B 4F          L1704       clra                            ; a = 0                            
9603   EF1C 5F                      clrb                            ; b = 0                            
9604   EF1D DD 70                   std     ignFallRelTime0         ; ignFallRelTime0 = 0, in case we don't update it below                              
9605   EF1F DC 6C                   ldd     timCas0                 ; d = timCas0                              
9606   EF21 83 00 C7                subd    #$00c7                  ; d = timCas0 - $00c7                              
9607   EF24 23 26                   bls     L1708                   ; Branch to use  ignFallRelTime0=0 if timCas0 <= $00c7 (70deg, 5deg BTDC)
9608   EF26 8F 61 40 05             brclr   casFlags0, #$40, L1705  ; Branch to compute ignFallRelTime0 if timing adjustment mode is not active                               
9609   EF2A CC 00 32                ldd     #$0032                  ; timing adjustment mode is active, use default of d = $0032 (ignFallRelTime0 = 200us, almost on the CAS falling edge, i.e. 5degBTDC)                              
9610   EF2D 20 1B                   bra     L1707                   ; Branch to update ignFallRelTime0 
9611   EF2F                                                      
9612   EF2F                         ;---------------------------------------------------------------------------------------------
9613   EF2F                         ; Compute 
9614   EF2F                         ;     [ignFallRelTime0:ignFallRelTime1] = [TcasNew0:TcasNew1]/2 * (timCas0 - $00c7)/256 - $12 
9615   EF2F                         ;                                       = [TcasNew0:TcasNew1]/2 * (timCas0 - 70deg)/256 - $12 
9616   EF2F                         ;
9617   EF2F                         ; [ignFallRelTime0:ignFallRelTime1] is the ignition time (timer clock) 
9618   EF2F                         ; relative to the CAS falling edge (-5 deg BTDC) minus 72us 
9619   EF2F                         ;
9620   EF2F                         ; Imposed minimum value is 1 since ignFallRelTime0=0 indicate we should not use it...
9621   EF2F                         ;---------------------------------------------------------------------------------------------
9622   EF2F D7 82       L1705       stab    temp24                  ; temp24 =  timCas0 - $00c7                              
9623   EF31 96 67                   ldaa    TcasNew1                ; a = TcasNew1                              
9624   EF33 3D                      mul                             ; d = TcasNew1 * (timCas0 - $00c7)                            
9625   EF34 D6 82                   ldab    temp24                  ; b = timCas0 - $00c7                              
9626   EF36 97 82                   staa    temp24                  ; temp24 = TcasNew1/256 * (timCas0 - $00c7)                              
9627   EF38 96 66                   ldaa    TcasNew0                ; a = TcasNew0                             
9628   EF3A 3D                      mul                             ; d = TcasNew0 * (timCas0 - $00c7)                            
9629   EF3B DB 82                   addb    temp24                  ; d = TcasNew0 * (timCas0 - $00c7) + TcasNew1/256 * (timCas0 - $00c7) =  (timCas0 - $00c7) * (TcasNew0 + TcasNew1/256) = (timCas0 - $00c7)/256 * [TcasNew0:TcasNew1]                              
9630   EF3D 89 00                   adca    #$00                    ; propagate carry                            
9631   EF3F 04                      lsrd                            ; d = (timCas0 - $00c7)/256/2 * [TcasNew0:TcasNew1]                             
9632   EF40 83 00 12                subd    #$0012                  ; d = (timCas0 - $00c7)/256/2 * [TcasNew0:TcasNew1] - $12                              
9633   EF43 25 02                   bcs     L1706                   ; Branch if underflow                             
9634   EF45 26 03                   bne     L1707                   ; Branch if not null                             
9635   EF47 CC 00 01    L1706       ldd     #$0001                  ; Null or underflow, use min of $0001                              
9636   EF4A DD 70       L1707       std     ignFallRelTime0         ; ignFallRelTime0 = [TcasNew0:TcasNew1]/2 * (timCas0 - $00c7)/256 - $12
9637   EF4C 20 3C       L1708       bra     L1713                   ; Branch to normal code continuation
9638   EF4E                                            
9639   EF4E                         ;--------------------------------------------------------------
9640   EF4E                         ; Section to re-init timing stuff in case of detected problems
9641   EF4E                         ; 2 different entry points, L1709 and L1710
9642   EF4E                         ;--------------------------------------------------------------
9643   EF4E                         ;----------------
9644   EF4E                         ; Update TcasLast0
9645   EF4E                         ;----------------
9646   EF4E DE 80       L1709       ldx     temp22                  ; get Tcas                                           
9647   EF50 DF 64                   stx     TcasLast0               ; store Tcas in TcasLast0                                
9648   EF52             
9649   EF52                         ;---------------------------------------------------------
9650   EF52                         ; Init casFlags0 to 0 or 1 depending where we came from
9651   EF52                         ;---------------------------------------------------------
9652   EF52 4F                      clra                            ; a = 1, rpm(Tcas)<505, no timing adjustment mode, etc                             
9653   EF53 20 02                   bra     L1711                   ;                              
9654   EF55 86 01       L1710       ldaa    #$01                    ; a = 1, rpm(Tcas)>=505, no timing adjustment mode, etc.                            
9655   EF57 97 61       L1711       staa    casFlags0               ; casFlags0 = 0 or 1                              
9656   EF59             
9657   EF59                         ;-------------------------------------------
9658   EF59                         ; Flush both coil output compare registers,
9659   EF59                         ; i.e. write the fartest possible time
9660   EF59                         ;-------------------------------------------
9661   EF59 DE 29                   ldx     t3_clock1               ;                                    
9662   EF5B 09                      dex                             ; x = t3_clock1-1, the fartest possible time                             
9663   EF5C DF 2B                   stx     t3_outCmpWr             ; Flush first output compare register                                       
9664   EF5E 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                             
9665   EF60 DF 2B                   stx     t3_outCmpWr             ; Flush second output compare register                                      
9666   EF62             
9667   EF62                         ;----------------------------------
9668   EF62                         ; Reset the current coil bit to 0?
9669   EF62                         ;----------------------------------
9670   EF62 96 7B                   ldaa    tdcMask0                ; a = $02 or $04
9671   EF64 48                      asla                            ; a = $04 or $08                                          
9672   EF65 43                      coma                            ; complement, a=~($04 or $08)
9673   EF66 94 19                   anda    t3_csr0                 ; Reset the coil bit to 0, energize coil at next interrupt
9674   EF68 97 19                   staa    t3_csr0                 ; Update t3_csr0                              
9675   EF6A             
9676   EF6A                         ;--------------------------------------------
9677   EF6A                         ; Re-init control register/flush them??? 
9678   EF6A                         ; Not sure what this means???
9679   EF6A                         ;--------------------------------------------
9680   EF6A 86 09                   ldaa    #$09                    ; a = $09                            
9681   EF6C 87 7B 02 02             brset   tdcMask0, #$02, L1712   ; branch if tdcMask0 is $02 (current TDC is for cylinder 1 or 4)                              
9682   EF70 86 06                   ldaa    #$06                    ; a = $06, current TDC is for 2 or 3                           
9683   EF72 97 1A       L1712       staa    t3_csr1                 ; t3_csr1 = $06 or $09 (00000110 or 00001001)                                   
9684   EF74 4F                      clra                            ; a = 0                            
9685   EF75 97 1A                   staa    t3_csr1                 ; t3_csr1 = 0                                   
9686   EF77             
9687   EF77                         ;--------------------------
9688   EF77                         ; Re-init timing variables
9689   EF77                         ;--------------------------
9690   EF77 DC 64                   ldd     TcasLast0               ; d = TcasLast0                                
9691   EF79 DD 66                   std     TcasNew0                ; TcasNew0:TcasNew1 = TcasLast0                                 
9692   EF7B 4F                      clra                            ;                             
9693   EF7C 5F                      clrb                            ; d = 0                             
9694   EF7D DD 70                   std     ignFallRelTime0         ; ignFallRelTime0 = 0                             
9695   EF7F CE 00 CA                ldx     #$00ca                  ; 4deg BTDC                              
9696   EF82 DF 6C                   stx     timCas0                 ; timCas0 = 4deg BTDC                                
9697   EF84 97 63                   staa    enerFlags               ; enerFlags = 0
9698   EF86 86 A0                   ldaa    #$a0                    ; 4.75deg BTDC                             
9699   EF88 97 7D                   staa    tim61                   ; tim61 = 4.75deg BTDC     
9700   EF8A                                                  
9701   EF8A                         ;-----------------------
9702   EF8A                         ; Normal flow continues
9703   EF8A                         ;-----------------------
9704   EF8A                         ;--------------------------------------------
9705   EF8A                         ; Update TcasLast128 = TcasLast0/128
9706   EF8A                         ;--------------------------------------------
9707   EF8A DC 64       L1713       ldd     TcasLast0               ; d = TcasLast0                                
9708   EF8C 05                      asld                            ; d = 2 * TcasLast0                            
9709   EF8D 24 02                   bcc     L1714                   ; Branch if no overflow                              
9710   EF8F 86 FF                   ldaa    #$ff                    ; use max of $ff                            
9711   EF91 97 7A       L1714       staa    TcasLast128             ; TcasLast128 =  2 * TcasLast0/256 = TcasLast0/128
9712   EF93                                          
9713   EF93                         ;---------------------------------------
9714   EF93                         ; Re-init t3_csr0 and t1_csr mode bits
9715   EF93                         ; This also changes the cas edge detection 
9716   EF93                         ; polarity for the next interrupt
9717   EF93                         ;---------------------------------------
9718   EF93 96 19                   ldaa    t3_csr0                 ; a = t3_csr0                             
9719   EF95 84 0C                   anda    #$0c                    ; Reset 1111 0011, reset all except bits corresponding to coil output
9720   EF97 8A 52                   oraa    #$52                    ; Set 0101 0010, set normal control bits...                            
9721   EF99 D6 08                   ldab    t1_csr                  ; b = t1_csr                               
9722   EF9B C4 19                   andb    #$19                    ; reset 1110 0110                            
9723   EF9D CA 02                   orab    #$02                    ; set 0000 0010, cas edge detection polarity                            
9724   EF9F DE 0D                   ldx     t1_inCapt               ; x = t1_inCapt (clear input capture flag?)                               
9725   EFA1 97 19                   staa    t3_csr0                 ; t3_csr0  = t3_csr0  & 0000 1100 | 0101 0010                             
9726   EFA3 D7 08                   stab    t1_csr                  ; t1_csr = t1_csr & 0001 1001 | 0000 0010                                
9727   EFA5             
9728   EFA5                         ;--------------------------------------
9729   EFA5                         ; Re-init timer T40s_casInt to 1.275sec
9730   EFA5                         ;--------------------------------------
9731   EFA5 86 33                   ldaa    #$33                    ; 1.275sec 
9732   EFA7 97 84                   staa    T40s_casInt             ; T40s_casInt = 1.275sec                                  
9733   EFA9             
9734   EFA9                         ;----------------------
9735   EFA9                         ; Update TcasOld
9736   EFA9                         ;----------------------
9737   EFA9 FC 01 45                ldd     Tcas                    ; d = Tcas                            
9738   EFAC FD 01 47                std     TcasOld                 ; TcasOld = Tcas                               
9739   EFAF             
9740   EFAF                         ;---------------------------------------------------
9741   EFAF                         ; Compute new Tcas = 1/2 * [TcasLast0:TcasLast1]
9742   EFAF                         ; and limit max value to $7fff (min rpm of 229rpm)
9743   EFAF                         ;---------------------------------------------------
9744   EFAF DC 64                   ldd     TcasLast0               ; d = TcasLast0
9745   EFB1 04                      lsrd                            ; d = TcasLast0/2                            
9746   EFB2 81 80                   cmpa    #$80                    ;                             
9747   EFB4 25 03                   bcs     L1715                   ; Branch if TcasLast0/2/256 < $80, i.e. TcasLast0/2 < $7fff?
9748   EFB6 CC 7F FF                ldd     #$7fff                  ; Use max of $7fff (229rpm)                              
9749   EFB9 FD 01 45    L1715       std     Tcas                    ; store new Tcas for rpm calculation
9750   EFBC             
9751   EFBC                         ;----------------------------------------------------------
9752   EFBC                         ; Update coilHist with input from the coil sensing circuit
9753   EFBC                         ; coilHist basically contains the sensing circuit value 
9754   EFBC                         ; (0 or 1) for the last 8 interrupts, bit 7 being the 
9755   EFBC                         ; oldest and  bit 0 the newest
9756   EFBC                         ;----------------------------------------------------------
9757   EFBC B6 01 75                ldaa    coilHist                ; a = coilHist                             
9758   EFBF 48                      asla                            ; a = 2*coilHist (shift existing bits left)                            
9759   EFC0 8F 86 04 01             brclr   p4Latched, #$04, L1716  ; Branch if CAS "clock" is clear?
9760   EFC4 4C                      inca                            ; a = 2*coilHist + 1 (set lower bit)
9761   EFC5 B7 01 75    L1716       staa    coilHist                ; coilHist = updated CAS clock history
9762   EFC8             
9763   EFC8                         ;-------------------------------------------------------------
9764   EFC8                         ; If "engine is running and rpm<5000 and 8V<=battRaw<=18V"
9765   EFC8                         ; then check if coilHist lower 4 bits make sense, i.e. should
9766   EFC8                         ; have changed on every CAS interrupt since we have ignition
9767   EFC8                         ; just as often...
9768   EFC8                         ;-------------------------------------------------------------
9769   EFC8 C6 20                   ldab    #$20                      ; preload b = $20 for eventual storage in coilChkCnt
9770   EFCA 8F 85 20 3E             brclr   coilChkFlags, #$20, L1722 ; Bail if not "engine is running and rpm<5000 and 8V<=battRaw<=18V" (we don't perform the test, so reset timer as if no problem...)
9771   EFCE 84 0F                   anda    #$0f                      ; a = coilHist & $0f                              
9772   EFD0 81 05                   cmpa    #$05                      ;                             
9773   EFD2 27 04                   beq     L1717                     ; Branch if coilHist & $0f = $05  (0000 0101)                            
9774   EFD4 81 0A                   cmpa    #$0a                      ;                              
9775   EFD6 26 08                   bne     L1718                     ; Branch if coilHist & $0f != $0a  (0000 1010)                            
9776   EFD8             
9777   EFD8                         ;------------------------------------------------------------------
9778   EFD8                         ; coilHist & $0f = $05 or $0a (0101 or 1010), this is the normal
9779   EFD8                         ; alternating pattern of the check circuit, everything is therefore OK, 
9780   EFD8                         ; reset error bit and allow all 4 injectors to be used
9781   EFD8                         ;------------------------------------------------------------------
9782   EFD8 02 85 7F    L1717       andm    coilChkFlags, #$7f      ; Reset error flag                                
9783   EFDB 03 85 0F                orm     coilChkFlags, #$0f      ; Set all 4 lower bits to 1, meaning all 4 injectors can be used
9784   EFDE 20 2C                   bra     L1722                   ; Bail                              
9785   EFE0             
9786   EFE0                         ;---------------------------------------------------------------
9787   EFE0                         ; coilHist & $0f != $05 or $0a
9788   EFE0                         ; That means some ignition signal were not properly generated.
9789   EFE0                         ;
9790   EFE0                         ; Investigate a little more the bit pattern and then decide
9791   EFE0                         ; if we need to deactivate some injectors.
9792   EFE0                         ; Did not attempt to understand this yet???
9793   EFE0                         ;---------------------------------------------------------------
9794   EFE0 44          L1718       lsra                            ; 
9795   EFE1 44                      lsra                            ; a = (coilHist & $0f)/4                             
9796   EFE2 B8 01 75                eora    coilHist                ; a = (coilHist & $0f)/4 eor coilHist                            
9797   EFE5 44                      lsra                            ; shift lower bit in carry                             
9798   EFE6 24 24                   bcc     L1722                   ; Branch if lower bit 0, no error to flag yet??                           
9799   EFE8 B6 01 75                ldaa    coilHist                ; a = coilHist                             
9800   EFEB 44                      lsra                            ; a = coilHist/2                            
9801   EFEC B8 01 75                eora    coilHist                ; a = coilHist/2 eor coilHist                             
9802   EFEF 44                      lsra                            ; shift lower bit in carry                            
9803   EFF0 25 0F                   bcs     L1720                   ; Branch if lower bit 1, flag an error but dont deactivate injectors                             
9804   EFF2             
9805   EFF2                         ;--------------------------------------------------------------------------------
9806   EFF2                         ; Select injectors that are OK to use depending on whether TDC is active or not
9807   EFF2                         ;--------------------------------------------------------------------------------
9808   EFF2 C6 05                   ldab    #$05                   ; Set bits corresponding to injectors 1 and 4                              
9809   EFF4 8F 06 04 02             brclr   port3, #$04, L1719     ; Branch if TDC signal is active
9810   EFF8 C6 0A                   ldab    #$0a                   ; Set bits corresponding to injectors 3 and 2                              
9811   EFFA             
9812   EFFA                         ;------------------------------------------------------------
9813   EFFA                         ; Update coilChkFlags with injectors that are ok to use
9814   EFFA                         ;------------------------------------------------------------
9815   EFFA 96 85       L1719       ldaa    coilChkFlags            ; a = coilChkFlags                              
9816   EFFC 84 F0                   anda    #$f0                    ; reset 4 lower bits
9817   EFFE 1B                      aba                             ; Set the injectors that are OK to use in lower 4 bits
9818   EFFF 97 85                   staa    coilChkFlags            ; Update coilChkFlags    
9819   F001                                                  
9820   F001                         ;---------------------------------------------------------
9821   F001                         ; We have a missing ignition signal, decrement coilChkCnt 
9822   F001                         ; (min of 0) and set coilChkFlags.7 error flag if it reached 0
9823   F001                         ; That would mean we missed $20 ignition signals...
9824   F001                         ;---------------------------------------------------------
9825   F001 F6 01 74    L1720       ldab    coilChkCnt              ; b = coilChkCnt                              
9826   F004 27 03                   beq     L1721                   ; Branch if coilChkCnt=0                             
9827   F006 5A                      decb                            ;                             
9828   F007 20 03                   bra     L1722                   ;
9829   F009 03 85 80    L1721       orm     coilChkFlags, #$80      ; Set error flag
9830   F00C             
9831   F00C                         ;---------------------------------------------------
9832   F00C                         ; Store new coilChkCnt value, $20 loaded way above 
9833   F00C                         ; or decremented value just calculated
9834   F00C                         ;---------------------------------------------------
9835   F00C F7 01 74    L1722       stab    coilChkCnt              ;                                                                                                     
9836   F00F             
9837   F00F                         ;----------------------------------------------------
9838   F00F                         ; Section to update knockSum from the knock sensor
9839   F00F                         ;----------------------------------------------------
9840   F00F                         ;-----------------------------------------------
9841   F00F                         ; Skip section (use knockSum = 0 ) if car has been 
9842   F00F                         ; running less than 1 sec
9843   F00F                         ;-----------------------------------------------
9844   F00F 8F 53 40 4D             brclr   knockFlags, #$40, L1731 ; Branch to use knockSum = 0 if engine has been running less than 1 sec?
9845   F013             
9846   F013                         ;---------------------------------------
9847   F013                         ; b = rawKnock value from the ADC port
9848   F013                         ;---------------------------------------
9849   F013 86 0E                   ldaa    #$0e                    ; A = knock port number 6 with start bit set = $06 | $08                                                                                
9850   F015 BD EC 0C                jsr     readAdc2                ; b = rawKnock from adc port
9851   F018             
9852   F018                         ;-----------------------------------------
9853   F018                         ; Increment knockTimer up to max of 255
9854   F018                         ;-----------------------------------------
9855   F018 B6 01 77                ldaa    knockTimer              ; Read current counter value                                                                          
9856   F01B 4C                      inca                            ; increment some knock related counter                                                               
9857   F01C 26 02                   bne     L1723                   ; Branch if no overflow
9858   F01E 86 FF                   ldaa    #$ff                    ; overflow, use max
9859   F020 B7 01 77    L1723       staa    knockTimer              ; store new counter value                                                              
9860   F023             
9861   F023                         ;--------------------------------------------------
9862   F023                         ; Decide if we are going to use rawKnock directly
9863   F023                         ;--------------------------------------------------
9864   F023 C1 0C                   cmpb    #$0c                    ; 
9865   F025 25 0C                   bcs     L1725                   ; branch to use it if rawKnock < $0c                                                                                     
9866   F027 C1 24                   cmpb    #$24                    ; 
9867   F029 22 08                   bhi     L1725                   ; branch to use it if rawKnock > $24
9868   F02B             
9869   F02B                         ;----------------------------------------------------------------
9870   F02B                         ; $0c <= rawKnock <= $24, this is a zone where we don't count
9871   F02B                         ; rawKnock except if  knockTimer > $78. knockTimer is however 
9872   F02B                         ; reset to 0 which means it only applies to the first time 
9873   F02B                         ; that happens. Basically, we ignore rawKnock when it is 
9874   F02B                         ; between $0c and $24???
9875   F02B                         ;----------------------------------------------------------------
9876   F02B 81 78                   cmpa    #$78                    ;                                                                                     
9877   F02D 22 01                   bhi     L1724                   ; Branch if knockTimer > $78 
9878   F02F             
9879   F02F                         ;--------------------------------------------
9880   F02F                         ; $0c <= rawKnock <= $24 and knockTimer<78
9881   F02F                         ;
9882   F02F                         ; Use rawKnock=0 and reset knockTimer
9883   F02F                         ;--------------------------------------------
9884   F02F 5F                      clrb                            ; b = 0                                                                                    
9885   F030 7F 01 77    L1724       clr     knockTimer              ; reset knockTimer                                                                                     
9886   F033             
9887   F033                         ;----------------------------------
9888   F033                         ; Update knockSensor from rawKnock
9889   F033                         ;----------------------------------
9890   F033 D7 D1       L1725       stab    knockSensor             ; knockSensor = rawKnock (processed port value)                                                      
9891   F035             
9892   F035                         ;----------------------------------
9893   F035                         ; Compute a = (rawKnock-4)/8
9894   F035                         ;----------------------------------
9895   F035 96 D1                   ldaa    knockSensor             ; a = rawKnock
9896   F037 80 04                   suba    #$04                    ; rawKnock -= 4                                                         
9897   F039 24 01                   bcc     L1726                   ; Branch rawKnock-4 >= 0
9898   F03B 4F                      clra                            ; Use min of 0    
9899   F03C 44          L1726       lsra                            ;                                                                                     
9900   F03D 44                      lsra                            ;                                                                                     
9901   F03E 44                      lsra                            ; a = (rawKnock-4)/8                                                           
9902   F03F             
9903   F03F                         ;------------------------------------------------- 
9904   F03F                         ; Compute a = (rawKnock-4)/8/2 if under low load
9905   F03F                         ;------------------------------------------------- 
9906   F03F 87 53 80 03             brset   knockFlags, #$80, L1727 ; branch if airVol>$49  (high load)
9907   F043 44                      lsra                            ; knock = knock/2 under low load                                                      
9908   F044 20 06                   bra     L1728                   ;                                                                                      
9909   F046             
9910   F046                         ;------------------------------------------------- 
9911   F046                         ; Check for max value of 7 under high load?
9912   F046                         ;------------------------------------------------- 
9913   F046 81 07       L1727       cmpa    #$07                    ;                                                                                                 
9914   F048 25 02                   bcs     L1728                   ; branch if (rawKnock-4)/8 < 7                                                                              
9915   F04A 86 07                   ldaa    #$07                    ; Use max of 7                                                                         
9916   F04C             
9917   F04C                         ;-----------------------------------------------------------
9918   F04C                         ; Add min((rawKnock-4)/8,7) or (rawKnock-4)/8/2 to knockSum
9919   F04C                         ; and check for max of 43
9920   F04C                         ;-----------------------------------------------------------
9921   F04C 9B 8B       L1728       adda    knockSum                ; a = knockSum + min((rawKnock-4)/8,7) or (rawKnock-4)/8/2
9922   F04E 25 04                   bcs     L1729                   ; Branch if overflow                                                                                                 
9923   F050 81 2B                   cmpa    #$2b                    ; No overflow, check for max of 43
9924   F052 23 02                   bls     L1730                   ; Branch if new knockSum <=43                                                                         
9925   F054 86 2B       L1729       ldaa    #$2b                    ; Use max of 43 
9926   F056                                                                                                            
9927   F056                         ;-------------------------------------------------------
9928   F056                         ; If knock sensor not working, use knockSum=$09 under 
9929   F056                         ; high load and knockSum=$00 under low load
9930   F056                         ;-------------------------------------------------------
9931   F056 8F D6 20 07 L1730       brclr   state2, #$20, L1732     ; Branch if knock sensor working properly?                                                                                                   
9932   F05A 86 09                   ldaa    #$09                    ; a = $09                                                                                                
9933   F05C 87 53 80 01             brset   knockFlags, #$80, L1732 ; Branch if airVol>$49                                                                                                  
9934   F060 4F          L1731       clra                            ;                                                                                                 
9935   F061             
9936   F061                         ;-------------------------------------------------------------
9937   F061                         ; Store new knockSum and reset knock sensor physical filter
9938   F061                         ;-------------------------------------------------------------
9939   F061 97 8B       L1732       staa    knockSum                ; Store new knock sum                                                                                 
9940   F063 03 2F 01                orm     port6, #$01             ; Reset knock sensor physical filter?
9941   F066             
9942   F066             
9943   F066                         ;----------------------------------------------
9944   F066                         ; Update maxAdv for E931 in order to slowly
9945   F066                         ; remove its effect with time
9946   F066                         ;----------------------------------------------
9947   F066~            #ifdef E931
9948   F066~                        ldaa    T_maxAdv                ;                               
9949   F066~                        beq     Mf078                   ; Branch if timer T_maxAdv expired                              
9950   F066~                        deca                            ; Decrement timer                             
9951   F066~                        bne     Mf081                   ; Bail if not expired                              
9952   F066~            
9953   F066~                        ;---------------------------------------------------------
9954   F066~                        ; Timer expired increase maxAdv by 1 (increase 
9955   F066~                        ; timing advance limit up to $80) and restart timer to 1
9956   F066~                        ;---------------------------------------------------------
9957   F066~            Mf078       ldab    maxAdv                  ;                               
9958   F066~                        bmi     Mf081                   ; Branch if maxAdv>=$80 (no limit to advance)                                
9959   F066~                        inc     maxAdv                  ;                               
9960   F066~                        ldaa    #$01                    ; re-init timer t0 1 (we do it every loop)                              
9961   F066~            Mf081       staa    T_maxAdv                ;                               
9962   F066             #endif
9963   F066             
9964   F066                         ;------------------------------------------
9965   F066                         ; Set flag masCasFlags.1 indicating to the 
9966   F066                         ; main loop that it can update rpmX4Filt
9967   F066                         ;------------------------------------------
9968   F066 03 9E 01                orm     masCasFlags, #$01       ;                                
9969   F069             
9970   F069                         ;---------------------------------------------------------------------
9971   F069                         ; Section to update o2Fbk from o2 sensor during closed loop operation
9972   F069                         ;---------------------------------------------------------------------
9973   F069 8F E6 80 24             brclr   state1, #$80, L1735     ; Bail  if open loop mode                                
9974   F06D 4F                      clra                            ; a = 0                            
9975   F06E D6 CE                   ldab    o2Raw                   ; b = o2Raw
9976   F070 C1 1A                   cmpb    #$1a                    ;                                                     
9977   F072 24 0D                   bcc     L1733                   ; branch if o2Raw >= 0.507V                                 
9978   F074             
9979   F074                         ;-----------------------------------------
9980   F074                         ; o2Raw < 0.507V (lean) 
9981   F074                         ; increase o2Fbk = o2Fbk + 8 * o2Fbk_inc
9982   F074                         ;-----------------------------------------
9983   F074 D6 EC                   ldab    o2Fbk_inc               ; d = o2Fbk_inc (a cleared earlier)                             
9984   F076 05                      asld                            ;                             
9985   F077 05                      asld                            ; d = 8 * o2Fbk_inc                             
9986   F078 D3 E9                   addd    o2Fbk                   ; d = 8 * o2Fbk_inc + o2Fbk
9987   F07A 24 13                   bcc     L1734                   ; Branch if no overflow                             
9988   F07C CC FF FF                ldd     #$ffff                  ; Use max of $ffff                              
9989   F07F 20 0E                   bra     L1734                   ; Branch to store
9990   F081             
9991   F081                         ;-------------------------------------
9992   F081                         ; o2Raw >= 0.507V (rich) 
9993   F081                         ; decrease o2Fbk = o2Fbk - 4 * o2Fbk_dec
9994   F081                         ;-------------------------------------
9995   F081 D6 EB       L1733       ldab    o2Fbk_dec               ; d = o2Fbk_dec (a cleared earlier)                              
9996   F083 05                      asld                            ;                             
9997   F084 05                      asld                            ; d = 4 * o2Fbk_inc                            
9998   F085 DD 5E                   std     temp8                   ;                               
9999   F087 DC E9                   ldd     o2Fbk                   ;                              
10000  F089 93 5E                   subd    temp8                   ; d = o2Fbk - 4 * o2Fbk_dec                               
10001  F08B 24 02                   bcc     L1734                   ; Branch if no underflow                             
10002  F08D 4F                      clra                            ;                             
10003  F08E 5F                      clrb                            ; Underflow, use min of $0000                            
10004  F08F             
10005  F08F                         ;--------------
10006  F08F                         ; Update o2Fbk 
10007  F08F                         ;--------------
10008  F08F DD E9       L1734       std     o2Fbk                   ; Store new o2Fbk
10009  F091             
10010  F091                         ;-------------------------------------
10011  F091                         ; Return from interrupt
10012  F091                         ;-------------------------------------
10013  F091 3B          L1735       rti                             ;                             
10014  F092             
10015  F092             
10016  F092             
10017  F092             ;******************************************************************
10018  F092             ;
10019  F092             ;
10020  F092             ; Section processing the CAS interrupt on the falling edge
10021  F092             ;
10022  F092             ;
10023  F092             ;******************************************************************
10024  F092                         ;------------------------------------------------------------
10025  F092                         ; Check which of t3_clock1 or t3_clock2 should be used?
10026  F092                         ; Not sure what that bit means???????????
10027  F092                         ;------------------------------------------------------------
10028  F092 87 19 10 03 casFallProc brset   t3_csr0, #$10, L1737    ; Branch if we should use t3_clock2, nothing to do, that's what we assumed above (from where we jumped to casFallProc...)
10029  F096             
10030  F096                         ;-------------------------------------------------------------------------
10031  F096                         ; t3_clock1 should be used, our assumption that it was
10032  F096                         ; t3_clock2 was wrong, update d and  temp20 with the correct values
10033  F096                         ;-------------------------------------------------------------------------
10034  F096 1A                      xgdx                            ; d = t3_clock1
10035  F097 DD 7E                   std     temp20                  ; temp20 = t3_clock1
10036  F099                                                                       
10037  F099                         ;------------------------------------------------
10038  F099                         ; Branch to rest of code if the time between CAS
10039  F099                         ; interrupts makes sense (rpm is not too high...)
10040  F099                         ;
10041  F099                         ; The time measured here is the cas pulse width 
10042  F099                         ; since it is measured from rising to falling edge
10043  F099                         ; Since the cas pulse is 70deg then the 0.5ms below
10044  F099                         ; correspond to 360/70*0.5ms = 2.57ms per rotation which
10045  F099                         ; correspond to 23333rpm???
10046  F099                         ;------------------------------------------------
10047  F099 93 68       L1737       subd    casRiseTime0            ; d = (t3_clock1 or t3_clock2) - casRiseTime0
10048  F09B 1C 00 7D                cmpd    #$007d                  ; 0.5ms at 250KHz                               
10049  F09E 24 07                   bcc     L1738                   ; Branch if (t3_clock1 or  t3_clock2 - casRiseTime0) >= $007d
10050  F0A0             
10051  F0A0                         ;------------------------------------------------
10052  F0A0                         ; RPM seems too high to make sense, check if it is
10053  F0A0                         ; not instead because RPM is so low that the 16 bit 
10054  F0A0                         ; counter subtraction above rolled-over.
10055  F0A0                         ;
10056  F0A0                         ; Branch to rest of code if the T200_casRise timer shows
10057  F0A0                         ; that rpm is very low... 
10058  F0A0                         ;------------------------------------------------
10059  F0A0 96 BF                   ldaa    T200_casRise                                                 
10060  F0A2 81 0E                   cmpa    #$0e                    ; 70ms at 200Hz                             
10061  F0A4 25 01                   bcs     L1738                   ; branch if T200_casRise<70ms, T200_casRise is init with 265ms, the time between interrupt is very high                                                                                                                            
10062  F0A6             
10063  F0A6                         ;-------------------------------------------------------------
10064  F0A6                         ; Time between interrupts doesn't make sense, just ignore it
10065  F0A6                         ; return from interrupt
10066  F0A6                         ;-------------------------------------------------------------
10067  F0A6 3B                      rti                                                          
10068  F0A7             
10069  F0A7                         ;---------------------------------------------------------------
10070  F0A7                         ; Update temp22:temp23 = Tcas measured on the cas falling edge
10071  F0A7                         ;---------------------------------------------------------------
10072  F0A7 DC 7E       L1738       ldd     temp20                  ; d = temp20
10073  F0A9 93 6A                   subd    casFallTime0            ; d = temp20-casFallTime0(old counter) = Tcas = 250000/2/(rpm/60)                                      
10074  F0AB DD 80                   std     temp22                  ; temp22:temp23 = Tcas (temp22 is not dedicated for that purpose...)                                 
10075  F0AD             
10076  F0AD                         ;---------------------------------
10077  F0AD                         ; Validate temp22:temp23 = Tcas
10078  F0AD                         ;---------------------------------
10079  F0AD D6 C0                   ldab    T200_casFall            ;                               
10080  F0AF 27 07                   beq     L1739                   ; Branch if timer expired (very long Tcas...)                             
10081  F0B1 4D                      tsta                            ;                             
10082  F0B2 2B 09                   bmi     L1740                   ; Bail if Tcas/256 >= 128 (rpm<229)                              
10083  F0B4 C1 0E                   cmpb    #$0e                    ;                             
10084  F0B6 22 05                   bhi     L1740                   ; Branch if T200_casRise > $0e (70ms)                             
10085  F0B8 CC FF FF    L1739       ldd     #$ffff                  ; Use max Tcas                               
10086  F0BB DD 80                   std     temp22                  ; store Tcas
10087  F0BD                                           
10088  F0BD                         ;--------------------------------------------------------------------
10089  F0BD                         ; At this point, we will check the CAS signal to make sure it stays
10090  F0BD                         ; reset until 56us after the start of the interrupt. I guess this might
10091  F0BD                         ; be to filter eventual glitches in the CAS signal
10092  F0BD                         ;--------------------------------------------------------------------
10093  F0BD DC 7E       L1740       ldd     temp20                  ;                                    
10094  F0BF C3 00 0E                addd    #$000e                  ; d = StartInterruptTime + $0e (56us)                               
10095  F0C2 87 16 01 01 L1741       brset   port5, #$01, L1742      ; Branch as long as CAS bit is set (CAS signal is reset)
10096  F0C6 3B                      rti                             ; CAS bit was reset, Bail of interrupt
10097  F0C7 1D 29       L1742       cmpd1   t3_clock1               ; Compare current time to time stored when we started the interrupt processing                                 
10098  F0C9 2A F7                   bpl     L1741                   ; Loop if t3_clock1 < (temp20 + $0e (56us)), i.e. if its been less than 56us since interrupt was called
10099  F0CB             
10100  F0CB             
10101  F0CB             
10102  F0CB             
10103  F0CB             ;******************************************************************
10104  F0CB             ;
10105  F0CB             ;
10106  F0CB             ; Interrupt was valid
10107  F0CB             ; Proceed with processing stuff on the CAS falling edge
10108  F0CB             ;
10109  F0CB             ;
10110  F0CB             ;******************************************************************
10111  F0CB                         ;---------------------------------------------------------
10112  F0CB                         ; restart T200_casRise timer to 175ms
10113  F0CB                         ;---------------------------------------------------------
10114  F0CB 86 35                   ldaa    #$35                    ; 265ms                             
10115  F0CD 97 C0                   staa    T200_casFall            ; T200_casFall = 265ms                               
10116  F0CF             
10117  F0CF                         ;-----------------------
10118  F0CF                         ; Update casFallTime0 
10119  F0CF                         ;-----------------------
10120  F0CF DC 7E                   ldd     temp20                  ;                                     
10121  F0D1 DD 6A                   std     casFallTime0            ; casFallTime0 = temp20                             
10122  F0D3             
10123  F0D3                         ;---------------------------------------------------------------------
10124  F0D3                         ; Branch to re-init if T40s_casInt expired or if Tcas/256 >= $80
10125  F0D3                         ;
10126  F0D3                         ; i.e. no cas rising edge interrupt received 
10127  F0D3                         ; in the last 1.275sec or rpm is very low
10128  F0D3                         ;---------------------------------------------------------------------
10129  F0D3 8F 84 FF 04             brclr   T40s_casInt, #$ff, L1743 ; Branch if T40s_casInt expired                                    
10130  F0D7 96 80                   ldaa    temp22                   ; a = Tcas/256                             
10131  F0D9 2A 11                   bpl     L1744                    ; Branch if a < $80                             
10132  F0DB             
10133  F0DB                         ;---------------------------------------------------------
10134  F0DB                         ; T40s_casInt expired or Tcas/256 >= $80 (too big)
10135  F0DB                         ; Re-init casFlags0, enerFlags and control registers 
10136  F0DB                         ; and jump over the entire ignition section
10137  F0DB                         ;---------------------------------------------------------
10138  F0DB 4F          L1743       clra                            ; a = 0                            
10139  F0DC 97 61                   staa    casFlags0               ; casFlags0 = 0                             
10140  F0DE 97 63                   staa    enerFlags               ; enerFlags = 0                              
10141  F0E0 03 19 0C                orm     t3_csr0, #$0c           ; set 0000 1100, disable both coils                               
10142  F0E3 03 1A 0A                orm     t3_csr1, #$0a           ; set 0000 1010, ???                                     
10143  F0E6 02 1A F0                andm    t3_csr1, #$f0           ; reset 0000 1111 (reset the bit we just set...)                                     
10144  F0E9 7E F2 39                jmp     L1765                   ; Bail, jump over ignition section                             
10145  F0EC                                                         
10146  F0EC                         ;---------------------------------------------------------
10147  F0EC                         ; Section to process ignFallRelTime0 when it is non-null
10148  F0EC                         ; Firs check just that...
10149  F0EC                         ;---------------------------------------------------------
10150  F0EC DC 70       L1744       ldd     ignFallRelTime0         ; d = ignFallRelTime0:ignFallRelTime1                              
10151  F0EE 26 03                   bne     L1745                   ; Branch if ignFallRelTime0:ignFallRelTime1 != 0                             
10152  F0F0 7E F1 8D                jmp     L1754                   ; Bail since ignFallRelTime0=0
10153  F0F3             
10154  F0F3                         ;----------------------------------------------------------
10155  F0F3                         ; At this point ignFallRelTime0 != 0
10156  F0F3                         ; When ignFallRelTime0:ignFallRelTime1 is not  0, it 
10157  F0F3                         ; means we determined on the cas rising edge that ignition
10158  F0F3                         ; would be scheduled on the cas falling edge, which we are in
10159  F0F3                         ; now... But coil need to be energized first...
10160  F0F3                         ;
10161  F0F3                         ; Check if current coil is already energized
10162  F0F3                         ;----------------------------------------------------------
10163  F0F3 96 16       L1745       ldaa    port5                   ; a = port5                             
10164  F0F5 94 7B                   anda    tdcMask0                ; a = port5 & tdcMask0  ($02 or $04)                            
10165  F0F7 27 57                   beq     L1750                   ; Branch if coil is energized
10166  F0F9             
10167  F0F9                         ;---------------------------------------------
10168  F0F9                         ; Currrent coil is not yet energized
10169  F0F9                         ;---------------------------------------------
10170  F0F9                         ;----------------------------------------------------------------------------
10171  F0F9                         ; Check if energization has been scheduled?, this would mean energization
10172  F0F9                         ; will occur soon, or should have occured by now
10173  F0F9                         ;----------------------------------------------------------------------------
10174  F0F9 87 63 02 03             brset   enerFlags, #$02, L1746  ; Branch if enerFlags=2, energization was scheduled
10175  F0FD 7E F1 8D                jmp     L1754                   ; Bail, not sure what this would mean, probably that ignition already occured and there is nothing left to do??????
10176  F100             
10177  F100                         ;--------------------------------------------------------------
10178  F100                         ; At this point 
10179  F100                         ; -Coil is not yet energized 
10180  F100                         ; -We determined on the cas rising edge that ignition would be
10181  F100                         ;  schedule on the cas falling edge (thats now...)
10182  F100                         ; -enerFlags indicates energization was scheduled from 
10183  F100                         ;  the cas rising edge and should already have occured 
10184  F100                         ;  or will occur very soon??? Just reschedule energization...
10185  F100                         ;--------------------------------------------------------------
10186  F100                         ;----------------------------------------------------------------------------------
10187  F100                         ; Compute enerAbsTime0:
10188  F100                         ;
10189  F100                         ;    enerAbsTime0 = casFallTime0 + ignFallRelTime0 - enerLenX0 - TcasLast128
10190  F100                         ;
10191  F100                         ; enerAbsTime0 is the coil energization absolute time (timer clock) 
10192  F100                         ; (calculated from the CAS falling edge in this case)
10193  F100                         ;----------------------------------------------------------------------------------
10194  F100 DC 70       L1746       ldd     ignFallRelTime0       ; d = ignFallRelTime0                             
10195  F102 93 72                   subd    enerLenX0             ; d = ignFallRelTime0 - enerLenX0                             
10196  F104 D0 7A                   subb    TcasLast128           ; d = ignFallRelTime0 - enerLenX0 - TcasLast128                             
10197  F106 82 00                   sbca    #$00                  ; propagate carry                             
10198  F108 D3 6A                   addd    casFallTime0          ; d = ignFallRelTime0 - enerLenX0 - TcasLast128 + casFallTime0                              
10199  F10A DD 74                   std     enerAbsTime0          ; enerAbsTime0 = casFallTime0 + ignFallRelTime0 - enerLenX0 - TcasLast128
10200  F10C             
10201  F10C                         ;---------------------------------------------------------------------------
10202  F10C                         ; Reset the proper coil bit in t3_csr0, i.e. energize coil at next interrupt
10203  F10C                         ;---------------------------------------------------------------------------
10204  F10C 96 7B                   ldaa    tdcMask0                ; a = $02 or $04                             
10205  F10E 48                      asla                            ; a = $04 or $08
10206  F10F 43                      coma                            ; a = ~($04 or $08)                            
10207  F110 94 19                   anda    t3_csr0                 ; Reset that coil bit, i.e. have the coil energized the next time
10208  F112 97 19                   staa    t3_csr0                 ; Update t3_csr0                              
10209  F114             
10210  F114                         ;------------------------------------------------------------------------------
10211  F114                         ; Check if enerAbsTime0 that we just calculated is sufficiently in the future
10212  F114                         ;------------------------------------------------------------------------------
10213  F114 DC 29                   ldd     t3_clock1               ; d = t3_clock1                                   
10214  F116 C3 00 06                addd    #$0006                  ; d = t3_clock1 + $06 (24us)                             
10215  F119 1A                      xgdx                            ; x = t3_clock1 + $06                            
10216  F11A 9C 74                   cpx     enerAbsTime0            ;                              
10217  F11C 2B 0A                   bmi     L1747                   ; Branch to use enerAbsTime0 if it is sufficiently "in the future", i.e. t3_clock1 + $06 < enerAbsTime0
10218  F11E             
10219  F11E                         ;------------------------------------------------------------------------
10220  F11E                         ; enerAbsTime0 is not sufficiently in the future, 
10221  F11E                         ;
10222  F11E                         ; schedule energization for "now", i.e. t3_clock1 + $06 
10223  F11E                         ; this is 24usec (a few cycles) I assume the output compare will
10224  F11E                         ; therefore happen before we schedule the ignition later in the code 
10225  F11E                         ; below... Note that only the first output compare register is updated.
10226  F11E                         ; Also update enerAbsTime0
10227  F11E                         ;
10228  F11E                         ; Update enerFlags = 1 to reflect the fact that coil is now energized.
10229  F11E                         ; It is not really but it will be in 24usec....
10230  F11E                         ;------------------------------------------------------------------------
10231  F11E DF 74                   stx     enerAbsTime0            ; enerAbsTime0 = t3_clock1 + $06
10232  F120 DF 2B                   stx     t3_outCmpWr             ; Schedule energization interrupt time on first output compare register                                   
10233  F122 86 01                   ldaa    #$01                    ;                             
10234  F124 97 63                   staa    enerFlags               ; Make sure flag reflects the fact that coil is energized or will be very soon???                             
10235  F126 20 44                   bra     L1752                   ; Branch to compute ignition time                             
10236  F128             
10237  F128                         ;-----------------------------------------------------
10238  F128                         ; enerAbsTime0 is sufficiently in the future
10239  F128                         ; Schedule regular coil energization interrupt time 
10240  F128                         ; and update enerAbsTime0 with it.
10241  F128                         ;
10242  F128                         ; Note that Ignition will be calculated below but scheduled 
10243  F128                         ; only  when the output compare interrupt to energize the 
10244  F128                         ; coil actually happens (i.e. in coilFunc)
10245  F128                         ;-----------------------------------------------------
10246  F128 DE 74       L1747       ldx     enerAbsTime0            ; x = enerAbsTime0                             
10247  F12A DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register                                     
10248  F12C 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                           
10249  F12E DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register 
10250  F130                                                             
10251  F130                         ;---------------------------------------------------------------------------
10252  F130                         ; Branch to compute ignTime0
10253  F130                         ; if we predicted we would schedule ignition on the CAS falling edge???
10254  F130                         ;---------------------------------------------------------------------------
10255  F130 87 62 01 14             brset   ignFallFlags, #$01, L1749 ; Branch if ignFallFlags = 1
10256  F134             
10257  F134                         ;-------------------------------------------------------------------
10258  F134                         ; Flag is not set, do it anyway if 
10259  F134                         ;
10260  F134                         ;     abs(ignTime0 - casFallTime0 - ignFallRelTime0) >= TcasLast128
10261  F134                         ;           abs(compIgnFallRelTime - ignFallRelTime0) >= TcasLast128
10262  F134                         ;
10263  F134                         ; where compIgnFallRelTime = ignTime0 - casFallTime0 is the ignition
10264  F134                         ; time relative to the cas falling edge but calculated from ignTime0...
10265  F134                         ;
10266  F134                         ; i.e. Do it anyway if they are more than 1.4deg apart??? Why not
10267  F134                         ; just recompute it anyway instead of doing this lenghty 
10268  F134                         ; computation to check it, there must be a reason??? I guess
10269  F134                         ; in most cases, it might be more acurate to use ignFallRelTime0
10270  F134                         ; but in case it is too far apart from what makes sense at this time
10271  F134                         ; then just use whatever makes sense at this time...
10272  F134                         ;-------------------------------------------------------------------
10273  F134 DC 76                   ldd     ignTime0                ; d = ignTime0                             
10274  F136 93 6A                   subd    casFallTime0            ; d = ignTime0 - casFallTime0                             
10275  F138 93 70                   subd    ignFallRelTime0         ; d = ignTime0 - casFallTime0 - ignFallRelTime0                            
10276  F13A 24 05                   bcc     L1748                   ; Branch if no overflow                             
10277  F13C 43                      coma                            ; overflow, compute 2s complement                            
10278  F13D 53                      comb                            ;                             
10279  F13E C3 00 01                addd    #$0001                  ; d = abs(ignTime0 - casFallTime0 - ignFallRelTime0)                             
10280  F141 4D          L1748       tsta                            ;                             
10281  F142 26 04                   bne     L1749                   ; Branch if abs(compIgnFallRelTime - ignFallRelTime0)/256 != 0                             
10282  F144 D1 7A                   cmpb    TcasLast128             ; high part is null, check low part                              
10283  F146 25 45                   bcs     L1754                   ; Bail if difference is small, i.e. abs(compIgnFallRelTime - ignFallRelTime0) <  TcasLast128
10284  F148                                                      
10285  F148                         ;------------------------------------------------------------------
10286  F148                         ; Compute ignTime0 = ignFallRelTime0 + casFallTime0
10287  F148                         ; The ignition time computed from the cas falling edge
10288  F148                         ;------------------------------------------------------------------
10289  F148 DC 70       L1749       ldd     ignFallRelTime0         ; d = ignFallRelTime0                               
10290  F14A D3 6A                   addd    casFallTime0            ; d = ignFallRelTime0 + casFallTime0                             
10291  F14C DD 76                   std     ignTime0                ; ignTime0 = ignFallRelTime0 + casFallTime0                              
10292  F14E 20 3D                   bra     L1754                   ; Bail                             
10293  F150             
10294  F150                         ;----------------------------------------------------------------
10295  F150                         ; At this point we detected that coil is already energized...
10296  F150                         ; Section of code similar to above one...
10297  F150                         ;----------------------------------------------------------------
10298  F150                         ;--------------------------------------------------
10299  F150                         ; Check if flag indicate ignition makes sense???
10300  F150                         ;--------------------------------------------------
10301  F150 8F 63 03 39 L1750       brclr   enerFlags, #$03, L1754    ; Bail if flag indicates coil is not energized and energization is not scheduled???
10302  F154             
10303  F154                         ;---------------------------------------------------------------------------
10304  F154                         ; Branch to compute ignTime0
10305  F154                         ; if we predicted we would schedule ignition on the CAS falling edge???
10306  F154                         ;---------------------------------------------------------------------------
10307  F154 87 62 01 14             brset   ignFallFlags, #$01, L1752 ; Branch if ??? TDC related                              
10308  F158             
10309  F158                         ;-------------------------------------------------------------------
10310  F158                         ; Flag is not set, do it anyway if 
10311  F158                         ;
10312  F158                         ;     abs(ignTime0 - casFallTime0 - ignFallRelTime0) >= TcasLast128
10313  F158                         ;           abs(compIgnFallRelTime - ignFallRelTime0) >= TcasLast128
10314  F158                         ;
10315  F158                         ; where compIgnFallRelTime = ignTime0 - casFallTime0 is the ignition
10316  F158                         ; time relative to the cas falling edge but calculated from ignTime0...
10317  F158                         ;
10318  F158                         ; i.e. Do it anyway if they are more than 1.4deg apart??? Why not
10319  F158                         ; just recompute it anyway instead of doing this lenghty 
10320  F158                         ; computation to check it, there must be a reason??? I guess
10321  F158                         ; in most cases, it might be more acurate to use ignFallRelTime0
10322  F158                         ; but in case it is too far apart from what makes sense at this time
10323  F158                         ; then just use whatever makes sense at this time...
10324  F158                         ;-------------------------------------------------------------------
10325  F158 DC 76                   ldd     ignTime0                  ; d = ignTime0                              
10326  F15A 93 6A                   subd    casFallTime0              ; d = ignTime0 - casFallTime0                             
10327  F15C 93 70                   subd    ignFallRelTime0           ; d = ignTime0 - casFallTime0 - ignFallRelTime0                              
10328  F15E 24 05                   bcc     L1751                     ; Branch if no overflow                             
10329  F160 43                      coma                              ; overflow, compute 2s complement                            
10330  F161 53                      comb                              ;                             
10331  F162 C3 00 01                addd    #$0001                    ; d = abs(ignTime0 - casFallTime0 - ignFallRelTime0)                              
10332  F165 4D          L1751       tsta                              ;                             
10333  F166 26 04                   bne     L1752                     ; Branch if abs(ignTime0 - casFallTime0 - ignFallRelTime0)/256 > 0                             
10334  F168 D1 7A                   cmpb    TcasLast128               ; high part is zero (a = 0), check low part for minimum                              
10335  F16A 25 21                   bcs     L1754                     ; Branch if difference is small, i.e. abs(ignTime0 - casFallTime0 - ignFallRelTime0) <  TcasLast128
10336  F16C             
10337  F16C                         ;----------------------------------------------------
10338  F16C                         ; Compute ignTime0 = ignFallRelTime0 + casFallTime0
10339  F16C                         ; The ignition time computed from the cas falling edge
10340  F16C                         ;----------------------------------------------------
10341  F16C DC 70       L1752       ldd     ignFallRelTime0         ; d = ignFallRelTime0                                              
10342  F16E D3 6A                   addd    casFallTime0            ; d = ignFallRelTime0 + casFallTime0                                     
10343  F170 DD 76                   std     ignTime0                ; ignTime0 = ignFallRelTime0 + casFallTime0 
10344  F172                                                         
10345  F172                         ;-------------------------------------------
10346  F172                         ; Update enerFlags = 1 since at this 
10347  F172                         ; point we know the coil is energized???
10348  F172                         ;-------------------------------------------
10349  F172 86 01                   ldaa    #$01                    ; a = $01                            
10350  F174 97 63                   staa    enerFlags               ; enerFlags = $01                             
10351  F176             
10352  F176                         ;------------------------------------------
10353  F176                         ; Make sure ignition time is in the future
10354  F176                         ;------------------------------------------
10355  F176 DC 29                   ldd     t3_clock1               ; d = t3_clock1                                   
10356  F178 C3 00 09                addd    #$0009                  ; d = t3_clock1 + $09 (36usec)                             
10357  F17B 1A                      xgdx                            ; x = t3_clock1 + $09                             
10358  F17C 9C 76                   cpx     ignTime0                ;                              
10359  F17E 2A 02                   bpl     L1753                   ; Branch to use t3_clock1 + $09 if ignTime0 is "in the past"                             
10360  F180 DE 76                   ldx     ignTime0                ; ignTime0 is valid, use it                             
10361  F182             
10362  F182                         ;-----------------------------------------------------------
10363  F182                         ; Schedule ignition time on both output compare registers
10364  F182                         ; Update the coil bits and save time in ignTime0
10365  F182                         ;-----------------------------------------------------------
10366  F182 DF 2B       L1753       stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register
10367  F184 03 19 0C                orm     t3_csr0, #$0c           ; Set both coil bits for ignition
10368  F187 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                            
10369  F189 DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register                                     
10370  F18B DF 76                   stx     ignTime0                ; ignTime0 = next interrupt time                             
10371  F18D             
10372  F18D                         ;-----------------------------------------------
10373  F18D                         ; Common branching place for most code above...
10374  F18D                         ;-----------------------------------------------
10375  F18D                         ;---------------------------------------------------------
10376  F18D                         ; Section to check if ignition should have occured by 
10377  F18D                         ; now and schedule it "now" if needed
10378  F18D                         ;---------------------------------------------------------
10379  F18D 8F 61 02 15 L1754       brclr   casFlags0, #$02, L1755    ; Branch if rpm(Tcas) < 505 previously
10380  F191 87 61 40 1F             brset   casFlags0, #$40, L1756    ; Branch to continue if timing adjustement mode active                             
10381  F195 DC 6C                   ldd     timCas0                   ; d = timCas0:timCas1                               
10382  F197 1C 00 C8                cmpd    #$00c8                    ;                               
10383  F19A 24 18                   bcc     L1756                     ; Branch if timCas0 >= $c8 (4.7 BTDC)                             
10384  F19C 96 16                   ldaa    port5                     ; a = port5                               
10385  F19E 94 7B                   anda    tdcMask0                  ; a = port5 & $02 or $04                              
10386  F1A0 26 12                   bne     L1756                     ; Branch if current coil bit is 1, i.e. coil is not energized
10387  F1A2 8F 63 03 0E             brclr   enerFlags, #$03, L1756    ; Branch to continue if flag indicate coil is not energized and energization is not scheduled
10388  F1A6                                                       
10389  F1A6                         ;-----------------------------------------------------------------------------------
10390  F1A6                         ; At this point, 
10391  F1A6                         ;     rpm(Tcas) < 505 
10392  F1A6                         ; or
10393  F1A6                         ;     current coil is energized
10394  F1A6                         ;     and timCas0 < $c8 (4.7 BTDC)
10395  F1A6                         ;     and enerFlags =  1 or 2, coil is energized or energization is scheduled
10396  F1A6                         ;
10397  F1A6                         ; In all those cases, ignition should have occured by now???
10398  F1A6                         ;
10399  F1A6                         ; Schedule interrupt on first output compare register to provoke 
10400  F1A6                         ; ignition now, save time in ignTime0 and clear enerFlags
10401  F1A6                         ;-----------------------------------------------------------------------------------
10402  F1A6 03 19 0C    L1755       orm     t3_csr0, #$0c           ; Set both coil bits for ignition
10403  F1A9 DE 29                   ldx     t3_clock1               ; x = t3_clock1                                   
10404  F1AB 08                      inx                             ;                             
10405  F1AC 08                      inx                             ; x = t3_clock1 + $02                             
10406  F1AD DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register
10407  F1AF DF 76                   stx     ignTime0                ; Update ignTime0 with the ignition time we just used                              
10408  F1B1 4F                      clra                            ;                             
10409  F1B2 97 63                   staa    enerFlags               ; enerFlags = 0                             
10410  F1B4             
10411  F1B4                         ;--------------------------------------------------------------
10412  F1B4                         ; Section to update ignition stuff when rpm(Tcas) < 505???
10413  F1B4                         ; Probably a dedicated section when engine is cranking???
10414  F1B4                         ; First check rpm flag...
10415  F1B4                         ;--------------------------------------------------------------
10416  F1B4 87 61 02 03 L1756       brset   casFlags0, #$02, L1757  ; Branch if rpm(Tcas) >= 505 previously
10417  F1B8 7E F2 39                jmp     L1765                   ; Bail                         
10418  F1BB                             
10419  F1BB                         ;---------------------
10420  F1BB                         ; rpm(Tcas) < 505rpm
10421  F1BB                         ;---------------------
10422  F1BB                         ;---------------------------------------------------------
10423  F1BB                         ; Compute enerLenX0 = min($60/128 * Tcas, 16*enerLen)
10424  F1BB                         ;                   = min(   0.75 * Tcas, 16*enerLen)
10425  F1BB                         ;---------------------------------------------------------
10426  F1BB 96 89       L1757       ldaa    enerLen                 ; a = enerLen                              
10427  F1BD 5F                      clrb                            ; d = enerLen*256                             
10428  F1BE 04                      lsrd                            ;                             
10429  F1BF 04                      lsrd                            ;                             
10430  F1C0 04                      lsrd                            ;                             
10431  F1C1 04                      lsrd                            ; d = enerLen*256/16 = 16*enerLen                            
10432  F1C2 DD 7E                   std     temp20                  ; temp20 = 16*enerLen                                   
10433  F1C4 96 81       L1758       ldaa    temp23                  ; a = temp23  (low part of Tcas)                            
10434  F1C6 C6 60                   ldab    #$60                    ; b = $60                             
10435  F1C8 3D                      mul                             ; d = $60 * temp23                            
10436  F1C9 97 72                   staa    enerLenX0               ; enerLenX0 = $60/256 * temp23                             
10437  F1CB 96 80                   ldaa    temp22                  ; a = temp22                             
10438  F1CD C6 60                   ldab    #$60                    ; b = $60                            
10439  F1CF 3D                      mul                             ; d = $60 * temp22                            
10440  F1D0 DB 72                   addb    enerLenX0               ; d = $60 * temp22 + $60/256 * temp23 = $60/256 * [temp22:temp23]                             
10441  F1D2 89 00                   adca    #$00                    ; propagate carry                            
10442  F1D4 05                      asld                            ; d = $60/128 * [temp22:temp23] = $60/128 * Tcas                            
10443  F1D5 25 04                   bcs     L1759                   ; Branch if overflow
10444  F1D7 1D 7E                   cmpd1   temp20                  ;                                     
10445  F1D9 25 02                   bcs     L1760                   ; Branch if $60/128 * Tcas < 16*enerLen                            
10446  F1DB DC 7E       L1759       ldd     temp20                  ; Use max of 16*enerLen                                     
10447  F1DD DD 72       L1760       std     enerLenX0               ; enerLenX0 = min($60/128 * Tcas, 16*enerLen)                    
10448  F1DF                      
10449  F1DF                         ;-------------------------------------------------------------------------------------
10450  F1DF                         ; Compute  temp20 = casFallTime0 + $9c/256 * Tcas + ignRelTime0  - enerLenX0 
10451  F1DF                         ;                 = casFallTime0 + 110deg + ignRelTime0  - enerLenX0 
10452  F1DF                         ;
10453  F1DF                         ; 110deg is the number of degrees between the CAS falling edge and the next
10454  F1DF                         ; CAS rising edge since CAS starts at -75deg and ends at -5deg, CAS width = 70deg
10455  F1DF                         ; and then distance from falling edge to next rising edge = 180deg - 70deg = 110deg
10456  F1DF                         ;
10457  F1DF                         ; we are therefore calculating the coil energization absolute time for the next
10458  F1DF                         ; CAS/cylinder from the CAS falling edge of the current CAS/cylinder... 
10459  F1DF                         ;-------------------------------------------------------------------------------------
10460  F1DF 8F 83 FE 56             brclr   tdcCasCount, #$fe, L1765 ; Bail if tdcCasCount = 0 or 1                                    
10461  F1E3 D6 81                   ldab    temp23                   ; b = temp23 (low part of Tcas)                            
10462  F1E5 86 9C                   ldaa    #$9c                     ; a = $9c                            
10463  F1E7 3D                      mul                              ; d = $9c * temp23                             
10464  F1E8 97 7F                   staa    temp21                   ; temp21 = $9c * temp23/256                               
10465  F1EA 96 80                   ldaa    temp22                   ; a = temp22                             
10466  F1EC C6 9C                   ldab    #$9c                     ; b = $9c                             
10467  F1EE 3D                      mul                              ; d =  $9c * temp22                            
10468  F1EF DB 7F                   addb    temp21                   ; d = $9c * temp22 + $9c * temp23/256  = $9c/256 * [temp22:temp23]                            
10469  F1F1 89 00                   adca    #$00                     ; propagate carry                            
10470  F1F3 D3 6E                   addd    ignRelTime0              ; d = $9c/256 * Tcas + ignRelTime0                             
10471  F1F5 93 72                   subd    enerLenX0                ; d = $9c/256 * Tcas + ignRelTime0  - enerLenX0                             
10472  F1F7 D3 6A                   addd    casFallTime0             ; d = $9c/256 * Tcas + ignRelTime0  - enerLenX0 + casFallTime0                             
10473  F1F9 DD 7E                   std     temp20                   ; temp20 = $9c/256 * Tcas + ignRelTime0  - enerLenX0 + casFallTime0                                      
10474  F1FB             
10475  F1FB                         ;----------------------------------------------------------------------
10476  F1FB                         ; Verify that energization time does not occur too close to ignition
10477  F1FB                         ; of current cylinder, i.e. energization should not occur sooner than 
10478  F1FB                         ; 1ms after ignition of preceeding cylinder
10479  F1FB                         ;----------------------------------------------------------------------
10480  F1FB DC 76                   ldd     ignTime0                 ; d = ignTime0                              
10481  F1FD C3 00 FA                addd    #$00fa                   ; d = ignTime0 + $fa (1ms)                              
10482  F200 1D 7E                   cmpd1   temp20                   ;                                    
10483  F202 2B 02                   bmi     L1761                    ; Branch if ignTime0 + $fa < casFallTime0 + $9c/256 * Tcas + ignRelTime0  - enerLenX0
10484  F204 DD 7E                   std     temp20                   ; Use closest possible energization time of ignTime0 + $fa (1ms)
10485  F206             
10486  F206                         ;-------------------------------------
10487  F206                         ; Check if current coil is energized
10488  F206                         ;-------------------------------------
10489  F206 96 16       L1761       ldaa    port5                   ; a = port5                              
10490  F208 94 7B                   anda    tdcMask0                ; a = port5 & tdcMask0 ($02 or $04)                             
10491  F20A 27 25                   beq     L1763                   ; Branch if coil bit is 0, i.e. coil is energized                              
10492  F20C             
10493  F20C                         ;--------------------------------------------------
10494  F20C                         ; Current coil is not yet energized,
10495  F20C                         ;
10496  F20C                         ; Check that energization time computed above and 
10497  F20C                         ; stored in temp20 is sufficiently in the future
10498  F20C                         ;--------------------------------------------------
10499  F20C 87 63 02 25             brset   enerFlags, #$02, L1764  ; Bail if flag indicates coil is energized or energization is scheduled
10500  F210 DC 29                   ldd     t3_clock1               ; d = t3_clock1                                   
10501  F212 C3 00 0A                addd    #$000a                  ; d = t3_clock1 + $0a  (40usec)                            
10502  F215 1A                      xgdx                            ; x = t3_clock1 + $0a                             
10503  F216 9C 7E                   cpx     temp20                  ; Compare to energization time                                    
10504  F218 2A 02                   bpl     L1762                   ; Branch to use t3_clock1 + $0a if energization time is "in the past"                             
10505  F21A DE 7E                   ldx     temp20                  ; Energization time is valid, use it
10506  F21C             
10507  F21C                         ;----------------------------------------------------
10508  F21C                         ; Schedule the coil energization 
10509  F21C                         ; time and store time in enerAbsTimeNext0
10510  F21C                         ;----------------------------------------------------
10511  F21C DF 2B       L1762       stx     t3_outCmpWr             ; Schedule interrupt time on first output compare register  
10512  F21E 96 1A                   ldaa    t3_csr1                 ; Go to next output compare register                                                                                               
10513  F220 DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt time on second output compare register 
10514  F222 DF 78                   stx     enerAbsTimeNext0        ; Store actual time used                             
10515  F224             
10516  F224                         ;--------------------------------------------------
10517  F224                         ; Reset the corresponding coil bit to 
10518  F224                         ; energize the coil at the specified time
10519  F224                         ;--------------------------------------------------
10520  F224 96 7C                   ldaa    tdcMask1                ; a = $02 or $04
10521  F226 48                      asla                            ; a = $04 or $08
10522  F227 43                      coma                            ; a = ~($04 or $08)                            
10523  F228 94 19                   anda    t3_csr0                 ; reset that coil bit, i.e. energize that coil at the specified time                             
10524  F22A 97 19                   staa    t3_csr0                 ; update t3_csr0                             
10525  F22C             
10526  F22C                         ;-----------------------------------------------
10527  F22C                         ; Set enerFlags = 0
10528  F22C                         ; Although coil is energized, it seems we use 
10529  F22C                         ; this value when rpm is low...
10530  F22C                         ;-----------------------------------------------
10531  F22C 4F                      clra                            ;                             
10532  F22D 97 63                   staa    enerFlags               ;                              
10533  F22F 20 08                   bra     L1765                   ;                              
10534  F231             
10535  F231                         ;------------------------------------------------------------------------------
10536  F231                         ; Update enerAbsTimeNext0 with its latest value if flag indicates 
10537  F231                         ; coil is energized or energization has been scheduled
10538  F231                         ; Makes sense to update the variable if energization time was actually used...
10539  F231                         ;------------------------------------------------------------------------------
10540  F231 8F 63 03 04 L1763       brclr   enerFlags, #$03, L1765  ; Branch if flag indicates coil is not energized and energization is not scheduled
10541  F235 DC 7E       L1764       ldd     temp20                  ; d = temp20                                   
10542  F237 DD 78                   std     enerAbsTimeNext0        ; enerAbsTimeNext0 = temp20                               
10543  F239             
10544  F239                         ;-------------------------------------------
10545  F239                         ; Common branching place for all code above
10546  F239                         ;-------------------------------------------
10547  F239                         ;-------------------------------------------------------
10548  F239                         ; Update ignFallFlags, t3_csr0 and t1_csr
10549  F239                         ; Change cas edge detection polarity among others... 
10550  F239                         ;-------------------------------------------------------
10551  F239 02 62 FE    L1765       andm    ignFallFlags, #$fe      ; Reset 0000 0001                               
10552  F23C 96 19                   ldaa    t3_csr0                 ; a = t3_csr0                              
10553  F23E 84 0C                   anda    #$0c                    ; reset both coil bits, i.e. energize both coil at the specified time
10554  F240 8A 42                   oraa    #$42                    ; set   0100 0010 ???                                                                                                  
10555  F242 D6 08                   ldab    t1_csr                  ; b = t1_csr                                                                                                       
10556  F244 C4 19                   andb    #$19                    ; reset 1110 0110, change cas detection polarity, enable injectors 5/6 bits???, reset injector and cas interrupt pending flags
10557  F246 DE 0D                   ldx     t1_inCapt               ; Clear input capture flag?
10558  F248 97 19                   staa    t3_csr0                 ; Update t3_csr0                                                                                                     
10559  F24A D7 08                   stab    t1_csr                  ; Update t1_csr   
10560  F24C                                                                                                                           
10561  F24C                         ;-----------------------------------
10562  F24C                         ; Reset instant knock sum???
10563  F24C                         ;-----------------------------------
10564  F24C 02 2F FE                andm    port6, #$fe             ; Reset instant knock sum???                                                                                             
10565  F24F             
10566  F24F                         ;---------------------------------------------------------------------
10567  F24F                         ; Reset engine rotating timer to 0.6sec or 1.2sec depending on 
10568  F24F                         ; whether key is in start. If key is in start it means we are 
10569  F24F                         ; cranking, rpm is therefore low and we need a longer timeout value...
10570  F24F                         ;---------------------------------------------------------------------
10571  F24F 86 18                   ldaa    #$18                    ; a = 0.6sec                                                                                                   
10572  F251 87 06 40 01             brset   port3, #$40, L1766      ; Branch if key is not in start???                                                                                                      
10573  F255 48                      asla                            ; key in start, use a = 1.2sec                                                                                                    
10574  F256 B7 01 20    L1766       staa    T40_engRot              ; T40_engRot = #$18 (0.6sec) or #$30 (1.2sec)
10575  F259             
10576  F259                         ;----------------------------
10577  F259                         ; Update rev limiter flag
10578  F259                         ;----------------------------
10579  F259 FE 01 45                ldx     Tcas                    ; Tcas = Time(s) per engine revolution * 125000, rpm = (125000*60)/(2*Tcas)                               
10580  F25C 8C 01 F4                cpx     #$01f4                  ; Rev limiter (limit rpm = (125000*60)/(2*$01F4) = 7500)                                                     
10581  F25F 24 05                   bcc     L1767                   ; branch if RPM lower than threshold (Tcas higher than threshold)
10582  F261 03 A2 04                orm     state3, #$04            ; RPM exceeds threshold, set bit                                
10583  F264 20 03                   bra     L1768                   ;                              
10584  F266 02 A2 FB    L1767       andm    state3, #$fb            ; RPM below threshold, reset bit                                
10585  F269             
10586  F269                         ;-----------------------------
10587  F269                         ; Update cylinder1 TDC state
10588  F269                         ;-----------------------------
10589  F269 02 B3 7F    L1768       andm    tdcCasFlags, #$7f         ; Assume flag is 0                                 
10590  F26C 8F B3 08 0A             brclr   tdcCasFlags, #$08, L1769  ; branch if TDC was 0 last time
10591  F270             
10592  F270                         ;------------------------------------------------
10593  F270                         ; TDC bit was 1 last time, check if it changed
10594  F270                         ;------------------------------------------------
10595  F270 87 06 04 06             brset   port3, #$04, L1769      ; branch if current TDC bit is 1                               
10596  F274             
10597  F274                         ;-------------------------------------------------------------------------------
10598  F274                         ; TDC bit was 1 last time and is now 0, update flag and reset counter (lower three bits)
10599  F274                         ;
10600  F274                         ; -> since we are executing this code on every falling edge of CAS pulses,
10601  F274                         ; we necessarily are on the cylinder #1 TDC
10602  F274                         ;-------------------------------------------------------------------------------
10603  F274 03 B3 80                orm     tdcCasFlags, #$80       ; 
10604  F277 02 B3 F8                andm    tdcCasFlags, #$f8       ; Reset lower 3 bits of tdcCasFlags
10605  F27A             
10606  F27A                         ;------------------------
10607  F27A                         ; Update stored TDC bit
10608  F27A                         ;------------------------
10609  F27A 02 B3 F7    L1769       andm    tdcCasFlags, #$f7       ; Reset old TDC bit to 0
10610  F27D 8F 06 04 03             brclr   port3, #$04, L1770      ; branch if current TDC bit is not set                               
10611  F281 03 B3 08                orm     tdcCasFlags, #$08       ; Current TDC bit set, update the flag with current value
10612  F284             
10613  F284                         ;---------------------------------------------------------
10614  F284                         ; Decrement tdcCasFlags lower 3 bits if not already at 0
10615  F284                         ;---------------------------------------------------------
10616  F284 8F B3 07 03 L1770       brclr   tdcCasFlags, #$07, L1771  ; Branch if lower 3 bits have reached 0                                
10617  F288 7A 00 B3                dec     tdcCasFlags               ; Decrement lower 3 bits
10618  F28B             
10619  F28B                         ;--------------------------------------------------------------------------------------------------
10620  F28B                         ; Increment casCylIndex (loop from 0 to 3) and reset it to 0 if TDC detected on #1 cyl (tdcCasFlags.7 set)
10621  F28B                         ;--------------------------------------------------------------------------------------------------
10622  F28B 96 B4       L1771       ldaa    casCylIndex               ;                              
10623  F28D 4C                      inca                              ;                             
10624  F28E 81 04                   cmpa    #$04                      ;                             
10625  F290 24 04                   bcc     L1772                     ; Branch if new value >= 4                             
10626  F292 8F B3 80 01             brclr   tdcCasFlags, #$80, L1773  ; New value < 4, branch if no TDC detected                              
10627  F296 4F          L1772       clra                              ; TDC detected, restart counter at 0                            
10628  F297 97 B4       L1773       staa    casCylIndex               ;                              
10629  F299             
10630  F299             
10631  F299                         ;------------------------------------------------
10632  F299                         ; Update tdcCheck
10633  F299                         ; Decrement on every cas falling edge and 
10634  F299                         ; re-init to 8 on cylinder #1 TDC, tdcCheck
10635  F299                         ; should never reach 0 if TDC sensor is working
10636  F299                         ;------------------------------------------------
10637  F299 96 B6                   ldaa    tdcCheck                  ;                              
10638  F29B 27 01                   beq     L1774                     ; Branch if tdcCheck already 0                            
10639  F29D 4A                      deca                              ; a = tdcCheck                          
10640  F29E 8F B3 80 02 L1774       brclr   tdcCasFlags, #$80, L1775  ; branch to store if not cylinder #1 TDC                                  
10641  F2A2 86 08                   ldaa    #$08                      ; We are at cylinder #1 TDC, restart tdcCheck with 8                          
10642  F2A4 97 B6       L1775       staa    tdcCheck                  ; Store new value                              
10643  F2A6             
10644  F2A6                         ;---------------------
10645  F2A6                         ; Update oldAirCnt0
10646  F2A6                         ;---------------------
10647  F2A6 DC 8D                   ldd     airCnt0                                                 
10648  F2A8 DD 92                   std     oldAirCnt0                                                 
10649  F2AA             
10650  F2AA                         ;---------------------------------------------------------------
10651  F2AA                         ; Compute d = t1_t2_diff/8, 
10652  F2AA                         ; the time between the last time we received a airflow
10653  F2AA                         ; sensor pulse and the time when the current cas edge was 
10654  F2AA                         ; detected (t1_lastCas stored at the beginning of the interrupt) 
10655  F2AA                         ;
10656  F2AA                         ; If airCntNew0 is null (we did not count any air since the 
10657  F2AA                         ; last time we were here) then use d = Tcas??? 
10658  F2AA                         ;---------------------------------------------------------------
10659  F2AA DC 90                   ldd     airCntNew0              ;                                 
10660  F2AC 26 05                   bne     L1776                   ; Branch if airCntNew0 != 0                            
10661  F2AE FC 01 45                ldd     Tcas                    ; airCntNew0=0, use d = Tcas??                           
10662  F2B1 20 0A                   bra     L1777                   ;          
10663  F2B3 DC 96       L1776       ldd     t1_lastCas              ; Get cas edge time value
10664  F2B5 93 98                   subd    t2_lastMas              ; Subtract last time mas interrupt was called, d = t1_lastCas - t2_lastMas = t1_t2_diff                                                        
10665  F2B7 CE 00 C1                ldx     #T200_mas               ;                                                                    
10666  F2BA BD F8 02                jsr     masFunc1                ; D = ~t1_t2_diff/8                                                       
10667  F2BD             
10668  F2BD                         ;---------------------------------------------------------------
10669  F2BD                         ; Loop to scale D=t1_t2_diff (and X=t2_diff8 at the same time) 
10670  F2BD                         ; to fit in lower nibble only
10671  F2BD                         ;---------------------------------------------------------------
10672  F2BD DE 9A       L1777       ldx     t2_diff8                ; X = t2_diff8                                                         
10673  F2BF 4D          L1778       tsta                            ;                                                                                       
10674  F2C0 27 06                   beq     L1779                   ; Branch if high nibble=0                                                                
10675  F2C2 04                      lsrd                            ; high nibble<>0, divide by 2                                                           
10676  F2C3 1A                      xgdx                            ; X<->D                                                                                 
10677  F2C4 04                      lsrd                            ; divide t2_diff8 by 2                                                                   
10678  F2C5 1A                      xgdx                            ; X<->D                                                                                 
10679  F2C6 20 F7                   bra     L1778                   ; At this point, X=t2_diff8/2, D=t1_t2_diff/2, loop back     
10680  F2C8                                                                 
10681  F2C8                         ;---------------------------------------------------------------------------
10682  F2C8                         ; At this point, D=scaledt1_t2_diff fits in lower nibble and X=scaledt2_diff8
10683  F2C8                         ;----------------------------------------------------------------------------
10684  F2C8 86 9C       L1779       ldaa    #$9c                    ; A=$9C, B=scaledt1_t2_diff                                         
10685  F2CA 3D                      mul                             ; D = scaledt1_t2_diff * $9C                                        
10686  F2CB 1A                      xgdx                            ; X = scaledt1_t2_diff * $9C, D=scaledt2_diff8
10687  F2CC             
10688  F2CC                         ;----------------------------------------------------------------
10689  F2CC                         ; Loop to scale X=scaledt1_t2_diff*$9C to fit in lower nibble
10690  F2CC                         ; scales D = scaledt2_diff8 by the same amount
10691  F2CC                         ;----------------------------------------------------------------
10692  F2CC 4D          L1780       tsta                            ;                                
10693  F2CD 27 06                   beq     L1781                   ;                                 
10694  F2CF 04                      lsrd                            ;                                
10695  F2D0 1A                      xgdx                            ;                                
10696  F2D1 04                      lsrd                            ;                                
10697  F2D2 1A                      xgdx                            ;                                
10698  F2D3 20 F7                   bra     L1780                   ;                                 
10699  F2D5             
10700  F2D5                         ;---------------------------------------------------------------
10701  F2D5                         ; At this point, D=scaledt2_diff8 and X=scaledt1_t2_diff * $9C
10702  F2D5                         ; Compute airQuantumRemainder = scaledt1_t2_diff/scaledt2_diff8 * $9C
10703  F2D5                         ;---------------------------------------------------------------
10704  F2D5 D7 5E       L1781       stab    temp8                   ; temp8 = scaledt2_diff8                                                       
10705  F2D7 1A                      xgdx                            ; D=scaledt1_t2_diff * $9C, X=scaledt2_diff8                                   
10706  F2D8 15 5E                   div     temp8                   ; D=D/temp8 = scaledt1_t2_diff * $9C / scaledt2_diff8?                                                                   
10707  F2DA 25 0A                   bcs     L1782                   ; Branch if overflow                                                                               
10708  F2DC 74 00 5E                lsr     temp8                   ; Check for ???                                                                              
10709  F2DF 91 5E                   cmpa    temp8                   ;                                                                               
10710  F2E1 25 05                   bcs     L1783                   ; 
10711  F2E3 5C                      incb                            ; 
10712  F2E4 26 02                   bne     L1783                   ;                                                                              
10713  F2E6 C6 FF       L1782       ldab    #$ff                    ; overflow, use max  
10714  F2E8                                        
10715  F2E8                         ;------------------------------------------------------------------------
10716  F2E8                         ; At this point, b = airQuantumRemainder = scaledt1_t2_diff/scaledt2_diff8 * $9C             
10717  F2E8                         ; Check if we should use it
10718  F2E8                         ;------------------------------------------------------------------------
10719  F2E8 D1 9C       L1783       cmpb    airQuantum              ;                              
10720  F2EA 25 07                   bcs     L1784                   ; Branch if airQuantumRemainder  < airQuantum, which means we can use it
10721  F2EC D6 9C                   ldab    airQuantum              ; airQuantumRemainder >= airQuantum (in theory, I suppose at most it should only be equal to it...) use b=airQuantum                             
10722  F2EE 7F 00 9C                clr     airQuantum              ; airQuantum=0 (since we "transfered" all of it to b)                             
10723  F2F1 20 05                   bra     L1785                   ;                              
10724  F2F3             
10725  F2F3                         ;------------------------------------------------------------------------
10726  F2F3                         ; At this point airQuantumRemainder < airQuantum
10727  F2F3                         ; and b = airQuantumRemainder = scaledt1_t2_diff/scaledt2_diff8 * $9C
10728  F2F3                         ; 
10729  F2F3                         ; We are going to use airQuantumRemainder in this calculation cycle. 
10730  F2F3                         ; Subtract it from airQuantum. What is left in airQuantum 
10731  F2F3                         ; is going to be used as the startup value for the next airflow
10732  F2F3                         ; calculation cycle. Basically we don't want to loose any air in
10733  F2F3                         ; the calculations... 
10734  F2F3                         ;------------------------------------------------------------------------
10735  F2F3 96 9C       L1784       ldaa    airQuantum              ; a = airQuantum
10736  F2F5 10                      sba                             ; a = airQuantum -  airQuantumRemainder
10737  F2F6 97 9C                   staa    airQuantum              ; airQuantum = old airQuantum - airQuantumRemainder, basically we subtract what we are going to use
10738  F2F8             
10739  F2F8                         ;------------------------------------------------------- 
10740  F2F8                         ; Finish calc and scale airQuantumRemainder if required
10741  F2F8                         ;------------------------------------------------------- 
10742  F2F8 4F          L1785       clra                              ; d = airQuantumRemainder (high part=0)                            
10743  F2F9 8F 9E 80 01             brclr   masCasFlags, #$80, L1786  ; Branch if no scaling                                       
10744  F2FD 05                      asld                              ; scale d = airQuantumRemainder * 2                                            
10745  F2FE             
10746  F2FE                         ;-----------------------------------------------------------------------
10747  F2FE                         ; At this point, d = airQuantumRemainder, 
10748  F2FE                         ; add it for a final time to airCntNew0, also check for minimum value
10749  F2FE                         ;-----------------------------------------------------------------------
10750  F2FE D3 90       L1786       addd    airCntNew0              ; d = airQuantumRemainder + airCntNew0                                                           
10751  F300 1F 01 87                cmpd    airCntMin0              ;                                                           
10752  F303 24 03                   bcc     L1787                   ; Branch if airCntNew0 + airQuantumRemainder > airCntMin0                                                          
10753  F305 FC 01 87                ldd     airCntMin0              ; Use airCntMin0                                                          
10754  F308 DD 90       L1787       std     airCntNew0              ; airCntNew0 =   max(airQuantumRemainder+airCntNew0, airCntMin0)
10755  F30A             
10756  F30A                         ;---------------------------------------------------------------------------------
10757  F30A                         ; Adjust airCntNew0 when mafRaw below 50Hz:
10758  F30A                         ; If mafRaw below 50Hz and (airCnt0-airCntNew0) >= $004e then airCntNew0 = (airCnt0-$0010)
10759  F30A                         ; Limits the downward rate of change of airCntNew0 under rapidly decreasing air flow conditions???
10760  F30A                         ;---------------------------------------------------------------------------------
10761  F30A 96 E4                   ldaa    mafRaw                  ; a = mafRaw                                                
10762  F30C~            #ifdef masLog2X                              
10763  F30C~                        cmpa    #$04                     
10764  F30C             #else                                        
10765  F30C 81 08                   cmpa    #$08                                                  
10766  F30E             #endif                                       
10767  F30E 24 12                   bcc     L1788                   ; Branch if mafRaw > 50Hz (no adjustment)
10768  F310 DC 8D                   ldd     airCnt0                 ; mafRaw<50Hz, d = airCnt0
10769  F312 93 90                   subd    airCntNew0              ; d = airCnt0-airCntNew0 
10770  F314 25 0C                   bcs     L1788                   ; Branch if airCnt0 < airCntNew0 (no adjustment)
10771  F316 1C 00 4E                cmpd    #$004e                  ; airCnt0 >= airCntNew0, check difference
10772  F319 25 07                   bcs     L1788                   ; Branch if (airCnt0-airCntNew0)<$004e (no adjustment)
10773  F31B DC 8D                   ldd     airCnt0                 ; (airCnt0-airCntNew0)>=$004e, subtract $10
10774  F31D 83 00 10                subd    #$0010                  ;                               
10775  F320 DD 90                   std     airCntNew0              ; airCntNew0 = (airCnt0-$0010)                              
10776  F322             
10777  F322                         ;--------------------------------------------------------
10778  F322                         ; Section below is to update airCnt0:airCnt1:airCnt2 
10779  F322                         ; (filtered air count) from airCntNew0:airCntNew1 (latest 
10780  F322                         ; air count received from aiflow sensor)
10781  F322                         ;--------------------------------------------------------
10782  F322                         ;------------------------------------------------------------
10783  F322                         ; Multiply airCnt0:airCnt1:airCnt2 by 8 * airFiltFact/256
10784  F322                         ;------------------------------------------------------------
10785  F322 96 9F       L1788       ldaa    airFiltFact             ;                                    
10786  F324 97 5E                   staa    temp8                   ; temp8=airFiltFact                               
10787  F326 DC 8E                   ldd     airCnt1                 ; d = airCnt1:airCnt2                                 
10788  F328 05                      asld                            ;                              
10789  F329 79 00 8D                rol     airCnt0                 ;                                
10790  F32C 05                      asld                            ;                             
10791  F32D 79 00 8D                rol     airCnt0                 ;                                
10792  F330 05                      asld                            ; d = 8*[airCnt1:airCnt2]
10793  F331 79 00 8D                rol     airCnt0                 ; airCnt0 = 8*airCnt0                                 
10794  F334 D6 5E                   ldab    temp8                   ; b = airFiltFact                               
10795  F336 3D                      mul                             ; d = airFiltFact * (8*[airCnt1:airCnt2])/256
10796  F337 DD 8E                   std     airCnt1                 ; airCnt1:airCnt2 =  airFiltFact * (8*[airCnt1:airCnt2])/256
10797  F339 96 8D                   ldaa    airCnt0                 ;                                 
10798  F33B D6 5E                   ldab    temp8                   ;                               
10799  F33D 3D                      mul                             ; d = airCnt0 * airFiltFact                             
10800  F33E DB 8E                   addb    airCnt1                 ; Add lower part                                 
10801  F340 89 00                   adca    #$00                    ; Propagate carry
10802  F342 DD 8D                   std     airCnt0                 ; Store final result, 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256
10803  F344             
10804  F344                         ;------------------------------------------------------------------
10805  F344                         ; Multiply airCntNew0:airCntNew1 by 4 with overflow check
10806  F344                         ;------------------------------------------------------------------
10807  F344 DC 90                   ldd     airCntNew0              ;                              
10808  F346 05                      asld                            ;                             
10809  F347 25 03                   bcs     L1789                   ;                              
10810  F349 05                      asld                            ;                             
10811  F34A 24 02                   bcc     L1790                   ;                              
10812  F34C 86 FF       L1789       ldaa    #$ff                    ; Use max
10813  F34E DD 90       L1790       std     airCntNew0              ;                              
10814  F350             
10815  F350                         ;-----------------------------------------------------------------------------------------------------------
10816  F350                         ; Add 2*(256-airFiltFact)*4*[airCntNew0:airCntNew1] to 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256
10817  F350                         ; with overflow check
10818  F350                         ;-----------------------------------------------------------------------------------------------------------
10819  F350 96 5E                   ldaa    temp8                   ; Still contains airFiltFact ($d1 or $e4 from code)?                               
10820  F352 40                      nega                            ;                               
10821  F353 48                      asla                            ; a = 2*(256-airFiltFact) -> $d1->$5e   $e4->$38    209->94   228->56 
10822  F354 3D                      mul                             ; d = 2*(256-airFiltFact) * airCntNew1
10823  F355 D3 8E                   addd    airCnt1                 ;                                        
10824  F357 DD 8E                   std     airCnt1                 ;                                 
10825  F359 96 8D                   ldaa    airCnt0                 ;                                 
10826  F35B 89 00                   adca    #$00                    ;                             
10827  F35D 24 02                   bcc     L1791                   ; Branch if no overflow                             
10828  F35F 86 FF                   ldaa    #$ff                    ; Use max if overflow                            
10829  F361 97 8D       L1791       staa    airCnt0                 ;                    
10830  F363             
10831  F363 96 5E                   ldaa    temp8                  ; Still contains airFiltFact                              
10832  F365 40                      nega                            ;                             
10833  F366 48                      asla                            ;                             
10834  F367 D6 90                   ldab    airCntNew0              ;                              
10835  F369 3D                      mul                             ;                             
10836  F36A D3 8D                   addd    airCnt0                 ;                                 
10837  F36C 24 03                   bcc     L1792                   ; Branch if no overflow                                 
10838  F36E CC FF FF                ldd     #$ffff                  ; Use max if overflow                                    
10839  F371             
10840  F371                         ;-------------------------------------------------------------------------------------------------------------------
10841  F371                         ; At this point, D:airCnt2 contains result from above: 
10842  F371                         ; D:airCnt2 = 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256 + 2*4*(256-airFiltFact)*[airCntNew0:airCntNew1] 
10843  F371                         ; Divide it by 8 and store it. 
10844  F371                         ; If no  pulse accumulator interrupts were receive, use airCntDef
10845  F371                         ;-------------------------------------------------------------------------------------------------------------------
10846  F371 04          L1792       lsrd                            ;                              
10847  F372 76 00 8F                ror     airCnt2                 ;                                 
10848  F375 04                      lsrd                            ;                             
10849  F376 76 00 8F                ror     airCnt2                 ;                                 
10850  F379 04                      lsrd                            ;                             
10851  F37A 76 00 8F                ror     airCnt2                 ; Divide D:airCnt2 by 8
10852  F37D 8F A2 02 06             brclr   state3, #$02, L1793     ; Branch if pulse accumulator interrupts received
10853  F381 D6 FF                   ldab    airCntDef               ; No pulse accumulator interrupts                              
10854  F383 4F                      clra                            ;                             
10855  F384 05                      asld                            ;                             
10856  F385 05                      asld                            ;                             
10857  F386 05                      asld                            ;                             
10858  F387 DD 8D       L1793       std     airCnt0                 ; Store airCnt0:airCnt1, airCnt2 was stored earlier                                 
10859  F389             
10860  F389                         ;-------------------------------------------------------------------------------------------------------------------------------------------
10861  F389                         ; At this point: 
10862  F389                         ;
10863  F389                         ; [airCnt0:airCnt1:airCnt2]    = 1/8 * ( 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256 + 2*4*(256-airFiltFact)*[airCntNew0:airCntNew1] )
10864  F389                         ;                              = 1/8 * ( 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256 + 256/256*2*4*(256-airFiltFact)*[airCntNew0:airCntNew1] )
10865  F389                         ;                              = 1/8 * ( 8*[airCnt0:airCnt1:airCnt2] * airFiltFact/256 + 8*(256-airFiltFact)/256 * 256*[airCntNew0:airCntNew1] )
10866  F389                         ;                              = [airCnt0:airCnt1:airCnt2] * airFiltFact/256 + (256-airFiltFact)/256 * 256*[airCntNew0:airCntNew1]
10867  F389                         ;                              = [airCnt0:airCnt1:airCnt2] * alpha + (1-alpha) * 256*[airCntNew0:airCntNew1]
10868  F389                         ;
10869  F389                         ;                              = alpha * oldAirCnt24bits + (1-alpha) * scaledNewAirCnt16bits
10870  F389                         ;
10871  F389                         ;                                        where alpha = airFiltFact/256, 0<=alpha<=1, 
10872  F389                         ;
10873  F389                         ; This is exponential averaging of [airCnt0:airCnt1:airCnt2] with [airCntNew0:airCntNew1]*256 as input 
10874  F389                         ;
10875  F389                         ;-------------------------------------------------------------------------------------------------------------------------------------------
10876  F389             
10877  F389                         ;-----------------------------------------------------------------
10878  F389                         ; If engine is notRotating or startingToCrank then ignore 
10879  F389                         ; airCnt0 we just calculated and use airCntMax*8 instead 
10880  F389                         ;-----------------------------------------------------------------
10881  F389 D6 A0                   ldab    airCntMax               ; d = airCntMax                                   
10882  F38B 4F                      clra                            ;                             
10883  F38C 05                      asld                            ;                             
10884  F38D 05                      asld                            ;                             
10885  F38E 05                      asld                            ; d = 8*airCntMax                             
10886  F38F 87 A2 11 04             brset   state3, #$11, L1794     ; Branch if notRotating or startingToCrank -> Always use airCntMax*8 in that case?                              
10887  F393             
10888  F393             
10889  F393                         ;-------------------------------------------------
10890  F393                         ; Engine is running, cap airCnt0 with airCntMax*8
10891  F393                         ;-------------------------------------------------
10892  F393 1D 8D                   cmpd1   airCnt0                 ;                                 
10893  F395 24 02                   bcc     L1795                   ; Branch if airCntMax*8 >= airCnt0                               
10894  F397 DD 8D       L1794       std     airCnt0                 ; Store airCntMax in airCnt0 
10895  F399             
10896  F399                         ;----------------------------------------------------------------------
10897  F399                         ; Update oldAirCnt0 if no pulse accumulator interrupts were received????
10898  F399                         ;----------------------------------------------------------------------
10899  F399 8F A2 02 04 L1795       brclr   state3, #$02, L1796     ; Branch if pulse accumulator interrupts are being received                               
10900  F39D DC 8D                   ldd     airCnt0                 ; No pulse accumulator interrupts received, store airCnt0 in oldAirCnt0???                                 
10901  F39F DD 92                   std     oldAirCnt0              ;                                    
10902  F3A1             
10903  F3A1                         ;-----------------------------------------
10904  F3A1                         ; Re-init airCntNew0, start a new cycle
10905  F3A1                         ;-----------------------------------------
10906  F3A1 4F          L1796       clra                                                         
10907  F3A2 5F                      clrb                                                         
10908  F3A3 DD 90                   std     airCntNew0     
10909  F3A5                          
10910  F3A5                         ;---------------------------------------------------------------------------------                  
10911  F3A5                         ; Execute the coil interrupt routine if an output capture interrupt is pending                       
10912  F3A5                         ;                                                                                                    
10913  F3A5                         ; Might be called from here because we are about to spend 
10914  F3A5                         ; a lot of time to calculate airflow and injectors???? I assume here
10915  F3A5                         ; that by doing so, the pending interrupt will be cleared?
10916  F3A5                         ;---------------------------------------------------------------------------------                                                              
10917  F3A5 8F 1A 40 03             brclr   t3_csr1, #$40, L1797   ; Branch if no interrupt pending                                   
10918  F3A9 BD FA 78                jsr     coilFunc                   ;                              
10919  F3AC             
10920  F3AC                         ;-------------------------------------------------------------------------------------
10921  F3AC                         ; Execute the pulse accumulator routine if an interrupt is pending
10922  F3AC                         ;
10923  F3AC                         ; At this point, airQuantum contains whatever air remains to be counted
10924  F3AC                         ; from the time the current CAS interrupt occured up to the time the next
10925  F3AC                         ; mas interrupt will happen (the next airflow sensor pulse). If the mas interrupt
10926  F3AC                         ; is pending then this air should already have been added. Do it now. I assume
10927  F3AC                         ; that by doing so, the pending interrupt will be cleared?
10928  F3AC                         ;
10929  F3AC                         ; If no interrupt is pending then the remaining air will be added when the
10930  F3AC                         ; next mas interrupt will occur, which is the normal way.
10931  F3AC                         ;
10932  F3AC                         ; In both cases airQuantum is re-initialized to its maximum value when masProc 
10933  F3AC                         ; is executed
10934  F3AC                         ;-------------------------------------------------------------------------------------
10935  F3AC 8F 18 80 03 L1797       brclr   t2_csr, #$80, L1798     ; Branch if no interrupt pending                                 
10936  F3B0 BD F7 A1                jsr     masProc                 ;                              
10937  F3B3             
10938  F3B3                         ;------------------------------------------------------------------------------------
10939  F3B3                         ; Compute a kind of airCnt0 derivative (acceleration and decceleration)
10940  F3B3                         ; Update airDiffPos or airDiffNeg with airFlowDifference = abs(airCnt0-oldAirCnt0)
10941  F3B3                         ; airDiffPos is updated when airCnt0-oldAirCnt0 >= 0
10942  F3B3                         ; airDiffNeg is updated when airCnt0-oldAirCnt0 < 0
10943  F3B3                         ;------------------------------------------------------------------------------------
10944  F3B3 CE 00 94    L1798       ldx     #airDiffPos             ;                               
10945  F3B6 DC 8D                   ldd     airCnt0                 ; d = airCnt0                                
10946  F3B8 93 92                   subd    oldAirCnt0              ; d = airCnt0-oldAirCnt0                             
10947  F3BA 24 06                   bcc     L1799                   ; Branch if result positive
10948  F3BC 43                      coma                            ; Result negative, change sign                           
10949  F3BD 53                      comb                            ;                            
10950  F3BE C3 00 01                addd    #$0001                  ; d = oldAirCnt0-airCnt0
10951  F3C1 08                      inx                             ; x =  x + 1                           
10952  F3C2 4D          L1799       tsta                            ; Check for overflow in a (we want result in b only)                           
10953  F3C3 27 02                   beq     L1800                   ; Branch if a=0 (b contains difference)                             
10954  F3C5 C6 FF                   ldab    #$ff                    ; a not null->overflow, use b = maximum
10955  F3C7 E1 00       L1800       cmpb    $00,x                   ; 
10956  F3C9 23 02                   bls     L1801                   ; Branch if abs(airCnt0-oldAirCnt0) <= airDiffPos or airDiffNeg
10957  F3CB E7 00                   stab    $00,x                   ; Store new value of airDiffPos or airDiffNeg
10958  F3CD                                                     
10959  F3CD                         ;---------------------------------------------------------------------------
10960  F3CD                         ; Decide what value we are going to use for injPw (0, injPwStart or normal)
10961  F3CD                         ;---------------------------------------------------------------------------
10962  F3CD 8F A2 01 05 L1801       brclr   state3, #$01, L1802     ; Branch if startingToCrank clear                                
10963  F3D1 FC 01 00                ldd     injPwStart              ; Engine startingToCrank, use injPwStart                              
10964  F3D4 20 06                   bra     L1803                   ; Do not compute injPw from airflow                              
10965  F3D6 8F A2 3C 06 L1802       brclr   state3, #$3c, L1804     ; startingToCrank clear, branch to compute normal injPw from airflow if all clear: "rotatingStopInj but not runningFast" and "notRotating" and "rotatingStopInj" and "rev limiter active"
10966  F3DA 4F                      clra                            ; Use injPw=0 if rev limiter is active or if engine is notRotating, rotatingStopInj or "rotatingStopInj and not runningFast" 
10967  F3DB 5F                      clrb                            ;                             
10968  F3DC DD A7       L1803       std     injPw                   ;                              
10969  F3DE 20 2E                   bra     L1807                   ;                              
10970  F3E0             
10971  F3E0             
10972  F3E0                         ;----------------------------------------------------------------
10973  F3E0                         ; Compute injector pulsewidth for normal engine conditions
10974  F3E0                         ;
10975  F3E0                         ; injPw =  [airCnt0:airCnt1] * injFactor/256, 16 bit multiply
10976  F3E0                         ;----------------------------------------------------------------
10977  F3E0 96 8E       L1804       ldaa    airCnt1                 ; a = airCnt1                                 
10978  F3E2 D6 A4                   ldab    injFactor+1             ; b = injFactor1                                    
10979  F3E4 3D                      mul                             ; d = airCnt1*injFactor1                             
10980  F3E5 16                      tab                             ; b = airCnt1*injFactor1/256                             
10981  F3E6 4F                      clra                            ; d = airCnt1*injFactor1/256                            
10982  F3E7 DD A7                   std     injPw                   ; injPw = airCnt1*injFactor1/256                              
10983  F3E9 96 8E                   ldaa    airCnt1                 ;                                 
10984  F3EB D6 A3                   ldab    injFactor               ;                                  
10985  F3ED 3D                      mul                             ;                             
10986  F3EE D3 A7                   addd    injPw                   ;                              
10987  F3F0 25 18                   bcs     L1805                   ;                              
10988  F3F2 DD A7                   std     injPw                   ;                              
10989  F3F4 96 8D                   ldaa    airCnt0                 ;                                 
10990  F3F6 D6 A4                   ldab    injFactor+1             ;                                    
10991  F3F8 3D                      mul                             ;                             
10992  F3F9 D3 A7                   addd    injPw                   ;                              
10993  F3FB 25 0D                   bcs     L1805                   ;                              
10994  F3FD DD A7                   std     injPw                   ;                              
10995  F3FF 96 8D                   ldaa    airCnt0                 ;                                 
10996  F401 D6 A3                   ldab    injFactor               ;                                  
10997  F403 3D                      mul                             ;                             
10998  F404 DB A7                   addb    injPw                   ;                              
10999  F406 89 00                   adca    #$00                    ; Propagate carry                            
11000  F408 27 02                   beq     L1806                   ; Branch if no overflow                             
11001  F40A C6 F0       L1805       ldab    #$f0                    ; Overflow, use max of ~$f000 (61ms) in case of overflow                             
11002  F40C D7 A7       L1806       stab    injPw                   ;                              
11003  F40E             
11004  F40E                         ;----------------------
11005  F40E                         ; Compute accEnrDiffT
11006  F40E                         ;----------------------
11007  F40E CE FF 1C    L1807       ldx     #L2040                   ; x points to L2040                              
11008  F411 D6 92                   ldab    oldAirCnt0               ; b = oldAirCnt0/256 (high part only...)                                  
11009  F413 C1 05                   cmpb    #$05                     ;                            
11010  F415 25 02                   bcs     L1808                    ; Branch if below max                            
11011  F417 C6 05                   ldab    #$05                     ; Use max                           
11012  F419 3A          L1808       abx                              ; x = L2040 + min(oldAirCnt0, 5)                            
11013  F41A E6 00                   ldab    $00,x                    ; b = L2040(oldAirCnt0/256)                            
11014  F41C F7 01 0C                stab    accEnrDiffT              ; accEnrDiffT = L2040(oldAirCnt0/256)                             
11015  F41F             
11016  F41F                         ;------------------------------------------------------------------------
11017  F41F                         ; Update accEnr
11018  F41F                         ;
11019  F41F                         ; At first accEnr is decreased by a fixed factor (exponentially)
11020  F41F                         ; on each iteration. When it reaches a certain level, it this 
11021  F41F                         ; then held constant for the duration of a timer and then 
11022  F41F                         ; decremented by 1 to 0. First do the exponential part...
11023  F41F                         ;------------------------------------------------------------------------
11024  F41F D6 A1                   ldab    accEnr                  ; b = accEnr                             
11025  F421 27 17                   beq     L1811                   ; Branch if accEnr = 0                            
11026  F423 B6 01 03                ldaa    accEnrDecay             ; a = accEnrDecay                            
11027  F426 3D                      mul                             ; d = accEnrDecay * accEnr                           
11028  F427 16                      tab                             ; b = accEnr * accEnrDecay/256                            
11029  F428 96 A1                   ldaa    accEnr                  ; a = accEnr                             
11030  F42A 10                      sba                             ; a = accEnrNew = accEnr - accEnr * accEnrDecay/256 = accEnr * (1-accEnrDecay/256)                             
11031  F42B 81 02                   cmpa    #$02                    ;                            
11032  F42D 24 0B                   bcc     L1811                   ; Branch if accEnrNew >= 2                            
11033  F42F             
11034  F42F                         ;-------------------------------------------------------------------
11035  F42F                         ; accEnr - accEnr * accEnrDecay/256 < 2 (which means accEnr much bigger than 2)
11036  F42F                         ; Just decrement accEnr by 1 if  accEnrTmr2=0 else don't change it
11037  F42F                         ;
11038  F42F                         ; Basically hold the accEnr to current value for 4 or 5 iterations 
11039  F42F                         ; and then start decrease it by 1 to 0
11040  F42F                         ;-------------------------------------------------------------------
11041  F42F B6 01 0D                ldaa    accEnrTmr2              ; 
11042  F432 27 03                   beq     L1810                   ;                             
11043  F434 4A                      deca                            ;                            
11044  F435 26 0F                   bne     L1812                   ;                             
11045  F437 D6 A1       L1810       ldab    accEnr                  ;                              
11046  F439 5A                      decb                            ;                            
11047  F43A D7 A1       L1811       stab    accEnr                  ;                              
11048  F43C             
11049  F43C                         ;----------------------------------
11050  F43C                         ; Update accEnrTmr2 from ect
11051  F43C                         ;----------------------------------
11052  F43C 86 04                   ldaa    #$04                    ; a = 4                           
11053  F43E D6 D3                   ldab    ectFiltered             ; b = ectFiltered                                  
11054  F440 C1 80                   cmpb    #$80                    ; 21degC                             
11055  F442 25 02                   bcs     L1812                   ; Branch if temperature(ectFiltered) >= 21degC
11056  F444 86 05                   ldaa    #$05                    ; temperature <21degC                           
11057  F446 B7 01 0D    L1812       staa    accEnrTmr2              ; re-init accEnrTmr2 with 5                            
11058  F449             
11059  F449                         ;--------------------------------------
11060  F449                         ; Decrement accEnrTimer if not yet 0
11061  F449                         ;--------------------------------------
11062  F449 B6 01 04                ldaa    accEnrTimer             ; 
11063  F44C 27 04                   beq     L1813                   ; Branch if accEnrTimer = 0                             
11064  F44E 4A                      deca                            ;                             
11065  F44F B7 01 04                staa    accEnrTimer             ;                              
11066  F452             
11067  F452                         ;---------------------------------------------------
11068  F452                         ; Re-init accEnrTimer to 4 if airCnt0>=accEnrMinAf 
11069  F452                         ;---------------------------------------------------
11070  F452 DC 8D       L1813       ldd     airCnt0                 ;                                 
11071  F454 1F 01 05                cmpd    accEnrMinAf             ;                                     
11072  F457 24 05                   bcc     L1814                   ; Branch if airCnt0>=accEnrMinAf 
11073  F459 86 04                   ldaa    #$04                    ;                              
11074  F45B B7 01 04                staa    accEnrTimer             ; re-init accEnrTimer = 4                              
11075  F45E             
11076  F45E                         ;----------------------------
11077  F45E                         ; Bail if engine not running 
11078  F45E                         ;----------------------------
11079  F45E 8F A2 13 06 L1814       brclr   state3, #$13, L1815     ; Branch if notRotating and startingToCrank and "no pulse accumulator interrupts" clear                               
11080  F462 7F 00 A1                clr     accEnr                  ; One of them set, no accEnr should be applied
11081  F465 7E F4 ED                jmp     L1825                   ; Bail                              
11082  F468             
11083  F468                         ;---------------------------------------------------
11084  F468                         ; Skip section if injPw==0
11085  F468                         ;---------------------------------------------------
11086  F468 DC A7       L1815       ldd     injPw                   ;                              
11087  F46A 26 03                   bne     L1816                   ; Branch if injPw !=0                             
11088  F46C 7E F4 ED                jmp     L1825                   ; Bail                              
11089  F46F             
11090  F46F                         ;---------------------------------------------------
11091  F46F                         ; Section to factor acceleration/deceleration enrichment
11092  F46F                         ; to injPw (when injPw!=0)
11093  F46F                         ;---------------------------------------------------
11094  F46F                         ;---------------------------------------------------
11095  F46F                         ; Compute diff = airCnt0-oldAirCnt0
11096  F46F                         ; Check if positive or negative
11097  F46F                         ;---------------------------------------------------
11098  F46F 7F 01 07    L1816       clr     decEnr                  ; Assume decEnr = 0
11099  F472 DC 8D                   ldd     airCnt0                 ; d = airCnt0                                 
11100  F474 93 92                   subd    oldAirCnt0              ; d = airCnt0-oldAirCnt0                                   
11101  F476 25 1F                   bcs     L1820                   ; Branch if result negative                             
11102  F478             
11103  F478                         ;---------------------------------------------------
11104  F478                         ; diff>=0 (airCnt0 increased or is unchanged)
11105  F478                         ; Check if conditions are met to apply acceleration enrichment
11106  F478                         ;---------------------------------------------------
11107  F478 7D 01 04                tst     accEnrTimer             ; Check if timer expired
11108  F47B 27 18                   beq     L1819                   ; Bail if accEnrTimer expired (airflow has been below absolute threshold for more than 4 iterations)                             
11109  F47D 87 06 80 14             brset   port3, #$80, L1819      ; Bail if idle switch is on                              
11110  F481             
11111  F481                         ;----------------------------------
11112  F481                         ; Check diff against max of $48
11113  F481                         ;----------------------------------
11114  F481 4D                      tsta                            ; test hi part of diff                            
11115  F482 26 04                   bne     L1817                   ; Branch if diff >=256 (hi(diff)!=0) -> use $48                             
11116  F484 C1 48                   cmpb    #$48                    ; diff <256 check low part against $48                           
11117  F486 25 02                   bcs     L1818                   ; Branch if diff <$48                                
11118  F488 C6 48       L1817       ldab    #$48                    ; use $48                             
11119  F48A             
11120  F48A                         ;---------------------------------------------------------------------------
11121  F48A                         ; At this point b contains diff=min(airCnt0-oldAirCnt0,$48)
11122  F48A                         ;
11123  F48A                         ; Update accEnr with diff if diff is big enough (big increase in airflow)
11124  F48A                         ; and higher than old accEnr
11125  F48A                         ;---------------------------------------------------------------------------
11126  F48A F1 01 0C    L1818       cmpb    accEnrDiffT             ;                              
11127  F48D 23 06                   bls     L1819                   ; Branch if diff<=accEnrDiffT                             
11128  F48F D1 A1                   cmpb    accEnr                  ; diff>accEnrDiffT store new value if higher than old one                             
11129  F491 23 02                   bls     L1819                   ;                              
11130  F493 D7 A1                   stab    accEnr                  ; accEnr = min(airCnt0-oldAirCnt0,$48)
11131  F495 20 1B       L1819       bra     L1822                   ;                              
11132  F497             
11133  F497                         ;---------------------------------------------------------
11134  F497                         ;
11135  F497                         ;
11136  F497                         ; airCnt0 decreased check if below absolute threshold
11137  F497                         ;
11138  F497                         ;
11139  F497                         ;---------------------------------------------------------
11140  F497 DC 8D       L1820       ldd     airCnt0                 ; d = airCnt0                               
11141  F499 1F 01 05                cmpd    accEnrMinAf             ;                              
11142  F49C 24 14                   bcc     L1822                   ; Bail if airCnt0 >= accEnrMinAf                            
11143  F49E             
11144  F49E                         ;---------------------------------------------------------
11145  F49E                         ; airCnt0 decreased and is below absolute threshold
11146  F49E                         ; compute diff = min(airCnt0-oldAirCnt0,$ff)
11147  F49E                         ;---------------------------------------------------------
11148  F49E DC 92                   ldd     oldAirCnt0              ;                                    
11149  F4A0 93 8D                   subd    airCnt0                 ; d = oldAirCnt0-airCnt0                                
11150  F4A2 4D                      tsta                            ; test hi part (diff>=256?)                            
11151  F4A3 27 02                   beq     L1821                   ; Branch if below max
11152  F4A5 C6 FF                   ldab    #$ff                    ; Use max of $ff                            
11153  F4A7             
11154  F4A7                         ;---------------------------------------------------------------------------
11155  F4A7                         ; Clear accEnr if diff is big enough (big decrease in airflow)
11156  F4A7                         ; At this point b contsains diff=min(airCnt0-oldAirCnt0,$ff)
11157  F4A7                         ;---------------------------------------------------------------------------
11158  F4A7 F1 01 0C    L1821       cmpb    accEnrDiffT             ;                              
11159  F4AA 23 06                   bls     L1822                   ;                              
11160  F4AC F7 01 07                stab    decEnr                  ; decEnr = min(airCnt0-oldAirCnt0,$ff)
11161  F4AF 7F 00 A1                clr     accEnr                  ; accEnr = 0                              
11162  F4B2             
11163  F4B2                         ;---------------------------------------------------
11164  F4B2                         ; Section to add acceleration enrichment to injPw or
11165  F4B2                         ; reduce it in case of deceleration
11166  F4B2                         ;
11167  F4B2                         ; Check if min(airCnt0-oldAirCnt0,$ff) >0
11168  F4B2                         ;---------------------------------------------------
11169  F4B2 F6 01 07    L1822       ldab    decEnr                  ; 
11170  F4B5 26 18                   bne     L1823                   ; Branch if decEnr > 0 (reduce injPw)                            
11171  F4B7             
11172  F4B7                         ;---------------------------------------------------------------
11173  F4B7                         ; decEnr = 0, increase or do not change injPw
11174  F4B7                         ;
11175  F4B7                         ; Apply enrichment: 
11176  F4B7                         ;     injPw = injPw + accEnr*accEnrFact/256
11177  F4B7                         ;           = injPw + 8 * min(airCnt0-oldAirCnt0,$48) * injMasComp/256 * t_accEnr1(rpm)/128 * [t_accEnr2a(ect) or t_accEnr2b(ect)]/128 * baroFact/128
11178  F4B7                         ;---------------------------------------------------------------
11179  F4B7 96 A1                   ldaa    accEnr                  ; a = accEnr                               
11180  F4B9 F6 01 08                ldab    accEnrFact              ; b = accEnrFact                            
11181  F4BC 3D                      mul                             ; d = accEnr * accEnrFact                             
11182  F4BD 1A                      xgdx                            ; x = accEnr * accEnrFact                           
11183  F4BE 96 A1                   ldaa    accEnr                  ;                               
11184  F4C0 F6 01 09                ldab    accEnrFact+1            ;                              
11185  F4C3 3D                      mul                             ; d = accEnr * L0109                            
11186  F4C4 16                      tab                             ; b = accEnr * L0109/256                            
11187  F4C5 3A                      abx                             ; x = accEnr * accEnrFact +  accEnr * L0109/256 = accEnr*(accEnrFact + L0109/256)                            
11188  F4C6 1A                      xgdx                            ; d = accEnr*(accEnrFact + L0109/256)
11189  F4C7 D3 A7                   addd    injPw                   ; d = injPw + accEnr*accEnrFact/256
11190  F4C9 24 20                   bcc     L1824                   ; Bail if no overflow                             
11191  F4CB 86 F0                   ldaa    #$f0                    ; Overflow, use max of $f000                            
11192  F4CD 20 1C                   bra     L1824                   ; Bail
11193  F4CF                                                       
11194  F4CF                         ;---------------------------------------------------
11195  F4CF                         ; decEnr > 0. decrease injPw
11196  F4CF                         ;
11197  F4CF                         ; Apply reduction 
11198  F4CF                         ;      injPw = injPw - decEnr*decEnrFact/256
11199  F4CF                         ;            = injPw +  8 * min(airCnt0-oldAirCnt0,$ff) * injMasComp/256 * t_decEnr1(rpm)/128 * t_decEnr2(ect)/128 * baroFact/128
11200  F4CF                         ;---------------------------------------------------
11201  F4CF B6 01 07    L1823       ldaa    decEnr                  ; a = decEnr                             
11202  F4D2 F6 01 0A                ldab    decEnrFact              ; b = decEnrFact                             
11203  F4D5 3D                      mul                             ; d = decEnr * decEnrFact                               
11204  F4D6 1A                      xgdx                            ; x = decEnr * decEnrFact                            
11205  F4D7 B6 01 07                ldaa    decEnr                  ;                              
11206  F4DA F6 01 0B                ldab    decEnrFact+1            ;                              
11207  F4DD 3D                      mul                             ; d = decEnr * L010b                            
11208  F4DE 16                      tab                             ; b = decEnr * L010b/256                            
11209  F4DF 3A                      abx                             ; x = decEnr * decEnrFact + decEnr * L010b/256                            
11210  F4E0 DF 5E                   stx     temp8                   ; temp8:dTemp2 = decEnr * decEnrFact + decEnr * L010b/256  = decEnr*(decEnrFact+L010b/256)                             
11211  F4E2 DC A7                   ldd     injPw                   ; d = injPw                             
11212  F4E4 93 5E                   subd    temp8                   ; d = injPw - decEnr*decEnrFact/256                               
11213  F4E6 22 03                   bhi     L1824                   ; Bail if positive                             
11214  F4E8 4F                      clra                            ;                             
11215  F4E9 C6 01                   ldab    #$01                    ; Use min of $0001                            
11216  F4EB DD A7       L1824       std     injPw                   ; Update injPw                             
11217  F4ED             
11218  F4ED                         ;---------------------------------------------------
11219  F4ED                         ; Skip section if injPw==0
11220  F4ED                         ;---------------------------------------------------
11221  F4ED DC A7       L1825       ldd     injPw                   ;                              
11222  F4EF 26 03                   bne     L1826                   ; Branch to do section when injPw!=0                            
11223  F4F1 7E F5 C7                jmp     L1845                   ; bail to next section                            
11224  F4F4             
11225  F4F4                         ;--------------------------------------------------------
11226  F4F4                         ; injPw != 0, increment injCount if not already at max(255)
11227  F4F4                         ;--------------------------------------------------------
11228  F4F4 7C 01 86    L1826       inc     injCount                ;                                 
11229  F4F7 26 03                   bne     L1827                   ; Branch if injCount!=0                               
11230  F4F9 7A 01 86                dec     injCount                ; injCount was 255 and is now 0, go back to max of 255                                
11231  F4FC             
11232  F4FC                         ;-------------------------------------------------
11233  F4FC                         ; Load injPw in d and divide by 4 if necessary???
11234  F4FC                         ;-------------------------------------------------
11235  F4FC 7F 00 B5    L1827       clr     newInjToAct               ; newInjToAct = 0                               
11236  F4FF DC A7                   ldd     injPw                     ;                              
11237  F501 87 A2 80 06             brset   state3, #$80, L1828       ; Branch if startingToCrankColdEngine                                
11238  F505 8F B3 07 05             brclr   tdcCasFlags, #$07, L1829  ; Branch if down counter = 0 (first TDC on cyl. #1 was already encoutered)                               
11239  F509             
11240  F509                         ;-------------------------------------------------------------------------------
11241  F509                         ; Seems we are startingToCrank (TDC #1 not yet encountered) but engine is 
11242  F509                         ; not cold so divide injPw by 4 since the value it constains(injPwStart) 
11243  F509                         ; was multiplied by 4 in injPwStart culculations, why???
11244  F509                         ;-------------------------------------------------------------------------------
11245  F509 04                      lsrd                            ; 
11246  F50A 04                      lsrd                            ; d = injPw/4 = injPwStart                              
11247  F50B 03 B5 80    L1828       orm     newInjToAct, #$80       ; Set flag indicating we should be doing simultaneous injection
11248  F50E             
11249  F50E                         ;-------------------------------------------------------
11250  F50E                         ; Add injector deadtime and check for max and min value
11251  F50E                         ;-------------------------------------------------------
11252  F50E BD F7 8E    L1829       jsr     addDeadtime             ; Add deadtime to d
11253  F511 81 EA                   cmpa    #$ea                    ;                             
11254  F513 25 03                   bcs     L1830                   ; Branch if d < $ea00
11255  F515 86 EA                   ldaa    #$ea                    ;                             
11256  F517 5F                      clrb                            ; Too big, use max of d=$ea00 (60ms)                            
11257  F518 1C 05 14    L1830       cmpd    #$0514                  ;                               
11258  F51B 24 03                   bcc     L1831                   ; Branch if above minimum                              
11259  F51D CC 05 14                ldd     #$0514                  ; Too small, use minimum of d=$0514 (1.3ms)                               
11260  F520 DD A7       L1831       std     injPw                   ; Store new value
11261  F522             
11262  F522                         ;--------------------------------------------------------------------------------
11263  F522                         ; Schedule all 4 injector interrupts and bail if in simultaneous injection mode
11264  F522                         ;--------------------------------------------------------------------------------
11265  F522 8F B5 80 09             brclr   newInjToAct, #$80, L1832 ; Branch if sequential injection                                
11266  F526 03 B5 0F                orm     newInjToAct, #$0f        ; Simultaneous injection, set mask corresponding to all 4 injectors
11267  F529 BD F7 46                jsr     schedInjSim              ; Schedule simultaneous injection interrupts                             
11268  F52C 7E F5 C7                jmp     L1845                    ; Bail to exit routine
11269  F52F             
11270  F52F                         ;---------------------------------------------------
11271  F52F                         ; At this point we are in sequential injection mode
11272  F52F                         ;---------------------------------------------------
11273  F52F                         ;------------------------------------------------------------------------------------
11274  F52F                         ; Get the injector mask of the injector to activate for this particular CAS interrupt
11275  F52F                         ; Injector for cylinder #1 starts injecting on the CAS falling edge of cylinder #3, 
11276  F52F                         ; i.e. at the end on #1 combustion cycle/start of #1 exhaust cycle
11277  F52F                         ;
11278  F52F                         ;   casCylIndex   Cylinder number   Injector number       mask
11279  F52F                         ;                 having its TDC    to activate on
11280  F52F                         ;                 closest to CAS    CAS falling edge
11281  F52F                         ;                 falling edge       
11282  F52F                         ;        0             1                  2                $08
11283  F52F                         ;        1             3                  1                $01
11284  F52F                         ;        2             4                  3                $02
11285  F52F                         ;        3             2                  4                $04
11286  F52F                         ;
11287  F52F                         ;------------------------------------------------------------------------------------
11288  F52F CE F5 F2    L1832       ldx     #t_cylMask              ; table content: [$08 $01 $02 $04] -> injector numbers: 2 1 3 4                            
11289  F532 D6 B4                   ldab    casCylIndex             ; b = casCylIndex                             
11290  F534 3A                      abx                             ; x = t_cylMask + casCylIndex                            
11291  F535 A6 00                   ldaa    $00,x                   ; a has one bit set to indicate which injector to use (one of $08 $01 $02 $04)                            
11292  F537             
11293  F537                         ;-------------------------------------------------------
11294  F537                         ; Reset the mask if engine not running or if
11295  F537                         ; disabled by an obd command or if ignition is not happening
11296  F537                         ;-------------------------------------------------------
11297  F537 87 A2 11 06             brset   state3, #$11, L1833        ; Branch if notRotating or startingToCrank                                
11298  F53B 8F 85 80 02             brclr   coilChkFlags, #$80, L1833  ; Branch if no ignition error found
11299  F53F 94 85                   anda    coilChkFlags               ; Reset the injectors corresponding to missing ignition signal
11300  F541 94 BA       L1833       anda    obdInjCmd                  ; Reset injector if disabled by OBD command                            
11301  F543             
11302  F543                         ;-------------------------------------------------------
11303  F543                         ; Update newInjToAct, injToAct and last_t1t2_clk
11304  F543                         ;-------------------------------------------------------
11305  F543 97 B5                   staa    newInjToAct             ; newInjToAct = injector to activate                               
11306  F545 9A B2                   oraa    injToAct                ;                                
11307  F547 97 B2                   staa    injToAct                ; injToAct = injToAct | newInjToAct
11308  F549 96 09                   ldaa    t1t2_clk                ;                                 
11309  F54B 97 B1                   staa    last_t1t2_clk           ; last_t1t2_clk = t1t2_clk/256 (current timer 1 clock?)                              
11310  F54D             
11311  F54D                         ;----------------------------------------------------------------
11312  F54D                         ; Branch to section depending on new injector to activate
11313  F54D                         ;----------------------------------------------------------------
11314  F54D 87 B5 0A 3E             brset   newInjToAct, #$0a, L1839   ; Branch if injector to activate is #2 or #3                                 
11315  F551 8F B5 05 72             brclr   newInjToAct, #$05, L1845   ; Bail if remaining injector #1 and #4 don't need activation either                                
11316  F555             
11317  F555                         ;----------------------------------------------------------------
11318  F555                         ; Injector to activate is #1 or #4, check if already activated
11319  F555                         ;----------------------------------------------------------------
11320  F555 8F 03 02 04 L1833b      brclr   port2, #$02, L1834      ; Branch if injector #1 activated (reverse logic)                               
11321  F559 87 02 08 24             brset   port1, #$08, L1838      ; Branch if injector #4 deactivated (reverse logic)
11322  F55D             
11323  F55D                         ;------------------------------------------------------------------------------
11324  F55D                         ; Injector #1 or #4 already activated
11325  F55D                         ;
11326  F55D                         ; Check how much time remains before next interrupt occurs
11327  F55D                         ;------------------------------------------------------------------------------
11328  F55D DC 0B       L1834       ldd     t1_outCmpWr             ; d = nextInterruptTime                                   
11329  F55F 93 09                   subd    t1t2_clk                ; remainingTime  = d = nextInterruptTime - t1t2_clk                                  
11330  F561 1C 00 32                cmpd    #$0032                  ;                               
11331  F564 25 09                   bcs     L1835                   ; Branch if remainingTime < $0032 (50us)                            
11332  F566 1C 00 C8                cmpd    #$00c8                  ;                               
11333  F569 24 08                   bcc     L1836                   ; Branch if remainingTime >= $00c8 (200us)                             
11334  F56B             
11335  F56B                         ;--------------------------------------------------------
11336  F56B                         ; 50us <= remainingTime < 200us, remaining time before the
11337  F56B                         ; next interrupt is long enough to allow us to do something 
11338  F56B                         ; but is not so long that activation will be too late...
11339  F56B                         ;
11340  F56B                         ; Enable injector activation bit and compute deactivation 
11341  F56B                         ; time as  nextInterruptTime + injPw Since the injector 
11342  F56B                         ; will be enabled when the interrupt occur, very shortly.
11343  F56B                         ; Then exit this interrupt.
11344  F56B                         ;--------------------------------------------------------
11345  F56B 8D 5B                   bsr     actDeact14             ; Enable injector activation bit and compute deactivation time                                   
11346  F56D 20 58                   bra     L1845                  ; Bail of interrupt                            
11347  F56F             
11348  F56F                         ;--------------------------------------------------------
11349  F56F                         ; remainingTime < $0032 (50us). remaining time before the
11350  F56F                         ; next interrupt is too short to do what we need to do... 
11351  F56F                         ; just wait for the interrupt to occur using an infinite 
11352  F56F                         ; loop (5000 cycles max assuming 1Mcycles/sec)
11353  F56F                         ;--------------------------------------------------------
11354  F56F 8F 08 40 FC L1835       brclr   t1_csr, #$40, L1835     ;                                
11355  F573                         ;--------------------------------------------------------------------------------
11356  F573                         ; Interrupt has been triggered we can now proceed with activation
11357  F573                         ;--------------------------------------------------------------------------------
11358  F573             
11359  F573                         ;------------------------------------------------------------------------------------
11360  F573                         ; At this point the remainingTime before the next interrupt is larger than 200us
11361  F573                         ; or it was smaller than 50us but we waited for the interrupt to occur. In both
11362  F573                         ; cases, we are certain an interrupt will no happen right away, just do what needs 
11363  F573                         ; doing...
11364  F573                         ;------------------------------------------------------------------------------------
11365  F573                         ;---------------------------------------------------------------------------
11366  F573                         ; First check if an injector is already activated and if so, just reflect 
11367  F573                         ; that fact in the activation bits (such that we don't change that injector
11368  F573                         ; state when we activate a new injector...)???
11369  F573                         ;---------------------------------------------------------------------------
11370  F573 87 03 02 03 L1836       brset   port2, #$02, L1837      ; Branch if injector #1 is deactivated                                
11371  F577 02 08 FE                andm    t1_csr, #$fe            ; injector #1 is activated, enable activation bit for it
11372  F57A 87 02 08 03 L1837       brset   port1, #$08, L1838      ; Branch if injector #4 is deactivated                              
11373  F57E 02 18 DF                andm    t2_csr, #$df            ; injector #4 is activated, enable activation bit for it
11374  F581             
11375  F581                         ;-----------------------------------------------------------------
11376  F581                         ; Enable the activation bit for the new injector #1 or #4.
11377  F581                         ; Schedule an interrupt for "now + 22us" to activate them.
11378  F581                         ; Compute its deactivation time and schedule an interrupt for it
11379  F581                         ;
11380  F581                         ; I assume here that the 22us delay is small enough that it ensures
11381  F581                         ; the injector activation will occur before the deactivation is scheduled???
11382  F581                         ; not sure if interrupt subroutine is called in that case since we are 
11383  F581                         ; already in interrupt??????????? 
11384  F581                         ;-----------------------------------------------------------------
11385  F581 DC 09       L1838       ldd     t1t2_clk                ; d = t1t2_clk (current time)                                  
11386  F583 C3 00 16                addd    #$0016                  ; activationTime   d = t1t2_clk + $16 (22us)
11387  F586 DD 0B                   std     t1_outCmpWr             ; Schedule interrupt at t1_outCmpWr = t1t2_clk + $16, i.e. activationTime = now + 22us                                  
11388  F588 8D 3E                   bsr     actDeact14              ; Enable new injector activation bit and compute deactivation time                                   
11389  F58A BD F6 0E                jsr     schedDeact14            ; Schedule deactivation time                            
11390  F58D 20 38                   bra     L1845                   ; Bail
11391  F58F                                                                     
11392  F58F                         ;-----------------------------------------------------
11393  F58F                         ; Injector to activate is #2 or #3 
11394  F58F                         ; Logic is identical to #1 #4 injectors 
11395  F58F                         ; above starting at L1833b ......
11396  F58F                         ;-----------------------------------------------------
11397  F58F 8F 02 02 04 L1839       brclr   port1, #$02, L1840      ; Injector 3                               
11398  F593 87 02 04 24             brset   port1, #$04, L1844      ; Injector 2                               
11399  F597 DC 1B       L1840       ldd     t2_outCmpWr             ;                                    
11400  F599 93 09                   subd    t1t2_clk                ;                                 
11401  F59B 1C 00 32                cmpd    #$0032                  ;                               
11402  F59E 25 09                   bcs     L1841                   ;                              
11403  F5A0 1C 00 C8                cmpd    #$00c8                  ;                               
11404  F5A3 24 08                   bcc     L1842                   ;                              
11405  F5A5 8D 36                   bsr     actDeact23              ;                                   
11406  F5A7 20 1E                   bra     L1845                   ; 
11407  F5A9 8F 18 40 FC L1841       brclr   t2_csr, #$40, L1841     ; Infinite loop waiting for interrupt to be triggered                               
11408  F5AD 87 02 02 03 L1842       brset   port1, #$02, L1843      ; 
11409  F5B1 02 18 FE                andm    t2_csr, #$fe            ; 
11410  F5B4 87 02 04 03 L1843       brset   port1, #$04, L1844      ; 
11411  F5B8 02 18 FB                andm    t2_csr, #$fb            ; 
11412  F5BB DC 09       L1844       ldd     t1t2_clk                ;                                 
11413  F5BD C3 00 16                addd    #$0016                  ;                               
11414  F5C0 DD 1B                   std     t2_outCmpWr             ;                                    
11415  F5C2 8D 19                   bsr     actDeact23              ;                                   
11416  F5C4 BD F6 6B                jsr     schedDeact23            ;                                     
11417  F5C7             
11418  F5C7                         ;-------
11419  F5C7                         ; Exit
11420  F5C7                         ;-------
11421  F5C7 3B          L1845       rti                             ;                             
11422  F5C8                                                                                ; 
11423  F5C8             
11424  F5C8             ;******************************************************************
11425  F5C8             ;
11426  F5C8             ; Enable injector activation bit for injector #1 or #4
11427  F5C8             ; and calculate the corresponding injector deactivation time
11428  F5C8             ;
11429  F5C8             ;
11430  F5C8             ;
11431  F5C8             ;******************************************************************
11432  F5C8 DC 0B       actDeact14  ldd     t1_outCmpWr              ; 
11433  F5CA D3 A7                   addd    injPw                    ; d = t1_outCmpWr + injPw                             
11434  F5CC 87 B5 04 07             brset   newInjToAct, #$04, L1847 ; Branch if inj #4 needs activation
11435  F5D0             
11436  F5D0                         ;--------------------------------
11437  F5D0                         ; Injector #1 needs activation
11438  F5D0                         ;--------------------------------
11439  F5D0 02 08 FE                andm    t1_csr, #$fe            ; Reset injector #1 bit                                 
11440  F5D3 DD A9                   std     inj1_offT               ; inj1_offT = t1_outCmpWr + injPw                             
11441  F5D5 20 05                   bra     L1848                   ; Bail                             
11442  F5D7             
11443  F5D7                         ;--------------------------------
11444  F5D7                         ; Injector #4 needs activation
11445  F5D7                         ;--------------------------------
11446  F5D7 02 18 DF    L1847       andm    t2_csr, #$df            ; Reset injector #4 bit                                 
11447  F5DA DD AD                   std     inj4_offT               ; inj4_offT = t1_outCmpWr + injPw                             
11448  F5DC 39          L1848       rts                             ;                             
11449  F5DD             
11450  F5DD             
11451  F5DD             
11452  F5DD             ;******************************************************************
11453  F5DD             ;
11454  F5DD             ; Enable injector activation bit for injector #1 or #4
11455  F5DD             ; and calculate the corresponding injector deactivation time
11456  F5DD             ;
11457  F5DD             ;
11458  F5DD             ;
11459  F5DD             ;******************************************************************
11460  F5DD DC 1B       actDeact23  ldd     t2_outCmpWr              ;                                                        
11461  F5DF D3 A7                   addd    injPw                     ; d = t1_outCmpWr + injPw                                                        
11462  F5E1 87 B5 08 07             brset   newInjToAct, #$08, L1850  ;                                                        
11463  F5E5             
11464  F5E5                         ;--------------------------------
11465  F5E5                         ; Injector #3 needs activation
11466  F5E5                         ;--------------------------------
11467  F5E5 02 18 FE                andm    t2_csr, #$fe            ; Reset injector #3 bit (enable output compare interrupt???)                                   
11468  F5E8 DD AB                   std     inj3_offT               ;                                                       
11469  F5EA 20 05                   bra     L1851                   ;                                                       
11470  F5EC             
11471  F5EC                         ;--------------------------------
11472  F5EC                         ; Injector #2 needs activation
11473  F5EC                         ;--------------------------------
11474  F5EC 02 18 FB    L1850       andm    t2_csr, #$fb            ; Reset injector #2 bit                                    
11475  F5EF DD AF                   std     inj2_offT               ;                                                       
11476  F5F1 39          L1851       rts                             ;                                                      
11477  F5F2             
11478  F5F2             
11479  F5F2             
11480  F5F2             ;******************************************************************
11481  F5F2             ;
11482  F5F2             ; Table used to determine which cylinder/injector the current 
11483  F5F2             ; CAS interrupt corresponds to. The table contains injector bit masks 
11484  F5F2             ;
11485  F5F2             ;
11486  F5F2             ; t_cylMask[casCylIndex] -> cylinder numbers: 2 1 3 4                            
11487  F5F2             ;
11488  F5F2             ;
11489  F5F2             ;******************************************************************
11490  F5F2 08 01 02 04 t_cylMask       .byte   $08, $01, $02, $04
11491  F5F6             
11492  F5F6             
11493  F5F6             
11494  F5F6             ;******************************************************************
11495  F5F6             ;
11496  F5F6             ; Output compare interrupt1 
11497  F5F6             ;
11498  F5F6             ; Triggered by injector #1 and #4 activation/deactivation
11499  F5F6             ;
11500  F5F6             ;
11501  F5F6             ;******************************************************************
11502  F5F6 96 08       outCompInt1 ldaa    t1_csr                  ; Ack interrupt?                              
11503  F5F8 DC 0B                   ldd     t1_outCmpWr             ; 
11504  F5FA DD 0B                   std     t1_outCmpWr             ; Flush the output compare value that triggered the current interrupt??? 
11505  F5FC BD F6 0E                jsr     schedDeact14            ; Schedule deactivation time
11506  F5FF             
11507  F5FF                         ;------------------------------------------
11508  F5FF                         ; Branch to execute rest of subroutine...
11509  F5FF                         ;------------------------------------------
11510  F5FF 20 09                   bra     L1855                                                 
11511  F601             
11512  F601             
11513  F601             
11514  F601             ;******************************************************************
11515  F601             ;
11516  F601             ; Output compare interrupt2
11517  F601             ;
11518  F601             ; Triggered by injector #2 and #3 activation/deactivation
11519  F601             ;
11520  F601             ;
11521  F601             ;******************************************************************
11522  F601 96 18       outCompInt2 ldaa    t2_csr                  ; Ack interrupt?                              
11523  F603 DC 1B                   ldd     t2_outCmpWr             ; 
11524  F605 DD 1B                   std     t2_outCmpWr             ; Flush the output compare value that triggered the current interrupt???                       
11525  F607 BD F6 6B                jsr     schedDeact23            ; Schedule deactivation time                                                           
11526  F60A             
11527  F60A                         ;------------------------------------------
11528  F60A                         ; Perform injector testing and update 
11529  F60A                         ; simultaneous injection mode if required
11530  F60A                         ;------------------------------------------
11531  F60A BD F6 EC    L1855       jsr     injUpdate0              ;                              
11532  F60D 3B                      rti                             ;                             
11533  F60E             
11534  F60E             
11535  F60E             
11536  F60E             ;******************************************************************
11537  F60E             ;
11538  F60E             ; Schedule injector #1 and #4 deactivation 
11539  F60E             ; time interrupt if necessary
11540  F60E             ;
11541  F60E             ;
11542  F60E             ;******************************************************************
11543  F60E                         ;-----------------------------------
11544  F60E                         ; Update oldInjToAct and injToAct
11545  F60E                         ;-----------------------------------
11546  F60E 96 B2       schedDeact14 ldaa   injToAct                ; a = injToAct                             
11547  F610 97 B7                   staa    oldInjToAct             ; oldInjToAct = old injToAct
11548  F612 8F 03 02 02             brclr   port2, #$02, L1857      ; Branch if injector #1 is activated                              
11549  F616 84 FE                   anda    #$fe                    ; Reset injector #1 bit                            
11550  F618 8F 02 08 02 L1857       brclr   port1, #$08, L1858      ; Branch if injector #4 is activated                              
11551  F61C 84 FB                   anda    #$fb                    ; Reset injector #4 bit                             
11552  F61E 97 B2       L1858       staa    injToAct                ; Update injToAct
11553  F620                                            
11554  F620                         ;--------------------------------------------------------------------------
11555  F620                         ; Clear sInjPw if injectors from both banks are activated (1 or 4 and 2 or 3)
11556  F620                         ;--------------------------------------------------------------------------
11557  F620 8F B7 05 0E             brclr   oldInjToAct, #$05, L1860 ; Branch if both inj #1 and #4 are not activated
11558  F624 8F 02 04 04             brclr   port1, #$04, L1859       ; inj #1 or #4 activated, branch if #2 activated (sim injection on)                               
11559  F628 87 02 02 06             brset   port1, #$02, L1860       ; Branch if #3 not activated (sim injection off                                
11560  F62C 7F 01 14    L1859       clr     sInjPw                   ; clear sInjPw and sInjPw+1                             
11561  F62F 7F 01 15                clr     sInjPw+1                 ;                              
11562  F632             
11563  F632                         ;----------------------------------
11564  F632                         ; Find which of #1 or #4 is active
11565  F632                         ;----------------------------------
11566  F632 8F 03 02 06 L1860       brclr   port2, #$02, L1861      ; Branch if inj #1 activated                                
11567  F636 87 02 08 30             brset   port1, #$08, L1866      ; Bail if inj #4 is also deactivated (none activated)                               
11568  F63A 20 14                   bra     L1862                   ; Only inj #4 activated, branch to deactivate it                            
11569  F63C             
11570  F63C                         ;------------------------------
11571  F63C                         ; Inj #1 activated, check #4
11572  F63C                         ;------------------------------
11573  F63C 87 02 08 1F L1861       brset   port1, #$08, L1864      ; Branch if #4 deactivated                              
11574  F640             
11575  F640                         ;--------------------------
11576  F640                         ; Inj #1 and #4 activated
11577  F640                         ;--------------------------
11578  F640 CE 00 A9                ldx     #inj1_offT              ; x points to injectors deactivation time table                              
11579  F643 BD F6 D9                jsr     injRemTime              ; Compute injection remaining time for #1 and #4, a = remTime1, b = remTime4                              
11580  F646 10                      sba                             ; a = remTime1 - remTime4                            
11581  F647 25 0E                   bcs     L1863                   ; Branch if remTime1 < remTime4                        
11582  F649                              
11583  F649                         ;---------------------------------------------------------------------------------
11584  F649                         ; Inj #1 and #4 are activated and remTime1 >= remTime4
11585  F649                         ;
11586  F649                         ; This would mean we are in #1 combustion cycle. In that case, we would 
11587  F649                         ; deactivate inj #4 first (since it has been injecting for a long time by now) 
11588  F649                         ; and eventually inj #1 (which has just started injecting)
11589  F649                         ;
11590  F649                         ; Branch to disable only inj #4 if remTime1 - remTime4 > 1.024ms
11591  F649                         ;---------------------------------------------------------------------------------
11592  F649 81 04                   cmpa    #$04                    ;                              
11593  F64B 22 03                   bhi     L1862                   ; Branch if remTime1-remTime4 > 4 (1.024ms)
11594  F64D             
11595  F64D                         ;--------------------------------------------------------------------
11596  F64D                         ; remTime1-remTime4 <= 4 (1.024ms). This means both injectors will 
11597  F64D                         ; be disabled at about the same time, just deactivate both
11598  F64D                         ; of them at that time...
11599  F64D                         ;
11600  F64D                         ; Disable the activation bit for inj. #1 and #4 (two lines below)
11601  F64D                         ; and use inj. #4 deactivation time
11602  F64D                         ;--------------------------------------------------------------------
11603  F64D 03 08 01                orm     t1_csr, #$01            ; Disable the activation bit for inj. #1
11604  F650             
11605  F650                         ;-----------------------------------------
11606  F650                         ; Disable the activation bit for inj. #4 
11607  F650                         ; and load deactivation time in d
11608  F650                         ;-----------------------------------------
11609  F650 03 18 20    L1862       orm     t2_csr, #$20            ; Disable the activation bit for inj. #4
11610  F653 DC AD                   ldd     inj4_offT               ; d = inj4_offT, injector #4 deactivation time                                   
11611  F655 20 0D                   bra     L1865                   ; Branch to schedule deactivation interrupt                             
11612  F657             
11613  F657                         ;--------------------------------------------------------------------------------------
11614  F657                         ; Inj #1 and #4 are activated and remTime1 < remTime4
11615  F657                         ; This would mean we are in #4 combustion cycle. In that case,
11616  F657                         ;--------------------------------------------------------------------------------------
11617  F657 40          L1863       nega                            ; make result positive, a = remTime4 - remTime1
11618  F658 81 04                   cmpa    #$04                    ;                             
11619  F65A 22 03                   bhi     L1864                   ; Branch if remTime4 - remTime1 > 4 (1.024ms)                             
11620  F65C             
11621  F65C                         ;--------------------------------------------------------------------
11622  F65C                         ; remTime4-remTime1 <= 4 (1.024ms). This means both injectors will 
11623  F65C                         ; be disabled at about the same time, just deactivate both
11624  F65C                         ; of them at that time???
11625  F65C                         ;
11626  F65C                         ; Disable the activation bit for inj. #4 and #1 (two lines below)
11627  F65C                         ; and use inj. #1 deactivation time
11628  F65C                         ;--------------------------------------------------------------------
11629  F65C 03 18 20                orm     t2_csr, #$20            ; Disable the activation bit for inj. #4
11630  F65F             
11631  F65F                         ;-----------------------------------------
11632  F65F                         ; Disable the activation bit for inj. #1
11633  F65F                         ; and load deactivation time in d
11634  F65F                         ;-----------------------------------------
11635  F65F 03 08 01    L1864       orm     t1_csr, #$01            ; Disable the activation bit for inj. #1
11636  F662 DC A9                   ldd     inj1_offT               ; d = inj1_offT, i.e. inj #1 deactivation time  
11637  F664                                                         
11638  F664                         ;--------------------------------------------------------------------------
11639  F664                         ; Validate deactivation time and write to timer 1 output compare register
11640  F664                         ;--------------------------------------------------------------------------
11641  F664 8D 5F       L1865       bsr     validDeactT             ; Validate deactivation time                              
11642  F666 DE 08                   ldx     t1_csr                  ; Read t1_csr and  t1t2_clk??? sequence to follow I assume but it is different from schedDeact23???
11643  F668 DD 0B                   std     t1_outCmpWr             ; Write next interrupt time                                    
11644  F66A 39          L1866       rts                             ;                             
11645  F66B             
11646  F66B             
11647  F66B             
11648  F66B             ;******************************************************************
11649  F66B             ;
11650  F66B             ; Schedule injector #2 and #3 deactivation time interrupt
11651  F66B             ;
11652  F66B             ; Logic is identical to the actDeact14 subroutine
11653  F66B             ;
11654  F66B             ;
11655  F66B             ;******************************************************************
11656  F66B 96 B2       schedDeact23 ldaa    injToAct               ;                               
11657  F66D 97 B7                   staa    oldInjToAct             ;                              
11658  F66F 8F 02 04 02             brclr   port1, #$04, L1868      ; 
11659  F673 84 F7                   anda    #$f7                    ; 
11660  F675 8F 02 02 02 L1868       brclr   port1, #$02, L1869      ; 
11661  F679 84 FD                   anda    #$fd                    ; 
11662  F67B 97 B2       L1869       staa    injToAct                ; 
11663  F67D 8F B7 0A 0E             brclr   oldInjToAct, #$0a, L1871 ;
11664  F681 8F 02 08 04             brclr   port1, #$08, L1870      ; 
11665  F685 87 03 02 06             brset   port2, #$02, L1871      ; 
11666  F689 7F 01 14    L1870       clr     sInjPw                  ; 
11667  F68C 7F 01 15                clr     sInjPw+1                ; 
11668  F68F 8F 02 04 06 L1871       brclr   port1, #$04, L1872      ; 
11669  F693 87 02 02 2D             brset   port1, #$02, L1877      ; 
11670  F697 20 22                   bra     L1875                   ;  
11671  F699 87 02 02 0F L1872       brset   port1, #$02, L1873      ; 
11672  F69D CE 00 AB                ldx     #$00ab                  ;  
11673  F6A0 8D 37                   bsr     injRemTime              ;  
11674  F6A2 10                      sba                             ;  
11675  F6A3 25 0E                   bcs     L1874                   ;  
11676  F6A5 81 04                   cmpa    #$04                    ;  
11677  F6A7 22 03                   bhi     L1873                   ;  
11678  F6A9 03 18 01                orm     t2_csr, #$01            ; 
11679  F6AC 03 18 04    L1873       orm     t2_csr, #$04            ; 
11680  F6AF DC AF                   ldd     inj2_offT               ;  
11681  F6B1 20 0D                   bra     L1876                   ;  
11682  F6B3 40          L1874       nega                            ;  
11683  F6B4 81 04                   cmpa    #$04                    ;  
11684  F6B6 22 03                   bhi     L1875                   ;  
11685  F6B8 03 18 04                orm     t2_csr, #$04            ; 
11686  F6BB 03 18 01    L1875       orm     t2_csr, #$01            ; 
11687  F6BE DC AB                   ldd     inj3_offT               ;  
11688  F6C0             
11689  F6C0                         ;--------------------------------------------------------------------------
11690  F6C0                         ; Validate deactivation time and write to timer 2 output compare register
11691  F6C0                         ; sequence is different compared to schedDeact14?????? (and the t1 and t2
11692  F6C0                         ; control registers are also different????)
11693  F6C0                         ;--------------------------------------------------------------------------
11694  F6C0 8D 03       L1876       bsr     validDeactT                                                 
11695  F6C2 DD 1B                   std     t2_outCmpWr                                                 
11696  F6C4 39          L1877       rts                                                          
11697  F6C5             
11698  F6C5             
11699  F6C5             
11700  F6C5             ;******************************************************************
11701  F6C5             ;
11702  F6C5             ; Check injector deactivation time for validity
11703  F6C5             ;
11704  F6C5             ; Input: 
11705  F6C5             ;       d = deactTime = injector deactivation time 
11706  F6C5             ;
11707  F6C5             ;
11708  F6C5             ; Output:
11709  F6C5             ;       d = deactTime or current time + 20us if deactTime>61ms
11710  F6C5             ;
11711  F6C5             ;******************************************************************
11712  F6C5 DD 5E       validDeactT std     temp8                   ; temp8 = deactTime                               
11713  F6C7 83 00 14                subd    #$0014                  ; d = deactTime - $14   (20us)                              
11714  F6CA 93 09                   subd    t1t2_clk                ; remTime = d = deactTime - $14 - t1t2_clk (remaining time until deactivation - 20us)                                
11715  F6CC 1C EE 00                cmpd    #$ee00                  ;                               
11716  F6CF DC 5E                   ldd     temp8                   ; d = deactTime                              
11717  F6D1 25 05                   bcs     L1879                   ; Branch if remTime < $ee00 (61ms)                             
11718  F6D3             
11719  F6D3                         ;--------------------------------------------- 
11720  F6D3                         ; Remaining time too high, deactivate in 20us
11721  F6D3                         ;--------------------------------------------- 
11722  F6D3 DC 09                   ldd     t1t2_clk                ; d = t1t2_clk                                 
11723  F6D5 C3 00 14                addd    #$0014                  ; d = t1t2_clk + 20us                              
11724  F6D8 39          L1879       rts                             ;                             
11725  F6D9             
11726  F6D9             
11727  F6D9             
11728  F6D9             ;******************************************************************
11729  F6D9             ;
11730  F6D9             ;  Compute the remainingInjectionTime/256 for injectors #1 and #4 (or #2 and #3)
11731  F6D9             ;  remaining time might be measured from the most recent CAS falling edge since
11732  F6D9             ;  that is what last_t1t2_clk contains... However the function might also be called 
11733  F6D9             ;  just after last_t1t2_clk has been updated... but not always??? In any case, the 
11734  F6D9             ;  difference between the two remaining times is the most important...
11735  F6D9             ;
11736  F6D9             ; Input: 
11737  F6D9             ;       x: points to inj1_offT or inj3_offT (injector deactivation time table)
11738  F6D9             ;
11739  F6D9             ; Output:
11740  F6D9             ;       a = 0 if inj #1 (or #2) remaining injection time > 61ms  else  remaining injection time/256
11741  F6D9             ;       b = 0 if inj #4 (or #3) remaining injection time > 61ms  else  remaining injection time/256
11742  F6D9             ;
11743  F6D9             ; Basically a and b are the remainingActivationTime/256
11744  F6D9             ; or 0 if it doesn't make sense (i.e. > 61ms)
11745  F6D9             ;
11746  F6D9             ;******************************************************************
11747  F6D9 A6 00       injRemTime  ldaa    $00,x                   ; a = inj1_offT/256
11748  F6DB 90 B1                   suba    last_t1t2_clk           ; a = inj1_offT - last_t1t2_clk
11749  F6DD 81 EE                   cmpa    #$ee                    ;                             
11750  F6DF 25 01                   bcs     L1881                   ; Branch if inj1_offT - last_t1t2_clk <$ee (61ms)
11751  F6E1 4F                      clra                            ; a = 0                            
11752  F6E2             
11753  F6E2 E6 04       L1881       ldab    $04,x                   ; b = inj4_offT/256
11754  F6E4 D0 B1                   subb    last_t1t2_clk           ; b = inj4_offT/256 - last_t1t2_clk
11755  F6E6 C1 EE                   cmpb    #$ee                    ;                            
11756  F6E8 25 01                   bcs     L1882                   ; Branch if inj1_offT - last_t1t2_clk <$ee (61ms)
11757  F6EA 5F                      clrb                            ; b = 0                            
11758  F6EB 39          L1882       rts                             ;                             
11759  F6EC             
11760  F6EC             
11761  F6EC             
11762  F6EC             ;******************************************************************
11763  F6EC             ;
11764  F6EC             ; Called on every injector activation/deactivation (output compare)
11765  F6EC             ;
11766  F6EC             ; Tests injector feedback bit if time has come and 
11767  F6EC             ; perform simultaneous injection activation/deactivation if
11768  F6EC             ; required
11769  F6EC             ;
11770  F6EC             ;
11771  F6EC             ;******************************************************************
11772  F6EC                         ;------------------------------------------------------------------
11773  F6EC                         ; Check whether we should test the injectors for proper operation
11774  F6EC                         ;------------------------------------------------------------------
11775  F6EC 96 B8       injUpdate0  ldaa    injToTest               ; a = injToTest                               
11776  F6EE 91 B7                   cmpa    oldInjToAct             ;                                    
11777  F6F0 26 11                   bne     L1885                   ; Bail if injToTest != oldInjToAct, i.e. the injector to test was not the one and only one activated
11778  F6F2 87 B2 0F 0D             brset   injToAct, #$0f, L1885   ; Bail if any injector currently activated          
11779  F6F6                                                
11780  F6F6                         ;--------------------------------------------------------------------------------
11781  F6F6                         ; At this point, we know that the current injector to test was
11782  F6F6                         ; active in the past (oldInjToAct) and that it is not active anymore
11783  F6F6                         ; (injToAct). Basically, we know that the injector to test was just 
11784  F6F6                         ; deactivated and no other injector is currently active. 
11785  F6F6                         ;
11786  F6F6                         ; port4.7 might be loaded on the falling edge of the injector driving current???
11787  F6F6                         ;--------------------------------------------------------------------------------
11788  F6F6                         ;------------------------------------------------------------------
11789  F6F6                         ; Check feedback flag to know if injector is working correctly???
11790  F6F6                         ;------------------------------------------------------------------
11791  F6F6 8F 07 80 05             brclr   port4, #$80, L1884      ; Branch if injector flag shows it is OK?                                
11792  F6FA 03 B9 01                orm     injBad, #$01            ; Set bit indicating injectors is bad?                                   
11793  F6FD 20 04                   bra     L1885                   ; Branch to rest of code, we will continue testing the same injector.                             
11794  F6FF             
11795  F6FF                         ;--------------------------------------------------------------
11796  F6FF                         ; Injector is OK, reset injBad flag and go to next injToTest
11797  F6FF                         ;--------------------------------------------------------------
11798  F6FF 48          L1884       asla                            ; a = injToTest<<1, go to next injector to test
11799  F700 02 B9 FE                andm    injBad, #$fe            ; Reset bit indicating injectors is bad?                                
11800  F703             
11801  F703                         ;-------------------
11802  F703                         ; Update injToTest
11803  F703                         ;-------------------
11804  F703 84 0F       L1885       anda    #$0f                    ; Keep only 4 bits, 4 injectors to test
11805  F705 26 02                   bne     L1886                   ; Branch if any injector bit left                             
11806  F707 86 01                   ldaa    #$01                    ; Nothing left, restart testing with injector at bit 0                             
11807  F709 97 B8       L1886       staa    injToTest               ; Update injToTest
11808  F70B                         ;-----------------------------------
11809  F70B                         ; Code continues in function below......
11810  F70B                         ;-----------------------------------
11811  F70B                         ;;;;; bra  simInject
11812  F70B             
11813  F70B             
11814  F70B             
11815  F70B             
11816  F70B             
11817  F70B             ;******************************************************************
11818  F70B             ;
11819  F70B             ; Simultaneous injection code called every 10ms from real time
11820  F70B             ; interrupt or from above code continuation. sInjPw is cleared
11821  F70B             ; if sim. injection is actually scheduled such that even if it 
11822  F70B             ; is called from multiple places, sim. injection will only happen
11823  F70B             ; once every time sInjPw is re-loaded...
11824  F70B             ;
11825  F70B             ;
11826  F70B             ;******************************************************************
11827  F70B                         ;----------------------------------------------------------------------------
11828  F70B                         ; Bail out of function if any injectors are set in injToAct 
11829  F70B                         ; (rest of function is for simultaneous injection and all bit should be 0?)
11830  F70B                         ;----------------------------------------------------------------------------
11831  F70B 87 B2 0F 7E simInject   brset   injToAct, #$0f, L1897   ; branch if any injector bit set
11832  F70F                                              
11833  F70F                         ;-------------------------------------------------------
11834  F70F                         ; All injectors are currently off, we can therefore
11835  F70F                         ; proceed with simultaneous injection if sInjPw >256us
11836  F70F                         ;
11837  F70F                         ; Update injPw from sInjPw if larger than 256us
11838  F70F                         ;-------------------------------------------------------
11839  F70F FC 01 14                ldd     sInjPw                  ; d = sInjPw
11840  F712 4D                      tsta                            ;                             
11841  F713 27 78                   beq     L1897                   ; Bail of subroutine if sInjPw/256 = 0 (sInjPw<256us), too small....
11842  F715 7F 01 14                clr     sInjPw                  ;                              
11843  F718 7F 01 15                clr     sInjPw+1                ; clear sInjPw                              
11844  F71B 8D 71                   bsr     addDeadtime             ; Add deadTime                                   
11845  F71D DD A7                   std     injPw                   ; injPw = sInjPw + deatTime
11846  F71F                                                      
11847  F71F                         ;------------------------------------------------------------
11848  F71F                         ; Round injPw up to specific values if within some ranges, 
11849  F71F                         ; Not quite sure why but I think that when the 
11850  F71F                         ; injection time becomes small, injection time is less 
11851  F71F                         ; predictable or simply non linear in some ranges... In
11852  F71F                         ; any case, since these times include the deadtime, they are
11853  F71F                         ; quite small..., not sure any fuel will actually come out?
11854  F71F                         ;
11855  F71F                         ;          injPw <= 840us  -> 840us
11856  F71F                         ;  840us < injPw <= 960us  -> no change
11857  F71F                         ;  960us < injPw <= 1100us -> 1100us
11858  F71F                         ; 1100us < injPw           -> no change
11859  F71F                         ;------------------------------------------------------------
11860  F71F CC 03 48                ldd     #$0348                  ; 
11861  F722 1D A7                   cmpd1   injPw                   ;                              
11862  F724 24 0E                   bcc     L1888                   ; Branch to use $0348 if injPw <= $0348 (840us)                           
11863  F726 CC 03 C0                ldd     #$03c0                  ; 
11864  F729 1D A7                   cmpd1   injPw                   ;                              
11865  F72B 24 09                   bcc     L1889                   ; Branch to use injPw if injPw <= $03c0 (960us)                              
11866  F72D CC 04 4C                ldd     #$044c                  ; 
11867  F730 1D A7                   cmpd1   injPw                   ;                              
11868  F732 25 02                   bcs     L1889                   ; Branch to use injPw if injPw > $044c (1100us)                             
11869  F734 DD A7       L1888       std     injPw                   ;                              
11870  F736             
11871  F736                         ;------------------------------------------------------
11872  F736                         ; Update newInjToAct, start with all injectors 
11873  F736                         ; active and remove the ones disabled by obd
11874  F736                         ; and the ones corresponding to missing ignition 
11875  F736                         ; signals
11876  F736                         ;------------------------------------------------------
11877  F736 86 0F       L1889       ldaa    #$0f                      ; All 4 injectors set by default                              
11878  F738 87 A2 01 08             brset   state3, #$01, L1891       ; Branch if startingToCrank                              
11879  F73C 8F 85 80 02             brclr   coilChkFlags, #$80, L1890 ; Branch if no error found on ignition
11880  F740 94 85                   anda    coilChkFlags              ; Disable injectors corresponding to missing ignition
11881  F742 94 BA       L1890       anda    obdInjCmd                 ; Disable injectors that are off on purpose (OBD)
11882  F744 97 B5       L1891       staa    newInjToAct               ; Update newInjToAct      
11883  F746                                    
11884  F746                         ;-----------------------------------
11885  F746                         ; Code continues in function below......
11886  F746                         ;-----------------------------------
11887  F746                         ;;;;; bra  schedInjSim
11888  F746             
11889  F746             
11890  F746             
11891  F746             
11892  F746             ;******************************************************************
11893  F746             ;
11894  F746             ; Function to schedule interrupts for injectors activation and 
11895  F746             ; deactivation in the case of simultaneous injection. Called from 
11896  F746             ; main code and from above code continuation...
11897  F746             ;
11898  F746             ; Simulataneous injection can be either when startingToCrank or
11899  F746             ; when starting a cold engine or during acceleration (sInjEnr) 
11900  F746             ;
11901  F746             ; injPw need to be initialized with the proper value (e.g. sInjPw)
11902  F746             ; prior to calling this function
11903  F746             ;
11904  F746             ;******************************************************************
11905  F746                         ;--------------------
11906  F746                         ; Update last_t1t2_clk
11907  F746                         ;--------------------
11908  F746 DC 09       schedInjSim ldd     t1t2_clk                ; a = t1t2_clk, current time                                
11909  F748 97 B1                   staa    last_t1t2_clk           ; last_t1t2_clk = t1t2_clk/256                             
11910  F74A             
11911  F74A                         ;------------------------------------------------------
11912  F74A                         ; Schedule interrupt in 2.048ms 
11913  F74A                         ;
11914  F74A                         ; This might be to revert to previous injector 
11915  F74A                         ; settings after 2.048ms ???? t1_outCmpWr
11916  F74A                         ; and t2_outCmpWr would need to be triple buffered???
11917  F74A                         ;------------------------------------------------------
11918  F74A 8B 08                   adda    #$08                    ; d = t1t2_clk + 8*256 (2.048ms)
11919  F74C DD 0B                   std     t1_outCmpWr             ; Store interrupt time for injector #1 and #4
11920  F74E DD 1B                   std     t2_outCmpWr             ; Store interrupt time for injector #2 and #3
11921  F750             
11922  F750                         ;--------------------
11923  F750                         ; Update injToAct
11924  F750                         ;--------------------
11925  F750 96 B5                   ldaa    newInjToAct             ;                               
11926  F752 84 3F                   anda    #$3f                    ; Keep only lower 6 bits (6 injectors max?)
11927  F754 97 B2                   staa    injToAct                ;                              
11928  F756             
11929  F756                         ;-------------------------------------------------------------------
11930  F756                         ; Reset bit of t1_csr and t2_csr according to activated injectors
11931  F756                         ;-------------------------------------------------------------------
11932  F756 96 B5                   ldaa    newInjToAct             ; a = newInjToAct                             
11933  F758 46                      rora                            ; transfer bit 0 to carry                            
11934  F759 24 03                   bcc     L1893                   ; Branch if injector 1 is off                               
11935  F75B 02 08 FE                andm    t1_csr, #$fe            ; Injector 1 is activated, reset bit                                 
11936  F75E 46          L1893       rora                            ;                             
11937  F75F 24 03                   bcc     L1894                   ; Branch if injector 3 is off                             
11938  F761 02 18 FE                andm    t2_csr, #$fe            ; Injector 3 is activated, reset bit
11939  F764 46          L1894       rora                            ;                             
11940  F765 24 03                   bcc     L1895                   ; Branch if injector 4 is off                             
11941  F767 02 18 DF                andm    t2_csr, #$df            ; Injector 4 is activated, reset bit
11942  F76A 46          L1895       rora                            ;                             
11943  F76B 24 03                   bcc     L1896                   ; Branch if injector 2 is off                             
11944  F76D 02 18 FB                andm    t2_csr, #$fb            ; Injector 2 is activated, reset bit
11945  F770             
11946  F770                         ;-------------------------------------------------------------
11947  F770                         ; Schedule interrupts to activate specified injectors in 10us
11948  F770                         ;-------------------------------------------------------------
11949  F770 DC 09       L1896       ldd     t1t2_clk                ; d = t1t2_clk
11950  F772 C3 00 0A                addd    #$000a                  ; d = t1t2_clk + 10us
11951  F775 DD 0B                   std     t1_outCmpWr             ; Turn injector on in 10us.                                     
11952  F777 DD 1B                   std     t2_outCmpWr             ; Turn injector on in 10us.                                     
11953  F779             
11954  F779                         ;-------------------------------------------------------------
11955  F779                         ; Compute and store deactivation time 
11956  F779                         ; (common to all injectors when using simultaneous injection)
11957  F779                         ;-------------------------------------------------------------
11958  F779 D3 A7                   addd    injPw                   ; d = t1t2_clk + 10us + injPw
11959  F77B DD A9                   std     inj1_offT               ;                              
11960  F77D DD AB                   std     inj3_offT               ;                              
11961  F77F DD AD                   std     inj4_offT               ;                              
11962  F781 DD AF                   std     inj2_offT               ;                              
11963  F783             
11964  F783                         ;------------------------------------------------------------------------
11965  F783                         ; Schedule interrupts to deactivate all injectors at the specified time
11966  F783                         ;------------------------------------------------------------------------
11967  F783 03 08 01                orm     t1_csr, #$01            ; Set bit for injector 1
11968  F786 03 18 25                orm     t2_csr, #$25            ; Set bits for injector 3 4 and 2
11969  F789 DD 0B                   std     t1_outCmpWr             ; Turn injector off at that time?
11970  F78B DD 1B                   std     t2_outCmpWr             ; Turn injector off at that time?                                 
11971  F78D 39          L1897       rts                                                          
11972  F78E             
11973  F78E             
11974  F78E             
11975  F78E             ;******************************************************************
11976  F78E             ;
11977  F78E             ;
11978  F78E             ; Injectors, add $18*deadTime to injPw (in d)
11979  F78E             ;
11980  F78E             ; deadTime is in increment of 24us and injPw in increment of 1us
11981  F78E             ;
11982  F78E             ;
11983  F78E             ;******************************************************************
11984  F78E DD 5E       addDeadtime std     temp8                   ; temp8 = injPw                               
11985  F790 96 A6                   ldaa    deadTime                ; a = deadTime                                
11986  F792 C6 18                   ldab    #$18                    ; b = $18                            
11987  F794 3D                      mul                             ; d = $18*deadTime                          
11988  F795 D3 5E                   addd    temp8                   ; d = injPw + $18*deadTime                              
11989  F797 24 02                   bcc     L1899                   ; Branch if no overflow                             
11990  F799 86 FF                   ldaa    #$ff                    ; Use max of ~$ff00 (65.3ms)                           
11991  F79B 39          L1899       rts                             ;                             
11992  F79C             
11993  F79C             
11994  F79C             
11995  F79C             ;******************************************************************
11996  F79C             ;
11997  F79C             ; Input capture interrupt 2
11998  F79C             ;
11999  F79C             ; This interrupt is triggered whenever the 
12000  F79C             ; airflow sensor emits one pulse
12001  F79C             ;
12002  F79C             ;******************************************************************
12003  F79C 96 18       inCaptInt2  ldaa    t2_csr                  ; ack/reset interrupt/timer control ???
12004  F79E 8D 01                   bsr     masProc                                                 
12005  F7A0 3B                      rti                                                          
12006  F7A1             
12007  F7A1             
12008  F7A1             
12009  F7A1             ;******************************************************************
12010  F7A1             ;
12011  F7A1             ; Mas airflow pulse accumulator subroutine 
12012  F7A1             ;
12013  F7A1             ; Called from interrupt and code (polling)
12014  F7A1             ;      
12015  F7A1             ; Assumptions: t2_csr.1 controls the input capture trigger edge 
12016  F7A1             ;              polarity. This would imply (from mafraw calculations)
12017  F7A1             ;              that the airflow sensor pulse frequency is 
12018  F7A1             ;              divided by two by the ECU circuitry. In that case, 
12019  F7A1             ;              counting edges (changing polarity through t2_csr.1 
12020  F7A1             ;              on every interrupt) would correspond to counting 
12021  F7A1             ;              airflow sensor pulses.
12022  F7A1             ;
12023  F7A1             ; Under low airflow, it is called on every rising and falling 
12024  F7A1             ; edge of incoming signal (airflow sensor frequency/2) and it is
12025  F7A1             ; therefore called on every airflow sensor pulse.
12026  F7A1             ;
12027  F7A1             ; When large airflow is detected or when the time between each
12028  F7A1             ; interrupt becomes small, it is called only once for every 2 
12029  F7A1             ; airflow sensor pulses (called scaling) in order to reduce 
12030  F7A1             ; the number of interrupts per sec (CPU load). 
12031  F7A1             ;
12032  F7A1             ; airCntNew0:airCntNew1 is increased by airQuantum = $9c on every 
12033  F7A1             ; call (rising and falling edge) or by 2*airQuantum if we are 
12034  F7A1             ; scaling.
12035  F7A1             ;
12036  F7A1             ;******************************************************************
12037  F7A1                         ;----------------------------------------------
12038  F7A1                         ; Compute t2_diff8 and update t2_lastMas
12039  F7A1                         ;----------------------------------------------
12040  F7A1 DC 1D       masProc     ldd     t2_inCapt               ; Read current input capture timer value                                 
12041  F7A3 93 98                   subd    t2_lastMas              ; D = t2_inCapt-t2_lastMas
12042  F7A5 CE 00 C1                ldx     #T200_mas               ;                                                                             
12043  F7A8 BD F8 02                jsr     masFunc1                ; D = (t2_inCapt-t2_lastMas)/8 with timer based rounding???                                                              
12044  F7AB DD 9A                   std     t2_diff8                ; t2_diff8 = (t2_inCapt-t2_lastMas)/8 with timer based rounding (see masFunc1)
12045  F7AD DC 1D                   ldd     t2_inCapt               ;                                                                            
12046  F7AF DD 98                   std     t2_lastMas              ; t2_lastMas = t2_inCapt
12047  F7B1             
12048  F7B1                         ;-----------------------------------
12049  F7B1                         ; Re-init counter used in masFunc1
12050  F7B1                         ;-----------------------------------
12051  F7B1 86 1A                   ldaa    #$1a                    ; 130ms                                                                           
12052  F7B3 97 C1                   staa    T200_mas                ;                                                                            
12053  F7B5             
12054  F7B5                         ;--------------------------------------
12055  F7B5                         ; Add scaled airQuantum to airCntNew0
12056  F7B5                         ;--------------------------------------
12057  F7B5 4F                      clra                              ;                                                                           
12058  F7B6 D6 9C                   ldab    airQuantum                ; d = airQuantum
12059  F7B8 8F 9E 80 01             brclr   masCasFlags, #$80, L1902  ; Branch if no scaling
12060  F7BC 05                      asld                              ; scale d = 2*airQuantum
12061  F7BD D3 90       L1902       addd    airCntNew0                ; d = airCntNew0 + airQuantum
12062  F7BF 26 01                   bne     L1903                     ; Branch if result not null                                                                           
12063  F7C1 5C                      incb                              ; Result is null, use min of 1                                                                     
12064  F7C2 DD 90       L1903       std     airCntNew0                ; Store airCntNew0 = max(airCntNew0 + airQuantum, 1)                                               
12065  F7C4             
12066  F7C4                         ;----------------------------------
12067  F7C4                         ; Re-init airQuantum with #9c
12068  F7C4                         ;----------------------------------
12069  F7C4 86 9C                   ldaa    #$9c                    ;                                                                           
12070  F7C6 97 9C                   staa    airQuantum              ; airQuantum = $9C                                                                
12071  F7C8             
12072  F7C8                         ;----------------------------------
12073  F7C8                         ; Check if we are using scaling
12074  F7C8                         ;----------------------------------
12075  F7C8 87 9E 80 13             brset   masCasFlags, #$80, L1905      ; branch if scaling by two                                                    
12076  F7CC             
12077  F7CC             
12078  F7CC                         ;-----------------------------------------------------------
12079  F7CC                         ; We are not scaling, check if that needs to change
12080  F7CC                         ; Either if airVol is high (i.e. airVol > $6b, corresponds
12081  F7CC                         ; to about 0.4gramOfAir) or if airflow sensor pulse
12082  F7CC                         ; frequency is high (>500Hz)
12083  F7CC                         ;-----------------------------------------------------------
12084  F7CC 96 E0                   ldaa    airVol                  ;                                                                             
12085  F7CE 81 6B                   cmpa    #$6b                    ;                                                                            
12086  F7D0 DC 9A                   ldd     t2_diff8                ; preload d = t2_diff8                                                                                       
12087  F7D2 22 05                   bhi     L1904                   ; branch if airVol > $6b        
12088  F7D4 1C 00 FA                cmpd    #$00fa                  ; $fa*8/1MHz = 2ms -> 500Hz
12089  F7D7 24 19                   bcc     L1907                   ; Branch if t2_diff8 > $00fa (freq<500Hz)  
12090  F7D9             
12091  F7D9                         ;----------------------------------------------------------------------------
12092  F7D9                         ; At this point we were not scaling by 2 but airVol>$6b or t2_diff8 < $00fa
12093  F7D9                         ; (freq>500Hz) we need to activate scaling
12094  F7D9                         ;----------------------------------------------------------------------------
12095  F7D9 05          L1904       asld                            ; t2_diff8 = t2_diff8*2                                                                        
12096  F7DA 03 9E 80                orm     masCasFlags, #$80       ; set scaling bit
12097  F7DD 20 11                   bra     L1906                   ; Go to rest of code                                                                                            
12098  F7DF             
12099  F7DF                         ;------------------------------------------------------
12100  F7DF                         ; We were scaling by 2, check if that needs to change 
12101  F7DF                         ;------------------------------------------------------
12102  F7DF 96 E0       L1905       ldaa    airVol                  ;                                                                                              
12103  F7E1 81 6B                   cmpa    #$6b                    ;                                                                                            
12104  F7E3 DC 9A                   ldd     t2_diff8                ; preload d=t2_diff8                                                                                              
12105  F7E5 22 09                   bhi     L1906                   ; branch if airVol>$6b                                                                        
12106  F7E7 1C 02 71                cmpd    #$0271                  ; airVol<=$6B                                                                                             
12107  F7EA 25 04                   bcs     L1906                   ; Branch if t2_diff8 < $0271                                                                    
12108  F7EC             
12109  F7EC                         ;----------------------------------------------------------------------------
12110  F7EC                         ; At this point, we were scaling by 2 but airVol<=$6B and t2_diff8 > $271
12111  F7EC                         ; we can therefore go back to no scaling
12112  F7EC                         ;----------------------------------------------------------------------------
12113  F7EC 04                      lsrd                            ; t2_diff8 = t2_diff8/2                                                                        
12114  F7ED 02 9E 7F                andm    masCasFlags, #$7f       ; reset scaling bit
12115  F7F0             
12116  F7F0                         ;----------------------------------
12117  F7F0                         ; Update t2_diff8
12118  F7F0                         ;----------------------------------
12119  F7F0 DD 9A       L1906       std     t2_diff8                ; store new value                                                                               
12120  F7F2             
12121  F7F2                         ;-------------------------------------------------------------------------------
12122  F7F2                         ; Change the interrupt trigger polarity if we are not scaling since in that case
12123  F7F2                         ; we want interrupts on both rising and falling edges of the incomming signal pulse
12124  F7F2                         ; In case of scaling by 2, the polarity remains the same on every interrupt and
12125  F7F2                         ; we therefore only receive interrupts on every two edges...
12126  F7F2                         ;-------------------------------------------------------------------------------
12127  F7F2 87 9E 80 06 L1907       brset   masCasFlags, #$80, L1908 ; branch if we are scaling
12128  F7F6 96 18                   ldaa    t2_csr                  ; We are not scaling, switch edge trigger polarity
12129  F7F8 88 02                   eora    #$02                    ; switch edge trigger polarity
12130  F7FA 97 18                   staa    t2_csr                  ;                                                                                              
12131  F7FC             
12132  F7FC                         ;----------------------------
12133  F7FC                         ; Restart timer and return
12134  F7FC                         ;----------------------------
12135  F7FC 86 0C       L1908       ldaa    #$0c                                                 
12136  F7FE B7 01 21                staa    T40_mas                                                 
12137  F801 39                      rts                                                          
12138  F802             
12139  F802             
12140  F802             
12141  F802             ;******************************************************************
12142  F802             ;
12143  F802             ; Divide the time between airflow sensor pulse by 8 with a 
12144  F802             ; timer based rounding???
12145  F802             ;
12146  F802             ; Input is the time between two airflow sensor pulse in D
12147  F802             ;
12148  F802             ; Input is also X which points to the timer T200_mas which is init 
12149  F802             ; to 130ms on every airflow sensor pulse receied.
12150  F802             ;
12151  F802             ; output: D = D/8 with timer based rounding if timer not expired (not 0)
12152  F802             ;         D = 3FFF otherwise
12153  F802             ;
12154  F802             ;******************************************************************
12155  F802 04          masFunc1    lsrd                            ;                                                                       
12156  F803 04                      lsrd                            ;                                                                       
12157  F804 04                      lsrd                            ; d = diff/8                                                      
12158  F805 DD 5E                   std     temp8                   ; temp8 = diff/8                                                                        
12159  F807 A6 00                   ldaa    $00,x                   ; a = timer value 
12160  F809 4D                      tsta                            ; why test, we just loaded in A??????                                   
12161  F80A 26 05                   bne     L1910                   ; Branch if counter not zero                                                                       
12162  F80C             
12163  F80C                         ;-------------------------------
12164  F80C                         ; Timer expired, return max value
12165  F80C                         ;-------------------------------
12166  F80C CC 3F FF                ldd     #$3fff                  ; If timer expired, return $3fff
12167  F80F 20 11                   bra     L1913                   ;                                                                                           
12168  F811             
12169  F811                         ;-----------------------------------------------
12170  F811                         ; Timer not expired, calculate value to return
12171  F811                         ; based on timeLeft (in ms)
12172  F811                         ;
12173  F811                         ;  0 <= timeLeft < 50   -> diff/8 | $2000
12174  F811                         ;
12175  F811                         ; 50 <= timeLeft < 80
12176  F811                         ;      $diff/8 <  $1000 -> diff/8 | $2000
12177  F811                         ;      $diff/8 >= $1000 -> diff/8
12178  F811                         ;
12179  F811                         ; 80 <= timeLeft < 130  -> diff/8
12180  F811                         ;
12181  F811                         ; I think this is basically some kind of round-up
12182  F811                         ; of the time between airflow sensor pulse when 
12183  F811                         ; the frequency is low. timeLeft between 0ms and 50ms
12184  F811                         ; correspond to a time between airflow pulse of 
12185  F811                         ; between 130ms to 80ms, which correspond to a 
12186  F811                         ; frequency of 7.7Hz to 20Hz. By setting value bit
12187  F811                         ; $2000, we are basically making sure the returned
12188  F811                         ; value corresponds to at least 65ms (15Hz), 
12189  F811                         ; assuming a 1MHz clock ($2000*8/1000000)
12190  F811                         ;-----------------------------------------------
12191  F811 81 10       L1910       cmpa    #$10                    ;                             
12192  F813 24 0B                   bcc     L1912                   ; Branch if time left >=80ms (16/200Hz), return value as is                           
12193  F815 81 0A                   cmpa    #$0a                    ;                             
12194  F817 25 04                   bcs     L1911                   ; Branch if time left <50ms (10/200Hz)
12195  F819 87 5E 10 03             brset   temp8, #$10, L1912      ; Timer is between 50ms<= timer <80ms, branch if diff/8 >= $1000 (value already big enough?, no need to set $2000...)                             
12196  F81D 03 5E 20    L1911       orm     temp8, #$20             ; set value bit $2000 (add that much to diff/8???)                                
12197  F820 DC 5E       L1912       ldd     temp8                   ; Load and return value                              
12198  F822 39          L1913       rts                             ;                             
12199  F823             
12200  F823             
12201  F823             
12202  F823             
12203  F823             ;******************************************************************
12204  F823             ;
12205  F823             ;
12206  F823             ; Real time Interrupt subroutine 
12207  F823             ; Frequency: 801.28Hz (see rti_freq)
12208  F823             ;
12209  F823             ;
12210  F823             ;******************************************************************
12211  F823 96 26       realTimeInt ldaa    rti_ctl                 ;                                
12212  F825 96 27                   ldaa    rti_freq                ;                                 
12213  F827 7C 00 BB    L1914b      inc     rtiCnt                  ; Increment real time interrupt counter
12214  F82A             
12215  F82A                         ;-----------------------------------------------------
12216  F82A                         ; Check if key is in start and cas signal is active
12217  F82A                         ;-----------------------------------------------------
12218  F82A 87 06 40 1E             brset   port3, #$40, L1915      ; Bail if key is not is start
12219  F82E 87 16 01 1A             brset   port5, #$01, L1915      ; Bail if cas signal is low 
12220  F832             
12221  F832                         ;------------------------------------------
12222  F832                         ; key is in start and cas signal is active
12223  F832                         ; reset a few things
12224  F832                         ;------------------------------------------
12225  F832 4F                      clra                            ;                             
12226  F833 5F                      clrb                            ;                             
12227  F834 97 61                   staa    casFlags0               ; casFlags0 = 0                              
12228  F836 97 63                   staa    enerFlags               ; enerFlags = 0                             
12229  F838 DD 70                   std     ignFallRelTime0         ; ignFallRelTime0 = 0
12230  F83A                                                      
12231  F83A                         ;------------------------------------------------------------------------------------
12232  F83A                         ; Key is in start and cas signal is active
12233  F83A                         ; If no cas interrupt is pending, enable the current coil bit  
12234  F83A                         ; and schedule an immediat output compare interrupt to energize it. 
12235  F83A                         ;
12236  F83A                         ; Basically this makes sure the coil is energized for the whole CAS pulse
12237  F83A                         ; during start of crank/cranking...
12238  F83A                         ;------------------------------------------------------------------------------------
12239  F83A 87 08 80 0E             brset   t1_csr, #$80, L1915     ; Branch if cas interrupt is pending?                                
12240  F83E 96 7B                   ldaa    tdcMask0                ; a = $02 or $04                             
12241  F840 48                      asla                            ; a = $04 or $08                            
12242  F841 43                      coma                            ; a = ~($04 or $08)                            
12243  F842 94 19                   anda    t3_csr0                 ; reset that bit, i.e. energize that coil at scheduled time
12244  F844 97 19                   staa    t3_csr0                 ; update t3_csr0                              
12245  F846 DE 29                   ldx     t3_clock1               ;                                    
12246  F848 08                      inx                             ;                             
12247  F849 08                      inx                             ; x = t3_clock1 + 2, basically in a few microsec                           
12248  F84A DF 2B                   stx     t3_outCmpWr             ; Schedule interrupt for "now" on first output compare register
12249  F84C             
12250  F84C                         ;------------------------------------------------
12251  F84C                         ; increament rtiCnt48 and loop from 47 to 0...
12252  F84C                         ; If we loop to 0, also reset the egr and boost 
12253  F84C                         ; control solenoid output, i.e. this is the start
12254  F84C                         ; of the pulswidth modulation cycle
12255  F84C                         ;------------------------------------------------
12256  F84C D6 BC       L1915       ldab    rtiCnt48                ; b = old rtiCnt48
12257  F84E 5C                      incb                            ;                             
12258  F84F D7 BC                   stab    rtiCnt48                ; rtiCnt48 = old rtiCnt48 + 1                                
12259  F851 C1 30                   cmpb    #$30                    ;                             
12260  F853 25 06                   bcs     L1916                   ; Branch if  old rtiCnt48 + 1 < 48
12261  F855 5F                      clrb                            ; b = 0                            
12262  F856 D7 BC                   stab    rtiCnt48                ; rtiCnt48 = 0                                                                                                                                              
12263  F858 02 16 D7                andm    port5, #$d7             ; When rtiCnt48 reaches 48, reset port5.5 and port5.3 
12264  F85B             
12265  F85B                         ;-----------------------------------------------------------
12266  F85B                         ; Set the egr solenoid output if time has come (duty cycle)
12267  F85B                         ;-----------------------------------------------------------
12268  F85B F1 01 7E    L1916       cmpb    egrDuty                 ; 
12269  F85E 25 03                   bcs     L1917                   ; Branch if rtiCnt48 < egrDuty                                                                                                                                           
12270  F860 03 16 08                orm     port5, #$08             ; Set the egr solenoid                                                                                            
12271  F863             
12272  F863                         ;-------------------------------------------------------------------------
12273  F863                         ; Set the boost control solenoid output if time has come (duty cycle)
12274  F863                         ;-------------------------------------------------------------------------
12275  F863 F1 01 81    L1917       cmpb    bcsDuty                 ; Boost control solenoid duty cycle, second threshold?                                                                                         
12276  F866 25 03                   bcs     L1918                   ; Branch if rtiCnt48 < egrDuty                                                                                                                                           
12277  F868 03 16 20                orm     port5, #$20             ; 
12278  F86B                                                                                                                                                                        
12279  F86B                         ;-------------------------------------------
12280  F86B                         ; At this point b = new value of rtiCnt48
12281  F86B                         ;
12282  F86B                         ; Update boost gauge output at 801.28Hz
12283  F86B                         ;-------------------------------------------
12284  F86B B6 01 7F    L1918       ldaa    bGaugeODuty             ; a = bGaugeODuty ("off-duty" cycle)
12285  F86E C1 18                   cmpb    #$18                    ; 
12286  F870 25 07                   bcs     L1919                   ; branch if rtiCnt48 < 24                                                                     
12287  F872 C0 18                   subb    #$18                    ; b = rtiCnt48-24 (we only need a value from 0 to 24 here, use 24 to 48 as a new 0 to 24...)
12288  F874 8F A2 10 01             brclr   state3, #$10, L1919     ; Branch if notRotating clear                                                                           
12289  F878 4C                      inca                            ; Engine not rotating, a = bGaugeODuty+1 (why?, wiggle the needle a bit?)                                                                        
12290  F879 5D          L1919       tstb                            ; 
12291  F87A 26 03                   bne     L1920                   ; Branch if rtiCnt48 != 0                                                                          
12292  F87C 02 2F FB                andm    port6, #$fb             ; rtiCnt48=0, start with boost gauge output = 0 at the beginning of cycle
12293  F87F 11          L1920       cba                             ; 
12294  F880 22 03                   bhi     L1921                   ; Branch if bGaugeODuty > rtiCnt48                                                                          
12295  F882 03 2F 04                orm     port6, #$04             ; Change boost gauge output to 1 when rtiCnt48 >= bGaugeODuty
12296  F885             L1921       .equ    $                       ;   
12297  F885             
12298  F885                         ;-----------------------------------------------------
12299  F885                         ; Branch to next section at 400Hz if time has come
12300  F885                         ;-----------------------------------------------------
12301  F885 8F BB 01 01 L1921b      brclr   rtiCnt, #$01, L1922     ; Branch once out of two times
12302  F889 3B                      rti                             ;                                                                       
12303  F88A             
12304  F88A             
12305  F88A             
12306  F88A             
12307  F88A             ;******************************************************************
12308  F88A             ;
12309  F88A             ;
12310  F88A             ; Code executed at 1/2 rate (~400Hz)
12311  F88A             ;
12312  F88A             ;
12313  F88A             ;******************************************************************
12314  F88A                         ;--------------------------------------------------------------------------------
12315  F88A                         ; Although we are still in interrupt code , we will re-enable interrupts
12316  F88A                         ; for the important ones (the coil and cas interrupts) until we get out of here
12317  F88A                         ;--------------------------------------------------------------------------------
12318  F88A 02 08 F7    L1922       andm    t1_csr, #$f7             ; reset 0000 1000, disable interrupts from injector 1???
12319  F88D 02 18 E7                andm    t2_csr, #$e7             ; reset 0001 1000 disable interrupts from injectors 2,3,4 and airflow sensor???
12320  F890 02 26 BF                andm    rti_ctl, #$bf            ; disable interrupts from real time interrupt (we are already in it and it is not re-entrant...)
12321  F893 02 11 EF                andm    sci_scr, #$ef            ; Disable serial port rx interrupt 
12322  F896 0E                      cli                              ; Re-enable all interrupts that were not disabled                                                                                         
12323  F897                                                                                 
12324  F897                         ;--------------------------------------------------------------------------------
12325  F897                         ; Speed sensor update:
12326  F897                         ; At 100km/h, reed switch sensor will generate ~reedHz=69Hz square wave (~40cm/cycle)
12327  F897                         ; vssValue will reflect the number of interrupt calls during one complete cycle,
12328  F897                         ; i.e. the quare wave period measured in 1/400sec
12329  F897                         ;--------------------------------------------------------------------------------
12330  F897 96 C4                   ldaa    vssCnt1                 ;                                                                                                                       
12331  F899 27 03                   beq     L1923                   ;                                                                                                                       
12332  F89B 4A                      deca                            ;                                                                                                                      
12333  F89C 97 C4                   staa    vssCnt1                 ;                                                                                                                       
12334  F89E 96 C5       L1923       ldaa    vssCnt2                 ;                                                                                                                       
12335  F8A0 27 03                   beq     L1924                   ;                                                                                                                       
12336  F8A2 4A                      deca                            ;                                                                                                                      
12337  F8A3 97 C5                   staa    vssCnt2                 ;                                                                                                                       
12338  F8A5 D6 BD       L1924       ldab    rtiReedFlags            ;                                                                                                                       
12339  F8A7 79 00 BD                rol     rtiReedFlags            ;                                                                                                                       
12340  F8AA 96 02                   ldaa    port1                   ;                                                                                                                        
12341  F8AC 49                      rola                            ;                                                                                                                      
12342  F8AD 76 00 BD                ror     rtiReedFlags            ; rtiReedFlags.7 contains latest REED switch value                                                                             
12343  F8B0 D8 BD                   eorb    rtiReedFlags            ; B.7 = 1 if reed switch value changed                                                                                  
12344  F8B2 2B 08                   bmi     L1925                   ; Branch if Reed switch value changed                                                                                   
12345  F8B4 96 C5                   ldaa    vssCnt2                 ; No change in reed switch value                                                                                        
12346  F8B6 26 16                   bne     L1927                   ; branch if C5 not yet 0                                                                                                
12347  F8B8 86 E2                   ldaa    #$e2                    ;                                                                                                                       
12348  F8BA 20 10                   bra     L1926                   ; vssCnt reached 0, prepare to store E2 in speedSensor (lowest possible speed)                                          
12349  F8BC             
12350  F8BC                         ;-----------------------------------
12351  F8BC                         ; Reed switch value changed, 
12352  F8BC                         ; update speedSensor pulse counter
12353  F8BC                         ;-----------------------------------
12354  F8BC C6 C8       L1925       ldab    #$c8                    ;                                                                                                                                                      
12355  F8BE D7 C4                   stab    vssCnt1                 ; Re-initialize vssSlowCnt                                                                                                                              
12356  F8C0 87 BD 80 0A             brset   rtiReedFlags, #$80, L1927 ; branch if new value is 1                                                                                                                               
12357  F8C4 86 E2                   ldaa    #$e2                    ; Reed switch value just changed to 0..                                                                                                                
12358  F8C6 90 C5                   suba    vssCnt2                 ; A = # pulses counted for the last interval                                                                                                            
12359  F8C8 C6 E2                   ldab    #$e2                    ;                                                                                                                                                      
12360  F8CA D7 C5                   stab    vssCnt2                 ; Re-Initialize vssCnt                                                                                                                                  
12361  F8CC 97 C6       L1926       staa    vss                     ; Store new speedSensor value (number of times interupt was called during an entire pulse (falling edge to falling edge)                                
12362  F8CE             
12363  F8CE             L1927       .equ    $
12364  F8CE             
12365  F8CE 8F BB 03 03 L1927b      brclr   rtiCnt, #$03, L1928     ; branch to other stuff at a frequency "real time int freq."/4                                                                                                       
12366  F8D2 7E F9 D8                jmp     L1950                   ;                                                                                                                                                       
12367  F8D5             
12368  F8D5                         ;----------------------------------
12369  F8D5                         ; Code executed at ~200Hz
12370  F8D5                         ; Read ADC (tpsRaw, battRaw)
12371  F8D5                         ;----------------------------------
12372  F8D5 86 0F       L1928       ldaa    #$0f                    ;                              
12373  F8D7 BD EC 0B                jsr     readAdc1                ;                                 
12374  F8DA 0E                      cli                             ;                             
12375  F8DB D7 D2                   stab    tpsRaw                  ;                               
12376  F8DD 86 0D                   ldaa    #$0d                    ;                             
12377  F8DF BD EC 0B                jsr     readAdc1                ;                                 
12378  F8E2 0E                      cli                             ;                             
12379  F8E3 D7 D0                   stab    battRaw                 ;     
12380  F8E5                         
12381  F8E5                         ;-------------------------------------------------------------------------------
12382  F8E5                         ; Decrement 5 down counters at  $be, $bf, $c0, $c1, $c2 
12383  F8E5                         ;-------------------------------------------------------------------------------
12384  F8E5 CE 00 BE                ldx     #T200_40Hz                                                 
12385  F8E8 C6 05                   ldab    #$05                    ; Loop 5 times, $be, $bf, $c0, $c1, $c2
12386  F8EA A6 00       L1929       ldaa    $00,x                                                 
12387  F8EC 27 02                   beq     L1930                   ; branch if counter already 0                              
12388  F8EE 6A 00                   dec     $00,x                   ; decrement  one of $be, $bf, $c0, $c1, $c2
12389  F8F0 08          L1930       inx                             ; go to next down counter                            
12390  F8F1 5A                      decb                            ;                             
12391  F8F2 26 F6                   bne     L1929                   ; loop                              
12392  F8F4             
12393  F8F4                         ;------------------------------------------
12394  F8F4                         ; Check/reset 40Hz counter (T200_40Hz)
12395  F8F4                         ;------------------------------------------
12396  F8F4 96 BE                   ldaa    T200_40Hz                  ;
12397  F8F6 26 06                   bne     L1931                   ; branch if first counter not 0
12398  F8F8 03 BE 05                orm     T200_40Hz, #$05            ; Reinit counter with 5 (5/200 = 25ms->40Hz)                               
12399  F8FB 03 BD 01                orm     rtiReedFlags, #$01             ; Set flag at 40 Hz for main loop events 
12400  F8FE             
12401  F8FE                         ;------------------------------------------
12402  F8FE                         ; Check T200_cop and change some output on port 6???
12403  F8FE                         ; Could be some kind of monitoring function:
12404  F8FE                         ; If main loop goes slower than 20Hz, port6.5 is not
12405  F8FE                         ; updated and external check could reset the ECU 
12406  F8FE                         ; in that case (COP)
12407  F8FE                         ;------------------------------------------
12408  F8FE 96 C2       L1931       ldaa    T200_cop                  ;                               
12409  F900 27 08                   beq     L1932                   ; Branch if T200_cop reached 0 (meaning main loop is executing at less than 20Hz???)  
12410  F902 0F                      sei                             ;                                               
12411  F903 96 2F                   ldaa    port6                   ; T200_cop not 0, toggle port6.5                             
12412  F905 88 20                   eora    #$20                    ;                             
12413  F907 97 2F                   staa    port6                   ; Toggle bit 
12414  F909 0E                      cli                                                          
12415  F90A             
12416  F90A                         ;----------------------------------------------------------------------------
12417  F90A                         ; Update knock decay:
12418  F90A                         ; Decrement knocksum by 1 every time T200s_knock expires and reload timer
12419  F90A                         ; T200s_knock with fast or slow decay constant depending on current airVol
12420  F90A                         ;----------------------------------------------------------------------------
12421  F90A 96 8C       L1932       ldaa    T200s_knock             ; a = T200s_knock, knock attenuation timer                                        
12422  F90C 27 03                   beq     L1933                   ; Branch if T200s_knock already expired
12423  F90E 4A                      deca                            ; a = T200s_knock-1                                      
12424  F90F 26 11                   bne     L1935                   ; branch if (T200s_knock-1)!=0 -> store T200s_knock-1 
12425  F911 0F          L1933       sei                             ; at this point T200s_knock = 0 or 1                                                      
12426  F912 96 8B                   ldaa    knockSum                ; a = knockSum
12427  F914 27 03                   beq     L1934                   ; Branch if knockSum = 0
12428  F916 7A 00 8B                dec     knockSum                ; knockSum = knockSum-1                                                
12429  F919 0E          L1934       cli                             ;                             
12430  F91A 86 78                   ldaa    #$78                    ; a=$78 (200Hz/120 = 1.67Hz, slow attenuation)
12431  F91C 87 53 80 02             brset   knockFlags, #$80, L1935 ; Branch if flag indicate that airVol>$49
12432  F920 86 02                   ldaa    #$02                    ; a=$02 (200Hz/2 = 100Hz, fast attenuation)
12433  F922 97 8C       L1935       staa    T200s_knock             ; store current knock attenuation count                                    
12434  F924             
12435  F924                         ;---------------------------------------------------------------
12436  F924                         ; Set iscLowBatt.7 flag if battRaw>=10V (with 0.33V hysteresis) 
12437  F924                         ; else reset it. If battRaw<10V the ISC spindle is not moved...
12438  F924                         ;---------------------------------------------------------------
12439  F924 C6 8D                   ldab    #$8d                    ; b= 10.33V = threshold                                                                           
12440  F926 B6 01 65                ldaa    iscLowBatt              ; a = iscLowBatt                                                                                   
12441  F929 2A 02                   bpl     L1936                   ; Branch if iscLowBatt.7 already set, meaning battRaw >=10v last time we were here                                                                                  
12442  F92B C6 88                   ldab    #$88                    ; reduce threshold (hysteresis) to 10.00V                                                                            
12443  F92D D1 D0       L1936       cmpb    battRaw                 ; Check battRaw against 10.00V or 10.33V                                        
12444  F92F 25 05                   bcs     L1937                   ; branch if battRaw > 10.00 or 10.33V                                        
12445  F931             
12446  F931                         ;---------------------------------------------------------------------
12447  F931                         ; battRaw <= 10.00 , clear iscLowBatt and bail, no ISC update
12448  F931                         ;---------------------------------------------------------------------
12449  F931 7F 01 65                clr     iscLowBatt              ; battRaw < 10.00 or 10.33V, clear iscLowBatt                                     
12450  F934 20 42                   bra     L1939                   ; Bail
12451  F936             
12452  F936                         ;--------------------------------------------------------------------------
12453  F936                         ; battRaw > 10.00 , set iscLowBatt.7 flag and increase iscLowBatt.0.1 counter by 1
12454  F936                         ; If counter < $03 we don't update the ISC spindle (that means that 
12455  F936                         ; battRaw has to be higher than 10.00V for 4/200 sec before we move
12456  F936                         ; the ISC spindle...
12457  F936                         ;--------------------------------------------------------------------------
12458  F936 8A 80       L1937       oraa    #$80                    ; a = iscLowBatt | $80                             
12459  F938 4C                      inca                            ; a = iscLowBatt | $80 + 1                            
12460  F939 B7 01 65                staa    iscLowBatt              ; iscLowBatt = old iscLowBatt | $80 + 1                              
12461  F93C 81 83                   cmpa    #$83                    ;                             
12462  F93E 25 38                   bcs     L1939                   ; Bail if new iscLowBatt.0.1 < $03, no ISC update                             
12463  F940 86 83                   ldaa    #$83                    ; Use max of iscLowBatt.0.1 = $03                            
12464  F942 B7 01 65                staa    iscLowBatt              ; iscLowBatt = $83 (flag set and counter = $03)                            
12465  F945             
12466  F945                         ;-------------------------
12467  F945                         ; Check ISC complement ???
12468  F945                         ;-------------------------
12469  F945 D6 4A                   ldab    iscPatrnIdx             ; preload b = iscPatrnIdx for later calc                             
12470  F947 96 49                   ldaa    iscStepCurr             ; a = iscStepCurr                               
12471  F949 43                      coma                            ;                             
12472  F94A 84 7F                   anda    #$7f                    ; a = ~iscStepCurr & $7f                             
12473  F94C 91 48                   cmpa    iscStepCom              ;                                                                                                  
12474  F94E 26 28                   bne     L1939                   ; branch if complement is incorrect???                                                        
12475  F950             
12476  F950                         ;----------------------------------
12477  F950                         ; Complement is OK, continue???
12478  F950                         ;----------------------------------
12479  F950                         ;---------------------------------------------------------------
12480  F950                         ; Section to move the ICS spindle by +/1 step if iscStepCurr != iscStepTarg
12481  F950                         ; this is where it happens...  code executed at 200Hz...
12482  F950                         ;---------------------------------------------------------------
12483  F950 96 49                   ldaa    iscStepCurr             ; a = iscStepCurr                                                                                              
12484  F952 91 FD                   cmpa    iscStepTarg             ; 
12485  F954 27 22                   beq     L1939                   ; Bail if current ISC step is what we want (no change needed)
12486  F956 4C                      inca                            ; assume a = iscStepCurr + 1                                                                                           
12487  F957 5C                      incb                            ; assume b = iscPatrnIdx + 1                                                                                           
12488  F958 25 04                   bcs     L1938                   ; Branch if iscStepCurr < iscStepTarg (tricky, carry flag is not affected by inca, incb...)
12489  F95A 4A                      deca                            ; iscStepCurr >= iscStepTarg, assumption wrong, go in the other direction                                                               
12490  F95B 4A                      deca                            ; a = iscStepCurr - 1                                                                                           
12491  F95C 5A                      decb                            ;                                                                                            
12492  F95D 5A                      decb                            ; b = iscPatrnIdx - 1                                                                                           
12493  F95E BD E4 A4    L1938       jsr     iscStepComp             ; Update iscStepCurr and iscStepCom with new values
12494  F961 D7 4A                   stab    iscPatrnIdx             ; Update iscPatrnIdx with new value
12495  F963 CE FE EA                ldx     #t_iscPattern           ; x points to t_iscPattern                                                                                              
12496  F966 C4 03                   andb    #$03                    ; b = new iscPatrnIdx & 00000011                                                                                             
12497  F968 3A                      abx                             ; x points to desired pattern                                                                                            
12498  F969 0F                      sei                             ;                                                                                             
12499  F96A 96 16                   ldaa    port5                   ; a = port5                                                                                             
12500  F96C 84 3F                   anda    #$3f                    ; a = port5 & 00111111
12501  F96E AB 00                   adda    $00,x                   ; a = (port5 & 00111111) + t_iscPattern(iscPatrnIdx)
12502  F970 97 16                   staa    port5                   ; update port5                                                                                             
12503  F972 0E                      cli                             ;                                                                                             
12504  F973 86 81                   ldaa    #$81                    ; a = $81 = 129                                                                                            
12505  F975 B7 01 65                staa    iscLowBatt              ; re-init iscLowBatt to $81
12506  F978                                                                                                                                      
12507  F978                         ;------------------------------------------------------
12508  F978                         ; Section of code to update port2.2 (up to ~L1949)
12509  F978                         ; according to TPS/rpm/airVol/idleSwitch/timer?????
12510  F978                         ;
12511  F978                         ; ????Could be airflow sensor filter reset???
12512  F978                         ;------------------------------------------------------
12513  F978 8F E6 10 05 L1939       brclr   state1, #$10, L1941     ; Branch if notRotating clear
12514  F97C             
12515  F97C                         ;-----------------------------------------
12516  F97C                         ; Engine notRotating, clear timer T40s_tps
12517  F97C                         ;-----------------------------------------
12518  F97C 7F 01 82                clr     T40s_tps                ;                                 
12519  F97F 20 50                   bra     L1948                   ;                              
12520  F981             
12521  F981                         ;----------------------------------------------------------------------------
12522  F981                         ; Engine is at least rotating,
12523  F981                         ; Check whether tpsRaw has increased by more than 1.5% and is between 26%-50% 
12524  F981                         ;----------------------------------------------------------------------------
12525  F981 7F 00 C9    L1941       clr     tempFlagTps             ; tempFlagTps = 0                                                                                                          
12526  F984 D6 D2                   ldab    tpsRaw                  ; b=tpsRaw                                                                                                        
12527  F986 96 C3                   ldaa    oldTps1                 ;                                                                                                           
12528  F988 10                      sba                             ; a = tpsDiff = oldTps1-tpsRaw 
12529  F989 23 14                   bls     L1942                   ; branch if new TPS is smaller or equal to old one                                                         
12530  F98B 81 04                   cmpa    #$04                    ; new tps higher than old one
12531  F98D 25 18                   bcs     L1944                   ; bail if tpsDiff < 4 (1.5%)                                                                            
12532  F98F 86 80                   ldaa    #$80                    ; tpsDiff is >=4                                                                                         
12533  F991 11                      cba                             ; 
12534  F992 23 13                   bls     L1944                   ; bail if tps>=50%
12535  F994 C1 43                   cmpb    #$43                    ; tps <50%
12536  F996 25 0F                   bcs     L1944                   ; bail if tps<26%                                                                                        
12537  F998 7A 00 C9                dec     tempFlagTps             ; at this point tpsDiff and 26%<= tps <50%, set tempFlagTps=$ff                                                                         
12538  F99B 86 0E                   ldaa    #$0e                    ; set T40s_tps to $0e (0.35s) after branch                                                                            
12539  F99D 20 05                   bra     L1943                   ;                                                                                                          
12540  F99F C1 43       L1942       cmpb    #$43                    ; New tps smaller than old one
12541  F9A1 25 04                   bcs     L1944                   ; branch if tps < 26%                                  
12542  F9A3 4F                      clra                            ; tps>26%, clear timer T40s_tps                                       
12543  F9A4 B7 01 82    L1943       staa    T40s_tps                ;                                                             
12544  F9A7             
12545  F9A7                         ;-----------------------------------------------------------------
12546  F9A7                         ; At this point b=tpsRaw and
12547  F9A7                         ; if TPS has increased by more than 1.5% and new value is between 26% and 50%
12548  F9A7                         ;    T40s_tps = $0e and tempFlagTps = $ff 
12549  F9A7                         ; else
12550  F9A7                         ;     tempFlagTps = $00
12551  F9A7                         ;     if new TPS<26%
12552  F9A7                         ;        previous T40s_tps is reset to 0
12553  F9A7                         ;-----------------------------------------------------------------
12554  F9A7 96 C9       L1944       ldaa    tempFlagTps             ;                                                                                                           
12555  F9A9 2B 21                   bmi     L1947                   ; Branch if tempFlagTps=FF (TPS increased to between 26% and 50%)                                     
12556  F9AB C1 43                   cmpb    #$43                    ; 
12557  F9AD 24 0D                   bcc     L1945                   ; branch if tps>= 26%                                                                                       
12558  F9AF B6 01 82                ldaa    T40s_tps                ; tps<26%                                                                                                          
12559  F9B2 26 18                   bne     L1947                   ; Branch if timer not expired                                                                                                          
12560  F9B4 C1 31                   cmpb    #$31                    ; tps<26% and timer expired
12561  F9B6 24 04                   bcc     L1945                   ; branch if tps>=19%                                                                                        
12562  F9B8 C1 0A                   cmpb    #$0a                    ; tps<19% and timer expired
12563  F9BA 24 10                   bcc     L1947                   ; branch if TPS>=4%                                                                                         
12564  F9BC                                                         ; tps<4% and timer expired
12565  F9BC             
12566  F9BC                         ;---------------------------------------------------------------------
12567  F9BC                         ; no TPS increase to 26% and 50%
12568  F9BC                         ; and tps>=26%
12569  F9BC                         ;     or 19%<=tps<26% and timer expired
12570  F9BC                         ;     or tps<4% and timer expired
12571  F9BC                         ; ......
12572  F9BC                         ;---------------------------------------------------------------------
12573  F9BC 96 DD       L1945       ldaa    rpm31                   ;                                                                                                                                                 
12574  F9BE 81 20                   cmpa    #$20                    ; 1000rpm
12575  F9C0 25 06                   bcs     L1946                   ; branch if rpm<1000                                                                                                                             
12576  F9C2 96 E0                   ldaa    airVol                  ; rpm>=1000                                                                                                                                                 
12577  F9C4 81 40                   cmpa    #$40                    ;                                                                                                                                                
12578  F9C6 24 09                   bcc     L1948                   ; branch if airVol >= $40                                                                                                                         
12579  F9C8 96 06       L1946       ldaa    port3                   ;                                                                                                                                                 
12580  F9CA 2A 05                   bpl     L1948                   ; branch if idle switch off                                                                                                                       
12581  F9CC             
12582  F9CC                         ;---------------------------------------------------------------------
12583  F9CC                         ; Reset port2.2 (Airflow sensor active filter reset?) 
12584  F9CC                         ; under a bunch of conditions 
12585  F9CC                         ;
12586  F9CC                         ; Not completly checked...
12587  F9CC                         ; TPS increased to between 26% and 50%
12588  F9CC                         ; or tps<26% and timer not expired
12589  F9CC                         ; or 4%<=tps<19% and timer expired
12590  F9CC                         ; or no TPS increase to 26% and 50%                  
12591  F9CC                         ;        and tps>=26%                                    
12592  F9CC                         ;           or 19%<=tps<26% and timer expired           
12593  F9CC                         ;           or tps<4% and timer expired                 
12594  F9CC                         ;    and idlSwOn and [ rpm<1000 or ( rpm>1000 and airVol<$40) ]
12595  F9CC                         ; .....
12596  F9CC                         ;---------------------------------------------------------------------
12597  F9CC 02 03 FB    L1947       andm    port2, #$fb             ; reset port output??????                                                                                                                                        
12598  F9CF 20 03                   bra     L1949                   ;             
12599  F9D1                                                                                                                                                             
12600  F9D1                         ;---------------------------------------------------------------------
12601  F9D1                         ; Set port2.2 (Airflow sensor active filter reset?) 
12602  F9D1                         ; under a bunch of conditions...
12603  F9D1                         ;---------------------------------------------------------------------
12604  F9D1 03 03 04    L1948       orm     port2, #$04             ; Set port output???? 
12605  F9D4             
12606  F9D4                         ;--------------------------
12607  F9D4                         ; Update oldTps1 at 200Hz
12608  F9D4                         ;--------------------------
12609  F9D4 96 D2       L1949       ldaa    tpsRaw                  ;                                                                                                                                               
12610  F9D6 97 C3                   staa    oldTps1                 ;                                                                                                                                                  
12611  F9D8             
12612  F9D8                         ;----------------------------------------------
12613  F9D8                         ; Update oldTps2 and tpsDiffMax1 at 100Hz 
12614  F9D8                         ;----------------------------------------------
12615  F9D8 87 BB 07 10 L1950       brset   rtiCnt, #$07, L1953     ; Branch if any of those bits set -> branch 7 out of 8 times
12616  F9DC 96 D2                   ldaa    tpsRaw                  ; Code executed at ~800Hz/8=100Hz, a=tpsRaw                           
12617  F9DE 16                      tab                             ; b=tpsRaw                             
12618  F9DF 90 C7                   suba    oldTps2                 ; a = tpsRaw-oldTps2                             
12619  F9E1 24 01                   bcc     L1951                   ; branch if result positive (tpsRaw>=oldTps2)                             
12620  F9E3 4F                      clra                            ; Use min of 0                            
12621  F9E4 91 C8       L1951       cmpa    tpsDiffMax1             ;                              
12622  F9E6 23 02                   bls     L1952                   ; branch if  (tpsRaw-oldTps2)<=tpsDiffMax1                             
12623  F9E8 97 C8                   staa    tpsDiffMax1             ; tpsDiffMax1 = max(tpsDiffMax1, (tpsRaw-oldTps2))                               
12624  F9EA D7 C7       L1952       stab    oldTps2                 ; oldTps2 = tpsRaw                             
12625  F9EC             
12626  F9EC                         ;------------------------------------------------------
12627  F9EC                         ; Update section at 200Hz (800Hz/4) if time has come
12628  F9EC                         ;------------------------------------------------------
12629  F9EC 87 BB 03 0D L1953       brset   rtiCnt, #$03, L1955     ; Branch if any of those bits set -> branch 3 out of 4 times                                
12630  F9F0             
12631  F9F0                         ;-------------------------------
12632  F9F0                         ; Code executed at 200Hz
12633  F9F0                         ;-------------------------------
12634  F9F0                         ;------------------------------------------------
12635  F9F0                         ; Update T200s_sInj timer and reset sInjEnr 
12636  F9F0                         ; to 0 if timer is expired
12637  F9F0                         ;
12638  F9F0                         ; Basically brings down enrichement to 0 a 
12639  F9F0                         ; little while after it is not needed anymore
12640  F9F0                         ;------------------------------------------------
12641  F9F0 B6 01 10                ldaa    T200s_sInj              ; 
12642  F9F3 27 05                   beq     L1954                   ; Branch if T200s_sInj already at 0                             
12643  F9F5 7A 01 10                dec     T200s_sInj              ; decrement T200s_sInj                             
12644  F9F8 26 03                   bne     L1955                   ; Bail if T200s_sInj not 0 yet                             
12645  F9FA 7F 01 11    L1954       clr     sInjEnr                 ;
12646  F9FD                                                           
12647  F9FD                         ;-----------------------------------------------------
12648  F9FD                         ; Update section at 100Hz (800Hz/8) if time has come
12649  F9FD                         ;-----------------------------------------------------
12650  F9FD 87 BB 07 62 L1955       brset   rtiCnt, #$07, L1962     ; Branch if any of those bits set -> branch 7 out of 8 times                                
12651  FA01             
12652  FA01                         ;-------------------------------
12653  FA01                         ; Code executed at 100Hz
12654  FA01                         ;-------------------------------
12655  FA01                         ;------------------------------------------------------------------
12656  FA01                         ; Section to increase simultaneous fuel injection time (sInjPw)
12657  FA01                         ; when the gas pedal is being pressed, simultaneous injection
12658  FA01                         ; during acceleration... 
12659  FA01                         ;------------------------------------------------------------------
12660  FA01 96 D2                   ldaa    tpsRaw                  ; a = tpsRaw
12661  FA03 B0 01 0E                suba    oldTps3                 ; a = tpsRaw - oldTps3                              
12662  FA06 24 01                   bcc     L1956                   ; Branch if result positive                              
12663  FA08 4F                      clra                            ; Use min of 0                             
12664  FA09 B7 01 0F    L1956       staa    tpsDiff100              ; tpsDiff100 = max(tpsRaw - oldTps3, 0)                              
12665  FA0C 81 03                   cmpa    #$03                                                 
12666  FA0E 25 4A                   bcs     L1961                   ; Bail if (tpsRaw - oldTps3) < 3                              
12667  FA10 F6 01 0E                ldab    oldTps3                 ;                              
12668  FA13 F1 01 13                cmpb    sInjTpsMax              ;                              
12669  FA16 24 42                   bcc     L1961                   ; Bail if oldTps3 >= sInjTpsMax                             
12670  FA18 87 A2 35 3E             brset   state3, #$35, L1961     ; Bail if "rotatingStopInj but not runningFast" or notRotating or rev limiter active or startingToCrank                                  
12671  FA1C 87 06 80 3A             brset   port3, #$80, L1961      ; Bail if idle switch on
12672  FA20                         
12673  FA20                         ;---------------------------------------------------------------------
12674  FA20                         ; At this point, idle switch is off, engine is "running normally?",
12675  FA20                         ; (tpsRaw - oldTps3) >=3 and oldTps3 < sInjTpsMax
12676  FA20                         ;
12677  FA20                         ; Basically means the gas pedal is moving forward, acceleration...
12678  FA20                         ;
12679  FA20                         ; Increase simultaneous fuel injection time if not already at max???? 
12680  FA20                         ; Kind of acceleration enrichement when still using simultaneous 
12681  FA20                         ; injection????
12682  FA20                         ;---------------------------------------------------------------------
12683  FA20 B6 01 11                ldaa    sInjEnr                 ; a = sInjEnr                              
12684  FA23 B1 01 12                cmpa    sInjEnrMax              ;                               
12685  FA26 24 32                   bcc     L1961                   ; Bail if sInjEnr >= sInjEnrMax (maximum enrichment reached)                             
12686  FA28 86 28                   ldaa    #$28                    ;                             
12687  FA2A B7 01 10                staa    T200s_sInj              ; Init timer T200s_sInj to $28 (0.2s)                             
12688  FA2D F6 01 0F                ldab    tpsDiff100              ; b = tpsDiff100                              
12689  FA30 54                      lsrb                            ;                             
12690  FA31 54                      lsrb                            ; b = tpsDiff100/4                            
12691  FA32 C1 08                   cmpb    #$08                    ;                             
12692  FA34 25 02                   bcs     L1957                   ; Branch if tpsDiff100/4 < 8                              
12693  FA36 C6 08                   ldab    #$08                    ; Use max of 8                            
12694  FA38 CE FC FA    L1957       ldx     #t_sInjEnr              ; x = t_sInjEnr                               
12695  FA3B 3A                      abx                             ; s = t_sInjEnr + tpsDiff100/4                           
12696  FA3C A6 00                   ldaa    $00,x                   ; a = t_sInjEnr(tpsDiff100)                             
12697  FA3E F6 01 16                ldab    sInjEnrInc              ; b = sInjEnrInc                             
12698  FA41 3D                      mul                             ; d = sInjEnrInc * t_sInjEnr(tpsDiff100)                            
12699  FA42 05                      asld                            ; d = 2 * sInjEnrInc * t_sInjEnr(tpsDiff100)                           
12700  FA43 25 04                   bcs     L1958                   ; Branch to use max if overflow                             
12701  FA45 81 15                   cmpa    #$15                    ;                             
12702  FA47 25 03                   bcs     L1959                   ; Branch if 2 * sInjEnrInc * t_sInjEnr(tpsDiff100) < 15*256                             
12703  FA49 86 15       L1958       ldaa    #$15                    ; 
12704  FA4B 5F                      clrb                            ; Use Max of d=$1500 (5.3ms)
12705  FA4C 36          L1959       psha                            ; st0 = 2/256 * sInjEnrInc * t_sInjEnr(tpsDiff100)
12706  FA4D F3 01 14                addd    sInjPw                  ; d = 2 * sInjEnrInc * t_sInjEnr(tpsDiff100) + sInjPw                                
12707  FA50 FD 01 14                std     sInjPw                  ; sInjPw = old sInjPw + 2 * sInjEnrInc * t_sInjEnr(tpsDiff100)
12708  FA53 33                      pulb                            ; b =  1/128 * sInjEnrInc * t_sInjEnr(tpsDiff100)
12709  FA54 FB 01 11                addb    sInjEnr                 ;                               
12710  FA57 F7 01 11                stab    sInjEnr                 ; sInjEnr = sInjEnr + 1/128 * sInjEnrInc * t_sInjEnr(tpsDiff100)
12711  FA5A                         
12712  FA5A                         ;----------------------------                                               
12713  FA5A                         ; Update oldTps3 at 100Hz)
12714  FA5A                         ;----------------------------                                               
12715  FA5A 96 D2       L1961       ldaa    tpsRaw                                                 
12716  FA5C B7 01 0E                staa    oldTps3                                                 
12717  FA5F 0F                      sei                                                          
12718  FA60             
12719  FA60                         ;-------------------------------------------------------------                                               
12720  FA60                         ; Schedule simultaneous injection injector activation and 
12721  FA60                         ; deactivation at 100Hz, i.e. every 10ms, this is what the 
12722  FA60                         ; tech manual says...
12723  FA60                         ;-------------------------------------------------------------                                               
12724  FA60 BD F7 0B                jsr     simInject                                                 
12725  FA63             
12726  FA63                         ;----------------------------------
12727  FA63                         ; Re-enable interrupts and return
12728  FA63                         ;----------------------------------
12729  FA63 0F          L1962       sei                                                          
12730  FA64 03 08 18                orm     t1_csr, #$18            ; Re-enable interrupt for                                                                                                      
12731  FA67 03 18 18                orm     t2_csr, #$18            ; Re-enable interrupt for                                                                                                    
12732  FA6A 03 26 40                orm     rti_ctl, #$40           ; Re-enable interrupt for                                                                                                     
12733  FA6D 8F FA 02 03             brclr   obdFlags, #$02, L1963   ; Branch if serial output on port 2 was previously init to 1 (means serial rx is also init)                               
12734  FA71 03 11 10                orm     sci_scr, #$10           ; re-enable serial port "rx interrupt"
12735  FA74 3B          L1963       rti                                                          
12736  FA75             
12737  FA75             
12738  FA75             
12739  FA75             ;******************************************************************
12740  FA75             ;
12741  FA75             ; Output compare interrupt 3
12742  FA75             ;
12743  FA75             ; Triggered when the output compare interrupt for 
12744  FA75             ; coil energization or ignition is triggered.
12745  FA75             ;
12746  FA75             ;
12747  FA75             ;******************************************************************
12748  FA75 8D 01       outCompInt3 bsr     coilFunc                                                 
12749  FA77 3B                      rti                                                          
12750  FA78             
12751  FA78             
12752  FA78             
12753  FA78             ;******************************************************************
12754  FA78             ;
12755  FA78             ;
12756  FA78             ; Called by code and interrupt subroutine when an output 
12757  FA78             ; compare interrupt for coil energization or ignition is
12758  FA78             ; triggered or pending.
12759  FA78             ;
12760  FA78             ;
12761  FA78             ;******************************************************************
12762  FA78                         ;-------------------------------------
12763  FA78                         ; Flush both output compare registers 
12764  FA78                         ; (write fartest possible time)
12765  FA78                         ;-------------------------------------
12766  FA78 DE 29       coilFunc    ldx     t3_clock1               ; x = t3_clock1                                                                      
12767  FA7A 09                      dex                             ;                                                              
12768  FA7B DF 2B                   stx     t3_outCmpWr             ; re-init count of first register
12769  FA7D 96 1A                   ldaa    t3_csr1                 ;                                                                     
12770  FA7F DF 2B                   stx     t3_outCmpWr             ; re-init count of second register                                     
12771  FA81             
12772  FA81                         ;-------------------------------------------
12773  FA81                         ; Branch to the right section depending on
12774  FA81                         ; the current state of affairs
12775  FA81                         ;-------------------------------------------
12776  FA81 87 63 02 25             brset   enerFlags, #$02, L1968       ; Branch if coil energization was scheduled and coil is therefore now energized?
12777  FA85 8F 63 01 39             brclr   enerFlags, #$01, L1971       ; Bail if enerFlags = 0, nothing needs doing.
12778  FA89             
12779  FA89                         ;----------------------------------------------------------------------
12780  FA89                         ; At this point enerFlags=1, the flag indicates coil was energized
12781  FA89                         ; and the current interrupt was for coil ignition, check if we should
12782  FA89                         ; schedule schedule coil energization for the next cylinder
12783  FA89                         ;----------------------------------------------------------------------
12784  FA89 87 62 01 35             brset   ignFallFlags, #$01, L1971    ; Bail if we decided ignition would be scheduled from the cas falling edge, In that case, energization is unlikely to be done before the cas rising edge...
12785  FA8D 8F 83 FE 15             brclr   tdcCasCount, #$fe, L1967     ; Branch if tdcCasCount = 0 or 1, we are starting to crank??                                     
12786  FA91             
12787  FA91                         ;---------------------------------------------------------------------------
12788  FA91                         ; At this point enerFlags=1 and ignFallFlags = 0 and tdcCasCount >= 2 
12789  FA91                         ; 
12790  FA91                         ; Schedule interrupt to energize the coil of the next cylinder 
12791  FA91                         ; using energization time and TDC of the next cylinder.
12792  FA91                         ;
12793  FA91                         ; This might be done in case the energization time falls before the cas
12794  FA91                         ; rising edge of the next cylinder (at high rpm). This is the only 
12795  FA91                         ; place we can schedule such an event. If on the cas rising edge the
12796  FA91                         ; energization already occured and the coil is energized, the code will not 
12797  FA91                         ; schedule energization again...If it did not occure, the output compare 
12798  FA91                         ; register will be flushed and energization will be scheduled again?
12799  FA91                         ;
12800  FA91                         ; Note that enerFlags is set to 0 instead of 1. Probably because the coil
12801  FA91                         ; being energized is on the next cylinder, not the current one. The 
12802  FA91                         ; energization we are doing here is more of a precautionary measure????
12803  FA91                         ;
12804  FA91                         ; Note that the second output compare register was already flushed at 
12805  FA91                         ; the beginning of subroutine. 
12806  FA91                         ;---------------------------------------------------------------------------
12807  FA91 DC 29                   ldd     t3_clock1                ; d = t3_clock1                                  
12808  FA93 C3 00 09                addd    #$0009                   ; d = t3_clock1 + $09                             
12809  FA96 1D 78                   cmpd1   enerAbsTimeNext0         ;                             
12810  FA98 2A 02                   bpl     L1966                    ; Branch to use t3_clock1 + $09 is enerAbsTimeNext0 is "in the past"
12811  FA9A DC 78                   ldd     enerAbsTimeNext0         ; enerAbsTimeNext0 is valid, use it                          
12812  FA9C DD 2B       L1966       std     t3_outCmpWr              ; Schedule interrupt on first output compare register                                  
12813  FA9E 96 7C                   ldaa    tdcMask1                 ; a = next tdc mask, not the current one..., $02 or $04
12814  FAA0 48                      asla                             ; a = $04 or $08                           
12815  FAA1 43                      coma                             ; a = ~($04 or $08)                           
12816  FAA2 94 19                   anda    t3_csr0                  ; reset next tdc coil bit, energize that coil at the scheduled time                            
12817  FAA4 97 19                   staa    t3_csr0                  ; update t3_csr0                            
12818  FAA6             
12819  FAA6                         ;--------------------
12820  FAA6                         ; Set enerFlags = 0
12821  FAA6                         ;--------------------
12822  FAA6 4F          L1967       clra                             ;                            
12823  FAA7 97 63                   staa    enerFlags                ;                             
12824  FAA9 39                      rts                              ;                            
12825  FAAA             
12826  FAAA                         ;------------------------------------------------------
12827  FAAA                         ; At this point enerFlags=2, coil energization was 
12828  FAAA                         ; scheduled and coil is therefore now energized...
12829  FAAA                         ;
12830  FAAA                         ; Schedule interrupt  on first output compare register
12831  FAAA                         ; to provoke ignition at the specified time
12832  FAAA                         ; Second output compare register was already 
12833  FAAA                         ; flushed at the beginning of subroutine
12834  FAAA                         ;------------------------------------------------------
12835  FAAA 87 62 01 10 L1968       brset   ignFallFlags, #$01, L1970 ; Branch if flag indicates ignition is to be scheduled on the cas falling edge, it will be done at that time...                              
12836  FAAE DC 29                   ldd     t3_clock1                 ; d = t3_clock1                                   
12837  FAB0 C3 00 08                addd    #$0008                    ; d = t3_clock1 + $08                              
12838  FAB3 1D 76                   cmpd1   ignTime0                  ;                               
12839  FAB5 2A 02                   bpl     L1969                     ; Branch to use t3_clock1 + $08 if ignTime0 is "in the past"                            
12840  FAB7 DC 76                   ldd     ignTime0                  ; ignTime0 is valid, use it                           
12841  FAB9 DD 2B       L1969       std     t3_outCmpWr               ; Schedule interrupt on first output compare register                                  
12842  FABB 03 19 0C                orm     t3_csr0, #$0c             ; Set both coil bits, i.e. provoke ignition on the energized coil at the scheduled time?                              
12843  FABE             
12844  FABE                         ;----------------------------------------------------
12845  FABE                         ; Set enerFlags = 1 indicating coil is energized?
12846  FABE                         ;----------------------------------------------------
12847  FABE 86 01       L1970       ldaa    #$01                    ;                             
12848  FAC0 97 63                   staa    enerFlags               ;                              
12849  FAC2 39          L1971       rts                             ;                             
12850  FAC3             
12851  FAC3             
12852  FAC3             
12853  FAC3             ;******************************************************************
12854  FAC3             ;
12855  FAC3             ;
12856  FAC3             ; Interrupt subroutine when a failure occurs (clock monitor??)
12857  FAC3             ;
12858  FAC3             ;
12859  FAC3             ;******************************************************************
12860  FAC3                         ;------------------------------------
12861  FAC3                         ; Clear flag ?????
12862  FAC3                         ;------------------------------------
12863  FAC3 02 14 BF    failureInt  andm    ramControl, #$bf             ; Reset 01000000 since we are here, disable ram??? or other function????
12864  FAC6             
12865  FAC6                         ;-----------------------------------------
12866  FAC6                         ; Disable all outputs, ie.e re-init all 
12867  FAC6                         ; data direction registers to all inputs 
12868  FAC6                         ;-----------------------------------------
12869  FAC6 4F                      clra                            ;                             
12870  FAC7 5F                      clrb                            ;                             
12871  FAC8 DD 00                   std     p1_ddr                  ; Initialize data direction registers for ports 1,2,3,4,5 to all input
12872  FACA DD 04                   std     p3_ddr                  ;                               
12873  FACC 97 15                   staa    p5_ddr                  ; 
12874  FACE             
12875  FACE                         ;---------------------------------------------------------------
12876  FACE                         ; Wait for an interrupt, I assume only system reset  
12877  FACE                         ; can be called since other interrupts have lower priority, 
12878  FACE                         ; might be triggered by above action on ramControl???
12879  FACE                         ;---------------------------------------------------------------
12880  FACE 3E                      wai                             ; Wait for an interrupt to jump to codeStart?
12881  FACF             
12882  FACF                         ;-----------------------------------------
12883  FACF                         ; I assume we never get here so that 
12884  FACF                         ; code continuation is from codeStart...
12885  FACF                         ;-----------------------------------------
12886  FACF             
12887  FACF                                                                 
12888  FACF                                                                 
12889  FACF                                                                  
12890  FACF             ;******************************************************************
12891  FACF             ;
12892  FACF             ; Code snipet from the first subroutine (jumps here and then 
12893  FACF             ; jumps back to first subroutine)
12894  FACF             ;
12895  FACF             ; This code might have been put here in case the cop function
12896  FACF             ; above (failureInt) ever skips the "wai" opcode above?? That 
12897  FACF             ; way we at least are executing some real code instead of 
12898  FACF             ; trying to execute the table content located further. Cop
12899  FACF             ; function should kick-in in a short while if everything
12900  FACF             ; is not back to normal...
12901  FACF             ;
12902  FACF             ;******************************************************************
12903  FACF                         ;----------------------------------------------------
12904  FACF                         ; We are in closed loop mode, limit the range
12905  FACF                         ; of o2Fbk to $4d-$d6 or $2a-$d6 depending on ect 
12906  FACF                         ;----------------------------------------------------
12907  FACF 96 E9       L1973       ldaa    o2Fbk                   ; a = o2Fbk                              
12908  FAD1 D6 D3                   ldab    ectFiltered             ; b = ectFiltered                                    
12909  FAD3 C1 1C                   cmpb    #$1c                    ; 86degC                              
12910  FAD5 25 10                   bcs     L1975                   ; Branch if temperature(ectFiltered) > 86degC                              
12911  FAD7             
12912  FAD7                         ;-------------------------------------------------------
12913  FAD7                         ; temperature(ectFiltered) <= 86degC 
12914  FAD7                         ; Check for o2Fbk min and max of $4d and $d6
12915  FAD7                         ;-------------------------------------------------------
12916  FAD7 81 4D                   cmpa    #$4d                    ;                             
12917  FAD9 24 04                   bcc     L1974                   ; Branch if o2Fbk >= $4d
12918  FADB 86 4D                   ldaa    #$4d                    ; Use min of $4d
12919  FADD 20 0D                   bra     L1976                   ; Branch to store new o2Fbk
12920  FADF 81 D6       L1974       cmpa    #$d6                    ;                             
12921  FAE1 25 0C                   bcs     L1977                   ; Branch if o2Fbk < $d6                               
12922  FAE3 86 D6                   ldaa    #$d6                    ; Use max of $d6                            
12923  FAE5 20 05                   bra     L1976                   ; Branch to store new o2Fbk                             
12924  FAE7             
12925  FAE7                         ;--------------------------------------
12926  FAE7                         ; temperature(ectFiltered) > 86degC
12927  FAE7                         ;--------------------------------------
12928  FAE7 81 2A       L1975       cmpa    #$2a                    ;                             
12929  FAE9 7E D7 99                jmp     L1140                   ;                              
12930  FAEC             
12931  FAEC 7E D7 A5    L1976       jmp     L1142                   ; Jump to store new o2Fbk                              
12932  FAEF 7E D7 A8    L1977       jmp     L1143                   ;                             
12933  FAF2             
12934  FAF2             
12935  FAF2              ;******************************************************************
12936  FAF2             ;
12937  FAF2             ;
12938  FAF2             ; E932 "patch" for rpm calculation, not sure why this is here
12939  FAF2             ;
12940  FAF2             ;******************************************************************
12941  FAF2             #ifdef E932
12942  FAF2 D6 DD       L1978       ldab    rpm31                   ;                              
12943  FAF4 CE 88 40                ldx     #$8840                  ;                               
12944  FAF7 BD EB B9                jsr     clipOffset              ; b = max(min(rpm31,$88)-$40,0)-> returns b = $00 to $48  (2250rpm to 4250rpm)                                           
12945  FAFA 58                      aslb                            ;                             
12946  FAFB 17                      tba                             ;                             
12947  FAFC CE FB BB                ldx     #t_closedLp2            ;                                     
12948  FAFF 7E D6 E6                jmp     L1120                   ;                              
12949  FB02             #endif
12950  FB02             
12951  FB02             
12952  FB02             ;******************************************************************
12953  FB02             ;
12954  FB02             ; Empty memory block
12955  FB02             ;
12956  FB02             ;******************************************************************
12957  FB02~            #ifdef E931
12958  FB02~                        .byte   $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff 
12959  FB02~                        .byte   $ff, $ff, $ff
12960  FB02~            
12961  FB02             #else
12962  FB02 FF FF FF FF             .byte   $ff, $ff, $ff, $ff, $ff   
12962  FB06 FF 
12963  FB07             #endif
12964  FB07             
12965  FB07             
12966  FB07             
12967  FB07             ;******************************************************************
12968  FB07             ;
12969  FB07             ; Resistor strapping flags
12970  FB07             ;
12971  FB07             ; Stored in config1:config2 based on port4 lowest 2 bits (resistor values)
12972  FB07             ;
12973  FB07             ;
12974  FB07             ;******************************************************************
12975  FB07 82 00       t_strap1    .word   $8200                ; Fwd  Federal   
12976  FB09 84 01                   .word   $8401                ; Fwd  California
12977  FB0B 82 82                   .word   $8282                ; Awd  Federal    
12978  FB0D 84 83                   .word   $8483                ; Awd  California 
12979  FB0F             
12980  FB0F             
12981  FB0F             
12982  FB0F             ;******************************************************************
12983  FB0F             ;
12984  FB0F             ; Indicates which table to use as a function of config resistors
12985  FB0F             ;
12986  FB0F             ;
12987  FB0F             ;
12988  FB0F             ;******************************************************************
12989  FB0F FB D5       t_strap2    .word   L1999                   ; Fwd  Federal    
12990  FB11 FB E1                   .word   L2000                   ; Fwd  California 
12991  FB13 FB ED                   .word   L2001                   ; Awd  Federal    
12992  FB15 FB F9                   .word   L2002                   ; Awd  California 
12993  FB17             
12994  FB17             
12995  FB17             ;******************************************************************
12996  FB17             ;
12997  FB17             ; Resistor strapping device id returned on diagnostic port
12998  FB17             ;
12999  FB17             ;******************************************************************
13000  FB17 E0 22       t_strap3    .word   $e022                   ; Fwd  Federal    
13001  FB19 E0 23                   .word   $e023                   ; Fwd  California 
13002  FB1B E0 22                   .word   $e022                   ; Awd  Federal    
13003  FB1D E0 23                   .word   $e023                   ; Awd  California 
13004  FB1F             
13005  FB1F             
13006  FB1F             
13007  FB1F             ;******************************************************************
13008  FB1F             ;
13009  FB1F             ; Table values are compared to mafRaw16/64 = mafRaw -> (xx/6.25)Hz
13010  FB1F             ;
13011  FB1F             ; These are the 2 thresholds determining which trim range to use,
13012  FB1F             ; low, mid, high. The first threshold delimiting "low" from "mid" 
13013  FB1F             ; corresponds to the first two value. It is 106.5Hz with an hysteresis
13014  FB1F             ; of +/-6Hz. The second threshold  delimiting mid from high correspond
13015  FB1F             ; to the last two values. It is 175Hz with an hysteresis of +/-6.25Hz
13016  FB1F             ;
13017  FB1F             ; Values are 
13018  FB1F             ;
13019  FB1F             ;   $12 = 112.50 Hz 
13020  FB1F             ;   $10 = 100.50 Hz 
13021  FB1F             ;
13022  FB1F             ;   $1d = 181.25 Hz 
13023  FB1F             ;   $1b = 168.75 Hz 
13024  FB1F             ;
13025  FB1F             ;******************************************************************
13026  FB1F 12 10 1D 1B t_ftrimRg   .byte   $12, $10, $1d, $1b    
13027  FB23             
13028  FB23             
13029  FB23             
13030  FB23             ;******************************************************************
13031  FB23             ;
13032  FB23             ; Table of rpm31 values , $23=1094rpm, $20=1000rpm, $1d=906rpm 
13033  FB23             ;
13034  FB23             ; Longer for AT
13035  FB23             ;
13036  FB23             ;******************************************************************
13037  FB23 23 20       L1983      .byte   $23, $20
13038  FB25             #ifdef E932
13039  FB25 20 1D                  .byte   $20, $1d    
13040  FB27             #endif
13041  FB27             
13042  FB27             
13043  FB27             
13044  FB27             ;******************************************************************
13045  FB27             ;
13046  FB27             ; Table contains RPM/31.25, interpolated by ECT. Eventually
13047  FB27             ; used as a threshold to determine if the engine is ???.
13048  FB27             ; used in state1 flags update
13049  FB27             ;
13050  FB27             ; Value is increased as a function of loads (see t_rpmEctOff)
13051  FB27             ;
13052  FB27             ;
13053  FB27             ; (1188, 1188, 1594, ....., 3000) 
13054  FB27             ;
13055  FB27             ; IX = FB40 from L1097
13056  FB27             ; ECT
13057  FB27             ;
13058  FB27             ;******************************************************************
13059  FB27 26 26 33 3C t_rpmEct    .byte   $26, $26, $33, $3c, $46, $50, $56, $60     
13059  FB2B 46 50 56 60 
13060  FB2F             
13061  FB2F             
13062  FB2F             
13063  FB2F             ;******************************************************************
13064  FB2F             ;
13065  FB2F             ; Table contains RPM/31.25 offsets that will be added to 
13066  FB2F             ; initial value of t_rpmEct, basically increasing RPM as a function 
13067  FB2F             ; of loads
13068  FB2F             ;
13069  FB2F             ;       $00 = +0rpm, 
13070  FB2F             ;       $08 = +250rpm, 
13071  FB2F             ;       $10 = +500rpm
13072  FB2F             ;       $1d = +906.25rpm
13073  FB2F             ;       $0d = +406.25RPM
13074  FB2F             ;
13075  FB2F             ;    3 bit index into table, b2 b1 b0 where:
13076  FB2F             ;
13077  FB2F             ;               b0 is set if ???
13078  FB2F             ;               b1 is set if tranmission is engaged
13079  FB2F             ;               b2 is set if A/C switch is ON
13080  FB2F             ;
13081  FB2F             ; IX = FB48 from L1102
13082  FB2F             ;
13083  FB2F             ;******************************************************************
13084  FB2F 08 00       t_rpmEctOff .byte   $08, $00, 
13085  FB31 10 00                   .byte   $10, $00,
13086  FB33 1D 0D                   .byte   $1d, $0d, 
13087  FB35 10 00                   .byte   $10, $00     
13088  FB37             
13089  FB37             
13090  FB37             
13091  FB37             ;******************************************************************
13092  FB37             ;
13093  FB37             ; Interpolated from modified tps and rpm
13094  FB37             ; Seems to be some kind of default air count used when we are
13095  FB37             ; not receiving airflow sensor interrupts
13096  FB37             ;
13097  FB37             ;******************************************************************
13098  FB37             L1986
13099  FB37~            #ifdef E931
13100  FB37~                        .byte   $62, $3d, $20, $16, $12
13101  FB37~                        .byte   $7a, $7a, $78, $6c, $5c
13102  FB37~                        .byte   $7d, $7d, $9e, $c2, $c0
13103  FB37~                        .byte   $7d, $7d, $a0, $cd, $cc
13104  FB37~                        .byte   $7d, $7d, $a8, $ce, $d8
13105  FB37~                        .byte   $8a, $8a, $bb, $d0, $df
13106  FB37             #else
13107  FB37 4D 2B 03 16             .byte   $4d, $2b, $03, $16, $12     
13107  FB3B 12 
13108  FB3C 78 84 84 60             .byte   $78, $84, $84, $60, $4a     
13108  FB40 4A 
13109  FB41 7A 88 D0 BD             .byte   $7a, $88, $d0, $bd, $a2     
13109  FB45 A2 
13110  FB46 7A 88 D2 E9             .byte   $7a, $88, $d2, $e9, $d0     
13110  FB4A D0 
13111  FB4B 7A 88 DE EE             .byte   $7a, $88, $de, $ee, $de     
13111  FB4F DE 
13112  FB50 7A 8A DA EC             .byte   $7a, $8a, $da, $ec, $e4     
13112  FB54 E4 
13113  FB55             #endif
13114  FB55             
13115  FB55             
13116  FB55             
13117  FB55             ;******************************************************************
13118  FB55             ;
13119  FB55             ; Mas compensation table as a function of airflow sensor frequency
13120  FB55             ;
13121  FB55             ;
13122  FB55             ; Index into t_masComp table are for the following frequencies:
13123  FB55             ;
13124  FB55             ;      85   85   A8   B6   BE   C3   C8   CC   D0   D4   D7   DA   DC   E3   E6   E8   EB   EA   EA   E8   E7
13125  FB55             ; Hz    0   25   50   75   100  125  150  175  200  225  250  275  300  400  500  600  800  1000 1200 1400 1600
13126  FB55             ;
13127  FB55             ;******************************************************************
13128  FB55             t_masComp
13129  FB55~            #ifdef custMas
13130  FB55~                        .byte   $85, $85, $A8, $B6, $BE, $C3, $C8, $CC, $D0, $D4, $D7, $DA, $DC, $E3, $E6, $E8, $EB, $EA, $EA, $E8, $E7
13131  FB55             #else
13132  FB55~            #ifdef E931
13133  FB55~                        .byte   $5b, $5b, $59, $59, $60, $65, $6c, $6e, $6e, $6f, $73, $76, $7a, $81, $82, $84, $87, $85, $7f, $7a, $7f
13134  FB55             #else
13135  FB55 5D 5D 5C 5A             .byte   $5d, $5d, $5c, $5a, $61, $68, $6c, $6f, $70, $74, $76, $77, $7a, $7f, $84, $85, $88, $86, $81, $7f, $7e 
13135  FB59 61 68 6C 6F 
13135  FB5D 70 74 76 77 
13135  FB61 7A 7F 84 85 
13135  FB65 88 86 81 7F 
13135  FB69 7E 
13136  FB6A             #endif
13137  FB6A             #endif
13138  FB6A             
13139  FB6A             
13140  FB6A             
13141  FB6A             ;******************************************************************
13142  FB6A             ;
13143  FB6A             ; This table is an airflow sensor compensation table (for temperature 
13144  FB6A             ; drift, flow characteristic change, etc?) as a function of 
13145  FB6A             ; air temperature, barometric pressure and airflow frequency.
13146  FB6A             ; Notice that frequency range is short which would mean airflow
13147  FB6A             ; sensor only need compensation under low flow conditions...
13148  FB6A             ;
13149  FB6A             ; Column index are airflow sensor frequency:
13150  FB6A             ;
13151  FB6A             ;   0Hz 25Hz 50Hz 75Hz 100Hz 125Hz 150Hz 175Hz 200Hz
13152  FB6A             ;
13153  FB6A             ; Row index are max(min(L1992(iat)*baroFactor,$52)-$22,0)/16,
13154  FB6A             ; at 1 bar that would correspond to (from top to bottom):
13155  FB6A             ;
13156  FB6A             ;   85degC, 84degC, 26degC, -31degC ?? 
13157  FB6A             ;
13158  FB6A             ; 2G mas table:  $87, $87, $87, $85, $85, $85, $85, $85, $80
13159  FB6A             ;                $80, $80, $80, $80, $80, $80, $80, $80, $80 
13160  FB6A             ;                $7d, $7d, $78, $7a, $7b, $7c, $7c, $7c, $80 
13161  FB6A             ;                $7b, $7b, $75, $78, $7a, $7a, $7a, $7a, $80 
13162  FB6A             ; 
13163  FB6A             ;
13164  FB6A             ;******************************************************************
13165  FB6A 7D 7D 7F 81 t_masLin    .byte   $7d, $7d, $7f, $81, $84, $81, $81, $83, $80     
13165  FB6E 84 81 81 83 
13165  FB72 80 
13166  FB73 80 80 80 80             .byte   $80, $80, $80, $80, $80, $80, $80, $80, $80     
13166  FB77 80 80 80 80 
13166  FB7B 80 
13167  FB7C 83 83 83 82             .byte   $83, $83, $83, $82, $80, $7d, $7f, $7f, $80     
13167  FB80 80 7D 7F 7F 
13167  FB84 80 
13168  FB85 85 85 85 83             .byte   $85, $85, $85, $83, $80, $7d, $7c, $7f, $80     
13168  FB89 80 7D 7C 7F 
13168  FB8D 80 
13169  FB8E             
13170  FB8E             
13171  FB8E             ;******************************************************************
13172  FB8E             ;
13173  FB8E             ; Interpolated using rpm (max=3000rpm)
13174  FB8E             ;
13175  FB8E             ; Could be maximum air count as a function of RPM, used in 
13176  FB8E             ; conjucntion with L1990 and L1991
13177  FB8E             ;
13178  FB8E             ;******************************************************************
13179  FB8E             t_airCntMax
13180  FB8E~            #ifdef E931
13181  FB8E~                        .byte   $5a, $5a, $5b, $5b, $61, $63, $8f, $a0, $ff, $ff, $ff, $ff, $ff
13182  FB8E             #else
13183  FB8E 5F 5F 5F 5F             .byte   $5f, $5f, $5f, $5f, $64, $6c, $73, $ff, $ff, $ff, $ff, $ff, $ff  
13183  FB92 64 6C 73 FF 
13183  FB96 FF FF FF FF 
13183  FB9A FF 
13184  FB9B             #endif
13185  FB9B             
13186  FB9B             
13187  FB9B             
13188  FB9B             ;******************************************************************
13189  FB9B             ;
13190  FB9B             ; Interpolated from ectCond
13191  FB9B             ;
13192  FB9B             ; ECT based correction factor for t_airCntMax
13193  FB9B             ;
13194  FB9B             ;******************************************************************
13195  FB9B 80 80 80 84 L1990       .byte   $80, $80, $80, $84, $88, $8b, $8f, $93      
13195  FB9F 88 8B 8F 93 
13196  FBA3             
13197  FBA3             
13198  FBA3             
13199  FBA3             ;******************************************************************
13200  FBA3             ;
13201  FBA3             ; Interpolated from iatCond
13202  FBA3             ;
13203  FBA3             ; IAT based correction factor for t_airCntMax
13204  FBA3             ;
13205  FBA3             ;******************************************************************
13206  FBA3 8C 86 83 80 L1991       .byte   $8c, $86, $83, $80, $7d, $79, $73      
13206  FBA7 7D 79 73 
13207  FBAA             
13208  FBAA             
13209  FBAA             
13210  FBAA             ;******************************************************************
13211  FBAA             ;
13212  FBAA             ; Interpolated from iatCond. Value from table is then compensated for 
13213  FBAA             ; barometric pressure and then used to interpolate t_masLin
13214  FBAA             ;
13215  FBAA             ; in degC
13216  FBAA             ;
13217  FBAA             ;  85  56  38  23  9  -7  -31 ??
13218  FBAA             ;
13219  FBAA             ;******************************************************************
13220  FBAA 45 3B 36 31 L1992       .byte   $45, $3b, $36, $31, $2d, $29, $22      
13220  FBAE 2D 29 22 
13221  FBB1             
13222  FBB1             
13223  FBB1             
13224  FBB1             ;******************************************************************
13225  FBB1             ;
13226  FBB1             ; Close loop table 1, interpolated from rpm
13227  FBB1             ;
13228  FBB1             ; The values of this table are airVolTB thresholds. Closed loop
13229  FBB1             ; only happens when airVolTB < theshold (with hysteresis of $06)
13230  FBB1             ;
13231  FBB1             ; rpm scale  500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13232  FBB1             ;
13233  FBB1             ;******************************************************************
13234  FBB1 9D 9D 9D 9D t_closedLp1 .byte   $9d, $9d, $9d, $9d, $9d, $80, $68, $55, $00, $00      
13234  FBB5 9D 80 68 55 
13234  FBB9 00 00 
13235  FBBB             
13236  FBBB             
13237  FBBB             
13238  FBBB             ;******************************************************************
13239  FBBB             ;
13240  FBBB             ; Close loop table 2, interpolated from rpm
13241  FBBB             ;
13242  FBBB             ; The values of this table are airVolTB thresholds. Once we are 
13243  FBBB             ; in closed loop, we will remain in closed loop as long as airVolTB
13244  FBBB             ; does not exceed the threshold of this table  (with hysteresis of 
13245  FBBB             ; 6) for more than 12sec or 20sec.
13246  FBBB             ;
13247  FBBB             ; rpm scale  500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13248  FBBB             ;
13249  FBBB             ;******************************************************************
13250  FBBB             t_closedLp2
13251  FBBB~            #ifdef E931
13252  FBBB~                        .byte   $9d, $9d, $9d, $a6, $ae, $ae, $9d, $73, $00, $00
13253  FBBB             #else
13254  FBBB C3 CD DA EB             .byte   $c3, $cd, $da, $eb, $cd, $aa, $68, $5f, $55, $00      
13254  FBBF CD AA 68 5F 
13254  FBC3 55 00 
13255  FBC5             #endif
13256  FBC5             
13257  FBC5             
13258  FBC5             
13259  FBC5             ;******************************************************************
13260  FBC5             ;
13261  FBC5             ; Closed loop table 3, interpolated from rpm
13262  FBC5             ;
13263  FBC5             ; Values are tspRaw threshold. Open loop only happens 
13264  FBC5             ; when tpsRaw > threshold  (with hysteresis of $0d to go
13265  FBC5             ; back to closed loop)
13266  FBC5             ;
13267  FBC5             ; rpm scale  500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13268  FBC5             ;
13269  FBC5             ;******************************************************************
13270  FBC5             t_closedLp3
13271  FBC5~            #ifdef E931
13272  FBC5~                        .byte   $5c, $66, $73, $8d, $8d, $85, $71, $5c, $00, $00
13273  FBC5             #else
13274  FBC5 5C 5C 73 8D             .byte   $5c, $5c, $73, $8d, $94, $8a, $66, $33, $00, $00      
13274  FBC9 94 8A 66 33 
13274  FBCD 00 00 
13275  FBCF             #endif
13276  FBCF             
13277  FBCF             
13278  FBCF             
13279  FBCF             ;******************************************************************
13280  FBCF             ;
13281  FBCF             ; Closed loop fuel adjustment values,
13282  FBCF             ;
13283  FBCF             ; First value is used in low trim range under low speed/rpm, 
13284  FBCF             ; second value in other cases
13285  FBCF             ;
13286  FBCF             ; Values are used in closed loop mode to adjust fuel amount:
13287  FBCF             ;
13288  FBCF             ;       o2FuelAdj = o2Fbk +/-  t_closedLpV1(xx) or t_closedLpV2(xx) or $02
13289  FBCF             ;
13290  FBCF             ; where +/- depends on o2Raw (lean or rich). 
13291  FBCF             ; Basically this controls how fast we change the mixture based on o2Fbk
13292  FBCF             ;
13293  FBCF             ;******************************************************************
13294  FBCF             #ifdef E932
13295  FBCF 03 07       t_closedLpV2       .byte   $03, $07     
13296  FBD1             #endif
13297  FBD1             
13298  FBD1             
13299  FBD1             
13300  FBD1             ;******************************************************************
13301  FBD1             ;
13302  FBD1             ; Closed loop fuel adjustment values,
13303  FBD1             ;
13304  FBD1             ; First value is used in low trim range under low speed/rpm, 
13305  FBD1             ; second value in other cases
13306  FBD1             ;
13307  FBD1             ; Values are used in closed loop mode to adjust fuel amount:
13308  FBD1             ;
13309  FBD1             ;       o2FuelAdj = o2Fbk +/-  t_closedLpV1(xx) or t_closedLpV2(xx) or $02
13310  FBD1             ;
13311  FBD1             ; where +/- depends on o2Raw (lean or rich). 
13312  FBD1             ; Basically this controls how fast we change the mixture based on o2Fbk
13313  FBD1             ;
13314  FBD1             ;******************************************************************
13315  FBD1 03 07       t_closedLpV1       .byte   $03, $07
13316  FBD3             
13317  FBD3             
13318  FBD3             
13319  FBD3             ;******************************************************************
13320  FBD3             ;
13321  FBD3             ; Default o2Fbk decrease and increase values (in that order)
13322  FBD3             ; when T40_o2Fbk is expired
13323  FBD3             ;
13324  FBD3             ;
13325  FBD3             ;******************************************************************
13326  FBD3 20 15       t_o2Fbk1    .byte   $20, $15     
13327  FBD5             
13328  FBD5             
13329  FBD5             
13330  FBD5             ;******************************************************************
13331  FBD5             ;
13332  FBD5             ; Tables of o2Fbk decrease/increase values. One table for 
13333  FBD5             ; each possible resistor strapping combinations
13334  FBD5             ;
13335  FBD5             ; Table format:
13336  FBD5             ;          First sub-table of six values: o2Fbk decrease values
13337  FBD5             ;          Last  sub-table of six values: 02Fbk increase values
13338  FBD5             ;      
13339  FBD5             ; Within each sub-table of six value we have
13340  FBD5             ;          First  pair: rpm < ~1500rpm
13341  FBD5             ;          Second pair: ~1500rpm < rpm < 2100rpm
13342  FBD5             ;          Third  pair: rpm > 2100rpm
13343  FBD5             ;
13344  FBD5             ; Within each pair we have
13345  FBD5             ;          First  value: airVolTB < ~40
13346  FBD5             ;          Second value: airVolTB > ~40
13347  FBD5             ;
13348  FBD5             ;******************************************************************
13349  FBD5~            #ifdef E931
13350  FBD5~            L1999       .byte   $32, $42, $36, $47, $35, $43, $2e, $42, $36, $49, $37, $51     ; Fwd  Federal    
13351  FBD5~            L2000       .byte   $32, $42, $36, $41, $31, $3d, $2e, $42, $36, $4f, $3b, $57     ; Fwd  California 
13352  FBD5~            L2001       .byte   $32, $42, $36, $45, $34, $43, $2e, $42, $36, $4b, $38, $51     ; Awd  Federal    
13353  FBD5~            L2002       .byte   $32, $42, $36, $41, $31, $3b, $2e, $42, $36, $4f, $3b, $59     ; Awd  California 
13354  FBD5             #else
13355  FBD5 32 46 40 50 L1999       .byte   $32, $46, $40, $50, $42, $52, $2e, $46, $40, $50, $42, $62     ; Fwd  Federal    
13355  FBD9 42 52 2E 46 
13355  FBDD 40 50 42 62 
13356  FBE1 32 46 40 49 L2000       .byte   $32, $46, $40, $49, $3c, $4b, $2e, $46, $40, $57, $48, $69     ; Fwd  California 
13356  FBE5 3C 4B 2E 46 
13356  FBE9 40 57 48 69 
13357  FBED 32 46 40 4F L2001       .byte   $32, $46, $40, $4f, $41, $52, $2e, $46, $40, $51, $43, $62     ; Awd  Federal    
13357  FBF1 41 52 2E 46 
13357  FBF5 40 51 43 62 
13358  FBF9 32 46 40 49 L2002       .byte   $32, $46, $40, $49, $3c, $48, $2e, $46, $40, $57, $48, $6c     ; Awd  California 
13358  FBFD 3C 48 2E 46 
13358  FC01 40 57 48 6C 
13359  FC05             #endif
13360  FC05             
13361  FC05             
13362  FC05             ;******************************************************************
13363  FC05             ;
13364  FC05             ; Table of relative air density as a function of temperature
13365  FC05             ; Factor of 1.0 correspond to around 25.6degC
13366  FC05             ; Interpolated from iatCond
13367  FC05             ;
13368  FC05             ; Fits the gas law quite well, taking the two extreme 
13369  FC05             ; points (85degC and -31degC) and using Kelvins, we have
13370  FC05             ;
13371  FC05             ;             T1/T2 = density2/density1
13372  FC05             ;
13373  FC05             ; In theory
13374  FC05             ;             (273+85)/(273-31) = 1.479
13375  FC05             ;
13376  FC05             ; The table gives us
13377  FC05             ;
13378  FC05             ;              density2/density1 = 1.23/0.828 = 1.486 
13379  FC05             ;
13380  FC05             ; This is a 0.5% difference.
13381  FC05             ;
13382  FC05             ;
13383  FC05             ;        degC    85     56     38    23     9    -7    -31 
13384  FC05             ; table value   $6a    $73    $7a    $81   $87   $8f   $9e
13385  FC05             ;     density  0.828  0.898  0.953  1.01  1.05   1.12  1.23 
13386  FC05             ;
13387  FC05             ;
13388  FC05             ;******************************************************************
13389  FC05 6A 73 7A 81 t_airDens   .byte   $6a, $73, $7a, $81, $87, $8f, $9e      
13389  FC09 87 8F 9E 
13390  FC0C             
13391  FC0C             
13392  FC0C             ;******************************************************************
13393  FC0C             ;
13394  FC0C             ; Fuel enrichment factor as a function of airVolCond
13395  FC0C             ; The value of this table reduces the enrichement of t_ectEnr 
13396  FC0C             ; down to 0 as airflow is increased
13397  FC0C             ;
13398  FC0C             ;******************************************************************
13399  FC0C 80 80 80 80 t_airEnr    .byte   $80, $80, $80, $80, $76, $4f, $38, $38, $2d, $2a, $20, $20     
13399  FC10 76 4F 38 38 
13399  FC14 2D 2A 20 20 
13400  FC18             
13401  FC18             
13402  FC18             
13403  FC18             ;******************************************************************
13404  FC18             ;
13405  FC18             ; Fuel enrichment factor as a function of ect (from 0% to 47% 
13406  FC18             ; enrichment in cold temp). This value is reduced by a factor taken 
13407  FC18             ; from t_airEnr when airflow is increased, see code
13408  FC18             ;
13409  FC18             ;******************************************************************
13410  FC18             t_ectEnr
13411  FC18~            #ifdef E931
13412  FC18~                        .byte   $80, $80, $87, $89, $8f, $9d, $ab, $bc
13413  FC18             #else
13414  FC18 80 80 87 89             .byte   $80, $80, $87, $89, $8f, $9a, $a4, $b5     
13414  FC1C 8F 9A A4 B5 
13415  FC20             #endif
13416  FC20             
13417  FC20             
13418  FC20             
13419  FC20             ;******************************************************************
13420  FC20             ;
13421  FC20             ; Seem to contain enrichment values as a function of ECT
13422  FC20             ; (run richer during warm-up/start-up)
13423  FC20             ; $09 when hot, $80 when cold..., seems a bit high??????
13424  FC20             ;
13425  FC20             ;  fuel enrichment applied = ($80+2*xx)/$80, enrich=$80=100%=no enrichment
13426  FC20             ;
13427  FC20             ;  value xx  $09    $0d   $10    $1a    $27    $33    $4d    $80 
13428  FC20             ;  enrich    1.14   1.20  1.26   1.40   1.60   1.80   2.2    3.00
13429  FC20             ;
13430  FC20             ;******************************************************************
13431  FC20 09 0D 10 1A t_enrWarmup .byte   $09, $0d, $10, $1a, $27, $33, $4d, $80   
13431  FC24 27 33 4D 80 
13432  FC28             
13433  FC28             
13434  FC28             ;******************************************************************
13435  FC28             ;
13436  FC28             ; Fuel map, value of $80 represent an enrichment factor of 1.0 
13437  FC28             ;
13438  FC28             ;  rpm  500 1000 1500 2000 2500 3000 3500 4000 4500 5000 5500 6000 6500 7000
13439  FC28             ;       
13440  FC28             ;       
13441  FC28             ;******************************************************************
13442  FC28             t_fuelMap      
13443  FC28~            #ifdef custFuelMap
13444  FC28~                        .byte   $84, $82, $81, $80, $80, $80, $80, $80, $80, $80, $80, $80, $80, $80
13445  FC28~                        .byte   $87, $85, $84, $82, $82, $82, $82, $84, $85, $85, $85, $85, $85, $85
13446  FC28~                        .byte   $90, $8e, $8c, $8b, $8a, $8b, $8d, $8f, $8f, $90, $91, $91, $91, $91
13447  FC28~                        .byte   $94, $94, $94, $96, $98, $9a, $9c, $9e, $a0, $a2, $a4, $a6, $a8, $aa
13448  FC28~                        .byte   $a5, $a6, $a9, $ae, $b2, $b6, $b8, $b8, $ba, $ba, $ba, $ba, $bc, $bc
13449  FC28~                        .byte   $b0, $b6, $b9, $bc, $c0, $c2, $c3, $c3, $c4, $c5, $c6, $c6, $c6, $c6
13450  FC28~                        .byte   $b2, $b8, $bb, $be, $c2, $c4, $c5, $c5, $c6, $c7, $c8, $c8, $c8, $c8
13451  FC28~                        .byte   $b4, $ba, $bd, $c0, $c4, $c6, $c7, $c7, $c8, $c9, $ca, $ca, $ca, $ca
13452  FC28~                        .byte   $b6, $bc, $bf, $c2, $c6, $c8, $c9, $c9, $ca, $cb, $cc, $cc, $cc, $cc
13453  FC28~                        .byte   $b8, $be, $c1, $c4, $c8, $ca, $cb, $cb, $cc, $cd, $ce, $ce, $ce, $ce
13454  FC28~                        .byte   $b9, $bf, $c2, $c5, $c9, $cb, $cc, $cc, $cd, $ce, $cf, $cf, $cf, $cf
13455  FC28~                        .byte   $ba, $c0, $c3, $c6, $ca, $cc, $cd, $cd, $ce, $cf, $d0, $d0, $d0, $d0
13456  FC28             #else
13457  FC28~            #ifdef E931
13458  FC28~                        .byte   $8d, $85, $80, $7c, $7f, $7f, $80, $82, $85, $85, $85, $98, $98, $a0
13459  FC28~                        .byte   $8d, $85, $80, $7c, $7f, $7f, $80, $83, $85, $85, $85, $98, $98, $a0
13460  FC28~                        .byte   $8d, $85, $80, $80, $80, $80, $80, $80, $80, $80, $80, $98, $98, $a0
13461  FC28~                        .byte   $8d, $86, $80, $80, $80, $80, $80, $83, $84, $8a, $96, $98, $9f, $a7
13462  FC28~                        .byte   $91, $86, $80, $80, $80, $80, $80, $85, $8f, $96, $98, $a8, $a8, $ae
13463  FC28~                        .byte   $92, $9c, $98, $80, $80, $80, $86, $90, $98, $a0, $a6, $af, $af, $b6
13464  FC28~                        .byte   $94, $9e, $98, $80, $80, $87, $91, $98, $a5, $a8, $b3, $b6, $b6, $be
13465  FC28~                        .byte   $94, $9e, $98, $98, $95, $93, $98, $a0, $ac, $b0, $b8, $bb, $be, $c5
13466  FC28~                        .byte   $94, $9e, $98, $98, $96, $a0, $a8, $a8, $b3, $b8, $bd, $c0, $c6, $ca
13467  FC28~                        .byte   $94, $9e, $98, $98, $a7, $b4, $ae, $b3, $ba, $bf, $c3, $c4, $ca, $ca
13468  FC28~                        .byte   $94, $9e, $98, $98, $a7, $b6, $b8, $b9, $c4, $c8, $ca, $c8, $ca, $ca
13469  FC28~                        .byte   $94, $9e, $98, $98, $a7, $b6, $b8, $b9, $ca, $ca, $ca, $c8, $ca, $ca
13470  FC28~            
13471  FC28             #else
13472  FC28 8D 85 80 7E             .byte   $8d, $85, $80, $7e, $7c, $7c, $7c, $7c, $85, $89, $9a, $a0, $a0, $a3       
13472  FC2C 7C 7C 7C 7C 
13472  FC30 85 89 9A A0 
13472  FC34 A0 A3 
13473  FC36 8D 85 80 7E             .byte   $8d, $85, $80, $7e, $7c, $7c, $7c, $7c, $85, $89, $9a, $a0, $a0, $a3       
13473  FC3A 7C 7C 7C 7C 
13473  FC3E 85 89 9A A0 
13473  FC42 A0 A3 
13474  FC44 8D 85 80 7E             .byte   $8d, $85, $80, $7e, $7c, $7c, $7c, $7c, $85, $89, $9a, $a0, $a0, $a3       
13474  FC48 7C 7C 7C 7C 
13474  FC4C 85 89 9A A0 
13474  FC50 A0 A3 
13475  FC52 8D 85 80 7E             .byte   $8d, $85, $80, $7e, $7c, $7c, $7c, $8a, $90, $96, $a0, $a3, $a6, $a9       
13475  FC56 7C 7C 7C 8A 
13475  FC5A 90 96 A0 A3 
13475  FC5E A6 A9 
13476  FC60 91 85 80 7E             .byte   $91, $85, $80, $7e, $7c, $7c, $86, $90, $9a, $a0, $a4, $a9, $aa, $ad       
13476  FC64 7C 7C 86 90 
13476  FC68 9A A0 A4 A9 
13476  FC6C AA AD 
13477  FC6E 97 97 80 7E             .byte   $97, $97, $80, $7e, $7c, $94, $91, $9c, $a0, $a3, $aa, $ac, $b2, $b5       
13477  FC72 7C 94 91 9C 
13477  FC76 A0 A3 AA AC 
13477  FC7A B2 B5 
13478  FC7C 97 97 99 7E             .byte   $97, $97, $99, $7e, $92, $94, $95, $a2, $a8, $a8, $ad, $b3, $b9, $bb       
13478  FC80 92 94 95 A2 
13478  FC84 A8 A8 AD B3 
13478  FC88 B9 BB 
13479  FC8A 97 97 99 92             .byte   $97, $97, $99, $92, $92, $98, $9f, $a8, $ac, $ad, $b2, $b9, $bb, $be       
13479  FC8E 92 98 9F A8 
13479  FC92 AC AD B2 B9 
13479  FC96 BB BE 
13480  FC98 97 97 99 92             .byte   $97, $97, $99, $92, $9c, $a2, $a7, $ac, $b3, $b4, $b7, $bc, $bc, $c0       
13480  FC9C 9C A2 A7 AC 
13480  FCA0 B3 B4 B7 BC 
13480  FCA4 BC C0 
13481  FCA6 97 97 99 A4             .byte   $97, $97, $99, $a4, $a9, $ac, $ad, $b0, $b7, $bb, $bd, $bc, $c0, $c0       
13481  FCAA A9 AC AD B0 
13481  FCAE B7 BB BD BC 
13481  FCB2 C0 C0 
13482  FCB4 97 97 99 AA             .byte   $97, $97, $99, $aa, $ae, $b0, $b2, $b6, $bd, $c0, $c0, $c0, $c0, $c0       
13482  FCB8 AE B0 B2 B6 
13482  FCBC BD C0 C0 C0 
13482  FCC0 C0 C0 
13483  FCC2 97 97 99 AA             .byte   $97, $97, $99, $aa, $ae, $b0, $b2, $b6, $bd, $c0, $c0, $c0, $c0, $c0       
13483  FCC6 AE B0 B2 B6 
13483  FCCA BD C0 C0 C0 
13483  FCCE C0 C0 
13484  FCD0             #endif
13485  FCD0             #endif
13486  FCD0             
13487  FCD0             
13488  FCD0             
13489  FCD0             ;******************************************************************
13490  FCD0             ;
13491  FCD0             ;
13492  FCD0             ; Injector deatime as a function of battery voltage 
13493  FCD0             ;
13494  FCD0             ; Each unit correspond to 24us ($08 = 192us)
13495  FCD0             ;
13496  FCD0             ;
13497  FCD0             ; Volts: 4.7, 7.0, 9.4, 11.7, 14.1, 16.4, 18.8
13498  FCD0             ;
13499  FCD0             ;******************************************************************
13500  FCD0             t_deadtime
13501  FCD0~            #ifdef custDeadTime
13502  FCD0~                        ; Denso 660 .byte   $b0, $5f, $37, $2a, $22, $1e, $1a
13503  FCD0~                        ; Worchester, fuel trim =  125,105, 100? .byte   $b5, $64, $3c, $2f, $27, $23, $1f
13504  FCD0~                        ; Worchester, fuel trim = <81, 102, 100? .byte   $bc, $6b, $43, $36, $2e, $2a, $26
13505  FCD0~                        ; Worchester, fuel trim = <81, 100, 103  .byte   $b9, $68, $40, $33, $2b, $27, $23
13506  FCD0~                        .byte   $b7, $66, $3e, $31, $29, $25, $21
13507  FCD0             #else
13508  FCD0~            #ifdef E931
13509  FCD0~                        .byte   $a9, $58, $30, $23, $1b, $17, $13
13510  FCD0             #else
13511  FCD0 A8 5A 32 26             .byte   $a8, $5a, $32, $26, $1a, $17, $11      
13511  FCD4 1A 17 11 
13512  FCD7             #endif
13513  FCD7             #endif
13514  FCD7             
13515  FCD7             
13516  FCD7             
13517  FCD7             ;******************************************************************
13518  FCD7             ;
13519  FCD7             ; Table used for the calculation of injPwStart
13520  FCD7             ;
13521  FCD7             ; non constant sample spacing:
13522  FCD7             ;
13523  FCD7             ;   ectCond/32          ectCond<$c0     
13524  FCD7             ;   (2*ectCond-$c0)/32  ectCond>=$c0
13525  FCD7             ;
13526  FCD7             ;   scale in degC:
13527  FCD7             ;   
13528  FCD7             ;        86 80 52 35 21 8 -7 -16 -29 
13529  FCD7             ;
13530  FCD7             ;******************************************************************
13531  FCD7             L2008 
13532  FCD7~            #ifdef E931
13533  FCD7~                        .byte   $07, $07, $0d, $14, $22, $36, $60, $83, $a6 
13534  FCD7             #else
13535  FCD7 07 07 0D 14             .byte   $07, $07, $0d, $14, $22, $39, $65, $8a, $af     
13535  FCDB 22 39 65 8A 
13535  FCDF AF 
13536  FCE0             #endif
13537  FCE0             
13538  FCE0             
13539  FCE0             
13540  FCE0             ;******************************************************************
13541  FCE0             ;
13542  FCE0             ; ect
13543  FCE0             ;
13544  FCE0             ;
13545  FCE0             ;******************************************************************
13546  FCE0 17 17 28 45 t_accEnr2a  .byte   $17, $17, $28, $45, $60, $70, $80, $80     
13546  FCE4 60 70 80 80 
13547  FCE8             
13548  FCE8             
13549  FCE8             
13550  FCE8             ;******************************************************************
13551  FCE8             ;
13552  FCE8             ; rpm
13553  FCE8             ;
13554  FCE8             ;
13555  FCE8             ;******************************************************************
13556  FCE8 FF B0 A8 80 t_accEnr1   .byte   $ff, $b0, $a8, $80, $80, $88, $90, $a0, $b0, $c0     
13556  FCEC 80 88 90 A0 
13556  FCF0 B0 C0 
13557  FCF2             
13558  FCF2             
13559  FCF2             
13560  FCF2             ;******************************************************************
13561  FCF2             ;
13562  FCF2             ; Table is interpolated from ect and used to initialize
13563  FCF2             ; accEnrDecay. Basically the values in this table are
13564  FCF2             ; the decay factor applied to accEnr on each iteration
13565  FCF2             ;
13566  FCF2             ;     accEnr = accEnr * (1-t_accEnrDecay(ect)/256)
13567  FCF2             ;
13568  FCF2             ; Slower decay under cold conditions...
13569  FCF2             ;
13570  FCF2             ;******************************************************************
13571  FCF2 A0 A0 F3 F6 t_accEnrDecay   .byte   $a0, $a0, $f3, $f6, $f7, $f8, $f9, $fa     
13571  FCF6 F7 F8 F9 FA 
13572  FCFA             
13573  FCFA             
13574  FCFA             
13575  FCFA             ;******************************************************************
13576  FCFA             ;
13577  FCFA             ; Interpolated from tpsDiff100/4
13578  FCFA             ;
13579  FCFA             ; Used to compute fuel enrichement when doing simultaneous 
13580  FCFA             ; injection under acceleration. It is basically a multipler
13581  FCFA             ; of the basic enrichment time (sInjEnrInc) depending on 
13582  FCFA             ; how much acceleration is requested, i.e. how fast the pedal is 
13583  FCFA             ; moving
13584  FCFA             ;
13585  FCFA             ;******************************************************************
13586  FCFA 03 04 05 07 t_sInjEnr       .byte   $03, $04, $05, $07, $09, $0b, $0e, $11, $18     
13586  FCFE 09 0B 0E 11 
13586  FD02 18 
13587  FD03             
13588  FD03             
13589  FD03             
13590  FD03             ;******************************************************************
13591  FD03             ;
13592  FD03             ; Table interpolated from ect. Used in the calculation
13593  FD03             ; of sInjEnrInc, fuel enrichment factor for sim injection 
13594  FD03             ; during acceleration
13595  FD03             ;
13596  FD03             ;******************************************************************
13597  FD03 00 00 04 12 L2013       .byte   $00, $00, $04, $12, $18, $20, $30, $40     
13597  FD07 18 20 30 40 
13598  FD0B             
13599  FD0B             
13600  FD0B             
13601  FD0B             ;******************************************************************
13602  FD0B             ;
13603  FD0B             ; Values are used as a maximum threshold on TPS when calculating fuel 
13604  FD0B             ; enrichement for simultaneous injection
13605  FD0B             ;
13606  FD0B             ; rpm scale: 500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13607  FD0B             ;
13608  FD0B             ;******************************************************************
13609  FD0B 5B 6C 76 85 t_sInjTpsMax  .byte   $5b, $6c, $76, $85, $94, $b3, $cd, $cd, $cd, $cd   
13609  FD0F 94 B3 CD CD 
13609  FD13 CD CD 
13610  FD15             
13611  FD15             
13612  FD15             
13613  FD15             ;******************************************************************
13614  FD15             ;
13615  FD15             ; IX = FD2C from L1213
13616  FD15             ; 5 10 15 20 25 30 35 40 45 50 x 100 RPM
13617  FD15             ;
13618  FD15             ;******************************************************************
13619  FD15 30 28 20 20 L2015       .byte   $30, $28, $20, $20, $20, $20, $20, $20, $20, $20   
13619  FD19 20 20 20 20 
13619  FD1D 20 20 
13620  FD1F             
13621  FD1F             
13622  FD1F             
13623  FD1F             ;******************************************************************
13624  FD1F             ;
13625  FD1F             ; XX = FD36 from L1207
13626  FD1F             ;
13627  FD1F             ;******************************************************************
13628  FD1F 50 50 8C B4 t_decEnr2       .byte   $50, $50, $8c, $b4, $f0, $f0, $ff, $ff    
13628  FD23 F0 F0 FF FF 
13629  FD27             
13630  FD27             
13631  FD27             
13632  FD27             ;******************************************************************
13633  FD27             ;
13634  FD27             ; IX = FD3E from L1206
13635  FD27             ;
13636  FD27             ;******************************************************************
13637  FD27 1A 20 26 2D t_decEnr1       .byte   $1a, $20, $26, $2d, $33, $4d, $66, $80, $c0, $ff    
13637  FD2B 33 4D 66 80 
13637  FD2F C0 FF 
13638  FD31             
13639  FD31             
13640  FD31             
13641  FD31             ;******************************************************************
13642  FD31             ;
13643  FD31             ; Table of timing values under high octane conditions, values are shifted by
13644  FD31             ; 10deg in oder to allow for timing retard (0 = -10deg advance, 18 = 8 deg advance)
13645  FD31             ; It contains timing values to use when octane=255 (no knock)
13646  FD31             ;
13647  FD31             ; Timing used is interpolated from 
13648  FD31             ;
13649  FD31             ;       timingOct = alpha * t_timingHiOct(rpm, load) + (1-alpha) * t_timingLoOct(rpm, load)
13650  FD31             ;
13651  FD31             ; where alpha = octane/255, 0<= alpha <=1
13652  FD31             ;
13653  FD31             ;  rpm  500 1000 1500 2000 2500 3000 3500 4000 4500 5000 5500 6000 6500 7000 7500 8000
13654  FD31             ;
13655  FD31             ;******************************************************************
13656  FD31             t_timingHiOct
13657  FD31~            #ifdef custTimingMap
13658  FD31~                        .byte   $14, $1a, $23, $26, $29, $2b, $2e, $30, $32, $32, $32, $32, $32, $32, $32, $32
13659  FD31~                        .byte   $14, $1a, $22, $25, $26, $27, $2a, $2b, $2c, $2c, $2c, $2c, $2c, $2c, $2d, $2d
13660  FD31~                        .byte   $13, $18, $1e, $20, $21, $24, $27, $27, $27, $27, $27, $27, $28, $2a, $2b, $2b
13661  FD31~                        .byte   $12, $16, $18, $1c, $1d, $1e, $21, $23, $24, $24, $25, $25, $26, $28, $29, $29
13662  FD31~                        .byte   $11, $12, $16, $18, $19, $1a, $1c, $1f, $21, $22, $23, $23, $26, $28, $28, $28
13663  FD31~                        .byte   $10, $11, $12, $14, $15, $16, $17, $19, $1a, $1c, $1d, $1e, $20, $22, $24, $24
13664  FD31~                        .byte   $0f, $10, $11, $12, $13, $14, $15, $16, $17, $19, $1a, $1b, $1d, $1f, $21, $21
13665  FD31~                        .byte   $0d, $0d, $0e, $0f, $10, $12, $13, $14, $15, $17, $18, $19, $1b, $1d, $1f, $1f
13666  FD31~                        .byte   $0b, $0c, $0c, $0d, $0e, $10, $11, $12, $13, $15, $16, $17, $19, $1b, $1c, $1d
13667  FD31~                        .byte   $0a, $0b, $0b, $0c, $0d, $0e, $0f, $10, $11, $13, $14, $15, $17, $19, $1a, $1b
13668  FD31~                        .byte   $09, $0a, $0a, $0b, $0b, $0c, $0d, $0e, $0f, $11, $12, $13, $15, $17, $18, $19
13669  FD31~                        .byte   $08, $09, $09, $0a, $0a, $0b, $0c, $0c, $0d, $0f, $10, $11, $13, $15, $16, $17
13670  FD31             #else
13671  FD31~            #ifdef E931
13672  FD31~                        .byte   $12, $17, $1c, $22, $28, $2f, $30, $31, $32, $33, $36, $37, $37, $37, $37, $37 
13673  FD31~                        .byte   $12, $17, $1d, $23, $27, $2d, $2e, $30, $30, $32, $34, $37, $37, $37, $37, $37 
13674  FD31~                        .byte   $12, $18, $1f, $25, $28, $2b, $2d, $2f, $32, $32, $32, $32, $32, $32, $32, $32
13675  FD31~                        .byte   $12, $1a, $22, $26, $28, $29, $2a, $2d, $2d, $2d, $2d, $2d, $2f, $2f, $2f, $2f 
13676  FD31~                        .byte   $12, $1a, $22, $25, $25, $27, $28, $2b, $2b, $2b, $2b, $2b, $2b, $2b, $2d, $2d 
13677  FD31~                        .byte   $12, $18, $20, $22, $22, $23, $26, $28, $28, $28, $28, $28, $29, $2a, $2c, $2d 
13678  FD31~                        .byte   $12, $18, $19, $1c, $1d, $1f, $24, $25, $25, $25, $26, $26, $27, $29, $2b, $29 
13679  FD31~                        .byte   $0f, $16, $18, $1c, $19, $19, $1e, $22, $24, $24, $25, $25, $26, $28, $28, $24 
13680  FD31~                        .byte   $0c, $12, $16, $18, $19, $17, $19, $1e, $22, $22, $23, $23, $26, $28, $26, $20 
13681  FD31~                        .byte   $0a, $0f, $13, $16, $17, $17, $15, $19, $1d, $1f, $20, $21, $23, $27, $22, $1d 
13682  FD31~                        .byte   $08, $0d, $11, $14, $15, $16, $15, $19, $19, $1c, $1c, $1d, $20, $23, $1e, $1d 
13683  FD31~                        .byte   $06, $0b, $0f, $12, $13, $14, $14, $18, $19, $1c, $1c, $1d, $20, $22, $1e, $1c 
13684  FD31             #else
13685  FD31 12 17 1C 22             .byte   $12, $17, $1c, $22, $28, $2f, $30, $31, $32, $33, $36, $37, $37, $37, $37, $37      
13685  FD35 28 2F 30 31 
13685  FD39 32 33 36 37 
13685  FD3D 37 37 37 37 
13686  FD41 12 17 1D 23             .byte   $12, $17, $1d, $23, $27, $2d, $2d, $2d, $2d, $30, $33, $37, $37, $37, $37, $37      
13686  FD45 27 2D 2D 2D 
13686  FD49 2D 30 33 37 
13686  FD4D 37 37 37 37 
13687  FD51 12 18 1E 25             .byte   $12, $18, $1e, $25, $28, $2a, $2a, $2e, $2e, $2f, $2e, $2d, $2d, $2d, $2a, $2a      
13687  FD55 28 2A 2A 2E 
13687  FD59 2E 2F 2E 2D 
13687  FD5D 2D 2D 2A 2A 
13688  FD61 12 19 1F 23             .byte   $12, $19, $1f, $23, $24, $28, $28, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a      
13688  FD65 24 28 28 2A 
13688  FD69 2A 2A 2A 2A 
13688  FD6D 2A 2A 2A 2A 
13689  FD71 12 1A 20 21             .byte   $12, $1a, $20, $21, $22, $24, $25, $27, $27, $27, $27, $27, $28, $28, $28, $28      
13689  FD75 22 24 25 27 
13689  FD79 27 27 27 27 
13689  FD7D 28 28 28 28 
13690  FD81 12 1A 1D 20             .byte   $12, $1a, $1d, $20, $21, $22, $23, $24, $25, $25, $26, $26, $27, $27, $27, $27      
13690  FD85 21 22 23 24 
13690  FD89 25 25 26 26 
13690  FD8D 27 27 27 27 
13691  FD91 12 16 18 19             .byte   $12, $16, $18, $19, $1c, $1e, $20, $22, $24, $24, $25, $26, $26, $27, $26, $24      
13691  FD95 1C 1E 20 22 
13691  FD99 24 24 25 26 
13691  FD9D 26 27 26 24 
13692  FDA1 0F 14 16 16             .byte   $0f, $14, $16, $16, $14, $16, $1a, $22, $24, $24, $24, $24, $25, $27, $24, $22      
13692  FDA5 14 16 1A 22 
13692  FDA9 24 24 24 24 
13692  FDAD 25 27 24 22 
13693  FDB1 0C 12 14 16             .byte   $0c, $12, $14, $16, $12, $13, $17, $1d, $21, $22, $22, $22, $24, $26, $22, $20      
13693  FDB5 12 13 17 1D 
13693  FDB9 21 22 22 22 
13693  FDBD 24 26 22 20 
13694  FDC1 0A 10 12 14             .byte   $0a, $10, $12, $14, $0f, $10, $15, $1a, $1d, $20, $20, $20, $22, $24, $20, $1e      
13694  FDC5 0F 10 15 1A 
13694  FDC9 1D 20 20 20 
13694  FDCD 22 24 20 1E 
13695  FDD1 08 0E 10 12             .byte   $08, $0e, $10, $12, $0d, $10, $15, $19, $1c, $1f, $1f, $1f, $21, $22, $1f, $1e      
13695  FDD5 0D 10 15 19 
13695  FDD9 1C 1F 1F 1F 
13695  FDDD 21 22 1F 1E 
13696  FDE1 06 0C 0E 10             .byte   $06, $0c, $0e, $10, $0c, $0e, $15, $19, $1c, $1e, $1e, $1f, $21, $20, $1f, $1d      
13696  FDE5 0C 0E 15 19 
13696  FDE9 1C 1E 1E 1F 
13696  FDED 21 20 1F 1D 
13697  FDF1             #endif
13698  FDF1             #endif
13699  FDF1             
13700  FDF1             
13701  FDF1             
13702  FDF1             ;******************************************************************
13703  FDF1             ;
13704  FDF1             ; Table of timing values under low octane conditions values are shifted by
13705  FDF1             ; 10deg in oder to allow for timing retard (0 = -10deg advance, 18 = 8 deg advance)
13706  FDF1             ; It contains timing values to use when octane=0 (lots of knock)
13707  FDF1             ;
13708  FDF1             ; Timing applied is interpolated from 
13709  FDF1             ;
13710  FDF1             ;       timingOct = alpha * t_timingHiOct(rpm, load) + (1-alpha) * t_timingLoOct(rpm, load)
13711  FDF1             ;
13712  FDF1             ; where alpha = octane/255, 0<= alpha <=1
13713  FDF1             ;
13714  FDF1             ; Note that the first three rows of t_timingLoOct have been eliminated from 
13715  FDF1             ; this table (t_timingLoOct correspond to the last 9 rows of t_timingHiOct)
13716  FDF1             ;
13717  FDF1             ;
13718  FDF1             ;******************************************************************
13719  FDF1             t_timingLoOct
13720  FDF1~            #ifdef custOctaneMap
13721  FDF1~                        .byte   $12, $16, $18, $1c, $1d, $1e, $21, $23, $24, $24, $25, $25, $26, $28, $29, $2a
13722  FDF1~                        .byte   $11, $12, $16, $18, $19, $1a, $1c, $1f, $21, $22, $23, $24, $25, $27, $28, $29
13723  FDF1~                        .byte   $10, $11, $12, $14, $15, $16, $17, $19, $1a, $1c, $1d, $1e, $20, $22, $24, $24
13724  FDF1~                        .byte   $0f, $10, $11, $12, $13, $14, $15, $16, $17, $19, $1a, $1b, $1d, $1f, $21, $21
13725  FDF1~                        .byte   $0b, $0d, $0e, $0f, $10, $12, $13, $14, $15, $17, $18, $19, $1b, $1d, $1f, $1f
13726  FDF1~                        .byte   $0a, $0c, $0c, $0d, $0e, $10, $11, $12, $13, $15, $16, $17, $19, $1b, $1c, $1d
13727  FDF1~                        .byte   $09, $0b, $0b, $0c, $0d, $0e, $0f, $10, $11, $13, $14, $15, $17, $19, $1a, $1b
13728  FDF1~                        .byte   $08, $0a, $0a, $0b, $0b, $0c, $0d, $0e, $0f, $11, $12, $13, $15, $17, $18, $19
13729  FDF1~                        .byte   $07, $08, $09, $0a, $0a, $0b, $0c, $0c, $0d, $0f, $10, $11, $13, $15, $16, $17
13730  FDF1             #else
13731  FDF1~            #ifdef E931
13732  FDF1~                        .byte   $12, $1a, $22, $26, $28, $29, $2a, $2d, $2d, $2d, $2d, $2d, $2f, $2f, $2f, $2f 
13733  FDF1~                        .byte   $12, $19, $1e, $21, $22, $24, $27, $2a, $2a, $2a, $2a, $2a, $2c, $2c, $2d, $2d 
13734  FDF1~                        .byte   $0c, $13, $19, $1d, $1e, $20, $24, $27, $28, $28, $28, $28, $28, $2a, $2a, $27 
13735  FDF1~                        .byte   $09, $0c, $11, $14, $15, $1b, $21, $24, $25, $25, $25, $25, $25, $25, $24, $20 
13736  FDF1~                        .byte   $07, $0c, $0d, $0e, $11, $13, $1b, $1f, $1f, $21, $23, $24, $24, $22, $22, $1c 
13737  FDF1~                        .byte   $05, $0a, $0b, $0c, $0e, $0e, $14, $18, $1d, $1e, $1e, $1f, $21, $21, $20, $1a 
13738  FDF1~                        .byte   $03, $08, $09, $0a, $0c, $0c, $0f, $16, $18, $1a, $1c, $1c, $1d, $20, $1e, $18 
13739  FDF1~                        .byte   $01, $06, $07, $08, $0b, $0b, $0e, $10, $15, $17, $17, $18, $18, $1a, $18, $16 
13740  FDF1~                        .byte   $00, $04, $05, $06, $0a, $0a, $0c, $0e, $12, $13, $14, $16, $16, $18, $16, $14 
13741  FDF1             #else
13742  FDF1 12 19 1F 23             .byte   $12, $19, $1f, $23, $24, $28, $28, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a      
13742  FDF5 24 28 28 2A 
13742  FDF9 2A 2A 2A 2A 
13742  FDFD 2A 2A 2A 2A 
13743  FE01 12 1C 21 23             .byte   $12, $1c, $21, $23, $24, $26, $28, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a, $2a      
13743  FE05 24 26 28 2A 
13743  FE09 2A 2A 2A 2A 
13743  FE0D 2A 2A 2A 2A 
13744  FE11 12 14 19 1B             .byte   $12, $14, $19, $1b, $1e, $20, $24, $27, $26, $29, $29, $29, $2a, $2a, $2a, $2a      
13744  FE15 1E 20 24 27 
13744  FE19 26 29 29 29 
13744  FE1D 2A 2A 2A 2A 
13745  FE21 0C 10 12 14             .byte   $0c, $10, $12, $14, $16, $18, $1c, $26, $26, $26, $25, $24, $26, $27, $27, $24      
13745  FE25 16 18 1C 26 
13745  FE29 26 26 25 24 
13745  FE2D 26 27 27 24 
13746  FE31 0B 0F 0D 0E             .byte   $0b, $0f, $0d, $0e, $0e, $11, $16, $1b, $1d, $20, $1c, $1b, $21, $22, $22, $1c      
13746  FE35 0E 11 16 1B 
13746  FE39 1D 20 1C 1B 
13746  FE3D 21 22 22 1C 
13747  FE41 09 0D 0B 0C             .byte   $09, $0d, $0b, $0c, $0c, $0c, $10, $17, $18, $1a, $1a, $19, $1e, $20, $1e, $18      
13747  FE45 0C 0C 10 17 
13747  FE49 18 1A 1A 19 
13747  FE4D 1E 20 1E 18 
13748  FE51 07 0B 09 0A             .byte   $07, $0b, $09, $0a, $0a, $0b, $0e, $12, $15, $17, $17, $18, $1b, $1d, $1a, $16      
13748  FE55 0A 0B 0E 12 
13748  FE59 15 17 17 18 
13748  FE5D 1B 1D 1A 16 
13749  FE61 05 09 07 08             .byte   $05, $09, $07, $08, $08, $09, $0d, $0f, $12, $15, $15, $16, $19, $1a, $18, $14      
13749  FE65 08 09 0D 0F 
13749  FE69 12 15 15 16 
13749  FE6D 19 1A 18 14 
13750  FE71 03 07 05 06             .byte   $03, $07, $05, $06, $06, $07, $0b, $0d, $10, $13, $13, $14, $17, $18, $16, $12      
13750  FE75 06 07 0B 0D 
13750  FE79 10 13 13 14 
13750  FE7D 17 18 16 12 
13751  FE81             #endif
13752  FE81             #endif
13753  FE81             
13754  FE81             
13755  FE81             ;******************************************************************
13756  FE81             ;
13757  FE81             ; Interpolated from ect, used in timing advance calculations
13758  FE81             ;
13759  FE81             ;       $81 =  1 deg advance
13760  FE81             ;       $80 =  0 deg
13761  FE81             ;       $7f = -1 deg advance
13762  FE81             ;
13763  FE81             ;******************************************************************
13764  FE81 80 80 80 80 L2020       .byte   $80, $80, $80, $80, $80, $84, $88, $8b      
13764  FE85 80 84 88 8B 
13765  FE89             
13766  FE89             
13767  FE89             
13768  FE89             ;******************************************************************
13769  FE89             ;
13770  FE89             ; Interpolated from iat, values used in 
13771  FE89             ; timing advance calculations
13772  FE89             ;
13773  FE89             ;       $81 =  1 deg advance
13774  FE89             ;       $80 =  0 deg
13775  FE89             ;       $7f = -1 deg advance
13776  FE89             ;
13777  FE89             ;******************************************************************
13778  FE89 7D 7F 80 80 L2021       .byte   $7d, $7f, $80, $80, $80, $7f, $7e    
13778  FE8D 80 7F 7E 
13779  FE90             
13780  FE90             
13781  FE90             
13782  FE90             ;******************************************************************
13783  FE90             ;
13784  FE90             ; Interpolated from battRaw. Values are basic coil 
13785  FE90             ; energization time, each unit correspond to 64usec?
13786  FE90             ;
13787  FE90             ;
13788  FE90             ; Voltages: 9.38v  10.56v  11.73v  12.9v  14.1v  15.2v  16.4v  17.6v  18.8v 
13789  FE90             ;
13790  FE90             ;******************************************************************
13791  FE90 BC 9C 7A 64 t_enerLen       .byte   $bc, $9c, $7a, $64, $56, $49, $42, $3a, $37    
13791  FE94 56 49 42 3A 
13791  FE98 37 
13792  FE99             
13793  FE99             
13794  FE99             
13795  FE99             ;******************************************************************
13796  FE99             ;
13797  FE99             ; Interpolated from ect, This is the isc step offset added to the
13798  FE99             ; base isc step when the engine is started.
13799  FE99             ;
13800  FE99             ;
13801  FE99             ;******************************************************************
13802  FE99 1F 1A 1B 1C L2023       .byte   $1f, $1a, $1b, $1c, $21, $2b, $3b, $46     
13802  FE9D 21 2B 3B 46 
13803  FEA1             
13804  FEA1             
13805  FEA1             
13806  FEA1             ;******************************************************************
13807  FEA1             ;
13808  FEA1             ; Interpolated from ect, values xx are loaded 
13809  FEA1             ; into T40_iscStart to produce 40/xx Hz
13810  FEA1             ;
13811  FEA1             ;******************************************************************
13812  FEA1 07 07 07 07 L2024       .byte   $07, $07, $07, $07, $07, $08, $0a, $0c     
13812  FEA5 07 08 0A 0C 
13813  FEA9             
13814  FEA9             
13815  FEA9             
13816  FEA9             
13817  FEA9             ;******************************************************************
13818  FEA9             ;
13819  FEA9             ; Target idle speed as a function of ect
13820  FEA9             ;
13821  FEA9             ;       idle speed = xx * 7.8125
13822  FEA9             ;
13823  FEA9             ; default = 750, 750, 1000, 1148, 1273, 1398, 1500, 1648   
13824  FEA9             ;******************************************************************
13825  FEA9 60 60 80 93 t_idleSpd   .byte   idleVal, idleVal, $80, $93, $a3, $b3, $c0, $d3    
13825  FEAD A3 B3 C0 D3 
13826  FEB1             
13827  FEB1             
13828  FEB1             
13829  FEB1             ;******************************************************************
13830  FEB1             ;
13831  FEB1             ; AT specific table (in drive???)
13832  FEB1             ;
13833  FEB1             ;       idle speed = xx * 7.8125
13834  FEB1             ;
13835  FEB1             ;   default = 648,  648,  797,  898,  1000, 1047, 1101, 1148
13836  FEB1             ;******************************************************************
13837  FEB1             #ifdef E932
13838  FEB1 53 53 66 73 t_idleSpdDr .byte   idleDrVal, idleDrVal, $66, $73, $80, $86, $8d, $93     
13838  FEB5 80 86 8D 93 
13839  FEB9             #endif
13840  FEB9             
13841  FEB9             
13842  FEB9             
13843  FEB9             ;******************************************************************
13844  FEB9             ;
13845  FEB9             ; Target or basic ISC step value as a function of ect
13846  FEB9             ; Used for instance to set iscStepTarg during basic 
13847  FEB9             ; idle speed adjustment
13848  FEB9             ;
13849  FEB9             ;******************************************************************
13850  FEB9             t_iscStEct0
13851  FEB9~            #ifdef E931
13852  FEB9~                        .byte   $09, $12, $2e, $3b, $3c, $41, $4a, $54
13853  FEB9             #else
13854  FEB9 09 10 34 3F             .byte   $09, $10, $34, $3f, $46, $50, $5a, $64    
13854  FEBD 46 50 5A 64 
13855  FEC1             #endif
13856  FEC1             
13857  FEC1             
13858  FEC1             
13859  FEC1             ;******************************************************************
13860  FEC1             ;
13861  FEC1             ; Target ISC step value as a function of ect
13862  FEC1             ;
13863  FEC1             ; AT specific table. This table corresponds to t_iscStEct0
13864  FEC1             ; but is used when AT is in drive
13865  FEC1             ;
13866  FEC1             ;******************************************************************
13867  FEC1             #ifdef E932
13868  FEC1 0C 13 3C 46 t_iscStEct1       .byte   $0c, $13, $3c, $46, $4e, $58, $64, $6e  
13868  FEC5 4E 58 64 6E 
13869  FEC9             #endif
13870  FEC9             
13871  FEC9             
13872  FEC9             ;******************************************************************
13873  FEC9             ;
13874  FEC9             ; Interpolated from conditionned TPS (conTps) (see main code)
13875  FEC9             ;
13876  FEC9             ; This is related to the minimum isc step to use when the idle
13877  FEC9             ; switch transition from off to on and rpm8 goes too low (500rpm)
13878  FEC9             ; We don't want the engine to stall...
13879  FEC9             ;
13880  FEC9             ;
13881  FEC9             ;******************************************************************
13882  FEC9 09 23 2C 3B t_iscStStall    .byte   $09, $23, $2c, $3b, $45, $4c, $53     
13882  FECD 45 4C 53 
13883  FED0             
13884  FED0             
13885  FED0             
13886  FED0             ;******************************************************************
13887  FED0             ;
13888  FED0             ; AT specific table, equivalent of t_iscStStall when not in park/neutral 
13889  FED0             ;
13890  FED0             ;******************************************************************
13891  FED0             #ifdef E932
13892  FED0 09 23 45 4F L2030       .byte   $09, $23, $45, $4f, $4f, $4f, $4f     
13892  FED4 4F 4F 4F 
13893  FED7             #endif
13894  FED7             
13895  FED7             
13896  FED7             
13897  FED7             ;******************************************************************
13898  FED7             ;
13899  FED7             ; Interpolated from ect, contains ISC step values
13900  FED7             ;
13901  FED7             ;******************************************************************
13902  FED7 5A 5A 5A 64 L2031       .byte   $5a, $5a, $5a, $64, $6e, $78, $78, $78     
13902  FEDB 6E 78 78 78 
13903  FEDF             
13904  FEDF             
13905  FEDF             
13906  FEDF             ;******************************************************************
13907  FEDF             ;
13908  FEDF             ; Table is interpolated from (rpm4/2 - idleSpdTarg)/4. 
13909  FEDF             ; Values are timer values (40Hz) used to update T40s_iscStable
13910  FEDF             ; when idle switch is off (isc is considered stable when this 
13911  FEDF             ; timer expires...).
13912  FEDF             ;
13913  FEDF             ;******************************************************************
13914  FEDF 50 50 6E 82 t_iscStableIdleSw  .byte   $50, $50, $6e, $82, $96, $aa, $be, $d2, $e6, $f4, $ff   
13914  FEE3 96 AA BE D2 
13914  FEE7 E6 F4 FF 
13915  FEEA             
13916  FEEA             
13917  FEEA             
13918  FEEA             ;******************************************************************
13919  FEEA             ;
13920  FEEA             ; ISC pattern sequence to load to port5 bit 6 
13921  FEEA             ; and 7 to move the ISC spindle 
13922  FEEA             ;
13923  FEEA             ;
13924  FEEA             ;                       --> move spindle
13925  FEEA             ;           bit 7      1 0 0 1 
13926  FEEA             ;           bit 6      0 0 1 1
13927  FEEA             ;
13928  FEEA             ;******************************************************************
13929  FEEA 80 00 40 C0 t_iscPattern  .byte   $80, $00, $40, $c0     
13930  FEEE             
13931  FEEE             
13932  FEEE             
13933  FEEE             ;******************************************************************
13934  FEEE             ;
13935  FEEE             ; ISC step offset as a function of barometric pressure?
13936  FEEE             ; The value in this table is added to iscStepCurr to compensate 
13937  FEEE             ; for barometric pressure
13938  FEEE             ;
13939  FEEE             ; Table interpolated with baroCond (0.45bar to 0.92bar)
13940  FEEE             ; which means there is no offset ($00) when baroCond > 0.92bar
13941  FEEE             ;
13942  FEEE             ;******************************************************************
13943  FEEE 1A 12 09 04 t_iscStBaro .byte   $1a, $12, $09, $04, $00    
13943  FEF2 00 
13944  FEF3             
13945  FEF3             
13946  FEF3             
13947  FEF3             ;******************************************************************
13948  FEF3             ;
13949  FEF3             ; Interpolated from 4 * abs(idleSpdTarg - rpm8), the difference 
13950  FEF3             ; between target idle speed and the current rpm
13951  FEF3             ;
13952  FEF3             ; Values are compared to iscStepTarg 
13953  FEF3             ;
13954  FEF3             ;******************************************************************
13955  FEF3 00 02 06 0A L2035       .byte   $00, $02, $06, $0a, $0d, $0e, $0e, $0f, $0f      
13955  FEF7 0D 0E 0E 0F 
13955  FEFB 0F 
13956  FEFC             
13957  FEFC             
13958  FEFC             
13959  FEFC             ;******************************************************************
13960  FEFC             ;
13961  FEFC             ; Used in the calculation of the default air count when we are
13962  FEFC             ; not receiving airflow sensor interrupts, interpolated from ect
13963  FEFC             ; Seem to be some kind of tps offset...
13964  FEFC             ;
13965  FEFC             ;******************************************************************
13966  FEFC 00 00 00 02 L2036       .byte   $00, $00, $00, $02, $03, $04, $0a, $10     
13966  FF00 03 04 0A 10 
13967  FF04             
13968  FF04             
13969  FF04             
13970  FF04             ;******************************************************************
13971  FF04             ;
13972  FF04             ; Open loop minimum fuel enrichment table ($80=100) 
13973  FF04             ; interpolated by TPS
13974  FF04             ;
13975  FF04             ;
13976  FF04             ;******************************************************************
13977  FF04 78 80 90 92 t_tpsEnr    .byte   $78, $80, $90, $92    
13978  FF08             
13979  FF08             
13980  FF08             
13981  FF08             ;******************************************************************
13982  FF08             ;
13983  FF08             ; Interpolated from rpm, contains airVolB thresholds used in 
13984  FF08             ; timing advance calculations, used in conjuction with L2021
13985  FF08             ;
13986  FF08             ;     500 1000 1500 2000 2500 3000 3500 4000 4500 5000
13987  FF08             ;
13988  FF08             ;******************************************************************
13989  FF08 00 00 71 71 L2038       .byte   $00, $00, $71, $71, $71, $80, $90, $a0, $a0, $a0    
13989  FF0C 71 80 90 A0 
13989  FF10 A0 A0 
13990  FF12             
13991  FF12             
13992  FF12             
13993  FF12             ;******************************************************************
13994  FF12             ;
13995  FF12             ; Table contains airCnt0 thresholds as a function of RPM
13996  FF12             ;
13997  FF12             ;    airCnt0 > $57*L2039(rpm)/16 ?
13998  FF12             ;
13999  FF12             ;    5 10 15 20 25 30 35 40 45 50 x 100 RPM
14000  FF12             ;
14001  FF12             ;******************************************************************
14002  FF12 6D 6D 85 B4 L2039       .byte   $6d, $6d, $85, $b4, $c8, $d0, $d6, $f0, $ff, $ff     
14002  FF16 C8 D0 D6 F0 
14002  FF1A FF FF 
14003  FF1C             
14004  FF1C             
14005  FF1C             
14006  FF1C             ;******************************************************************
14007  FF1C             ;
14008  FF1C             ; Acceleration enrichment
14009  FF1C             ;
14010  FF1C             ; Interpolated from L2040(min(oldAirCnt0/256,5))
14011  FF1C             ;
14012  FF1C             ;******************************************************************
14013  FF1C 0B 0B 0D 10 L2040       .byte   $0b, $0b, $0d, $10, $15, $1b      
14013  FF20 15 1B 
14014  FF22             
14015  FF22             
14016  FF22             
14017  FF22             ;******************************************************************
14018  FF22             ;
14019  FF22             ; Interpolated from f(rpm4)
14020  FF22             ;
14021  FF22             ; Table contain airVol threshold values 
14022  FF22             ;
14023  FF22             ;******************************************************************
14024  FF22 FF FF FF FF L2041       .byte   $ff, $ff, $ff, $ff, $ff, $9b, $a0, $a5, $b8, $c8, $d0, $ff   
14024  FF26 FF 9B A0 A5 
14024  FF2A B8 C8 D0 FF 
14025  FF2E             
14026  FF2E             
14027  FF2E             
14028  FF2E             ;******************************************************************
14029  FF2E             ;
14030  FF2E             ; Table used for the calculation of injPwStart
14031  FF2E             ; Only factored-in if injCount<5 (when the engine starts to crank??)
14032  FF2E             ;
14033  FF2E             ; non constant sample spacing:
14034  FF2E             ;
14035  FF2E             ;   ectCond/32          if ectCond<$c0     
14036  FF2E             ;   (2*ectCond-$c0)/32  if ectCond>=$c0
14037  FF2E             ;
14038  FF2E             ;   scale in degC:
14039  FF2E             ;   
14040  FF2E             ;        86 80 52 35 21 8 -7 -16 -29 
14041  FF2E             ;
14042  FF2E             ;******************************************************************
14043  FF2E 00 00 00 00 L2042       .byte   $00, $00, $00, $00, $00, $00, $00, $20, $40      
14043  FF32 00 00 00 20 
14043  FF36 40 
14044  FF37             
14045  FF37             
14046  FF37             
14047  FF37             ;******************************************************************
14048  FF37             ;
14049  FF37             ;
14050  FF37             ; Boost gauge scale interpolated from airVolT/16
14051  FF37             ;
14052  FF37             ;
14053  FF37             ;******************************************************************
14054  FF37 02 05 08 0A t_bGauge       .byte   $02, $05, $08, $0a, $0d, $0f, $11, $13, $14     
14054  FF3B 0D 0F 11 13 
14054  FF3F 14 
14055  FF40             
14056  FF40             
14057  FF40             
14058  FF40             ;******************************************************************
14059  FF40             ;
14060  FF40             ; EGR solenoid duty cycle 
14061  FF40             ; as a function of rpm(column) and airVol(row)
14062  FF40             ;
14063  FF40             ;******************************************************************
14064  FF40             t_egrDutyFact 
14065  FF40~            #ifdef E931
14066  FF40~                        .byte   $00, $00, $00, $00, $00, $00, $00, $00
14067  FF40~                        .byte   $00, $00, $00, $5b, $56, $4c, $4d, $00
14068  FF40~                        .byte   $00, $00, $00, $5b, $56, $4c, $4d, $00
14069  FF40~                        .byte   $00, $00, $00, $5b, $56, $60, $5c, $00
14070  FF40~                        .byte   $00, $00, $60, $76, $6c, $5f, $5b, $00
14071  FF40~                        .byte   $80, $80, $80, $7d, $6e, $5f, $60, $00
14072  FF40~                        .byte   $80, $80, $80, $80, $76, $68, $61, $00
14073  FF40~                        .byte   $80, $80, $80, $80, $80, $60, $61, $00
14074  FF40~                        .byte   $00, $80, $80, $80, $80, $78, $6e, $00
14075  FF40             #else
14076  FF40 00 00 00 00             .byte   $00, $00, $00, $00, $00, $00, $00, $00     
14076  FF44 00 00 00 00 
14077  FF48 00 00 00 5A             .byte   $00, $00, $00, $5a, $40, $3b, $41, $00     
14077  FF4C 40 3B 41 00 
14078  FF50 00 00 00 5A             .byte   $00, $00, $00, $5a, $40, $3b, $41, $00     
14078  FF54 40 3B 41 00 
14079  FF58 00 00 00 4C             .byte   $00, $00, $00, $4c, $48, $5a, $56, $00     
14079  FF5C 48 5A 56 00 
14080  FF60 00 00 53 4D             .byte   $00, $00, $53, $4d, $5d, $57, $55, $00     
14080  FF64 5D 57 55 00 
14081  FF68 80 80 68 6A             .byte   $80, $80, $68, $6a, $5c, $57, $53, $00     
14081  FF6C 5C 57 53 00 
14082  FF70 80 80 80 6E             .byte   $80, $80, $80, $6e, $5f, $57, $55, $00     
14082  FF74 5F 57 55 00 
14083  FF78 80 80 80 80             .byte   $80, $80, $80, $80, $5f, $5a, $56, $00     
14083  FF7C 5F 5A 56 00 
14084  FF80 00 80 80 80             .byte   $00, $80, $80, $80, $80, $80, $80, $00     
14084  FF84 80 80 80 00 
14085  FF88             #endif
14086  FF88             
14087  FF88             
14088  FF88             
14089  FF88             
14090  FF88             ;******************************************************************
14091  FF88             ;
14092  FF88             ; EGR solenoid duty cycle as a function of ECT
14093  FF88             ;
14094  FF88             ; Value of $00 to $80 will produce 
14095  FF88             ; 0 to 100% duty cycle 
14096  FF88             ; 
14097  FF88             ;
14098  FF88             ;******************************************************************
14099  FF88 80 80 5B 4F t_egrDuty   .byte   $80, $80, $5b, $4f, $00, $00, $00, $00     
14099  FF8C 00 00 00 00 
14100  FF90             
14101  FF90             
14102  FF90             
14103  FF90             ;******************************************************************
14104  FF90             ;
14105  FF90             ; Interpolated from iat, values are used as minimum egrt
14106  FF90             ; temperature for egrt sensor to be considered as working correctly
14107  FF90             ;
14108  FF90             ; if temperature(egrtRaw) < L2046(iat) then egrt is probably in error
14109  FF90             ;
14110  FF90             ;
14111  FF90             ; in degCC for E931: 83 83 53 41 31 -31 -68
14112  FF90             ;
14113  FF90             ;******************************************************************
14114  FF90             L2046
14115  FF90~            #ifdef E931
14116  FF90~                        .byte   $9a, $9a, $ae, $b6, $bd, $e6, $ff
14117  FF90             #else
14118  FF90 9A 9A A4 AB             .byte   $9a, $9a, $a4, $ab, $bd, $e6, $ff      
14118  FF94 BD E6 FF 
14119  FF97             #endif
14120  FF97             
14121  FF97             
14122  FF97             
14123  FF97             ;******************************************************************
14124  FF97             ;
14125  FF97             ; Interpolated from rpm, values are used as minimum airVol
14126  FF97             ; to verify if egrt sensor is working properly
14127  FF97             ;
14128  FF97             ;     500 1000 1500 2000 2500 3000 3500 4000 4500 5000
14129  FF97             ;
14130  FF97             ;******************************************************************
14131  FF97             L2047 
14132  FF97~            #ifdef E931
14133  FF97~                        .byte   $60, $60, $58, $44, $35, $33, $30, $30, $30, $30
14134  FF97             #else
14135  FF97 60 60 60 4C             .byte   $60, $60, $60, $4c, $40, $38, $33, $30, $30, $30    
14135  FF9B 40 38 33 30 
14135  FF9F 30 30 
14136  FFA1             #endif
14137  FFA1             
14138  FFA1             
14139  FFA1             
14140  FFA1             ;******************************************************************
14141  FFA1             ;
14142  FFA1             ; Interpolated from rpm, values are used as maxmimum airVol
14143  FFA1             ; to verify if egrt sensor is working properly
14144  FFA1             ;
14145  FFA1             ;     500 1000 1500 2000 2500 3000 3500 4000 4500 5000
14146  FFA1             ;
14147  FFA1             ;******************************************************************
14148  FFA1             L2048 
14149  FFA1~            #ifdef E931
14150  FFA1~                        .byte   $60, $60, $68, $88, $98, $9c, $a4, $88, $88, $88
14151  FFA1             #else
14152  FFA1 60 60 78 98             .byte   $60, $60, $78, $98, $a8, $b0, $b0, $b0, $b0, $b0     
14152  FFA5 A8 B0 B0 B0 
14152  FFA9 B0 B0 
14153  FFAB             #endif
14154  FFAB             
14155  FFAB             
14156  FFAB             
14157  FFAB             ;******************************************************************
14158  FFAB             ;
14159  FFAB             ; Table interpolated from ect
14160  FFAB             ;
14161  FFAB             ;******************************************************************
14162  FFAB 1C 1E 30 53 t_accEnr2b       .byte   $1c, $1e, $30, $53, $73, $86, $9a, $9a    
14162  FFAF 73 86 9A 9A 
14163  FFB3             
14164  FFB3             
14165  FFB3             
14166  FFB3             ;******************************************************************
14167  FFB3             ;
14168  FFB3             ; Table interpolated from ect. Used in the calculation
14169  FFB3             ; of sInjEnrInc, fuel enrichment factor for sim injection 
14170  FFB3             ; during acceleration
14171  FFB3             ;
14172  FFB3             ;******************************************************************
14173  FFB3 10 14 18 29 L2050       .byte   $10, $14, $18, $29, $30, $3a, $4d, $60      
14173  FFB7 30 3A 4D 60 
14174  FFBB             
14175  FFBB             
14176  FFBB             
14177  FFBB             ;******************************************************************
14178  FFBB             ;
14179  FFBB             ; Table interpolated from ect. Values are timer thresholds (2Hz timer)
14180  FFBB             ; used in deciding acceleration enrichment factor and simultaneous 
14181  FFBB             ; injection enrichment
14182  FFBB             ;
14183  FFBB             ;******************************************************************
14184  FFBB 1E 22 2E 36 L2051       .byte   $1e, $22, $2e, $36, $3c, $42, $4a, $56       
14184  FFBF 3C 42 4A 56 
14185  FFC3             
14186  FFC3             
14187  FFC3             
14188  FFC3             ;******************************************************************
14189  FFC3             ;
14190  FFC3             ; Piecewise linear rpm transformation data
14191  FFC3             ;
14192  FFC3             ; Using pwiseLin with this table, we get input(x)/output(y) relationship:
14193  FFC3             ;
14194  FFC3             ;           $00<=x<=$03 -> y = 0 
14195  FFC3             ;           $04<=x<=$07 -> y = x-$03 
14196  FFC3             ;           $08<=x<=$1c -> y = (x+$02)/2
14197  FFC3             ;           $1d<=x      -> y = ($1c+$02)/2
14198  FFC3             ;
14199  FFC3             ;    First row is 
14200  FFC3             ;           max, offset
14201  FFC3             ;    Other rows (i=1 to n) are
14202  FFC3             ;           addVal(i), nshift(i), compVal(i)  
14203  FFC3             ;
14204  FFC3             ;******************************************************************
14205  FFC3 1C 03       L2052       .byte   $1c, $03, 
14206  FFC5 00 01 05                .byte   $00, $01, $05, 
14207  FFC8 05 02 FF                .byte   $05, $02, $ff      
14208  FFCB             
14209  FFCB             
14210  FFCB             
14211  FFCB             ;******************************************************************
14212  FFCB             ;
14213  FFCB             ; Piecewise linear rpm transformation data
14214  FFCB             ;
14215  FFCB             ; Using pwiseLin with this table, we get input(x)/output(y) relationship:
14216  FFCB             ;
14217  FFCB             ;           $00<=x<=$02 -> y = 0 
14218  FFCB             ;           $03<=x<=$03 -> y = (x-$02)/2 
14219  FFCB             ;           $04<=x<=$10 -> y = x/4 
14220  FFCB             ;           $11<=x      -> y = $10/4
14221  FFCB             ;
14222  FFCB             ;    First row is 
14223  FFCB             ;           max, offset
14224  FFCB             ;    Other rows (i=1 to n) are
14225  FFCB             ;           addVal(i), nshift(i), compVal(i)  
14226  FFCB             ;
14227  FFCB             ;******************************************************************
14228  FFCB 10 02       L2053       .byte   $10, $02, 
14229  FFCD 00 02 02                .byte   $00, $02, $02, 
14230  FFD0 02 03 FF                .byte   $02, $03, $ff
14231  FFD3             
14232  FFD3             
14233  FFD3             
14234  FFD3             ;******************************************************************
14235  FFD3             ;
14236  FFD3             ; Piecewise linear mafRaw16 (gramOfAir/sec) transformation data
14237  FFD3             ; Note that this table is the same in 2G ECUs so that it doesn't need
14238  FFD3             ; to be changed if 2G maf is used...
14239  FFD3             ;
14240  FFD3             ; The output of pwiseLin using this table is used to interpolate t_masComp
14241  FFD3             ; This means that t_masComp is a table with non-constant spacing between values
14242  FFD3             ; The spacing is given by the transformation in this table...
14243  FFD3             ;
14244  FFD3             ; Using pwiseLin with this table, we get input(x)/output(y) relationship:
14245  FFD3             ;
14246  FFD3             ;           $00<=x<=$0b -> y = x 
14247  FFD3             ;           $0c<=x<=$17 -> y = (x+$24)/4 
14248  FFD3             ;           $18<=x<=$40 -> y = (x+$60)/8 
14249  FFD3             ;           $41<=x      -> y = ($40+$60)/8
14250  FFD3             ;
14251  FFD3             ;    First row is 
14252  FFD3             ;           max, offset
14253  FFD3             ;    Other rows (i=1 to n) are
14254  FFD3             ;           addVal(i), nshift(i), compVal(i)  
14255  FFD3             ;
14256  FFD3             ;******************************************************************
14257  FFD3 40 00       L2054       .byte   $40, $00, 
14258  FFD5 00 01 0C                .byte   $00, $01, $0c, 
14259  FFD8 24 03 18                .byte   $24, $03, $18, 
14260  FFDB 60 04 FF                .byte   $60, $04, $ff 
14261  FFDE                         
14262  FFDE             ;******************************************************************
14263  FFDE             ;
14264  FFDE             ; Unused??????
14265  FFDE             ;
14266  FFDE             ;******************************************************************
14267  FFDE 01 01       L2055       .byte    $01, $01     
14268  FFE0             
14269  FFE0             
14270  FFE0             
14271  FFE0             ;******************************************************************
14272  FFE0             ;
14273  FFE0             ; Interrupt vector
14274  FFE0             ;      
14275  FFE0             ;      
14276  FFE0             ;
14277  FFE0             ;******************************************************************
14278  FFE0~            #if  (codeOffset > 0)
14279  FFE0~                        .fill   intVector-$, $ff
14280  FFE0             #endif
14281  FFE0             intVector   .org    $ffe0
14282  FFE0 EA 00                   .word   serialRxInt   ; Serial port Rx interrupt subroutine
14283  FFE2 D0 3E                   .word   reset         ; ???
14284  FFE4 F8 23                   .word   realTimeInt   ; Real time interrupt (801.28Hz)
14285  FFE6 D0 3E                   .word   reset         ; ???                     
14286  FFE8 D0 3E                   .word   reset         ; ???
14287  FFEA D0 3E                   .word   reset         ; ???                            
14288  FFEC FA 75                   .word   outCompInt3   ; Output compare interrupt3 (coil power transistor activation/deactivation)
14289  FFEE F6 01                   .word   outCompInt2   ; Output compare interrupt2 (injector 2 or 3 activation/deactivation)                            
14290  FFF0 F5 F6                   .word   outCompInt1   ; Output compare interrupt1 (injector 1 or 4 activation/deactivation)                         
14291  FFF2 D0 3E                   .word   reset         ; ???
14292  FFF4 F7 9C                   .word   inCaptInt2    ; Input capture interrupt 2 (airflow sensor pulse)
14293  FFF6 EC 62                   .word   inCaptInt1    ; Input capture interrupt 1 (cas rising or falling edge)
14294  FFF8 D0 3E                   .word   reset         ; Illegal opcode trap?
14295  FFFA D0 3E                   .word   reset         ; Cop failure?
14296  FFFC FA C3                   .word   failureInt    ; Timer clock failure?
14297  FFFE CE FF                   .word   codeStart     ; System reset              
14298  10000                         .end
14299  10000             
14300  10000             
14301  10000             
14302  10000             
tasm: Number of errors = 0
